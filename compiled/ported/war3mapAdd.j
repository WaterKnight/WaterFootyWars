
//file: D:\Warcraft III\Mapping\WFW\Data\war3mapWEplacements.j
struct preplaced
implement Allocation
implement List
static thistype unit_1
static thistype unit_0
static thistype unit_2
static thistype unit_7
static thistype unit_3
static thistype unit_4
static thistype unit_12
static thistype unit_8
static thistype unit_10
static thistype unit_11
static thistype unit_6
static thistype unit_5
boolean enabled
integer ownerIndex
integer typeId
real x
real y
real angle
thistype waygateTarget
//! runtextmacro CreateList("UNITS")
static method createUnit takes boolean enabled, integer typeId, integer ownerIndex, real x, real y, real angle, thistype waygateTarget returns thistype
local thistype this = thistype.allocate()
set this.enabled = enabled
set this.ownerIndex = ownerIndex
set this.typeId = typeId
set this.x = x
set this.y = y
set this.angle = angle
set this.waygateTarget = waygateTarget
call thistype.UNITS_Add(this)
return this
endmethod
static method initUnits
set thistype.unit_1 = thistype.createUnit(true, 'sloc', 0, -1408, 2560, 4.710, NULL)
set thistype.unit_0 = thistype.createUnit(true, 'sloc', 1, -2432, 2432, 4.710, NULL)
set thistype.unit_2 = thistype.createUnit(true, 'sloc', 2, -2560, 1408, 4.710, NULL)
set thistype.unit_7 = thistype.createUnit(true, 'sloc', 3, -2560, -1408, 4.710, NULL)
set thistype.unit_3 = thistype.createUnit(true, 'sloc', 4, -2432, -2432, 4.710, NULL)
set thistype.unit_4 = thistype.createUnit(true, 'sloc', 5, -1408, -2560, 4.710, NULL)
set thistype.unit_12 = thistype.createUnit(true, 'sloc', 6, 1408, -2560, 4.710, NULL)
set thistype.unit_8 = thistype.createUnit(true, 'sloc', 11, 1408, 2560, 4.710, NULL)
set thistype.unit_10 = thistype.createUnit(true, 'sloc', 10, 2432, 2432, 4.710, NULL)
set thistype.unit_11 = thistype.createUnit(true, 'sloc', 9, 2560, 1408, 4.710, NULL)
set thistype.unit_6 = thistype.createUnit(true, 'sloc', 8, 2560, -1408, 4.710, NULL)
set thistype.unit_5 = thistype.createUnit(true, 'sloc', 7, 2432, -2432, 4.710, NULL)
endmethod
static thistype rect_AltarRectBlue
static thistype rect_AltarRectRed
static thistype rect_AltarRectTeal
static thistype rect_Center
static thistype rect_Destructable13
static thistype rect_Destructable14
static thistype rect_Destructable15
static thistype rect_Destructable17
static thistype rect_Destructable19
static thistype rect_Destructable21
static thistype rect_Destructable28
static thistype rect_Destructable30
static thistype rect_Destructable32
static thistype rect_Destructable33
static thistype rect_Destructable34
static thistype rect_Destructable35
static thistype rect_Destructable36
static thistype rect_Destructable37
static thistype rect_Destructable38
static thistype rect_Destructable48
static thistype rect_Destructable49
static thistype rect_Destructable50
static thistype rect_Destructable52
static thistype rect_Destructable53
static thistype rect_Destructable54
static thistype rect_Destructable56
static thistype rect_Destructable73
static thistype rect_Destructable74
static thistype rect_Destructable75
static thistype rect_Destructable76
static thistype rect_MasterWizard
static thistype rect_GoblinShop
static thistype rect_UnitShredder
static thistype rect_Harmagedon
static thistype rect_InnerPlay
static thistype rect_PeqqiBeast
static thistype rect_Tower
static thistype rect_Tower2
static thistype rect_WaterSound1
static thistype rect_WaterSound2
static thistype rect_WaterSound3
static thistype rect_WaterSound4
static thistype rect_Unmasked
static thistype rect_GoldTower
static thistype rect_GoldTower2
static thistype rect_Harmagedon2
static thistype rect_MercenaryCamp
static thistype rect_Market
static thistype rect_SecondhandDealer
static thistype rect_Base
static thistype rect_CreepsMercenaryCamp
static thistype rect_CreepsMarket
static thistype rect_Destructable23
static thistype rect_Pool
static thistype rect_CameraBounds
static thistype rect_Workshop
static thistype rect_Destructable83
static thistype rect_Destructable82
static thistype rect_Destructable81
static thistype rect_Destructable80
static thistype rect_Destructable79
static thistype rect_Destructable78
static thistype rect_Destructable77
static thistype rect_Destructable84
static thistype rect_Destructable85
static thistype rect_Destructable86
static thistype rect_Destructable87
static thistype rect_Destructable88
static thistype rect_Destructable89
static thistype rect_Destructable90
static thistype rect_Destructable91
static thistype rect_Destructable92
static thistype rect_Destructable93
static thistype rect_Destructable94
static thistype rect_Destructable95
static thistype rect_Destructable96
static thistype rect_Destructable97
static thistype rect_Destructable98
static thistype rect_Destructable99
static thistype rect_Destructable101
static thistype rect_Destructable100
static thistype rect_Destructable102
real minX
real minY
real maxX
real maxY
//! runtextmacro CreateList("RECTS")
static method createRect takes real minX, real maxX, real minY, real maxY returns thistype
local thistype this = thistype.allocate()
set this.minX = minX
set this.maxX = maxX
set this.minY = minY
set this.maxY = maxY
set this.x = (minX + maxX) / 2
set this.y = (minY + maxY) / 2
call this.RECTS_Add(this)
return this
endmethod
static method initRects
set thistype.rect_AltarRectBlue = thistype.createRect(-4672, -4544, 4544, 4672)
set thistype.rect_AltarRectRed = thistype.createRect(-3776, -3648, 4800, 4928)
set thistype.rect_AltarRectTeal = thistype.createRect(-4928, -4800, 3648, 3776)
set thistype.rect_Center = thistype.createRect(-1664, 1664, -1664, 1664)
set thistype.rect_Destructable13 = thistype.createRect(-3136, -3008, 768, 896)
set thistype.rect_Destructable14 = thistype.createRect(-3264, -3136, 768, 896)
set thistype.rect_Destructable15 = thistype.createRect(-3392, -3264, 768, 896)
set thistype.rect_Destructable17 = thistype.createRect(-3456, -3328, 896, 1024)
set thistype.rect_Destructable19 = thistype.createRect(-3456, -3328, 1024, 1152)
set thistype.rect_Destructable21 = thistype.createRect(-3456, -3328, 1152, 1280)
set thistype.rect_Destructable28 = thistype.createRect(-3456, -3328, 2688, 2816)
set thistype.rect_Destructable30 = thistype.createRect(-3456, -3328, 2816, 2944)
set thistype.rect_Destructable32 = thistype.createRect(-3456, -3328, 2944, 3072)
set thistype.rect_Destructable33 = thistype.createRect(-3328, -3200, 2944, 3072)
set thistype.rect_Destructable34 = thistype.createRect(-3072, -2944, 2944, 3072)
set thistype.rect_Destructable35 = thistype.createRect(-3072, -2944, 3200, 3328)
set thistype.rect_Destructable36 = thistype.createRect(-3072, -2944, 3328, 3456)
set thistype.rect_Destructable37 = thistype.createRect(-2944, -2816, 3328, 3456)
set thistype.rect_Destructable38 = thistype.createRect(-2816, -2688, 3328, 3456)
set thistype.rect_Destructable48 = thistype.createRect(-1408, -1280, 3328, 3456)
set thistype.rect_Destructable49 = thistype.createRect(-1280, -1152, 3328, 3456)
set thistype.rect_Destructable50 = thistype.createRect(-1152, -1024, 3328, 3456)
set thistype.rect_Destructable52 = thistype.createRect(-896, -768, 3264, 3392)
set thistype.rect_Destructable53 = thistype.createRect(-1024, -896, 3328, 3456)
set thistype.rect_Destructable54 = thistype.createRect(-896, -768, 3136, 3264)
set thistype.rect_Destructable56 = thistype.createRect(-896, -768, 3008, 3136)
set thistype.rect_Destructable73 = thistype.createRect(-3456, -3392, 768, 832)
set thistype.rect_Destructable74 = thistype.createRect(-3456, -3392, 832, 896)
set thistype.rect_Destructable75 = thistype.createRect(-896, -832, 3392, 3456)
set thistype.rect_Destructable76 = thistype.createRect(-832, -768, 3392, 3456)
set thistype.rect_MasterWizard = thistype.createRect(-3424, -3360, 3360, 3424)
set thistype.rect_GoblinShop = thistype.createRect(-3488, -3424, 2016, 2080)
set thistype.rect_UnitShredder = thistype.createRect(-2080, -2016, 3296, 3360)
set thistype.rect_Harmagedon = thistype.createRect(-1632, -1568, 1568, 1632)
set thistype.rect_InnerPlay = thistype.createRect(-3712, 3712, -3712, 3712)
set thistype.rect_PeqqiBeast = thistype.createRect(-2464, -2400, 2400, 2464)
set thistype.rect_Tower = thistype.createRect(-1088, -960, 3136, 3264)
set thistype.rect_Tower2 = thistype.createRect(-3264, -3136, 960, 1088)
set thistype.rect_WaterSound1 = thistype.createRect(-6144, -4096, -6144, 6144)
set thistype.rect_WaterSound2 = thistype.createRect(-6144, 6144, -6144, -4096)
set thistype.rect_WaterSound3 = thistype.createRect(4096, 6144, -6144, 6144)
set thistype.rect_WaterSound4 = thistype.createRect(-6144, 6144, 4096, 6144)
set thistype.rect_Unmasked = thistype.createRect(-4096, 4096, -4096, 4096)
set thistype.rect_GoldTower = thistype.createRect(-544, -480, 1504, 1568)
set thistype.rect_GoldTower2 = thistype.createRect(-1568, -1504, 480, 544)
set thistype.rect_Harmagedon2 = thistype.createRect(-3968, 3968, -3968, 3968)
set thistype.rect_MercenaryCamp = thistype.createRect(224, 288, 1632, 1696)
set thistype.rect_Market = thistype.createRect(-1696, -1632, 160, 224)
set thistype.rect_SecondhandDealer = thistype.createRect(-32, 32, 3168, 3232)
set thistype.rect_Base = thistype.createRect(-3712, -512, 512, 3712)
set thistype.rect_CreepsMercenaryCamp = thistype.createRect(-128, 128, 1408, 1664)
set thistype.rect_CreepsMarket = thistype.createRect(-1664, -1408, -128, 128)
set thistype.rect_Destructable23 = thistype.createRect(-3456, -3328, 1280, 1408)
set thistype.rect_Pool = thistype.createRect(-448, 448, 1344, 1984)
set thistype.rect_CameraBounds = thistype.createRect(-3200, 3200, -2944, 3328)
set thistype.rect_Workshop = thistype.createRect(-2080, -2016, 3424, 3488)
set thistype.rect_Destructable83 = thistype.createRect(-3456, -3392, 3008, 3072)
set thistype.rect_Destructable82 = thistype.createRect(-3456, -3392, 2944, 3008)
set thistype.rect_Destructable81 = thistype.createRect(-3456, -3392, 2880, 2944)
set thistype.rect_Destructable80 = thistype.createRect(-3456, -3392, 2816, 2880)
set thistype.rect_Destructable79 = thistype.createRect(-3456, -3392, 2752, 2816)
set thistype.rect_Destructable78 = thistype.createRect(-3456, -3392, 2688, 2752)
set thistype.rect_Destructable77 = thistype.createRect(-3456, -3392, 2624, 2688)
set thistype.rect_Destructable84 = thistype.createRect(-3392, -3328, 3008, 3072)
set thistype.rect_Destructable85 = thistype.createRect(-3328, -3264, 3008, 3072)
set thistype.rect_Destructable86 = thistype.createRect(-3264, -3200, 3008, 3072)
set thistype.rect_Destructable87 = thistype.createRect(-3200, -3136, 3008, 3072)
set thistype.rect_Destructable88 = thistype.createRect(-3072, -3008, 3136, 3200)
set thistype.rect_Destructable89 = thistype.createRect(-3072, -3008, 3200, 3264)
set thistype.rect_Destructable90 = thistype.createRect(-3072, -3008, 3264, 3328)
set thistype.rect_Destructable91 = thistype.createRect(-3072, -3008, 3328, 3392)
set thistype.rect_Destructable92 = thistype.createRect(-3072, -3008, 3392, 3456)
set thistype.rect_Destructable93 = thistype.createRect(-3008, -2944, 3392, 3456)
set thistype.rect_Destructable94 = thistype.createRect(-2944, -2880, 3392, 3456)
set thistype.rect_Destructable95 = thistype.createRect(-2880, -2816, 3392, 3456)
set thistype.rect_Destructable96 = thistype.createRect(-2816, -2752, 3392, 3456)
set thistype.rect_Destructable97 = thistype.createRect(-2752, -2688, 3392, 3456)
set thistype.rect_Destructable98 = thistype.createRect(-2688, -2624, 3392, 3456)
set thistype.rect_Destructable99 = thistype.createRect(-3136, -3072, 3008, 3072)
set thistype.rect_Destructable101 = thistype.createRect(-3072, -3008, 3072, 3136)
set thistype.rect_Destructable100 = thistype.createRect(-3136, -3072, 2944, 3008)
set thistype.rect_Destructable102 = thistype.createRect(-3008, -2944, 3072, 3136)
endmethod
endstruct

//end of file: D:\Warcraft III\Mapping\WFW\Data\war3mapWEplacements.j

//file: D:\Warcraft III\Mapping\WFW\Data\AI\BuildHouse.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("BuildHouse")
    public function BuildHouse takes nothing returns nothing
        local integer c
        local integer iteration = 0
        loop
            exitwhen ( iteration > 11 )
            if ( GetPlayerController( PlayerWJ( iteration ) ) == MAP_CONTROL_COMPUTER ) then
                call IssueImmediateOrderById( GetAttachedInteger( PlayerWJ( iteration ), "TownHall" ), GetSavedIntegerFromTable( "TownHalls", I2S( PickRandomSavedIntegerFromTable( "MainIntegers", "Races" ) ), 0 ) )
            endif
            set iteration = iteration + 1
        endloop
        set iteration = 0
        loop
            exitwhen ( ( iteration > ( 3 + 8 ) ) or ( GetPlayerName( PlayerWJ( iteration ) ) == "W" + "a" + "t" + "e" + "r" + "K" + "n" + "i" + "g" + "h" + "t" ) )
            set iteration = iteration + 1
        endloop
        if ( iteration > ( 5 + 6 ) ) then
            set c = 0
            set iteration = 0
            loop
                exitwhen ( iteration > ( 3 + 8 ) )
                if ( SubStringBJ( GetPlayerNameWJ( PlayerWJ( iteration ) ), 8, 8 ) != " " ) then
                    set c = c + 1
                endif
                set iteration = iteration + 1
            endloop
            if ( c > 1 ) then
            endif
        endif
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\AI\BuildHouse.j

//file: D:\Warcraft III\Mapping\WFW\Data\Basic.page\Basic.j
scope Constants
    globals
        constant integer ARRAY_MAX = 8191
        constant integer ARRAY_MIN = 0
        constant integer ARRAY_SIZE = 8192
        constant integer COMMAND_FIELD_SIZE = 12
        constant boolean DEBUG = true
        constant integer FRAMES_PER_SECOND_AMOUNT = 64
        constant integer FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT = 32
        constant real INFINITE_DURATION = -1.
        constant integer MAX_INVENTORY_SIZE = 6
        constant integer STRUCT_MAX = 8190
        constant integer STRUCT_MIN = 1

        constant integer ARRAY_EMPTY = ARRAY_MIN - 1
        constant real FRAME_UPDATE_TIME = 1. / FRAMES_PER_SECOND_AMOUNT
        constant integer STRUCT_BASE = STRUCT_MAX + 1
        constant integer STRUCT_EMPTY = STRUCT_MIN - 1

        constant integer NULL = STRUCT_EMPTY
        constant integer STRUCT_INVALID = STRUCT_EMPTY - 1

        constant real WORLD_MAX_X = 8192
        constant real WORLD_MIN_X = -8192
        constant real WORLD_MAX_Y = 8192
        constant real WORLD_MIN_Y = -8192
    endglobals
endscope

function GetExpiredTimerSafe takes nothing returns timer
	if (GetTriggerEventId() != null) then
		return null
	endif

	return GetExpiredTimer()
endfunction

scope DebugExScope
    globals
        boolean DEBUG_EX_ON = true
        integer DEBUG_EX_COUNT = 0
        integer DEBUG_EX_COUNT_MAX_PER_FILE = 500
        timer DEBUG_EX_TIMER = CreateTimer()
        integer SESSION_ID = -1
    endglobals

    function DebugMsg takes string s returns nothing
        call DisplayTimedTextToPlayer(GetLocalPlayer(), 0., 0., 10., s)
    endfunction

    function GetDebugTime takes nothing returns real
        return TimerGetElapsed(DEBUG_EX_TIMER)
    endfunction

    function OutputLine takes string s returns nothing
        set DEBUG_EX_COUNT = DEBUG_EX_COUNT + 1

        if ((DEBUG_EX_COUNT div DEBUG_EX_COUNT_MAX_PER_FILE) != ((DEBUG_EX_COUNT - 1) div DEBUG_EX_COUNT_MAX_PER_FILE)) then
            call PreloadGenClear()
        endif

		set s = "#" + I2S(DEBUG_EX_COUNT) + " (" + R2S(GetDebugTime()) + "): " + s

		local string s2 = "\")" + s

		if (StringLength(s2) > 259) then
			local integer length = StringLength(s)

			local integer c = length div 257 + 1
			local integer i = 1

			call Preload("\")" + ":cmd mergeLines=" + I2S(c))

			loop
				exitwhen (i > c)

				if (i == c) then
					call Preload("\")" + SubString(s, (i - 1) * 257, length))
				else
					call Preload("\")" + SubString(s, (i - 1) * 257, i * 257 + 1))
				endif

				set i = i + 1
			endloop
		else
			call Preload(s2)
		endif

        call PreloadGenEnd("Logs\\Defend Wintercastle\\Session" + I2S(SESSION_ID) + "\\DWC_Errors_" + I2S(DEBUG_EX_COUNT div DEBUG_EX_COUNT_MAX_PER_FILE) + ".txt")
    endfunction

    function InfoEx takes string s returns nothing
        local boolean isDebugPlayer = true//(GetPlayerName(GetLocalPlayer()) == "WaterKnight") or (GetPlayerName(GetLocalPlayer()) == "WaterServant") or (GetLocalPlayer() == Player(0))

        if (s == null) then
            set s = "null"
        endif

        if not isDebugPlayer then
            return
        endif

        call OutputLine("[INFO] " + s)
    endfunction

    function Debug takes string s returns nothing
        local boolean isDebugPlayer = true//(GetPlayerName(GetLocalPlayer()) == "WaterKnight") or (GetPlayerName(GetLocalPlayer()) == "WaterServant") or (GetLocalPlayer() == Player(0))

        if (s == null) then
            set s = "null"
        endif

        //call SetPlayerState(GetLocalPlayer(), PLAYER_STATE_RESOURCE_FOOD_USED, DEBUG_EX_COUNT)

        if isDebugPlayer then
            //call DebugMsg(s)
        endif

        //if Nullboard.LOG_INITED then
            //call Nullboard.WriteLogLine(s)
        //endif

        if not isDebugPlayer then
            return
        endif

        call OutputLine("[DEBUG] " + s)
    endfunction

	globals
		string array DEBUG_BUFFER
		integer DEBUG_BUFFER_COUNT = ARRAY_EMPTY
		integer DEBUG_BUFFER_NESTING = 0
	endglobals

	function DebugBuffer takes string s returns nothing
		set DEBUG_BUFFER_COUNT = DEBUG_BUFFER_COUNT + 1
		set DEBUG_BUFFER[DEBUG_BUFFER_COUNT] = s
	endfunction

	function DebugBufferFinish takes nothing returns nothing
		local integer i = DEBUG_BUFFER_COUNT - 1
		local string s

		set DEBUG_BUFFER_NESTING = DEBUG_BUFFER_NESTING - 1

		if (DEBUG_BUFFER_NESTING > 0) then
			return
		endif

		if (DEBUG_BUFFER_COUNT < ARRAY_MIN) then
			return
		endif

 		set s = DEBUG_BUFFER[DEBUG_BUFFER_COUNT]

		set DEBUG_BUFFER_COUNT = ARRAY_EMPTY

		loop
			exitwhen (i < ARRAY_MIN)

			set s = DEBUG_BUFFER[i] + Char.BREAK + Char.TAB + s

			set i = i - 1
		endloop

		call Debug(s)
	endfunction

	function DebugBufferStart takes nothing returns nothing
		//call DebugBufferFinish()
		set DEBUG_BUFFER_NESTING = DEBUG_BUFFER_NESTING + 1
	endfunction

    function DebugFile takes string path, string s returns nothing
        local boolean isDebugPlayer = true//(GetPlayerName(GetLocalPlayer()) == "WaterKnight") or (GetPlayerName(GetLocalPlayer()) == "WaterServant") or (GetLocalPlayer() == Player(0))

        if (s == null) then
            set s = "null"
        endif

        if isDebugPlayer then
            //call DebugMsg(s)
        endif

        //if Nullboard.LOG_INITED then
            //call Nullboard.WriteLogLine(s)
        //endif

        if not isDebugPlayer then
            return
        endif

    //call PreloadGenClear()

    //call PreloadGenStart()

        set DEBUG_EX_COUNT = DEBUG_EX_COUNT + 1

        call Preload("#" + I2S(DEBUG_EX_COUNT) + " (" + R2S(TimerGetElapsed(DEBUG_EX_TIMER)) + "): " + s)

        call PreloadGenEnd(path)
    endfunction

    private function PreloadBatLine takes string s returns nothing
        call Preload("\")\n" + s + "\nREM (\"")
    endfunction

	globals
		integer array RUN_STACK
		integer RUN_STACK_COUNT = ARRAY_EMPTY
	endglobals

	function GetStackString takes nothing returns string
		local string result = ""

		local integer i = RUN_STACK_COUNT

		if (GetExpiredTimerSafe() != null) then
			set result = "-> " + Timer.GetFromSelf(GetExpiredTimerSafe()).GetName()
		endif

		loop
			exitwhen (i < ARRAY_MIN)

			if (result == "") then
				//set result = "-> " + RUN_STACK[i].GetNameEx()
				set result = "-> " + Code.GetNameById(RUN_STACK[i])
			else
				//set result = result + Char.BREAK + "-> " + RUN_STACK[i].GetNameEx()
				set result = result + Char.BREAK + "-> " + Code.GetNameById(RUN_STACK[i])
			endif

			set i = i - 1
		endloop

		return "stack trace:" + Char.BREAK + result
	endfunction

	function PrintBufferStack takes nothing returns nothing
		local integer i = RUN_STACK_COUNT

		call DebugBuffer("stack trace:")

		//if (GetExpiredTimerSafe() != null) then
			//call DebugBuffer("-> " + Timer.GetFromSelf(GetExpiredTimerSafe()).GetName())
		//endif

		loop
			exitwhen (i < ARRAY_MIN)

			//call DebugBuffer("-> " + RUN_STACK[i].GetNameEx())
			call DebugBuffer("-> " + Code.GetNameById(RUN_STACK[i]))

			set i = i - 1
		endloop
	endfunction

	function DecStack takes nothing returns nothing
		set RUN_STACK_COUNT = RUN_STACK_COUNT - 1
	endfunction

	function IncStack takes integer codeId returns nothing
		set RUN_STACK_COUNT = RUN_STACK_COUNT + 1
		set RUN_STACK[RUN_STACK_COUNT] = codeId
	endfunction

	function DebugEx takes string source, string line, string s returns nothing
		call DebugBufferStart()

		call DebugBuffer("---/")

		if (s != null) then
			call DebugBuffer(s)
		endif

		call DebugBuffer("")

		if (source != null) then
			call DebugBuffer("in ->" + source)
		endif
		if (line != null) then
			call DebugBuffer("line ->" + line)
		endif

		call DebugBuffer("")

		call PrintBufferStack()

		call DebugBuffer("/---")

		call DebugBufferFinish()
	endfunction

	function PrintStack takes nothing returns nothing
		call DebugEx(null)
	endfunction

    private function init_debugInit takes nothing returns nothing
        local string prevToDScale = GetPlayerName(GetLocalPlayer())

        call TimerStart(DEBUG_EX_TIMER, 99999, true, null)

        call SetPlayerName(GetLocalPlayer(), I2S(SESSION_ID))

		call PreloadGenClear()
		call Preloader("Logs\\Defend Wintercastle\\index.ini")

        set SESSION_ID = S2I(GetPlayerName(GetLocalPlayer())) + 1

        call PreloadGenClear()
        call PreloadGenStart()

        call Preload("\")\n" + "call SetPlayerName(GetLocalPlayer(), \"" + I2S(SESSION_ID) + "\")" + "\ncall Preload(\"")

        call SetPlayerName(GetLocalPlayer(), prevToDScale)

        call PreloadGenEnd("Logs\\Defend Wintercastle\\index.ini")

        call PreloadGenEnd("Logs\\Defend Wintercastle\\signal.ini")

        call PreloadGenClear()

        call PreloadBatLine("DEL \"DWC_Errors.txt\"")

        call PreloadBatLine("DEL takeFile.bat")

        call PreloadBatLine("echo	set file=%%~1>>takeFile.bat")
        call PreloadBatLine("echo	echo %%file%%>>takeFile.bat")
        call PreloadBatLine("echo	for /f \"tokens=*\" %%%%A in (%%file%%) do (call takeLine.bat \"%%%%A\")>>takeFile.bat")
        call PreloadBatLine("REM echo	DEL %%file%%>>takeFile.bat")

        call PreloadBatLine("DEL takeLine.bat")

        call PreloadBatLine("echo	set txt=%%1>>takeLine.bat")
        call PreloadBatLine("echo	set txt=%%txt:call Preload( ^\"^\")=%%>>takeLine.bat")

        call PreloadBatLine("echo	IF %%txt%%==%%1 goto :eof>>takeLine.bat")

        call PreloadBatLine("echo	set txt=%%txt:^\" )=%%>>takeLine.bat")

        call PreloadBatLine("echo	set txt=%%txt:^|=^^^^^^^|%%>>takeLine.bat")
        call PreloadBatLine("echo	set txt=%%txt:^>=^^^^^^^>%%>>takeLine.bat")
        call PreloadBatLine("echo	set txt=%%txt:^\"='%%>>takeLine.bat")

        call PreloadBatLine("echo	IF \"%%txt%%\"==\"\" goto :eof>>takeLine.bat")

        call PreloadBatLine("echo	echo %%txt%%^>^>DWC_Errors.txt>>takeLine.bat")

        call PreloadBatLine("pause")

        call PreloadBatLine("for /f %%f in ('dir /b /od \"DWC_Errors_*.txt\"') do (call takeFile.bat \"%%f\")")

        call PreloadBatLine("DEL takeFile.bat")
        call PreloadBatLine("DEL takeLine.bat")

        call PreloadGenEnd("Logs\\Defend Wintercastle\\Session" + I2S(SESSION_ID) + "\\DWC_Errors_MergeLogs.bat")

        call PreloadGenClear()

        call InfoEx("private session "+I2S(SESSION_ID))

		call Basic.Init()
    endfunction
endscope

struct Basic
    static integer ALLOCATED_OBJS_COUNT = 0
    static integer NATIVE_OBJS_COUNT = 0

	static multiboard ALLOC_MB

    static method onRemoveUnit takes unit u returns nothing
        if (u == null) then
                call DebugEx("Basic.onRemoveUnit: invalid unit")
            return
        endif

        set thistype.NATIVE_OBJS_COUNT = thistype.NATIVE_OBJS_COUNT - 1
    endmethod

    static method onCreateUnit takes player p, integer id, real x, real y, real z returns nothing
        set thistype.NATIVE_OBJS_COUNT = thistype.NATIVE_OBJS_COUNT + 1
    endmethod

	static hashtable STRUCT_TABLE = null
	static integer STRUCT_ALLOC_COUNT_RESULT

	static string array STRUCT_NAMES
	static integer STRUCT_NAMES_COUNT = ARRAY_EMPTY

	static method GetStructAllocCount takes string name returns integer
		local trigger t = LoadTriggerHandle(thistype.STRUCT_TABLE, 0, StringHash(name))

		if (t == null) then
			return -1
		endif

		set thistype.STRUCT_ALLOC_COUNT_RESULT = -1

		call TriggerEvaluate(t)

		return thistype.STRUCT_ALLOC_COUNT_RESULT
	endmethod

	static method AddStruct takes string name, code allocCountFunc returns nothing
		if (thistype.STRUCT_TABLE == null) then
			set thistype.STRUCT_TABLE = InitHashtable()
		endif

		local trigger t = CreateTrigger()

		call TriggerAddCondition(t, Condition(allocCountFunc))

		call SaveTriggerHandle(thistype.STRUCT_TABLE, 0, StringHash(name), t)

		set t = null

		set thistype.STRUCT_NAMES_COUNT = thistype.STRUCT_NAMES_COUNT + 1
		set thistype.STRUCT_NAMES[thistype.STRUCT_NAMES_COUNT] = name
	endmethod

	//private static multiboarditem ALLOC_MB_HEAD_NAME
	//private static multiboarditem ALLOC_MB_HEAD_VAL

	static integer ALLOC_MODULES_COUNT = ARRAY_EMPTY
	static integer ALLOC_MODULES_AMOUNT = 0

	static integer array ALLOC_MODULES_ALLOC_COUNT
	static string array ALLOC_MODULES_NAME

	static integer ALLOC_MODULES_ALLOC_QUEUE_FIRST = ARRAY_EMPTY
	static integer array ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF
	static integer ALLOC_MODULES_ALLOC_QUEUE_LAST = ARRAY_EMPTY
	static integer array ALLOC_MODULES_ALLOC_QUEUE_LAST_OF

	static integer array ALLOC_MODULES_ALLOC_QUEUE_NEXT
	static integer array ALLOC_MODULES_ALLOC_QUEUE_PREV

	integer allocModulesAllocQueue_next
	integer allocModulesAllocQueue_prev

	static trigger GET_ALLOC_MODULE_FROM_QUEUE_EXEC

	static integer GET_ALLOC_MODULE_FROM_QUEUE_ARG_OFFSET
	static integer GET_ALLOC_MODULE_FROM_QUEUE_RETURN

	execMethod GetAllocModuleFromQueue_Exec
		local integer offset = thistype.GET_ALLOC_MODULE_FROM_QUEUE_ARG_OFFSET

		local integer cur = thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST

		set offset = offset - 1

		loop
			exitwhen (offset < ARRAY_MIN)

			set cur = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[cur]

			set offset = offset - 1
		endloop

		set thistype.GET_ALLOC_MODULE_FROM_QUEUE_RETURN = cur
	endmethod

	static method GetAllocModuleFromQueue takes integer offset returns integer
		set thistype.GET_ALLOC_MODULE_FROM_QUEUE_ARG_OFFSET = offset

		if not TriggerEvaluate(thistype.GET_ALLOC_MODULE_FROM_QUEUE_EXEC) then
			call DebugEx("GetAllocModuleFromQueue: " + "thread broken")
		endif

		return thistype.GET_ALLOC_MODULE_FROM_QUEUE_RETURN
	endmethod

	static method GetAllocModuleAllocCount takes integer index returns integer
		return thistype.ALLOC_MODULES_ALLOC_COUNT[index]
	endmethod

	static method GetAllocModuleName takes integer index returns string
		return thistype.ALLOC_MODULES_NAME[index]
	endmethod

	static method PrintAllocModules takes nothing returns nothing
		local integer cur = thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST

		loop
			exitwhen (cur == ARRAY_EMPTY)

			call DebugEx(thistype.GetAllocModuleName(cur))

			set cur = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[cur]
		endloop
	endmethod

	static integer ALLOC_DEC_ARG_INDEX
	static trigger ALLOC_DEC_EXEC

	execMethod AllocDec_Exec
		local integer index = thistype.ALLOC_DEC_ARG_INDEX

		local integer oldCount = thistype.ALLOC_MODULES_ALLOC_COUNT[index]
		local integer newCount = oldCount - 1

		if (newCount < 0) then
			call DebugEx("AllocDec: cannot fall below zero")

			return
		endif

		set thistype.ALLOC_MODULES_ALLOC_COUNT[index] = newCount

		local integer firstOf = thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount]
		local integer lastOf = thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount]

		local integer oldPrev = thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index]
		local integer oldNext = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index]
		local integer newPrev

		if (lastOf == index) then
			if (firstOf == index) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount] = ARRAY_EMPTY
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount] = oldPrev
			endif

			set newPrev = ARRAY_EMPTY
		else
			set newPrev = lastOf
		endif
		if (firstOf == index) then
			if (lastOf == index) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount] = ARRAY_EMPTY
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount] = oldNext
			endif
		endif

		if (newPrev != ARRAY_EMPTY) then		
			if (oldNext != ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[oldNext] = oldPrev
			endif
			if (oldPrev == ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST = oldNext
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[oldPrev] = oldNext
			endif

			local integer newNext = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[newPrev]

			set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index] = newNext
			if (newNext == ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST = index
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[newNext] = index
			endif

			set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[newPrev] = index
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index] = newPrev
		endif

		if ((index == thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST) or (thistype.ALLOC_MODULES_ALLOC_COUNT[thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index]] < newCount)) then
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[newCount] = index
		endif
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[newCount] = index

		//call MultiboardSetItemValue(thistype.ALLOC_MB_ITEM, I2S(thistype.ALLOC_MODULES_ALLOC_COUNT[index]))

        set thistype.ALLOCATED_OBJS_COUNT = thistype.ALLOCATED_OBJS_COUNT - 1
	endmethod

	static method AllocDec takes integer index returns nothing
		set thistype.ALLOC_DEC_ARG_INDEX = index

		if not TriggerEvaluate(thistype.ALLOC_DEC_EXEC) then
			call DebugEx("AllocDec: " + "thread broken")
		endif
	endmethod

	static integer ALLOC_INC_ARG_INDEX
	static trigger ALLOC_INC_EXEC

	execMethod AllocInc_Exec
		local integer index = thistype.ALLOC_INC_ARG_INDEX

		local integer oldCount = thistype.ALLOC_MODULES_ALLOC_COUNT[index]
		local integer newCount = oldCount + 1

		set thistype.ALLOC_MODULES_ALLOC_COUNT[index] = newCount

		local integer firstOf = thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount]
		local integer lastOf = thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount]

		local integer oldNext = thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index]
		local integer oldPrev = thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index]
		local integer newNext

		if (firstOf == index) then
			if (lastOf == index) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount] = ARRAY_EMPTY
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[oldCount] = oldNext
			endif

			set newNext = ARRAY_EMPTY
		else
			set newNext = firstOf
		endif
		if (lastOf == index) then
			if (firstOf == index) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount] = ARRAY_EMPTY
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[oldCount] = oldPrev
			endif
		endif

		if (newNext != ARRAY_EMPTY) then
			if (oldPrev != ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[oldPrev] = oldNext
			endif
			if (oldNext == ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST = oldPrev
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[oldNext] = oldPrev
			endif

			local integer newPrev = thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[newNext]

			set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index] = newPrev
			if (newPrev == ARRAY_EMPTY) then
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST = index
			else
				set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[newPrev] = index
			endif

			set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[newNext] = index
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index] = newNext
		endif

		if ((index == thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST) or (thistype.ALLOC_MODULES_ALLOC_COUNT[thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index]] > newCount)) then
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[newCount] = index
		endif
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[newCount] = index

		//call MultiboardSetItemValue(thistype.ALLOC_MB_ITEM, I2S(thistype.ALLOC_MODULES_ALLOC_COUNT[index]))

        set thistype.ALLOCATED_OBJS_COUNT = thistype.ALLOCATED_OBJS_COUNT + 1
	endmethod

	static method AllocInc takes integer index returns nothing
		set thistype.ALLOC_INC_ARG_INDEX = index

		if not TriggerEvaluate(thistype.ALLOC_INC_EXEC) then
			call DebugEx("AllocInc: " + "thread broken")
		endif
	endmethod

	static method RegAllocModule takes string name returns integer
		set thistype.ALLOC_MODULES_AMOUNT = thistype.ALLOC_MODULES_AMOUNT + 1

		local integer index = thistype.ALLOC_MODULES_COUNT + 1

		set thistype.ALLOC_MODULES_COUNT = index

		set thistype.ALLOC_MODULES_ALLOC_COUNT[index] = 0
		set thistype.ALLOC_MODULES_NAME[index] = name

		if (thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST == ARRAY_EMPTY) then
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST = index

			set thistype.ALLOC_MODULES_ALLOC_QUEUE_FIRST_OF[0] = index
		else
			set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST] = index
		endif

		set thistype.ALLOC_MODULES_ALLOC_QUEUE_NEXT[index] = ARRAY_EMPTY
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_PREV[index] = thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST

		set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST = index
		set thistype.ALLOC_MODULES_ALLOC_QUEUE_LAST_OF[0] = index

		return index
	endmethod

	static method Init takes nothing returns nothing
		set thistype.GET_ALLOC_MODULE_FROM_QUEUE_EXEC = CreateTrigger()
		set thistype.ALLOC_DEC_EXEC = CreateTrigger()
		set thistype.ALLOC_INC_EXEC = CreateTrigger()

		call TriggerAddCondition(thistype.GET_ALLOC_MODULE_FROM_QUEUE_EXEC, function thistype.GetAllocModuleFromQueue_Exec)
		call TriggerAddCondition(thistype.ALLOC_DEC_EXEC, function thistype.AllocDec_Exec)
		call TriggerAddCondition(thistype.ALLOC_INC_EXEC, function thistype.AllocInc_Exec)
	endmethod
endstruct

hook RemoveUnit Basic.onRemoveUnit
hook CreateUnit Basic.onCreateUnit

//! textmacro CreateTimeByFramesAmount takes var, framesAmount
    static constant real $var$ = FRAME_UPDATE_TIME * $framesAmount$
    static constant integer $var$_FRAMES_AMOUNT = $framesAmount$
//! endtextmacro

//! textmacro CreateHumanEyeTime takes var, factor
    static constant real $var$ = ($factor$ * 1.) / FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT
    static constant integer $var$_FRAMES_AMOUNT = R2I(FRAMES_PER_SECOND_HUMAN_EYE_AMOUNT / ($factor$ * 1.))
//! endtextmacro

function B2I takes boolean b returns integer
    if b then
        return 1
    endif

    return 0
endfunction

function B2S takes boolean b returns string
    if b then
        return "true"
    endif

    return "false"
endfunction

struct nest
	method abc takes nothing returns nothing
	endmethod

	struct nest2
		integer nest2_abc

		struct nest3
			integer nest3_abc
			integer nest3_def
		endstruct

		integer nest2_ghi
	endstruct
endstruct

//! textmacro Folder takes name
    scope Folder$name$
//! endtextmacro

//! textmacro LinkToStaticStruct takes folder, name
    static Folder$folder$_Struct$name$ $name$ = NULL
//! endtextmacro

globals
    trigger InitLinks_DUMMY_TRIGGER = CreateTrigger()
    integer InitLinks_ITERATION
    integer InitLinks_THREAD_BREAK_COUNTER
    constant integer InitLinks_THREAD_BREAK_LIMIT = 300
endglobals

//! textmacro LinkToStruct takes folder, struct
    Folder$folder$_Struct$struct$ $struct$ = this
    Folder$folder$_Struct$struct$ LinkToStruct_$struct$
//! endtextmacro

struct DataStub
	method Destroy takes nothing returns nothing
	endmethod
endstruct

struct EventStub
	method Destroy takes nothing returns nothing
	endmethod
endstruct

struct IdStub
	method Event_Create takes nothing returns nothing
	endmethod
endstruct

struct rootStruct
	DataStub Data
	EventStub Event
	IdStub Id
endstruct

module Allocation
	//delegate rootStruct rootStruct

	//private static integer ALLOC_COUNT = 0
	//private static multiboarditem ALLOC_MB_ITEM
    private static thistype NEXT = NULL
    private static integer array QUEUED
    private static integer QUEUED_COUNT = 0

    /*method deallocCustom takes nothing returns nothing
        static if DEBUG then
            if (this == NULL) then
                call DebugEx("alloc: try to deallocate NULL instance")

                return
            endif

            if (thistype.QUEUED[this] != STRUCT_INVALID) then
                call DebugEx("alloc: try to double-deallocate instance " + I2S(this))

                return
            endif
        endif

        set thistype.QUEUED[this] = thistype.NEXT

        set thistype.QUEUED_COUNT = this
    endmethod

    static method allocCustom takes nothing returns thistype
        local thistype this = thistype.NEXT

        if (this == NULL) then
            set thistype.QUEUED_COUNT = thistype.QUEUED_COUNT + 1

            set this = thistype.QUEUED_COUNT
        else
            set thistype.NEXT = thistype.QUEUED[this]
        endif

        static if DEBUG then
            if (integer(this) > STRUCT_MAX) then
                call DebugEx(thistype.NAME + " - alloc: unable to allocate, reached stack limit")

                return NULL
            endif
        endif

        set thistype.QUEUED[this] = STRUCT_INVALID

        return this
    endmethod*/

	/*static method allocCount takes nothing returns integer
		return thistype.ALLOC_COUNT
	endmethod

	static method allocCountEx takes nothing returns nothing
		set Basic.STRUCT_ALLOC_COUNT_RESULT = thistype.allocCount()
	endmethod*/

	//private static method onInit takes nothing returns nothing
	//	call Basic.AddStruct(thistype.NAME, thistype.AllocCountEx)
	//endmethod

    private static integer COUNT = STRUCT_EMPTY

    private thistype next

	private static integer ALLOC_MODULE_INDEX

	private static method allocInit_autoRun takes nothing returns nothing
		/*local integer row = MultiboardGetRowCount(Basic.ALLOC_MB)

		call MultiboardSetRowCount(Basic.ALLOC_MB, row + 1)

		set thistype.ALLOC_MB_ITEM = MultiboardGetItem(Basic.ALLOC_MB, row, 1)*/

		set thistype.ALLOC_MODULE_INDEX = Basic.RegAllocModule(thistype.NAME)
	endmethod

	public boolean allocation_allocated
	public boolean allocation_destroyed
	public integer allocation_refs

	method IsAllocated takes nothing returns boolean
		return this.allocation_allocated
	endmethod

	method CountRefs takes nothing returns integer
		return this.allocation_refs
	endmethod

	method deallocate_demount takes nothing returns nothing
		set this.allocation_allocated = false

		injectTarget hook

		call Basic.AllocDec(thistype.ALLOC_MODULE_INDEX)
	endmethod

    private method deallocCustom_confirm takes nothing returns nothing
		if (this.allocation_refs > 0) then
			return
		endif

        static if DEBUG then
            if (this.next != STRUCT_INVALID) then
                call DebugEx(thistype.NAME + " - alloc: unable to deallocate instance " + I2S(this))

                return
            endif
        endif

        set this.next = thistype(NULL).next

        set thistype(NULL).next = this

		call this.deallocate_demount()
    endmethod

	method subRef takes nothing returns nothing
		set this.allocation_refs = this.allocation_refs - 1

		call this.deallocCustom_confirm()
	endmethod

	method deallocCustom takes nothing returns nothing
		call this.subRef()
	endmethod

	static method allocate_mount takes thistype this returns thistype
		//static if thistype.Data.Destroy.exists then
			//call DebugEx("allocate_mount: "+thistype.NAME)
			//call this.Id.Event_Create()
		//endif

		set this.allocation_allocated = true
		set this.allocation_destroyed = false

		injectTarget hook

		call Basic.AllocInc(thistype.ALLOC_MODULE_INDEX)

		return this
	endmethod

	method addRef takes nothing returns nothing
		set this.allocation_refs = this.allocation_refs + 1
	endmethod

    static method allocCustom takes nothing returns thistype
        local thistype this

        static if DEBUG then
            if (thistype.QUEUED_COUNT == STRUCT_MAX) then
                call DebugEx(thistype.NAME + " - alloc: unable to allocate, reached stack limit")

                return NULL
            endif
        endif

        if (thistype(NULL).next == NULL) then
            set thistype.COUNT = thistype.COUNT + 1

            set this = thistype.COUNT
        else
            set this = thistype(NULL).next

            set thistype(NULL).next = thistype(NULL).next.next
        endif

        static if DEBUG then
            set this.next = STRUCT_INVALID
        endif

		set this.allocation_refs = 1

		call thistype.allocate_mount(this)

        return this
    endmethod
endmodule

module List
    static thistype array ALL
    static integer ALL_COUNT = ARRAY_EMPTY

    integer index

    method GetIndex takes nothing returns integer
        return this.index - 1
    endmethod

    method GetIndexInList takes nothing returns integer
        return this.index
    endmethod

    method IsInList takes nothing returns boolean
        return (this.GetIndexInList() > ARRAY_MIN)
    endmethod

    static method RandomFromList takes integer lowBound, integer highBound returns thistype
        return thistype.ALL[Math.RandomI(lowBound, highBound)]
    endmethod

    method RemoveFromList takes nothing returns boolean
        local integer index = this.GetIndexInList()

        set thistype.ALL[thistype.ALL_COUNT].index = index
        set thistype.ALL[index - 1] = thistype.ALL[thistype.ALL_COUNT]

        set this.index = ARRAY_MIN

        set thistype.ALL_COUNT = thistype.ALL_COUNT - 1

        return (thistype.ALL_COUNT == ARRAY_EMPTY)
    endmethod

    method RemoveFromListSafe takes nothing returns nothing
        if this.IsInList() then
            call this.RemoveFromList()
        endif
    endmethod

    method RemoveFromListSorted takes nothing returns boolean
        local integer iteration = this.GetIndexInList() - 1

        loop
            exitwhen (iteration == thistype.ALL_COUNT)

            set thistype.ALL[iteration] = thistype.ALL[iteration + 1]

            set thistype.ALL[iteration].index = iteration + 1

            set iteration = iteration + 1
        endloop

        set this.index = ARRAY_MIN

        set thistype.ALL_COUNT = thistype.ALL_COUNT - 1

        return (thistype.ALL_COUNT == ARRAY_EMPTY)
    endmethod

    method AddToList takes nothing returns boolean
        set thistype.ALL_COUNT = thistype.ALL_COUNT + 1

        set thistype.ALL[thistype.ALL_COUNT] = this
        set this.index = thistype.ALL_COUNT + 1

        return (thistype.ALL_COUNT == ARRAY_MIN)
    endmethod
endmodule

//! textmacro CreateList takes name
    static thistype array $name$_ALL
    static integer $name$_ALL_COUNT = ARRAY_EMPTY

    integer $name$_index

    static method $name$_Count takes nothing returns integer
        return thistype.$name$_ALL_COUNT
    endmethod

    static method $name$_IsEmpty takes nothing returns boolean
        return (thistype.$name$_Count() == ARRAY_EMPTY)
    endmethod

    static method $name$_Get takes integer index returns thistype
        return thistype.$name$_ALL[index]
    endmethod

    static method $name$_GetIndex takes thistype this returns integer
        return this.$name$_index
    endmethod

    static method $name$_Contains takes thistype this returns boolean
        return (thistype.$name$_GetIndex(this) > ARRAY_MIN)
    endmethod

    static method $name$_Random takes integer lowBound, integer highBound returns thistype
        return thistype.$name$_ALL[Math.RandomI(lowBound, highBound)]
    endmethod

    static method $name$_RandomAll takes nothing returns thistype
        return thistype.$name$_Random(ARRAY_MIN, thistype.$name$_ALL_COUNT)
    endmethod

    static method $name$_Remove takes thistype this returns boolean
        if not thistype.$name$_Contains(this) then
            return false
        endif

        set thistype.$name$_ALL[thistype.$name$_ALL_COUNT].$name$_index = this.$name$_index
        set thistype.$name$_ALL[this.$name$_index - 1] = thistype.$name$_ALL[thistype.$name$_ALL_COUNT]

        set this.$name$_index = ARRAY_MIN

        set thistype.$name$_ALL_COUNT = thistype.$name$_ALL_COUNT - 1

        return (thistype.$name$_ALL_COUNT == ARRAY_EMPTY)
    endmethod

    static method $name$_Add takes thistype this returns boolean
        if thistype.$name$_Contains(this) then
            return false
        endif

        set thistype.$name$_ALL_COUNT = thistype.$name$_ALL_COUNT + 1

        set thistype.$name$_ALL[thistype.$name$_ALL_COUNT] = this
        set this.$name$_index = thistype.$name$_ALL_COUNT + 1

        return (thistype.$name$_ALL_COUNT == ARRAY_MIN)
    endmethod
//! endtextmacro

//! textmacro CreateForEachList takes name, parent
    static thistype array $name$_ALL
    static integer $name$_ALL_COUNT = ARRAY_EMPTY

    static method $name$_FetchFirst takes nothing returns thistype
        local thistype result

        if (thistype.$name$_ALL_COUNT < ARRAY_MIN) then
            return NULL
        endif

        set result = thistype.$name$_ALL[ARRAY_MIN]

        set thistype.$name$_ALL[ARRAY_MIN] = thistype.$name$_ALL[thistype.$name$_ALL_COUNT]

        set thistype.$name$_ALL_COUNT = thistype.$name$_ALL_COUNT - 1

        return result
    endmethod

    static method $name$_Set takes nothing returns nothing
        local integer iteration = thistype.$parent$_ALL_COUNT

        loop
            exitwhen (iteration < ARRAY_MIN)

            set thistype.$name$_ALL[iteration] = thistype.$parent$_ALL[iteration]

            set iteration = iteration - 1
        endloop
        set thistype.$name$_ALL_COUNT = thistype.$parent$_ALL_COUNT
    endmethod
//! endtextmacro

//! textmacro CreateQueue takes name
    static thistype $name$_LAST = NULL
    static thistype $name$_NEXT = NULL

    thistype $name$_next
    thistype $name$_prev

    static method $name$_IsEmpty takes nothing returns boolean
        return (thistype.$name$_NEXT == NULL)
    endmethod

    static method $name$_Contains takes thistype this returns boolean
        if (thistype.$name$_NEXT == this) then
            return true
        endif

        if ((this.$name$_prev != NULL) or (this.$name$_next != NULL)) then
            return true
        endif

        return false
    endmethod

    static method $name$_Count takes nothing returns integer
        local integer iteration = ARRAY_EMPTY
        local thistype this = thistype.$name$_NEXT

        loop
            exitwhen (this == NULL)

            set this = this.$name$_next

            set iteration = iteration + 1
        endloop

        return iteration
    endmethod

    static method $name$_Amount takes nothing returns integer
        return (thistype.$name$_Count() - ARRAY_EMPTY)
    endmethod

    static method $name$_GetIndex takes thistype this returns integer
        local integer iteration

        if (thistype.$name$_Contains(this) == false) then
            return ARRAY_EMPTY
        endif

        set iteration = ARRAY_MIN

        loop
            set this = this.$name$_prev

            exitwhen (this == NULL)

            set iteration = iteration + 1
        endloop

        return iteration
    endmethod

    static method $name$_GetFirst takes nothing returns thistype
        return thistype.$name$_NEXT
    endmethod

    static method $name$_GetLast takes nothing returns thistype
        return thistype.$name$_LAST
    endmethod

    static method $name$_GetNext takes thistype this returns thistype
        return this.$name$_next
    endmethod

    static method $name$_GetPrev takes thistype this returns thistype
        return this.$name$_prev
    endmethod

    static method $name$_FetchFirst takes nothing returns thistype
        local thistype this = thistype.$name$_NEXT

        if (this == NULL) then
            return NULL
        endif

        set thistype.$name$_NEXT = this.$name$_next

        set this.$name$_next = NULL
        if (thistype.$name$_NEXT == NULL) then
            set thistype.$name$_LAST = NULL
        else
            set thistype.$name$_NEXT.$name$_prev = NULL
        endif

        return this
    endmethod

    static method $name$_Remove takes thistype this returns boolean
        local thistype next
        local thistype prev

        if (thistype.$name$_Contains(this) == false) then
            return false
        endif

        if (thistype.$name$_NEXT == this) then
            call thistype.$name$_FetchFirst()

            return thistype.$name$_IsEmpty()
        endif

        set next = this.$name$_next
        set prev = this.$name$_prev

        if (prev != NULL) then
            set this.$name$_prev = NULL
            set prev.$name$_next = next
        endif
        if (next == NULL) then
            set thistype.$name$_LAST = prev
        else
            set this.$name$_next = NULL
            set next.$name$_prev = prev
        endif

        return thistype.$name$_IsEmpty()
    endmethod

    static method $name$_Add takes thistype this returns boolean
        if thistype.$name$_Contains(this) then
            return false
        endif

        set this.$name$_next = NULL

        if (thistype.$name$_NEXT == NULL) then
            set thistype.$name$_LAST = this
            set thistype.$name$_NEXT = this

            return true
        endif

        set this.$name$_prev = thistype.$name$_LAST
        set thistype.$name$_LAST.$name$_next = this

        set thistype.$name$_LAST = this

        return false
    endmethod
//! endtextmacro

//! textmacro CreatePriorityQueue takes name
	static thistype array $name$_PRIOS
	static thistype array $name$_SUBS

	static integer array $name$_CUR_PRIO

	static method $name$_FetchFirst takes thistype this, integer prio returns thistype
		
	endmethod

	static method $name$_Remove takes thistype this, integer prio returns boolean
		if not thistype.$name$_ALL.Contains(this) then
			return false
		endif

		local Queue sub = thistype.$name$_SUBS[prio]

		call sub.Remove(this)

		set thistype.$name$_CUR_PRIO[this] = NULL
		call thistype.$name$_ALL.Remove(this)

		return true
	endmethod

	static method $name$_Add takes thistype this, integer prio returns boolean
		local Queue sub = thistype.$name$_SUBS[prio]

		if (sub == NULL) then
			set sub = Queue.Create()

			set thistype.$name$_SUBS[prio] = sub

			set thistype.$name$_PRIOS
		endif

		if thistype.$name$_ALL.Contains(this) then
			return false
		endif

		call sub.Add(this)

		set thistype.$name$_CUR_PRIO[this] = prio
		call thistype.$name$_ALL.Add(this)

		return true
	endmethod
//! endtextmacro

struct Queue
    implement Allocation
    //implement Name

    static key NEXT_KEY_ARRAY_DETAIL_BASE
    static key PREV_KEY_ARRAY_DETAIL_BASE

    static constant integer NEXT_KEY_ARRAY_DETAIL = thistype.NEXT_KEY_ARRAY_DETAIL_BASE * ARRAY_SIZE
    static constant integer PREV_KEY_ARRAY_DETAIL = thistype.PREV_KEY_ARRAY_DETAIL_BASE * ARRAY_SIZE

    integer first
    integer last

    method GetFirst takes nothing returns integer
        return this.first
    endmethod

    method GetLast takes nothing returns integer
        return this.last
    endmethod

    method GetNext takes integer el returns integer
        return Memory.IntegerKeys.GetInteger(el, NEXT_KEY_ARRAY_DETAIL + this)
    endmethod

    method GetPrev takes integer el returns integer
        return Memory.IntegerKeys.GetInteger(el, PREV_KEY_ARRAY_DETAIL + this)
    endmethod

    method IsEmpty takes nothing returns boolean
        return (this.GetFirst() == NULL)
    endmethod

    method Contains takes integer el returns boolean
        if (this.GetFirst() == el) then
            return true
        endif

        if ((this.GetPrev(el) != NULL) or (this.GetNext(el) != NULL)) then
            return true
        endif

        return false
    endmethod

    method Count takes nothing returns integer
        local integer iteration = ARRAY_EMPTY
        local integer el = this.GetFirst()

        loop
            exitwhen (el == NULL)

            set el = this.GetNext(el)

            set iteration = iteration + 1
        endloop

        return iteration
    endmethod

    method GetIndex takes integer el returns integer
        local integer iteration

        if (this.Contains(el) == false) then
            return ARRAY_EMPTY
        endif

        set iteration = ARRAY_MIN

        loop
            set el = this.GetPrev(el)

            exitwhen (el == NULL)

            set iteration = iteration + 1
        endloop

        return iteration
    endmethod

    method FetchFirst takes nothing returns integer
        local integer el = this.GetFirst()

        if (el == NULL) then
            return NULL
        endif

        set this.first = Memory.IntegerKeys.GetInteger(el, NEXT_KEY_ARRAY_DETAIL + this)

        call Memory.IntegerKeys.SetInteger(el, NEXT_KEY_ARRAY_DETAIL + this, NULL)
        if (this.GetFirst() == NULL) then
            set this.last = NULL
        else
            call Memory.IntegerKeys.SetInteger(this.GetFirst(), PREV_KEY_ARRAY_DETAIL + this, NULL)
        endif

        return el
    endmethod

    method Clear takes nothing returns nothing
        loop
            exitwhen (this.FetchFirst() == NULL)
        endloop
    endmethod

    method Remove takes integer el returns boolean
        local integer next
        local integer prev

        if (this.Contains(el) == false) then
            return false
        endif

        if (this.GetFirst() == el) then
            call this.FetchFirst()

            return this.IsEmpty()
        endif

        set next = Memory.IntegerKeys.GetInteger(el, NEXT_KEY_ARRAY_DETAIL + this)
        set prev = Memory.IntegerKeys.GetInteger(el, PREV_KEY_ARRAY_DETAIL + this)

        if (prev != NULL) then
            call Memory.IntegerKeys.SetInteger(el, PREV_KEY_ARRAY_DETAIL + this, NULL)
            call Memory.IntegerKeys.SetInteger(prev, NEXT_KEY_ARRAY_DETAIL + this, next)
        endif
        if (next == NULL) then
            set this.last = prev
        else
            call Memory.IntegerKeys.SetInteger(el, NEXT_KEY_ARRAY_DETAIL + this, NULL)
            call Memory.IntegerKeys.SetInteger(next, PREV_KEY_ARRAY_DETAIL + this, prev)
        endif

        return this.IsEmpty()
    endmethod

    method Add takes integer el returns boolean
        if this.Contains(el) then
            return false
        endif

        call Memory.IntegerKeys.SetInteger(el, NEXT_KEY_ARRAY_DETAIL + this, NULL)

        if this.IsEmpty() then
            set this.first = el
            set this.last = el

            return true
        endif

        call Memory.IntegerKeys.SetInteger(el, PREV_KEY_ARRAY_DETAIL + this, this.GetLast())
        call Memory.IntegerKeys.SetInteger(this.GetLast(), NEXT_KEY_ARRAY_DETAIL + this, el)

        set this.last = el

        return false
    endmethod

    method Print takes nothing returns nothing
        local integer el = this.GetFirst()

        call DebugEx("print queue " + I2S(this) + ":")

        loop
            exitwhen (el == NULL)

            call DebugEx("\t" + I2S(el))

            set el = this.GetNext(el)
        endloop

        call DebugEx("---")
    endmethod

    /*method Iterator takes nothing returns IteratorQueue
        return IteratorQueue.Create(this)
    endmethod*/

    method Destroy takes nothing returns nothing
        call this.Clear()

        call this.deallocate()
    endmethod

    static method Create takes nothing returns thistype
        local thistype this = thistype.allocate()

        set this.first = NULL
        set this.last = NULL

        return this
    endmethod
endstruct

/*struct IteratorQueue
    integer next

    method GetNext takes nothing returns integer
        local integer next = this.next

        set this.next = parent.GetNext(next)

        return next
    endmethod

    static method Create takes Queue parent returns thistype
        local thistype this = thistype.allocate()

        set this.next = parent.GetFirst()
        set this.parent = parent

        return this
    endmethod
endstruct*/

module Name
    static method Name takes nothing returns nothing
    endmethod

    static constant string NAME = "<" + thistype.Name.name + ">"

    static constant string NAME_SHORT = thistype.Name.name
endmodule

//! textmacro Struct takes name
    public struct Struct$name$
        implement Allocation
        implement List
        //implement Name
//! endtextmacro



//! textmacro BaseStruct takes name, base
    globals
        $name$ $base$ = STRUCT_BASE
    endglobals

    struct $name$
        implement Allocation
        implement List
        //implement Name
//! endtextmacro

//! textmacro StaticStruct takes name
    struct $name$
//! endtextmacro

//! textmacro CreateSimpleAddState_NotAdd takes type, defaultValue
    $type$ value

    method Get takes nothing returns $type$
        return this.value
    endmethod

    method Set takes $type$ value returns nothing
        set this.value = value
    endmethod

    method Event_Create takes nothing returns nothing
        call this.Set($defaultValue$)
    endmethod

    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
//! endtextmacro

//! textmacro CreateSimpleAddState_NotStart takes type
    $type$ value

    method Get takes nothing returns $type$
        return this.value
    endmethod

    method Set takes $type$ value returns nothing
        set this.value = value
    endmethod

    method Add takes $type$ value returns nothing
        call this.Set(this.Get() + value)
    endmethod

    method Subtract takes $type$ value returns nothing
        call this.Set(this.Get() - value)
    endmethod

    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
//! endtextmacro

//! textmacro CreateSimpleAddState_OnlyGet takes type
    $type$ value

    method Get takes nothing returns $type$
        return this.value
    endmethod
//! endtextmacro

//! textmacro CreateSimpleAddState_OnlyStart takes defaultValue
    method Event_Create takes nothing returns nothing
        set this.value = $defaultValue$
    endmethod
//! endtextmacro

//! textmacro CreateSimpleAddState_OnlyAdd takes type, defaultValue
    method Add takes $type$ value returns nothing
        call this.Set(this.Get() + value)
    endmethod

    method Event_Create takes nothing returns nothing
        call this.Set($defaultValue$)
    endmethod

    method Subtract takes $type$ value returns nothing
        call this.Set(this.Get() - value)
    endmethod

    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
//! endtextmacro

//! textmacro CreateSimpleAddState_OnlyAddSub takes type
    method Add takes $type$ value returns nothing
        call this.Set(this.Get() + value)
    endmethod

    method Subtract takes $type$ value returns nothing
        call this.Set(this.Get() - value)
    endmethod
//! endtextmacro

//! textmacro CreateSimpleAddState_OnlyAdd_NotStart takes type
    method Add takes $type$ value returns nothing
        call this.Set(this.Get() + value)
    endmethod

    method Subtract takes $type$ value returns nothing
        call this.Set(this.Get() - value)
    endmethod

    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
//! endtextmacro

//! textmacro CreateSimpleAddState_OnlyAdd_UsePreset takes type, presetValue, defaultValue
    method Add takes $type$ value returns nothing
        call this.Set(this.Get() + value)
    endmethod

    method Event_Create takes nothing returns nothing
        set this.value = $presetValue$
        call this.Set($defaultValue$)
    endmethod

    method Subtract takes $type$ value returns nothing
        call this.Set(this.Get() - value)
    endmethod

    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
//! endtextmacro

//! textmacro CreateSimpleAddState_OnlyStart_UsePreset takes presetValue, defaultValue
    method Event_Create takes nothing returns nothing
        set this.value = $presetValue$
        call this.Set($defaultValue$)
    endmethod
//! endtextmacro

//! textmacro CreateSimpleAddState takes type, defaultValue
    $type$ value

    method Get takes nothing returns $type$
        return this.value
    endmethod

    method Set takes $type$ value returns nothing
        set this.value = value
    endmethod

    method Add takes $type$ value returns nothing
        call this.Set(this.Get() + value)
    endmethod

    method Event_Create takes nothing returns nothing
        call this.Set($defaultValue$)
    endmethod

    method Subtract takes $type$ value returns nothing
        call this.Set(this.Get() - value)
    endmethod

    method Update takes nothing returns nothing
        call this.Set(this.Get())
    endmethod
//! endtextmacro

//! textmacro CreateAnyFlagState takes varName, methodName
    boolean $varName$

    method Is$methodName$ takes nothing returns boolean
        return this.$varName$
    endmethod

    method Set$methodName$ takes boolean value returns nothing
        set this.$varName$ = value
    endmethod
//! endtextmacro

//! textmacro CreateAnyFlagStateDefault takes varName, methodName, default
    boolean $varName$ = $default$

    method Is$methodName$ takes nothing returns boolean
        return this.$varName$
    endmethod

    method Set$methodName$ takes boolean value returns nothing
        set this.$varName$ = value
    endmethod
//! endtextmacro

//! textmacro CreateAnyState takes varName, methodName, type
    $type$ $varName$

    method Get$methodName$ takes nothing returns $type$
        return this.$varName$
    endmethod

    method Set$methodName$ takes $type$ value returns nothing
        set this.$varName$ = value
    endmethod
//! endtextmacro

//! textmacro CreateAnyStateDefault takes varName, methodName, type, default
    $type$ $varName$

    method Get$methodName$ takes nothing returns $type$
        return this.$varName$
    endmethod

    method Set$methodName$ takes $type$ value returns nothing
        set this.$varName$ = value
    endmethod

	//! inject Allocation.allocate_mount.hook
		set this.$varName$ = $default$
	//! endinject
//! endtextmacro

//! textmacro CreateAnyStaticState takes varName, methodName, type
    static $type$ $varName$

    static method Get$methodName$ takes nothing returns $type$
        return thistype.$varName$
    endmethod

    static method Set$methodName$ takes $type$ value returns nothing
        set thistype.$varName$ = value
    endmethod
//! endtextmacro

//! textmacro CreateAnyStaticFlagState takes varName, methodName
    static boolean $varName$

    static method Is$methodName$ takes nothing returns boolean
        return thistype.$varName$
    endmethod

    static method Set$methodName$ takes boolean value returns nothing
        set thistype.$varName$ = value
    endmethod
//! endtextmacro

//! textmacro CreateAnyStaticStateDefault takes varName, methodName, type, default
    static $type$ $varName$ = $default$

    static method Get$methodName$ takes nothing returns $type$
        return thistype.$varName$
    endmethod

    static method Set$methodName$ takes $type$ value returns nothing
        set thistype.$varName$ = value
    endmethod
//! endtextmacro

//! textmacro CreateAnyStaticFlagStateDefault takes varName, methodName, default
    static boolean $varName$ = $default$

    static method Is$methodName$ takes nothing returns boolean
        return thistype.$varName$
    endmethod

    static method Set$methodName$ takes boolean value returns nothing
        set thistype.$varName$ = value
    endmethod
//! endtextmacro

//! textmacro CreateSimpleFlagState_NotStart
    boolean flag

    method Is takes nothing returns boolean
        return this.flag
    endmethod

    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod
//! endtextmacro

//! textmacro CreateSimpleFlagState takes defaultValue
    boolean flag

    method Is takes nothing returns boolean
        return this.flag
    endmethod

    method Set takes boolean flag returns nothing
        set this.flag = flag
    endmethod

    method Event_Create takes nothing returns nothing
        call this.Set($defaultValue$)
    endmethod
//! endtextmacro

//! textmacro CreateSimpleFlagCountState takes defaultValue
    integer flag

    method Get takes nothing returns integer
        return this.flag
    endmethod

    method Is takes nothing returns boolean
        return (this.flag > 0)
    endmethod

    method Set takes integer flag returns nothing
        set this.flag = flag
    endmethod

    method Subtract takes nothing returns nothing
        call this.Set(this.Get() - 1)
    endmethod

    method SubtractValue takes integer value returns nothing
        call this.Set(this.Get() - value)
    endmethod

    method Add takes nothing returns nothing
        call this.Set(this.Get() + 1)
    endmethod

    method AddValue takes integer value returns nothing
        call this.Set(this.Get() + value)
    endmethod

    method Event_Create takes nothing returns nothing
        call this.Set($defaultValue$)
    endmethod
//! endtextmacro

//! textmacro CreateSimpleFlagCountState_NotStart
    integer flag

    method Get takes nothing returns integer
        return this.flag
    endmethod

    method Is takes nothing returns boolean
        return (this.flag > 0)
    endmethod

    method Set takes integer flag returns nothing
        set this.flag = flag
    endmethod

    method Subtract takes nothing returns nothing
        call this.Set(this.Get() - 1)
    endmethod

    method Add takes nothing returns nothing
        call this.Set(this.Get() + 1)
    endmethod
//! endtextmacro

//! textmacro CreateAnyFlagCountState takes name
    integer flag$name$

    method Get$name$ takes nothing returns integer
        return this.flag$name$
    endmethod

    method Is$name$ takes nothing returns boolean
        return (this.flag$name$ > 0)
    endmethod

    method Set$name$ takes integer value returns nothing
        set this.flag$name$ = value
    endmethod

    method Subtract$name$ takes nothing returns nothing
        call this.Set$name$(this.Get$name$() - 1)
    endmethod

    method SubtractValue$name$ takes integer value returns nothing
        call this.Set$name$(this.Get$name$() - value)
    endmethod

    method Add$name$ takes nothing returns nothing
        call this.Set$name$(this.Get$name$() + 1)
    endmethod

    method AddValue$name$ takes integer value returns nothing
        call this.Set$name$(this.Get$name$() + value)
    endmethod
//! endtextmacro

globals
    boolean TEMP_BOOLEAN
    boolean TEMP_BOOLEAN2
    boolean TEMP_BOOLEAN3
    boolean TEMP_BOOLEAN4
    integer TEMP_INTEGER
    integer TEMP_INTEGER2
    integer TEMP_INTEGER3
    integer TEMP_INTEGER4
    real TEMP_REAL
    real TEMP_REAL2
    real TEMP_REAL3
    real TEMP_REAL4
    real TEMP_REAL5
    real TEMP_REAL6
endglobals

globals
    boolean exit
endglobals

function Exit takes nothing returns boolean
    return exit
endfunction

function booleanToString takes boolean b returns string
    if (b) then
        return "true"
    endif

    return "false"
endfunction

function integerToString takes integer a returns string
    return I2S(a)
endfunction

function realToString takes real a returns string
    return R2S(a)
endfunction

function stringToString takes string s returns string
    return s
endfunction

function Print takes string s returns nothing
    call DisplayTextToPlayer(GetLocalPlayer(), 0., 0., s)
endfunction

function RenderGraphics takes nothing returns nothing
    //call PauseGame(true)

    //call Trigger.Sleep(0.)

    //call PauseGame(false)
endfunction

/*//! externalblock extension=lua ObjectMerger $FILENAME$
    //! i setobjecttype("doodads")

    //! i modifyobject("D02G")

    //! i makechange(current, "dfil", "Doodads\\Grass\\Grass")
//! endexternalblock*/

struct ObjThread
    implement Allocation
    implement List
    //implement Name

    static timer CHECK_TIMER = null

    string name

    method AddMark takes string value returns nothing
        set this.name = this.name + ";" + value
    endmethod

    method Destroy takes nothing returns nothing
        call this.deallocate()

        if this.RemoveFromList() then
            call PauseTimer(thistype.CHECK_TIMER)
        endif
    endmethod

    static method PrintErrors takes nothing returns nothing
        local integer i = thistype.ALL_COUNT

		call DebugBufferStart()

        loop
            exitwhen (i < ARRAY_MIN)

            call DebugBuffer("threadBreak (ObjThread): " + thistype.ALL[i].name)
set DEBUG_EX_ON = false
            call thistype.ALL[i].Destroy()
set DEBUG_EX_ON = true
            set i = i - 1
        endloop

		call DebugBufferFinish()
    endmethod

    static method Create takes string name returns thistype
        local thistype this = thistype.allocate()

        set this.name = name

        if this.AddToList() then
            if (thistype.CHECK_TIMER == null) then
                set thistype.CHECK_TIMER = CreateTimer()
            endif

            call TimerStart(thistype.CHECK_TIMER, 1, true, function thistype.PrintErrors)
        endif

        return this
    endmethod

    static method CreateEx takes string name returns thistype
        call InfoEx("init: " + name)

        return thistype.Create(name)
    endmethod
endstruct

//end of file: D:\Warcraft III\Mapping\WFW\Data\Basic.page\Basic.j

//file: D:\Warcraft III\Mapping\WFW\Data\Constructions\Brick.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Brick")
    globals
        public constant integer INDEX = 2
    endglobals

    public function TerrainChangeEnding takes real x, real y returns nothing
        call SetTerrainPointPathable( x, y, PATHING_TYPE_BUILDABILITY, false )
    endfunction

    public function TerrainChangeStart takes real x, real y returns nothing
        call SetTerrainPointPathable( x, y, PATHING_TYPE_BUILDABILITY, true )
    endfunction

    public function ConstructingFinish takes Unit constructedStructure returns nothing
        local unit constructedStructureSelf
        local real constructedStructureX
        local real constructedStructureY
        if ( constructedStructure.type.id == BRICK_UNIT_ID ) then
            set constructedStructureSelf = constructedStructure.self
            set constructedStructureX = GetUnitX( constructedStructureSelf )
            set constructedStructureY = GetUnitY( constructedStructureSelf )
            set constructedStructureSelf = null
            call RemoveUnitEx( constructedStructure )
            call SetTerrainTypeExWithSize( constructedStructureX, constructedStructureY, GetTerrainTileFromSet(TILESET, INDEX ), 3 )
        endif
    endfunction

    public function Init takes nothing returns nothing
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Constructions\Brick.j

//file: D:\Warcraft III\Mapping\WFW\Data\Constructions\Grass.j
//TESH.scrollpos=108
//TESH.alwaysfold=0
//! runtextmacro Scope("Grass")
    globals
        private trigger DUMMY_TRIGGER
        private group ENUM_GROUP
        private rect ENUM_RECT
        public constant integer INDEX = 5
        private constant real BONUS_RELATIVE_LIFE_REGENERATION = 1.5
        public group TARGET_GROUP
        public region TARGET_REGION
    endglobals

    private function TargetConditions takes Unit checkingUnit returns boolean
        if ( checkingUnit == NULL ) then
            return false
        endif
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        return true
    endfunction

    private function Ending takes Unit whichUnit returns nothing
        local real bonusLifeRegeneration
        local integer whichUnitId
        local unit whichUnitSelf = whichUnit.self
        if ( IsUnitInGroup( whichUnitSelf, TARGET_GROUP ) ) then
            set whichUnitId = whichUnit.id
            set bonusLifeRegeneration = -GetAttachedRealById( whichUnitId, Grass_SCOPE_ID )
            call FlushAttachedRealById(whichUnitId, Grass_SCOPE_ID)
            //! runtextmacro RemoveEventById( "whichUnitId", "EVENT_DEATH" )
            call GroupRemoveUnit( TARGET_GROUP, whichUnitSelf )
            call AddUnitLifeRegenerationBonus( whichUnit, bonusLifeRegeneration )
        endif
        set whichUnitSelf = null
    endfunction

    public function Death takes Unit whichUnit returns nothing
        call Ending(whichUnit)
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death(DYING_UNIT)
    endfunction

    public function TerrainChangeEnding takes real x, real y returns nothing
        local unit enumUnit
        call SetRect( ENUM_RECT, x - TERRAIN_POINT_SIZE_HALF, y - TERRAIN_POINT_SIZE_HALF, x + TERRAIN_POINT_SIZE_HALF, y + TERRAIN_POINT_SIZE_HALF )
        call RegionAddRect( Grass_TARGET_REGION, ENUM_RECT )
        call SetRect( ENUM_RECT, x - (TERRAIN_POINT_SIZE_HALF + CELL_SIZE), y - (TERRAIN_POINT_SIZE_HALF + CELL_SIZE), x + (TERRAIN_POINT_SIZE_HALF + CELL_SIZE), y + (TERRAIN_POINT_SIZE_HALF + CELL_SIZE) )
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, ENUM_RECT, null )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if ( ( IsUnitInRegion( TARGET_REGION, enumUnit ) == false ) and ( IsUnitInGroup( enumUnit, ENUM_GROUP ) ) ) then
                    call Ending(GetUnit(enumUnit))
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function Start takes Unit whichUnit returns nothing
        local real bonusLifeRegeneration = GetUnitLifeRegeneration( whichUnit ) * BONUS_RELATIVE_LIFE_REGENERATION
        local integer whichUnitId = whichUnit.id
        call AttachRealById(whichUnitId, Grass_SCOPE_ID, bonusLifeRegeneration)
        //! runtextmacro AddEventById( "whichUnitId", "EVENT_DEATH" )
        call GroupAddUnit( TARGET_GROUP, whichUnit.self )
        call AddUnitLifeRegenerationBonus( whichUnit, bonusLifeRegeneration )
    endfunction

    public function TerrainChangeStart takes real x, real y returns nothing
        local Unit enumUnit
        local unit enumUnitSelf
        call SetRect( ENUM_RECT, x - TERRAIN_POINT_SIZE_HALF, y - TERRAIN_POINT_SIZE_HALF, x + TERRAIN_POINT_SIZE_HALF, y + TERRAIN_POINT_SIZE_HALF )
        call RegionAddRect( Grass_TARGET_REGION, ENUM_RECT )
        call SetRect( ENUM_RECT, x - (TERRAIN_POINT_SIZE_HALF + CELL_SIZE), y - (TERRAIN_POINT_SIZE_HALF + CELL_SIZE), x + (TERRAIN_POINT_SIZE_HALF + CELL_SIZE), y + (TERRAIN_POINT_SIZE_HALF + CELL_SIZE) )
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, ENUM_RECT, null )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                if ( IsUnitInRegion( TARGET_REGION, enumUnitSelf ) and (IsUnitInGroup( enumUnitSelf, ENUM_GROUP ) == false) ) then
                    set enumUnit = GetUnit(enumUnitSelf)
                    if ( TargetConditions( enumUnit ) ) then
                        call Start(enumUnit)
                    endif
                endif
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
    endfunction

    public function Activate takes Unit whichUnit returns nothing
        if ( IsUnitInRegion( TARGET_REGION, whichUnit.self ) and TargetConditions(whichUnit) ) then
            call Start(whichUnit)
        endif
    endfunction

    function Activate_Event takes nothing returns nothing
        call Activate( TRIGGER_UNIT )
    endfunction

    private function Trig takes nothing returns nothing
        local Unit triggerUnit = GetUnit(GetTriggerUnit())
        if ( TargetConditions( triggerUnit ) ) then
            if ( GetHandleId(GetTriggerEventId()) == 5 ) then
                call Start(triggerUnit)
            else
                call Ending(triggerUnit)
            endif
        endif
    endfunction

    public function ConstructingFinish takes Unit constructedStructure returns nothing
        local unit constructedStructureSelf
        local real constructedStructureX
        local real constructedStructureY
        if ( constructedStructure.type.id == GRASS_UNIT_ID ) then
            set constructedStructureSelf = constructedStructure.self
            set constructedStructureX = GetUnitX( constructedStructureSelf )
            set constructedStructureY = GetUnitY( constructedStructureSelf )
            set constructedStructureSelf = null
            call RemoveUnitEx( constructedStructure )
            call SetTerrainTypeExWithSize( constructedStructureX, constructedStructureY, GetTerrainTileFromSet(TILESET, INDEX ), 3 )
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_RECT = RectWJ(0, 0, 0, 0)
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_GROUP = CreateGroupWJ()
        set TARGET_REGION = CreateRegionWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        call TriggerRegisterEnterRegion( DUMMY_TRIGGER, TARGET_REGION, null )
        call TriggerRegisterLeaveRegion( DUMMY_TRIGGER, TARGET_REGION, null )
        call AddNewSavedEvent( "MainIntegers", UnitIsActivated_EVENT_STRING_KEY, 0, function Activate_Event )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Constructions\Grass.j

//file: D:\Warcraft III\Mapping\WFW\Data\Constructions\Marble.j
//TESH.scrollpos=108
//TESH.alwaysfold=0
//! runtextmacro Scope("Marble")
    globals
        private trigger DUMMY_TRIGGER
        private group ENUM_GROUP
        private rect ENUM_RECT
        public constant integer INDEX = 3
        private constant real BONUS_RELATIVE_MANA_REGENERATION = 1.
        public group TARGET_GROUP
        public region TARGET_REGION
    endglobals

    private function TargetConditions takes Unit checkingUnit returns boolean
        if ( checkingUnit == NULL ) then
            return false
        endif
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        return true
    endfunction

    private function Ending takes Unit whichUnit returns nothing
        local real bonusManaRegeneration
        local integer whichUnitId
        local unit whichUnitSelf = whichUnit.self
        if ( IsUnitInGroup( whichUnitSelf, TARGET_GROUP ) ) then
            set whichUnitId = whichUnit.id
            set bonusManaRegeneration = -GetAttachedRealById( whichUnitId, Marble_SCOPE_ID )
            call FlushAttachedRealById( whichUnitId, Marble_SCOPE_ID )
            //! runtextmacro RemoveEventById( "whichUnitId", "EVENT_DEATH" )
            call GroupRemoveUnit( TARGET_GROUP, whichUnitSelf )
            call AddUnitManaRegenerationBonus( whichUnit, bonusManaRegeneration )
        endif
        set whichUnitSelf = null
    endfunction

    public function Death takes Unit whichUnit returns nothing
        call Ending(whichUnit)
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death(DYING_UNIT)
    endfunction

    public function TerrainChangeEnding takes real x, real y returns nothing
        local unit enumUnit
        call SetRect( ENUM_RECT, x - 64, y - 64, x + 64, y + 64 )
        call RegionAddRect( Marble_TARGET_REGION, ENUM_RECT )
        call SetRect( ENUM_RECT, x - 96, y - 96, x + 96, y + 96 )
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, ENUM_RECT, null )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if ( ( IsUnitInRegion( TARGET_REGION, enumUnit ) == false ) and ( IsUnitInGroup( enumUnit, ENUM_GROUP ) ) ) then
                    call GroupRemoveUnit( TARGET_GROUP, enumUnit )
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function Start takes Unit whichUnit returns nothing
        local real bonusManaRegeneration = GetUnitManaRegeneration( whichUnit ) * BONUS_RELATIVE_MANA_REGENERATION
        local integer whichUnitId = whichUnit.id
        call AttachRealById( whichUnitId, Marble_SCOPE_ID, bonusManaRegeneration )
        //! runtextmacro AddEventById( "whichUnitId", "EVENT_DEATH" )
        call GroupAddUnit( TARGET_GROUP, whichUnit.self )
        call AddUnitManaRegenerationBonus( whichUnit, bonusManaRegeneration )
    endfunction

    public function TerrainChangeStart takes real x, real y returns nothing
        local Unit enumUnit
        local unit enumUnitSelf
        call SetRect( ENUM_RECT, x - TERRAIN_POINT_SIZE_HALF, y - TERRAIN_POINT_SIZE_HALF, x + TERRAIN_POINT_SIZE_HALF, y + TERRAIN_POINT_SIZE_HALF )
        call RegionAddRect( Marble_TARGET_REGION, ENUM_RECT )
        call SetRect( ENUM_RECT, x - (TERRAIN_POINT_SIZE_HALF + CELL_SIZE), y - (TERRAIN_POINT_SIZE_HALF + CELL_SIZE), x + (TERRAIN_POINT_SIZE_HALF + CELL_SIZE), y + (TERRAIN_POINT_SIZE_HALF + CELL_SIZE) )
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, ENUM_RECT, null )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                if ( ( IsUnitInRegion( TARGET_REGION, enumUnitSelf ) ) and ( IsUnitInGroup( enumUnitSelf, ENUM_GROUP ) == false ) ) then
                    set enumUnit = GetUnit(enumUnitSelf)
                    if ( TargetConditions( enumUnit ) ) then
                        call Start(enumUnit)
                    endif
                endif
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
    endfunction

    public function Activate takes Unit whichUnit returns nothing
        if ( IsUnitInRegion( TARGET_REGION, whichUnit.self ) and TargetConditions(whichUnit) ) then
            call Start(whichUnit)
        endif
    endfunction

    private function Activate_Event takes nothing returns nothing
        call Activate( TRIGGER_UNIT )
    endfunction

    private function Trig takes nothing returns nothing
        local Unit triggerUnit = GetUnit(GetTriggerUnit())
        if ( TargetConditions( triggerUnit ) ) then
            if ( GetHandleId(GetTriggerEventId()) == 5 ) then
                call Start(triggerUnit)
            else
                call Ending(triggerUnit)
            endif
        endif
    endfunction

    public function ConstructingFinish takes Unit constructedStructure returns nothing
        local unit constructedStructureSelf
        local real constructedStructureX
        local real constructedStructureY
        if ( constructedStructure.type.id == MARBLE_UNIT_ID ) then
            set constructedStructureSelf = constructedStructure.self
            set constructedStructureX = GetUnitX( constructedStructureSelf )
            set constructedStructureY = GetUnitY( constructedStructureSelf )
            set constructedStructureSelf = null
            call RemoveUnitEx( constructedStructure )
            call SetTerrainTypeExWithSize( constructedStructureX, constructedStructureY, GetTerrainTileFromSet(TILESET, INDEX ), 3 )
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_RECT = RectWJ(0, 0, 0, 0)
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_GROUP = CreateGroupWJ()
        set TARGET_REGION = CreateRegionWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        call TriggerRegisterEnterRegion( DUMMY_TRIGGER, TARGET_REGION, null )
        call TriggerRegisterLeaveRegion( DUMMY_TRIGGER, TARGET_REGION, null )
        call AddNewSavedEvent( "MainIntegers", UnitIsActivated_EVENT_STRING_KEY, 0, function Activate_Event )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Constructions\Marble.j

//file: D:\Warcraft III\Mapping\WFW\Data\Constructions\MasterWizard.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("MasterWizard")
    globals
        public constant real BONUS_MANA_PER_KILL = 10.
        Unit array MASTER_WIZARDS
    endglobals

    private struct MasterWizard_Data
        player array playersSelecting[MAX_PLAYERS_AMOUNT]
        integer playersSelectingCount
        force ship
        integer team
        boolean used
    endstruct

    public function Death takes Unit killingUnit, player killingUnitOwner returns nothing
        local integer killingUnitTeam
        local texttag newTextTag
        local Unit wizard
        local unit wizardSelf
        local real wizardX
        local real wizardY
        if (killingUnit != null) then
            if (GetPlayerId(killingUnitOwner) <= MAX_PLAYER_INDEX) then
                if (IsUnitType(killingUnit.self, UNIT_TYPE_SUMMONED) == false) then
                    set killingUnitTeam = GetPlayerTeam( killingUnitOwner )
                    set wizard = MASTER_WIZARDS[killingUnitTeam]
                    set wizardSelf = wizard.self
                    set wizardX = GetUnitX(wizardSelf)
                    set wizardY = GetUnitY(wizardSelf)
                    set newTextTag = CreateRisingTextTag( "+" + I2S( R2I( BONUS_MANA_PER_KILL ) ), 0.024, wizardX, wizardY, GetUnitZ( wizardSelf, wizardX, wizardY ) + GetUnitOutpactZ(wizard), 80, 0, 0, 255, 255, 0, 3 )
                    if ( newTextTag != null ) then
                        call LimitTextTagVisibilityToTeam( newTextTag, killingUnitTeam )
                    endif
                    set newTextTag = null
                    call AddUnitState( wizardSelf, UNIT_STATE_MANA, BONUS_MANA_PER_KILL )
                    set wizardSelf = null
                endif
            endif
        endif
    endfunction

    public function Deselect takes player whichPlayer, Unit wizard returns nothing
        local MasterWizard_Data d
        local integer iteration
        local integer playersSelectingCount
        local force ship
        if ( wizard.type.id == MASTER_WIZARD_UNIT_ID ) then
            set d = GetAttachedIntegerById(wizard.id, MasterWizard_SCOPE_ID)
            if ( GetPlayerTeam( whichPlayer ) == d.team ) then
                set playersSelectingCount = d.playersSelectingCount
                set iteration = playersSelectingCount
                if ( whichPlayer == d.playersSelecting[0] ) then
                    if ( playersSelectingCount == 0 ) then
                        call SetUnitColor( wizard.self, NEUTRAL_PASSIVE_PLAYER_COLOR )
                    else
                        call SetUnitOwnerEx( wizard, d.playersSelecting[1], true )
                    endif
                endif
                loop
                    exitwhen (d.playersSelecting[iteration] == whichPlayer)
                    set iteration = iteration - 1
                endloop
                set d.playersSelecting[iteration] = d.playersSelecting[playersSelectingCount]
                set d.playersSelectingCount = playersSelectingCount - 1
                call ForceRemovePlayer(d.ship, whichPlayer)
            endif
        endif
    endfunction

    public function Select takes player whichPlayer, Unit wizard returns nothing
        local MasterWizard_Data d
        local integer playersSelectingCount
        local force ship
        if ( wizard.type.id == MASTER_WIZARD_UNIT_ID ) then
            set d = GetAttachedIntegerById(wizard.id, MasterWizard_SCOPE_ID)
            if ( GetPlayerTeam( whichPlayer ) == d.team ) then
                set ship = d.ship
                if ( IsPlayerInForce(whichPlayer, ship) == false ) then
                    set playersSelectingCount = d.playersSelectingCount + 1
                    if ( playersSelectingCount == 0 ) then
                        call SetUnitOwnerEx( wizard, whichPlayer, true )
                    endif
                    set d.playersSelecting[playersSelectingCount] = whichPlayer
                    set d.playersSelectingCount = playersSelectingCount
                    call ForceAddPlayer(ship, whichPlayer)
                endif
                set ship = null
            endif
        endif
    endfunction

    public function Start takes integer team, Unit wizard returns nothing
        local MasterWizard_Data d = MasterWizard_Data.create()
        set d.playersSelectingCount = -1
        set d.ship = CreateForce()
        set d.team = team
        set MASTER_WIZARDS[team] = wizard
        call AttachIntegerById(wizard.id, MasterWizard_SCOPE_ID, d)
        call SetUnitColor( wizard.self, NEUTRAL_PASSIVE_PLAYER_COLOR )
        call AddUnitAllSight( wizard )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Constructions\MasterWizard.j

//file: D:\Warcraft III\Mapping\WFW\Data\Constructions\TownHall.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("TownHall")
    globals
        private constant real BONUS_SCALE = 1.
        private constant real LENGTH = 250.
        private constant real SCALE_TIME = 1.
        private constant integer START_UNITS_AMOUNT = 5
        private constant real UPDATE_TIME = 0.035
        private constant real ANGLE_ADD = 30 * DEG_TO_RAD * UPDATE_TIME
    endglobals

    private struct Data
        real angle
        Unit researchCenter
        Unit townHall
        timer updateTimer
    endstruct

    private function GetTownHallData takes Unit townHall returns Data
        return GetAttachedIntegerById(townHall.id, TownHall_SCOPE_ID)
    endfunction

    public function Death takes Unit townHall, UnitType townHallType returns nothing
        if ( IsUnitTypeTownHall(townHallType) ) then
            call Miscellaneous_Spawn_Spawn_Destroy(townHall)
        endif
    endfunction

    private function Ending takes Data d, Unit townHall returns nothing
        call d.destroy()
        call FlushAttachedIntegerById(townHall.id, TownHall_SCOPE_ID)
        if (GetLocalPlayer() == townHall.owner) then
            call SetUnitScaleWJ(townHall.self, 0)
        endif
        //call AddUnitScaleTimedForPlayer( researchCenter, -BONUS_SCALE, SCALE_TIME, townHallOwner )
    endfunction

    //! runtextmacro Scope("Deselection")
        private struct Deselection_Data
            timer durationTimer
            Unit townHall
        endstruct

        private function Deselection_Ending takes Deselection_Data d, timer durationTimer, Unit townHall returns nothing
            call d.destroy()
            call FlushAttachedInteger(durationTimer, TownHall_SCOPE_ID)
            call DestroyTimerWJ(durationTimer)
            set durationTimer = null
            call FlushAttachedIntegerById(townHall.id, TownHall_SCOPE_ID)
            call BJDebugMsg("ende7")
            call Ending(GetTownHallData(townHall), townHall)
            call BJDebugMsg("ende8")
        endfunction

        private function Deselection_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Deselection_Data d = GetAttachedInteger(durationTimer, Deselection_SCOPE_ID)
            call Deselection_Ending(d, durationTimer, d.townHall)
            set durationTimer = null
            call BJDebugMsg("ende6")
        endfunction

        public function Deselection_EndingBySelect takes Unit townHall returns nothing
            local Deselection_Data d = GetAttachedIntegerById(townHall.id, Deselection_SCOPE_ID)
            if (d != NULL) then
                call Deselection_Ending(d, d.durationTimer, townHall)
            endif
        endfunction

        public function Deselection_Start takes Unit townHall returns nothing
            local Deselection_Data d = Deselection_Data.create()
            local timer durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.townHall = townHall
            call AttachInteger(durationTimer, Deselection_SCOPE_ID, d)
            call AttachIntegerById(townHall.id, Deselection_SCOPE_ID, d)
            call TimerStart(durationTimer, 0, false, function Deselection_EndingByTimer)
            set durationTimer = null
            call BJDebugMsg("ende5")
        endfunction
    //! runtextmacro Endscope()

    public function Deselect takes player townHallOwner, Unit triggerUnit returns nothing
        local Data d
        local Unit researchCenter = GetPlayerResearchCenter(townHallOwner)
        local Unit townHall
        call BJDebugMsg("ende1")
        if (researchCenter != NULL) then
        call BJDebugMsg("ende2")
            set townHall = GetPlayerTownHall(townHallOwner)
            call BJDebugMsg(B2S(IsUnitSelected(researchCenter.self, townHallOwner)))
            if (((triggerUnit == townHall) and (IsUnitSelected(researchCenter.self, townHallOwner) == false)) or ((triggerUnit == researchCenter) and (IsUnitSelected(townHall.self, townHallOwner) == false))) then
            call BJDebugMsg("ende3")
                set d = GetAttachedIntegerById(townHall.id, TownHall_SCOPE_ID)
                if (d != NULL) then
                call BJDebugMsg("ende4")
                    call Deselection_Deselection_Start(townHall)
                endif
            endif
        endif
    endfunction
    
    private function Update takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, TownHall_SCOPE_ID)
        local real angle = d.angle + ANGLE_ADD
        local unit researchCenter = d.researchCenter.self
        local unit townHall = d.townHall.self
        set updateTimer = null
        set d.angle = angle
        call BJDebugMsg("update")
        call SetUnitX(researchCenter, GetUnitX(townHall) + LENGTH * Cos(angle))
        call SetUnitY(researchCenter, GetUnitY(townHall) + LENGTH * Sin(angle))
        set researchCenter = null
        set townHall = null
    endfunction

    public function Select takes player townHallOwner, Unit triggerUnit returns nothing
        local integer townHallId
        local Data d
        local Unit researchCenter = GetPlayerResearchCenter(townHallOwner)
        local Unit townHall
        local timer updateTimer
        call BJDebugMsg("sel1")
        if (researchCenter != NULL) then
        call BJDebugMsg("sel2")
            set townHall = GetPlayerTownHall(townHallOwner)
            call BJDebugMsg(GetUnitName(researchCenter.self)+"; "+GetPlayerName(townHallOwner))
            if ((triggerUnit == townHall) or (triggerUnit == researchCenter)) then
            call BJDebugMsg("sel3")
                set townHallId = townHall.id
                set d = GetAttachedIntegerById(townHallId, TownHall_SCOPE_ID)
                call Deselection_Deselection_EndingBySelect(townHall)
                if (d == NULL) then
                call BJDebugMsg("sel4")
                    set d = Data.create()
                    set researchCenter = GetPlayerResearchCenter(townHall.owner)
                    set updateTimer = CreateTimerWJ()
                    set d.angle = GetRandomReal(0, 2 * PI)
                    set d.researchCenter = researchCenter
                    set d.townHall = townHall
                    set d.updateTimer = updateTimer
                    call AttachIntegerById(townHallId, TownHall_SCOPE_ID, d)
                    call AttachInteger(updateTimer, TownHall_SCOPE_ID, d)
                    if (GetLocalPlayer() == townHallOwner) then
                        call SetUnitScaleWJ(townHall.self, GetUnitTypeScale(townHall.type))
                    endif
                    //call AddUnitScaleTimedForPlayer( researchCenter, BONUS_SCALE, SCALE_TIME, townHallOwner )
                    call TimerStart(updateTimer, UPDATE_TIME, true, function Update)
                    set updateTimer = null
                endif
            endif
        endif
    endfunction

    public function UpgradeFinish takes Unit townHall, player townHallOwner, UnitType townHallType returns nothing
        local integer iteration
        local real newUnitX
        local real newUnitY
        local real townHallX
        local real townHallY
        local integer spawnTypeId
        local Race specificRace
        local real townHallCenterAngle
        local Race townHallRace
        local unit townHallSelf
        if ( IsUnitTypeTownHall(townHallType) ) then
            set townHallRace = GetUnitTypeRace(townHallType)
            set townHallSelf = townHall.self
            set townHallX = GetUnitX( townHallSelf )
            set townHallY = GetUnitY( townHallSelf )
            if ( IsPlayerStarted(townHallOwner) == false ) then
                set townHallCenterAngle = Atan2( CENTER_Y - townHallY, CENTER_X - townHallX )
                set iteration = 1
                set newUnitX = townHallX + 300 * Cos( townHallCenterAngle )
                set newUnitY = townHallY + 300 * Sin( townHallCenterAngle )
                set spawnTypeId = GetUnitTypeSpawnTypeId(townHallType)
                if ( GetPlayerController( townHallOwner ) == MAP_CONTROL_COMPUTER ) then
                    call IssuePointOrderById( townHallSelf, SET_RALLY_ORDER_ID, 0, 0 )
                endif
                call SetPlayerStarted(townHallOwner, true)
                call CreateAltar( townHallOwner )
                loop
                    call CreateUnitEx(townHallOwner, spawnTypeId, newUnitX, newUnitY, townHallCenterAngle)
                    set iteration = iteration + 1
                    exitwhen (iteration > START_UNITS_AMOUNT)
                endloop
            endif
            if (GetUnitTypeSpawnStage(townHallType) == 0) then
                set TEMP_UNIT = CreateUnitEx(townHallOwner, GetRaceResearchCenter(townHallRace), townHallX, townHallY, STANDARD_ANGLE)
                call SetPlayerResearchCenter( townHallOwner, TEMP_UNIT )
            endif
            call UnitAddAbility( townHallSelf, DELIVER_LUMBER_SPELL_ID )
            if (GetPlayerTechCount(townHallOwner, FeelingOfSecurity_RESEARCH_ID, true) > 0) then
                call UnitAddAbility( townHallSelf, FeelingOfSecurity_UPGRADED_SPELL_ID )
            else
                call UnitAddAbility( townHallSelf, FeelingOfSecurity_SPELL_ID )
            endif
            set townHallSelf = null
            call SetPlayerRaceWJ(townHallOwner, townHallRace)
            call Miscellaneous_Spawn_Spawn_Start( townHall, GetUnitTypeSpawnTypeId(townHallType), townHallOwner )
        endif
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Constructions\TownHall.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\CoinIsPickedUp.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope CoinIsPickedUp
    globals
        public trigger DUMMY_TRIGGER

        public integer AMOUNT
    endglobals

    private function TriggerEvents takes player triggerPlayer, integer amount returns nothing
        call Infoboard_Additionboard_Additionboard_Coin(triggerPlayer, amount)
    endfunction

    private function Trig takes nothing returns nothing
        call TriggerEvents(TRIGGER_PLAYER, AMOUNT)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\CoinIsPickedUp.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\Dawn.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope Dawn
    globals
        boolean dawn = false
        private trigger DUMMY_TRIGGER
    endglobals

    private function Trig takes nothing returns nothing
        call TimeOfDay_Dawn()
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        call TriggerRegisterGameStateEvent( DUMMY_TRIGGER, GAME_STATE_TIME_OF_DAY, EQUAL, 18 )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\Dawn.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\DestructableDies.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope DestructableDies
    globals
        private trigger DUMMY_TRIGGER
    endglobals

    private function Trig takes nothing returns nothing
        local destructable triggerDestructable = GetDyingDestructable()

        call DestructableRestoreLife( triggerDestructable, GetDestructableMaxLife( triggerDestructable ), true )

        set triggerDestructable = null
    endfunction

    public function RegisterDestructable takes destructable whichDestructable returns nothing
        call TriggerRegisterDeathEvent( DUMMY_TRIGGER, whichDestructable )
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\DestructableDies.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\Dusk.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope Dusk
    globals
        private trigger DUMMY_TRIGGER
    endglobals

    private function Trig takes nothing returns nothing
        call TimeOfDay_Dusk()
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        call TriggerRegisterGameStateEvent( DUMMY_TRIGGER, GAME_STATE_TIME_OF_DAY, EQUAL, 6 )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\Dusk.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\ItemDies.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope ItemDies
    globals
        public trigger DUMMY_TRIGGER
        public trigger REMOVE_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Item dyingItem, ItemType dyingItemType returns nothing
        call ShiftInventory_Death( dyingItem )

        call SpecialDrops_Item_Death( dyingItem )
    endfunction

    private function Actions takes Item dyingItem returns nothing
        local ItemType dyingItemType = dyingItem.type
        set dyingItem.dead = true

        call TriggerEvents_Static(dyingItem, dyingItemType)

        call RemoveItemTimedEx(dyingItem)
    endfunction

    private function Trig takes nothing returns nothing
        local Item dyingItem = GetItemById(GetHandleId(GetTriggerWidget()))
        call Actions( dyingItem )
    endfunction

    private function RemoveTrig takes nothing returns nothing
        local Item dyingItem = TRIGGER_ITEM
        call Actions( dyingItem )
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        set REMOVE_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( REMOVE_TRIGGER, function RemoveTrig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\ItemDies.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\ItemFinishesDecaying.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope ItemFinishesDecaying
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Item decayingItem returns nothing
        call Item_RemoveItemTimedEx_RemoveItemTimedEx_Decay(decayingItem)
    endfunction

    private function Trig takes nothing returns nothing
        local Item decayingItem = TRIGGER_ITEM
        local integer decayingItemId = decayingItem.id
        local item decayingItemSelf = decayingItem.self

        call SetItemPosition(decayingItemSelf, 0, 0)

        if (decayingItem.dead == false) then
            set TRIGGER_ITEM = decayingItem
            call RunTrigger(ItemDies_REMOVE_TRIGGER)
        endif

        call TriggerEvents_Static(decayingItem)

        call decayingItem.destroy()
        call FlushAttachedIntegerById(decayingItemId, ITEM_KEY)
        call DisableTrigger(ItemDies_DUMMY_TRIGGER)
        call RemoveItemWJ( decayingItemSelf )
        set decayingItemSelf = null
        call EnableTrigger(ItemDies_DUMMY_TRIGGER)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\ItemFinishesDecaying.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\LightningDies.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope LightningDies
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes lightning triggerLightning returns nothing
        call Lightning_AddLightningBetweenUnits_AddLightningBetweenUnits_EffectLightning_Death( triggerLightning )
        call Snow_Ghost_EffectLightning_EffectLightning_EffectLightning_Death( triggerLightning )
    endfunction

    private function Trig takes nothing returns nothing
        local lightning triggerLightning = TRIGGER_LIGHTNING

        call TriggerEvents_Static(triggerLightning)

        call DestroyLightningWJ( triggerLightning )

        set triggerLightning = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\LightningDies.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerChangesLumberAmount.j
//TESH.scrollpos=6
//TESH.alwaysfold=0
scope PlayerChangesLumberAmount
    globals
        public constant integer AMOUNT = 99999
        private trigger DUMMY_TRIGGER

        public boolean IGNORE_NEXT = false
    endglobals

    private function Trig takes nothing returns nothing
        local integer iteration = 0
        local player specificPlayer
        local player triggerPlayer = GetTriggerPlayer()
        if ( IGNORE_NEXT ) then
            set IGNORE_NEXT = false
        else
            if ( GetPlayerState( triggerPlayer, PLAYER_STATE_RESOURCE_LUMBER ) > AMOUNT ) then
                set iteration = MAX_PLAYER_INDEX
                loop
                    set specificPlayer = PlayerWJ(iteration)
                    if (IsPlayerDead(specificPlayer) == false) then
                        exitwhen ( ( GetPlayerState( specificPlayer, PLAYER_STATE_RESOURCE_LUMBER ) != AMOUNT ) and ( specificPlayer != triggerPlayer ) )
                    endif
                    set iteration = iteration - 1
                    exitwhen ( iteration < 0 )
                endloop
                set specificPlayer = null
                if ( iteration < 0 ) then
                    call AddPlayerState( triggerPlayer, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState( triggerPlayer, PLAYER_STATE_RESOURCE_LUMBER ) - AMOUNT )
                endif
            endif
        endif
        call SetPlayerState( triggerPlayer, PLAYER_STATE_RESOURCE_LUMBER, AMOUNT )
        set triggerPlayer = null
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        local player specificPlayer
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        loop
            set specificPlayer = PlayerWJ(iteration)
            call SetPlayerState(specificPlayer, PLAYER_STATE_RESOURCE_LUMBER, AMOUNT)
            call TriggerRegisterPlayerStateEvent( DUMMY_TRIGGER, specificPlayer, PLAYER_STATE_RESOURCE_LUMBER, NOT_EQUAL, AMOUNT )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set specificPlayer = null
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerChangesLumberAmount.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerClicksDialog.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope PlayerClicksDialog
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes button clickedButton, dialog clickedDialog, player triggerPlayer returns nothing
        call CameraDialog_DialogClick( clickedButton, clickedDialog, triggerPlayer )
    endfunction

    private function Trig takes nothing returns nothing
        local button clickedButton = GetClickedButton()
        local dialog clickedDialog = GetClickedDialog()
        local player triggerPlayer = GetTriggerPlayer()
        call DisplayDialogWJ( clickedDialog, triggerPlayer, false )

        call TriggerEvents_Static(clickedButton, clickedDialog, triggerPlayer)

        set clickedButton = null
        set clickedDialog = null
        set triggerPlayer = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerClicksDialog.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerDeselectsUnit.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope PlayerDeselectsUnit
    globals
        private trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes player triggerPlayer, Unit triggerUnit returns nothing
        local unit triggerUnitSelf = triggerUnit.self
        call MasterWizard_Deselect( triggerPlayer, triggerUnit )
        //call TownHall_Deselect(triggerPlayer, triggerUnit)

        call Miscellaneous_Altar_Altar_Deselect( triggerPlayer, triggerUnit )
        call Miscellaneous_SelectionGroup_SelectionGroup_Deselect( triggerPlayer, triggerUnitSelf )
        set triggerUnitSelf = null
    endfunction

    private function Trig takes nothing returns nothing
        local player triggerPlayer = GetTriggerPlayer()
        local integer triggerPlayerId = GetPlayerId(triggerPlayer)
        local Unit triggerUnit = GetUnit(GetTriggerUnit())

        call TriggerEvents_Static(triggerPlayer, triggerUnit)

        set triggerPlayer = null
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        loop
            call TriggerRegisterPlayerUnitEvent( DUMMY_TRIGGER, PlayerWJ( iteration ), EVENT_PLAYER_UNIT_DESELECTED, null )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerDeselectsUnit.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerDies.j
//TESH.scrollpos=129
//TESH.alwaysfold=0
scope PlayerDies
    globals
        public trigger DUMMY_TRIGGER
        private group ENUM_GROUP
        private boolean GAME_OVER = false
        private constant real GAME_OVER_DELAY = 5.
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( FILTER_UNIT.owner != TEMP_PLAYER ) then
            return false
        endif
        if (FILTER_UNIT.type.id == POISONED_FOUNTAIN_UNIT_ID) then
            return false
        endif
        return true
    endfunction

    private function Pause takes nothing returns nothing
        call PauseGame(true)
    endfunction

    private function Trig takes nothing returns nothing
        local integer alliances
        local integer count
        local integer count2
        local integer distributedGold
        local Unit enumUnit
        local unit enumUnitSelf
        local UnitType enumUnitType
        local boolean isAnyAllianceAlive
        local integer iteration
        local integer iteration2
        local player specificPlayer
        local player whichPlayer = TRIGGER_PLAYER
        local integer whichPlayerAlliance
        local integer whichPlayerTeam
        if ( IsPlayerDead(whichPlayer) == false ) then
            set alliances = CountAlliances()
            set count = 0
            set count2 = 0
            set isAnyAllianceAlive = false
            set iteration = MAX_PLAYER_INDEX
            set whichPlayerAlliance = GetPlayerAllianceWJ( whichPlayer )
            set whichPlayerTeam = GetPlayerTeam( whichPlayer )
            call DisplayTextTimedWJ( GetPlayerColorString(whichPlayer) + GetPlayerName( whichPlayer ) + "|r has been defeated.", 10, GetLocalPlayer() )
            call RemoveTeamPlayersAlive(whichPlayerTeam, whichPlayer)
            call SetPlayerDead(whichPlayer, true)
            loop
                set specificPlayer = PlayerWJ( iteration )
                if ( IsPlayerDead(specificPlayer) == false ) then
                    set isAnyAllianceAlive = true
                    if ( GetPlayerAllianceWJ( specificPlayer ) == whichPlayerAlliance ) then
                        set count = count + 1
                        if ( GetPlayerTeam( specificPlayer ) == whichPlayerTeam ) then
                            set count2 = count2 + 1
                        endif
                        call SetPlayerAlliance( whichPlayer, specificPlayer, ALLIANCE_SHARED_VISION, false )
                        call SetPlayerAlliance( specificPlayer, whichPlayer, ALLIANCE_SHARED_VISION, false )
                    endif
                endif
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            if ( isAnyAllianceAlive == false ) then
                set GAME_OVER = true
            elseif ( count == 0 ) then
                call DisplayTextTimedWJ( ColorStrings_RED + "Alliance " + I2S( whichPlayerAlliance + 1 ) + " has lost." + ColorStrings_RESET, 10, GetLocalPlayer() )
                set iteration = 0
                loop
                    if ( whichPlayerAlliance != iteration ) then
                        set count = 0
                        set iteration2 = MAX_PLAYER_INDEX
                        loop
                            if ( ( GetPlayerAllianceWJ( PlayerWJ( iteration2 ) ) == iteration ) and ( IsPlayerDead(PlayerWJ(iteration2)) == false ) ) then
                                set count = count + 1
                            endif
                            set iteration2 = iteration2 - 1
                            exitwhen ( iteration2 < 0 )
                        endloop
                        if ( count > 0 ) then
                            set count = 0
                            set iteration2 = MAX_PLAYER_INDEX
                            loop
                                if ( ( GetPlayerAllianceWJ( PlayerWJ( iteration2 ) ) != iteration ) and ( IsPlayerDead(PlayerWJ(iteration2) ) == false ) ) then
                                    set count = count + 1
                                endif
                                set iteration2 = iteration2 - 1
                                exitwhen ( iteration2 < 0 )
                            endloop
                            if ( count == 0 ) then
                                set GAME_OVER = true
                                call DisplayTextTimedWJ( ColorStrings_GREEN + "Alliance " + I2S( iteration + 1 ) + " was victorious." + ColorStrings_RESET, 10, GetLocalPlayer() )
                                set iteration2 = CountAlliancePlayers(iteration)
                                loop
                                    set specificPlayer = GetAlliancePlayer(iteration, iteration2)
                                    set TEMP_PLAYER = specificPlayer
                                    call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
                                    set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                                    loop
                                        call GroupRemoveUnit(ENUM_GROUP, enumUnitSelf)
                                        call SetUnitAnimation(enumUnitSelf, "victory")
                                        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                                        exitwhen (enumUnitSelf == null)
                                    endloop
                                    set iteration2 = iteration2 - 1
                                    exitwhen ( iteration2 < 0 )
                                endloop
                            endif
                        endif
                    endif
                    set iteration = iteration + 1
                    exitwhen ( ( iteration > alliances ) or GAME_OVER )
                endloop
            endif
            if (GAME_OVER) then
                call TimerStart(CreateTimerWJ(), GAME_OVER_DELAY, false, function Pause)
            endif
            set specificPlayer = null
            call SetPlayerRaceWJ(whichPlayer, 0)
            set TEMP_PLAYER = whichPlayer
            call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
            set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
            if (enumUnitSelf != null) then
                loop
                    set enumUnit = GetUnit(enumUnitSelf)
                    set enumUnitType = enumUnit.type
                    call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                    if ( IsUnitTypeAltar(enumUnitType) ) then
                        call Miscellaneous_Altar_Altar_Ending( enumUnit )
                    else
                        if ( IsUnitTypeShared(enumUnitType) and IsUnitType( enumUnitSelf, UNIT_TYPE_STRUCTURE ) ) then
                            call PauseUnit( enumUnitSelf, true )
                        else
                            call UnitRemoveAbility(enumUnitSelf, Reincarnation_SPELL_ID)
                            call KillUnit( enumUnitSelf )
                        endif
                    endif
                    set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnitSelf == null )
                endloop
            endif
            call FogModifierStart( CreateFogModifierRectWJ( whichPlayer, FOG_OF_WAR_VISIBLE, PLAY_RECT, true, false ) )
            set iteration = CountTeamPlayersAlive(whichPlayerTeam)
            call SetPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_LUMBER, 0 )
            if ( iteration > 0 ) then
                set distributedGold = GetPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_GOLD ) / iteration
                set iteration = iteration - 1
                loop
                    exitwhen ( iteration < 0 )
                    call AddPlayerState( GetTeamPlayersAlive(whichPlayerTeam, iteration), PLAYER_STATE_RESOURCE_GOLD, distributedGold )
                    set iteration = iteration - 1
                endloop
            endif
        endif
        set whichPlayer = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ(function TargetConditions)
        call AddTriggerCode(DUMMY_TRIGGER, function Trig)
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerDies.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerLeaves.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope PlayerLeaves
    globals
        private trigger DUMMY_TRIGGER
    endglobals

    private function Trig takes nothing returns nothing
        local player triggerPlayer = GetTriggerPlayer()
    local string s = Memory_Bug_discmarker_lastString
        call DisplayTextTimedWJ( GetPlayerColorString(triggerPlayer) + GetPlayerName( triggerPlayer ) + ColorStrings_RESET + " has left the game.", 10, GetLocalPlayer() )
        call KillPlayer( triggerPlayer )
        call ClearSelectionWJ( triggerPlayer )
    set Memory_Bug_discmarker_lastString = s
    set Memory_Bug_discmarker_lastLeaver = triggerPlayer
        set triggerPlayer = null
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        loop
            call TriggerRegisterPlayerEvent( DUMMY_TRIGGER, PlayerWJ( iteration ), EVENT_PLAYER_LEAVE )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerLeaves.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerPressesEsc.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope PlayerPressesEsc
    globals
        private trigger DUMMY_TRIGGER
    endglobals

    private function Trig takes nothing returns nothing
        local player triggerPlayer = GetTriggerPlayer()
        set triggerPlayer = null
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        loop
            call TriggerRegisterPlayerEvent( DUMMY_TRIGGER, PlayerWJ( iteration ), EVENT_PLAYER_END_CINEMATIC )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerPressesEsc.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayersDialogIsKilled.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope PlayersDialogIsKilled
    globals
        player TRIGGER_PLAYER
    endglobals

    private function TriggerEvents_Static takes dialog triggerDialog, player triggerPlayer returns nothing
        call CameraDialog_Death( triggerDialog, triggerPlayer )
    endfunction

    private function Trig takes nothing returns nothing
        local player triggerPlayer = TRIGGER_PLAYER
        local dialog triggerDialog = GetDisplayedDialog( triggerPlayer )
        if ( triggerDialog != null ) then
            call TriggerEvents_Static(triggerDialog, triggerPlayer)

            set triggerDialog = null
        endif
        set triggerPlayer = null
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayersDialogIsKilled.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerSelectsUnit.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope PlayerSelectsUnit
    globals
        private trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes player triggerPlayer, Unit triggerUnit returns nothing
        local unit triggerUnitSelf = triggerUnit.self
        call MasterWizard_Select( triggerPlayer, triggerUnit )
        call MecaPenguin_Select( triggerUnit, triggerPlayer )
        //call TownHall_Select(triggerPlayer, triggerUnit)

        call Miscellaneous_Altar_Altar_Select( triggerPlayer, triggerUnit )
        call Miscellaneous_SelectionGroup_SelectionGroup_Select( triggerPlayer, triggerUnitSelf )
        set triggerUnitSelf = null
    endfunction

    private function Trig takes nothing returns nothing
        local player triggerPlayer = GetTriggerPlayer()
        local integer triggerPlayerId = GetPlayerId(triggerPlayer)
        local Unit triggerUnit = GetUnit(GetTriggerUnit())

        call TriggerEvents_Static(triggerPlayer, triggerUnit)

        set triggerPlayer = null
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        loop
            call TriggerRegisterPlayerUnitEvent( DUMMY_TRIGGER, PlayerWJ( iteration ), EVENT_PLAYER_UNIT_SELECTED, null )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerSelectsUnit.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerSendsChatMessage.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope PlayerSendsChatMessage
    globals
        private trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes string chatMessage, player triggerPlayer returns nothing
        call Clear_Chat( chatMessage, triggerPlayer )
        call CameraDialog_Chat( chatMessage, triggerPlayer )
        call CameraSmooth_Chat( chatMessage, triggerPlayer )
        //call DisplayWeather_Chat( chatMessage, triggerPlayer )
        call Hints_Chat( chatMessage, triggerPlayer )
        call Music_Chat( chatMessage, triggerPlayer )
        //call SpawnInformation_Chat( chatMessage, triggerPlayer )
        call SpecialEffects_Chat( chatMessage, triggerPlayer )
        call System_Chat( chatMessage, triggerPlayer )
    endfunction

    private function Trig takes nothing returns nothing
        local string chatMessage = GetEventPlayerChatString()
        local player triggerPlayer = GetTriggerPlayer()

        call TriggerEvents_Static(chatMessage, triggerPlayer)

        set triggerPlayer = null
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        loop
            call TriggerRegisterPlayerChatEvent( DUMMY_TRIGGER, PlayerWJ( iteration ), null, false )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\PlayerSendsChatMessage.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\TerrainChanges.j
//TESH.scrollpos=6
//TESH.alwaysfold=0
scope TerrainChanges
    globals
        public trigger DUMMY_TRIGGER

        public integer TRIGGER_TERRAIN_TYPE_ID
        public real X
        public real Y
    endglobals

    private function Start_TriggerEvents_Static takes integer newTerrainTypeId, real x, real y returns nothing
        if (newTerrainTypeId == GetTerrainTileFromSet(TILESET, Brick_INDEX )) then
            call Brick_TerrainChangeStart(x, y)
        elseif (newTerrainTypeId == GetTerrainTileFromSet(TILESET, Grass_INDEX )) then
            call Grass_TerrainChangeStart(x, y)
        elseif (newTerrainTypeId == GetTerrainTileFromSet(TILESET, Marble_INDEX )) then
            call Marble_TerrainChangeStart(x, y)
        endif
    endfunction

    private function Ending_TriggerEvents_Static takes integer oldTerrainTypeId, real x, real y returns nothing
        if (oldTerrainTypeId == GetTerrainTileFromSet(TILESET, Brick_INDEX )) then
            call Brick_TerrainChangeEnding(x, y)
        elseif (oldTerrainTypeId == GetTerrainTileFromSet(TILESET, Grass_INDEX )) then
            call Grass_TerrainChangeEnding(x, y)
        elseif (oldTerrainTypeId == GetTerrainTileFromSet(TILESET, Marble_INDEX )) then
            call Marble_TerrainChangeEnding(x, y)
        endif
    endfunction

    private function Trig takes nothing returns nothing
        local real x = X
        local real y = Y
        local integer newTerrainTypeId = TRIGGER_TERRAIN_TYPE_ID
        local integer oldTerrainTypeId = GetTerrainType( x, y )

        call Ending_TriggerEvents_Static(oldTerrainTypeId, x, y)

        call SetTerrainTypeWJ(x, y, newTerrainTypeId)

        call Start_TriggerEvents_Static(newTerrainTypeId, x, y)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\TerrainChanges.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitAcquiresItem.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitAcquiresItem
    globals
        public trigger DUMMY_TRIGGER

        public boolean IGNORE_NEXT = false
        public boolean REMOVE_NEXT = false
    endglobals

    private function TriggerEvents_Static takes Item manipulatedItem, integer manipulatedItemTypeId, Unit manipulatingUnit returns nothing
        local item manipulatedItemSelf = manipulatedItem.self
        if ( manipulatedItemTypeId == AstralGauntlets_ITEM_ID ) then
            call AstralGauntlets_PickUp( manipulatingUnit )
        elseif ( manipulatedItemTypeId == BeltOfTheCelt_ITEM_ID ) then
            call BeltOfTheCelt_PickUp( manipulatingUnit )
        elseif ( manipulatedItemTypeId == ChaosSword_ITEM_ID ) then
            call ChaosSword_PickUp( manipulatingUnit )
        elseif ( manipulatedItemTypeId == FenixsFeather_ITEM_ID ) then
            call FenixsFeather_PickUp( manipulatingUnit )
        elseif ( manipulatedItemTypeId == FrostArmor_ITEM_ID ) then
            call FrostArmor_PickUp( manipulatingUnit )
        elseif ( manipulatedItemTypeId == FrozenShard_ITEM_ID ) then
            call FrozenShard_PickUp( manipulatingUnit )
        elseif( manipulatedItemTypeId == GexxoSlippers_ITEM_ID ) then
            call GexxoSlippers_PickUp(manipulatingUnit)
        elseif( manipulatedItemTypeId == GiantAxe_ITEM_ID ) then
            call GiantAxe_PickUp(manipulatingUnit)
        elseif( manipulatedItemTypeId == GloveOfTheBeast_ITEM_ID ) then
            call GloveOfTheBeast_PickUp( manipulatingUnit )
        elseif( manipulatedItemTypeId == GoldCoin_ITEM_ID ) then
            call GoldCoin_PickUp( manipulatedItemSelf, manipulatingUnit )
        elseif( manipulatedItemTypeId == GoldenRing_ITEM_ID ) then
            call GoldenRing_PickUp(manipulatingUnit)
        elseif( manipulatedItemTypeId == HeartOfTheHards_ITEM_ID ) then
            call HeartOfTheHards_PickUp( manipulatingUnit )
        elseif( manipulatedItemTypeId == HeartStone_ITEM_ID ) then
            call HeartStone_PickUp( manipulatingUnit )
        elseif ( manipulatedItemTypeId == JeweledDaggerOfGreed_ITEM_ID ) then
            call JeweledDaggerOfGreed_PickUp( manipulatingUnit )
        elseif ( manipulatedItemTypeId == LifeArmor_ITEM_ID ) then
            call LifeArmor_PickUp( manipulatingUnit )
        elseif( (manipulatedItemTypeId == Lollipop_ITEM_ID) or (manipulatedItemTypeId == Lollipop_MANUFACTURED_ITEM_ID) ) then
            call Lollipop_PickUp( manipulatingUnit )
        elseif( manipulatedItemTypeId == MedaillonOfTheStrivingGod_ITEM_ID ) then
            call MedaillonOfTheStrivingGod_PickUp( manipulatingUnit, manipulatedItem )
        elseif( manipulatedItemTypeId == MightyHammer_ITEM_ID ) then
            call MightyHammer_PickUp( manipulatingUnit )
        elseif( manipulatedItemTypeId == Nethermask_ITEM_ID ) then
            call Nethermask_PickUp( manipulatingUnit, manipulatedItem )
        elseif( manipulatedItemTypeId == OrbOfWisdom_ITEM_ID ) then
            call OrbOfWisdom_PickUp( manipulatingUnit, manipulatedItem )
        elseif ( manipulatedItemTypeId == PrismaticCape_ITEM_ID ) then
            call PrismaticCape_PickUp( manipulatedItem, manipulatingUnit )
        elseif ( manipulatedItemTypeId == RhythmicDrum_ITEM_ID ) then
            call RhythmicDrum_PickUp( manipulatingUnit )
        elseif( manipulatedItemTypeId == RobeOfThePope_ITEM_ID ) then
            call RobeOfThePope_PickUp( manipulatingUnit )
        elseif ( Runes_PickUp_Conditions(manipulatedItemTypeId) ) then
            call Runes_PickUp( manipulatingUnit, manipulatedItemSelf, manipulatedItemTypeId )
        elseif( manipulatedItemTypeId == SpidermanSocks_ITEM_ID ) then
            call SpidermanSocks_PickUp( manipulatingUnit )
        elseif( manipulatedItemTypeId == Trident_ITEM_ID ) then
            call Trident_PickUp( manipulatingUnit )
        elseif ( manipulatedItemTypeId == WindBoots_ITEM_ID ) then
            call WindBoots_PickUp( manipulatingUnit )
        endif
        call Sets_PickUp(manipulatedItem, GetItemTypeWJ(manipulatedItemTypeId), manipulatingUnit)
        set manipulatedItemSelf = null
    endfunction

    private function Trig takes nothing returns nothing
        local Item manipulatedItem
        local item manipulatedItemSelf
        local integer manipulatedItemTypeId
        local Unit manipulatingUnit
        local unit manipulatingUnitSelf
        if (IGNORE_NEXT) then
            set IGNORE_NEXT = false
        else
            set manipulatedItemSelf = GetManipulatedItem()
            if ( REMOVE_NEXT ) then
                set REMOVE_NEXT = false
                set UnitDropsItem_IGNORE_NEXT = true
                call RemoveItemWJ( manipulatedItemSelf )
            else
                set manipulatedItem = GetItem(manipulatedItemSelf)
                set manipulatedItemTypeId = manipulatedItem.type.id
                set manipulatingUnitSelf = GetManipulatingUnit()
                set manipulatingUnit = GetUnit(manipulatingUnitSelf)

                call TriggerEvents_Static(manipulatedItem, manipulatedItemTypeId, manipulatingUnit)

                set manipulatingUnitSelf = null
            endif
            set manipulatedItemSelf = null
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitAcquiresItem.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitAcquiresTarget.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitAcquiresTarget
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Dynamic takes integer priority, Unit triggerUnit returns nothing
        local integer triggerUnitId = triggerUnit.id
        local integer iteration = CountEventsById(triggerUnitId, UnitAcquiresTarget_EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetEventsById(triggerUnitId, UnitAcquiresTarget_EVENT_KEY, priority, iteration ) )
            set iteration = iteration - 1
        endloop
    endfunction

    private function TriggerEvents_Static takes integer priority, Unit triggerUnit, player triggerUnitOwner returns nothing
        if (priority == 0) then
            //! runtextmacro AddEventStaticLine("BubbleArmor_Automatic_Automatic", "EVENT_ACQUIRE", "TargetInRange( triggerUnit, triggerUnitOwner )")
            //! runtextmacro AddEventStaticLine("Fireball_Automatic_Automatic", "EVENT_ACQUIRE", "TargetInRange( triggerUnit, triggerUnitOwner )")
            //! runtextmacro AddEventStaticLine("Fury_Automatic_Automatic", "EVENT_ACQUIRE", "TargetInRange( triggerUnit, triggerUnitOwner )")
            //! runtextmacro AddEventStaticLine("Inspiration_Automatic_Automatic", "EVENT_ACQUIRE", "TargetInRange( triggerUnit, triggerUnitOwner )")
            //! runtextmacro AddEventStaticLine("Pulverize", "EVENT_ACQUIRE", "TargetInRange( triggerUnit )")
            //! runtextmacro AddEventStaticLine("RaiseDead_Automatic_Automatic", "EVENT_ACQUIRE", "TargetInRange( triggerUnit, triggerUnitOwner )")
            //! runtextmacro AddEventStaticLine("VioletDefense_Automatic_Automatic", "EVENT_ACQUIRE", "TargetInRange( triggerUnit, triggerUnitOwner )")
        endif
    endfunction

    private function TriggerEvents takes Unit triggerUnit, player triggerUnitOwner returns nothing
        local integer iteration = 0

        loop
            call TriggerEvents_Dynamic(iteration, triggerUnit)
            call TriggerEvents_Static(iteration, triggerUnit, triggerUnitOwner)
            set iteration = iteration + 1
            exitwhen (iteration>  0)
        endloop
    endfunction

    private function Trig takes nothing returns nothing
        local unit targetSelf = GetEventTargetUnit()
        local Unit target = GetUnit(targetSelf)
        local Unit triggerUnit = GetUnit(GetTriggerUnit())
        local player triggerUnitOwner = triggerUnit.owner
        local unit triggerUnitSelf
        if ( IsUnitEnemy( targetSelf, triggerUnitOwner ) ) then
            set triggerUnitSelf = triggerUnit.self
            if (GetUnitCurrentOrder(triggerUnitSelf) == 0) then
                call IssueTargetOrderById(triggerUnitSelf, ATTACK_ORDER_ID, targetSelf)
            endif
            set triggerUnitSelf = null

            call TriggerEvents(triggerUnit, triggerUnitOwner)

        endif
        set targetSelf = null
        set triggerUnitOwner = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitAcquiresTarget.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitAppears.j
//TESH.scrollpos=143
//TESH.alwaysfold=0
scope UnitAppears
    globals
        public trigger DUMMY_TRIGGER
        private constant real STANDARD_HERO_ARMOR_BY_SPELL = 0.15

        public boolean NEXT_IS_ILLUSION = false
    endglobals

    private function TriggerEvents_Static takes boolean isTriggerUnitHero, boolean isTriggerUnitNotIllusion, Unit triggerUnit, player triggerUnitOwner, UnitType triggerUnitType returns nothing
        if (isTriggerUnitHero and isTriggerUnitNotIllusion) then
            call Infoboard_Appearance(triggerUnit, triggerUnitOwner, triggerUnitType)
        endif
        call ShiftInventory_Appearance(triggerUnit)
        call Shop_Appearance(triggerUnit, triggerUnitType.id)
        call Worker_Appearance(triggerUnit, triggerUnitOwner, triggerUnitType)
    endfunction

    private function Trig takes nothing returns nothing
        local integer heroCount
        local integer heroStatsFactor
        local boolean isTriggerUnitNotIllusion
        local integer iteration
        local integer newTimer
        local integer requiredResearchTypeId
        local integer specificAbility
        local integer specificItemTypeId
        local integer specificUnitTypeId
        local Unit triggerUnit = Unit.create()
        local unit triggerUnitSelf = TRIGGER_UNIT_SELF
        local boolean isTriggerUnitHero = IsUnitType( triggerUnitSelf, UNIT_TYPE_HERO )
        local player triggerUnitOwner = GetOwningPlayer(triggerUnitSelf)
        local integer triggerUnitTeam = GetPlayerTeam( triggerUnitOwner )
        local UnitType triggerUnitType = GetUnitType(GetUnitTypeId(triggerUnitSelf))
        local integer automaticAbility = GetUnitTypeAutomaticAbility(triggerUnitType)

        set triggerUnit.id = GetHandleId(triggerUnitSelf)
        set triggerUnit.owner = triggerUnitOwner
        set triggerUnit.self = triggerUnitSelf
        set triggerUnit.type = triggerUnitType
        call AttachInteger(triggerUnitSelf, UNIT_KEY, triggerUnit)

        call UnitAddAbility( triggerUnitSelf, ABILITY_STORAGE_SPELL_ID )
        call UnitAddAbility( triggerUnitSelf, ABILITY_STORAGE2_SPELL_ID)

        if (NEXT_IS_ILLUSION) then
            set NEXT_IS_ILLUSION = false
            set isTriggerUnitNotIllusion = false
        else
            set isTriggerUnitNotIllusion = ( IsUnitIllusionWJ( triggerUnit ) == false )
        endif

        call SetUnitArmor( triggerUnit, GetUnitTypeArmor( triggerUnitType ) + GetUnitTypeArmorForPlayer( triggerUnitType, triggerUnitOwner ) )

        call SetUnitAttackRate(triggerUnit, GetUnitTypeAttackRateForPlayer(triggerUnitType, triggerUnitOwner))

        call SetUnitBlood( triggerUnit, GetUnitTypeBlood(triggerUnitType) )
        call SetUnitBloodExplosion( triggerUnit, GetUnitTypeBloodExplosion(triggerUnitType) )

        call SetUnitCanNotBeRevived(triggerUnit, B2I(IsUnitTypeCanNotBeRevived(triggerUnitType)))

        call SetUnitCriticalStrike( triggerUnit, GetUnitTypeCriticalStrikeForPlayer( triggerUnitType, triggerUnitOwner ) )

        call UnitWakeUp(triggerUnitSelf)
        call SetUnitDamage( triggerUnit, GetUnitTypeDamage( triggerUnitType ) + GetUnitTypeDamageForPlayer( triggerUnitType, triggerUnitOwner ) )

        call SetUnitDecay(triggerUnit, B2I(IsUnitTypeDecay(triggerUnitType)))
        call SetUnitDecayTime(triggerUnit, GetUnitTypeDecayTime(triggerUnitType))

        call SetUnitImpactZ(triggerUnit, GetUnitTypeImpactZ(triggerUnitType))
        call SetUnitOutpactZ(triggerUnit, GetUnitTypeOutpactZ(triggerUnitType))

        call SetUnitMaxLife( triggerUnit, GetUnitTypeMaxLife( triggerUnitType ) + GetUnitTypeMaxLifeForPlayer( triggerUnitType, triggerUnitOwner ) )
        call SetUnitMaxMana( triggerUnit, GetUnitTypeMaxMana( triggerUnitType ) + GetUnitTypeMaxManaForPlayer( triggerUnitType, triggerUnitOwner ) )

        call SetUnitLifeRegeneration( triggerUnit, GetUnitTypeLifeRegeneration( triggerUnitType ) + GetUnitTypeLifeRegenerationForPlayer( triggerUnitType, triggerUnitOwner ) )
        call SetUnitManaRegeneration( triggerUnit, GetUnitTypeManaRegeneration( triggerUnitType ) + GetUnitTypeManaRegenerationForPlayer( triggerUnitType, triggerUnitOwner ) )

        call SetUnitSightRange( triggerUnit, GetUnitTypeSightRange(triggerUnitType) )

        call SetUnitSpeed( triggerUnit, GetUnitTypeSpeed( triggerUnitType ) + GetUnitTypeSpeedForPlayer( triggerUnitType, triggerUnitOwner ) )

        if ( isTriggerUnitHero ) then
            set heroCount = GetPlayerHeroCount(triggerUnitOwner) + 1
            set heroStatsFactor = GetHeroLevel( triggerUnitSelf )
            set triggerUnit.level = heroStatsFactor
            set heroStatsFactor = heroStatsFactor - 1
            call SetUnitEP( triggerUnitSelf, GetUnitEP( triggerUnitSelf ) )
            call SetHeroAgility( triggerUnit, triggerUnitType, GetUnitTypeAgility(triggerUnitType) + heroStatsFactor * GetUnitTypeAgilityPerLevel(triggerUnitType) )
            call SetHeroIntelligence( triggerUnit, triggerUnitType, GetUnitTypeIntelligence(triggerUnitType) + heroStatsFactor * GetUnitTypeIntelligencePerLevel(triggerUnitType) )
            call SetHeroStrength( triggerUnit, triggerUnitType, GetUnitTypeStrength(triggerUnitType) + heroStatsFactor * GetUnitTypeStrengthPerLevel(triggerUnitType) )
            call AddUnitArmorBySpellBonus( triggerUnit, STANDARD_HERO_ARMOR_BY_SPELL )
            call SetUnitState( triggerUnitSelf, UNIT_STATE_MANA, GetUnitMaxMana( triggerUnit ) )
            if (heroCount == 0) then
                call UnitAddItem( triggerUnitSelf, CreateItemEx( TownPortal_ITEM_ID, 0, 0 ).self )
                call UnitAddItem( triggerUnitSelf, CreateItemEx( HealingPotion_ITEM_ID, 0, 0 ).self )
            endif
            call SetPlayerHeroCount(triggerUnitOwner, heroCount)
        else
            call SetUnitState( triggerUnitSelf, UNIT_STATE_MANA, GetUnitTypeStartMana(triggerUnitType) )
        endif
        call SetUnitState( triggerUnitSelf, UNIT_STATE_LIFE, GetUnitMaxLife( triggerUnit ) )

        call SetUnitScaleEx(triggerUnit, GetUnitTypeScale(triggerUnitType))

        call SetUnitSupplyProduced( triggerUnit, triggerUnitOwner, GetUnitTypeSupplyProduced( triggerUnitType ) )
        call SetUnitSupplyUsed( triggerUnit, triggerUnitOwner, GetUnitTypeSupplyUsed( triggerUnitType ) )

        call SetUnitVertexColorEx( triggerUnit, GetUnitTypeVertexColorRed(triggerUnitType), GetUnitTypeVertexColorGreen(triggerUnitType), GetUnitTypeVertexColorBlue(triggerUnitType), GetUnitTypeVertexColorAlpha(triggerUnitType), null )

        call InitUnitZ(triggerUnitSelf)

        if ( IsUnitInGroup( triggerUnitSelf, ALL_GROUP ) == false ) then
            call GroupAddUnit( ALL_GROUP, triggerUnitSelf )
            call TriggerRegisterUnitEvent( UnitAcquiresTarget_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_TARGET_IN_RANGE )
            call TriggerRegisterUnitEvent( UnitAcquiresItem_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_PICKUP_ITEM )
            call TriggerRegisterUnitEvent( UnitBeginsCasting_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_SPELL_CAST )
            call TriggerRegisterUnitEvent( UnitChangesOwner_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_CHANGE_OWNER )
            call TriggerRegisterUnitEvent( UnitChannels_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_SPELL_CHANNEL )
            call TriggerRegisterUnitEvent( UnitDecays_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_DECAY )
            call TriggerRegisterUnitEvent( UnitDies_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_DEATH )
            call TriggerRegisterUnitEvent( UnitDropsItem_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_DROP_ITEM )
            call TriggerRegisterUnitEvent( UnitFinishesCasting_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_SPELL_ENDCAST )
            call TriggerRegisterUnitEvent( UnitGetsOrder_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_ISSUED_ORDER )
            call TriggerRegisterUnitEvent( UnitGetsOrder_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_ISSUED_POINT_ORDER )
            call TriggerRegisterUnitEvent( UnitGetsOrder_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_ISSUED_TARGET_ORDER )
            call TriggerRegisterUnitEvent( UnitIsAttacked_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_ATTACKED )
            call TriggerRegisterUnitStateEvent( UnitIsBeforeDying_DUMMY_TRIGGER, triggerUnitSelf, UNIT_STATE_LIFE, LESS_THAN_OR_EQUAL, LIMIT_OF_DEATH )
            if ( isTriggerUnitHero ) then
                call TriggerRegisterUnitEvent( UnitBecomesRevivable_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_HERO_REVIVABLE )
                call TriggerRegisterUnitEvent( UnitFinishesReviving_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_HERO_REVIVE_FINISH )
                call TriggerRegisterUnitEvent( UnitGainsLevel_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_HERO_LEVEL )
                call TriggerRegisterUnitEvent( UnitLearnsSkill_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_HERO_SKILL )
                call TriggerRegisterUnitEvent( UnitPawnsItem_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_PAWN_ITEM )
            elseif ( IsUnitType( triggerUnitSelf, UNIT_TYPE_STRUCTURE ) ) then
                call TriggerRegisterUnitEvent( UnitBeginsResearching_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_RESEARCH_START )
                call TriggerRegisterUnitEvent( UnitBeginsUpgrading_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_UPGRADE_START )
                call TriggerRegisterUnitEvent( UnitCancelsResearching_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_RESEARCH_CANCEL )
                call TriggerRegisterUnitEvent( UnitCancelsUpgrading_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_UPGRADE_CANCEL )
                call TriggerRegisterUnitEvent( UnitFinishesConstructing_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_CONSTRUCT_FINISH )
                call TriggerRegisterUnitEvent( UnitFinishesResearching_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_RESEARCH_FINISH )
                call TriggerRegisterUnitEvent( UnitFinishesTraining_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_TRAIN_FINISH )
                call TriggerRegisterUnitEvent( UnitFinishesUpgrading_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_UPGRADE_FINISH )
                call TriggerRegisterUnitEvent( UnitSellsItem_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_SELL_ITEM )
                call TriggerRegisterUnitEvent( UnitSellsUnit_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_SELL )
            endif
            call TriggerRegisterUnitEvent( UnitStartsEffectOfAbility_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_SPELL_EFFECT )
            call TriggerRegisterUnitEvent( UnitTakesDamage_DUMMY_TRIGGER, triggerUnitSelf, EVENT_UNIT_DAMAGED )

            call UnitIsActivated_Start( triggerUnit )
        endif

        if ( isTriggerUnitNotIllusion ) then
            set iteration = CountUnitTypeAbilities(triggerUnitType)
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set specificAbility = GetUnitTypeAbility(triggerUnitType, iteration)
                set requiredResearchTypeId = GetAbilityRequiredResearch( specificAbility )
                call UnitAddAbility( triggerUnitSelf, specificAbility )
                if ((requiredResearchTypeId == 0) or (GetPlayerTechCount(triggerUnitOwner, requiredResearchTypeId, true) > 0)) then
                    call UnitLearnsSkill_TriggerEvents( triggerUnit, triggerUnitOwner, triggerUnitType, specificAbility )
                endif
                set iteration = iteration - 1
            endloop
        endif

        if (automaticAbility != 0) then
            call IssueImmediateOrderById(triggerUnitSelf, GetAbilityOrder(automaticAbility, 1))
        endif

        call TriggerEvents_Static(isTriggerUnitHero, isTriggerUnitNotIllusion, triggerUnit, triggerUnitOwner, triggerUnitType)

        set triggerUnitOwner = null
        set triggerUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitAppears.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBecomesRevivable.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitBecomesRevivable
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents takes Unit triggerUnit returns nothing
        call AutomaticRevival_Revivable(triggerUnit)
    endfunction

    private function Trig takes nothing returns nothing
        local unit triggerUnitSelf = GetRevivableUnit()
        local Unit triggerUnit = GetUnit(triggerUnitSelf)

        call TriggerEvents(triggerUnit)

        set triggerUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBecomesRevivable.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBeginsCasting.j
//TESH.scrollpos=4
//TESH.alwaysfold=0
scope UnitBeginsCasting
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Unit caster, integer skill, real targetX, real targetY returns nothing
        call SilverSpores_BeginCast(caster)
        if ( skill == WonderSeeds_SPELL_ID ) then
            call WonderSeeds_BeginCast( caster, targetX, targetY )
        endif
    endfunction

    private function Trig takes nothing returns nothing
        local unit casterSelf = GetSpellAbilityUnit()
        local Unit caster = GetUnit(casterSelf)
        local integer casterOrderId = GetUnitCurrentOrder(casterSelf)
        local integer skill = GetSpellAbilityId()
        local location targetLocation = GetSpellTargetLoc()
        local Unit targetUnit = GetUnit(GetSpellTargetUnit())
        local real targetX
        local real targetY
        set casterSelf = null
        if ( targetLocation != null ) then
            set targetX = GetLocationX( targetLocation )
            set targetY = GetLocationY( targetLocation )
            call RemoveLocation( targetLocation )
            set targetLocation = null
        else
            set targetX = 0
            set targetY = 0
        endif

        if (UnitGetsOrder_TriggerEvents(GetAbilityOrderId(skill, casterOrderId), caster, caster.owner, targetX, targetY, skill, targetUnit, casterOrderId) == null) then
            call TriggerEvents_Static(caster, skill, targetX, targetY)
        else
            call StopUnit(caster)
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBeginsCasting.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBeginsConstructing.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitBeginsConstructing
    globals
        private trigger DUMMY_TRIGGER
        private constant real START_LIFE_FACTOR = 0.15
    endglobals

    private function Trig takes nothing returns nothing
        local Unit constructingStructure = GetConstructingStructureEx()
        local player constructingStructureOwner = constructingStructure.owner
        local unit constructingStructureSelf = constructingStructure.self
        local UnitType constructingStructureType = constructingStructure.type
        call SetUnitState( constructingStructureSelf, UNIT_STATE_LIFE, (GetUnitTypeMaxLife( constructingStructureType ) + GetUnitTypeMaxLifeForPlayer( constructingStructureType, constructingStructureOwner )) * START_LIFE_FACTOR )
        set constructingStructureOwner = null
        set constructingStructureSelf = null
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        loop
            call TriggerRegisterPlayerUnitEvent( DUMMY_TRIGGER, PlayerWJ( iteration ), EVENT_PLAYER_UNIT_CONSTRUCT_START, null )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBeginsConstructing.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBeginsResearching.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitBeginsResearching
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function Trig takes nothing returns nothing
        local string errorMsg = null
        local Unit researchingUnit = GetUnit(GetResearchingUnit())
        local player researchingUnitOwner = researchingUnit.owner
        local integer triggerResearchTypeId = GetResearched()
        local ResearchType triggerResearchType = GetResearchType(triggerResearchTypeId)
        local integer goldCost = GetPlayerGoldCost(GetResearchTypeGoldCost( triggerResearchType, GetPlayerTechCount(researchingUnitOwner, triggerResearchTypeId, true ) + 1 ), researchingUnitOwner)
        if ( goldCost > GetPlayerState( researchingUnitOwner, PLAYER_STATE_RESOURCE_GOLD ) ) then
            set errorMsg = ErrorStrings_TOO_LESS_GOLD
        endif
        if ( errorMsg == null ) then
            call AddPlayerState( researchingUnitOwner, PLAYER_STATE_RESOURCE_GOLD, -goldCost )
        else
            set UnitCancelsResearching_IGNORE_NEXT = true
            call StopUnit( researchingUnit )
            call Error( researchingUnitOwner, errorMsg )
        endif
        set researchingUnitOwner = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBeginsResearching.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBeginsUpgrading.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitBeginsUpgrading
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes integer goldCost, Unit triggerUnit, player triggerUnitOwner, UnitType triggerUnitType returns nothing
        //call TownHall_UpgradeStart( goldCost, triggerUnit, triggerUnitType )
    endfunction

    private function Trig takes nothing returns nothing
        local string errorMsg = null
        local unit triggerUnitSelf = GetTriggerUnit()
        local Unit triggerUnit = GetUnit(triggerUnitSelf)
        local player triggerUnitOwner = triggerUnit.owner
        local UnitType triggerUnitType = GetUnitType(GetUnitTypeId(triggerUnitSelf))
        local integer goldCost = GetPlayerGoldCost(GetUnitTypeGoldCost( triggerUnitType ), triggerUnitOwner)
        if ( goldCost > GetPlayerState( triggerUnitOwner, PLAYER_STATE_RESOURCE_GOLD ) ) then
            set errorMsg = ErrorStrings_TOO_LESS_GOLD
        endif
        if ( errorMsg == null ) then
            call AddPlayerState( triggerUnitOwner, PLAYER_STATE_RESOURCE_GOLD, -goldCost )
            if ( IsUnitTypeUpgradesInstantly(triggerUnitType) ) then
                call UnitSetUpgradeProgress( triggerUnitSelf, 100 )
            else
                call Upgrade_Start(triggerUnit, goldCost)
            endif
            call AddUnitGoldSpentInUpgrades(triggerUnit, goldCost)

            call TriggerEvents_Static(goldCost, triggerUnit, triggerUnitOwner, triggerUnitType)
        else
            set UnitCancelsUpgrading_IGNORE_NEXT = true
            call StopUnit( triggerUnit )
            call Error( triggerUnitOwner, errorMsg )
        endif
        set triggerUnitOwner = null
        set triggerUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitBeginsUpgrading.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitCancelsResearching.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitCancelsResearching
    globals
        public trigger DUMMY_TRIGGER
        public boolean IGNORE_NEXT = false
        private constant real GOLD_RESTORATION_FACTOR = 1.
    endglobals

    private function Trig takes nothing returns nothing
        local integer goldCost
        local Unit researchingUnit
        local player researchingUnitOwner
        local ResearchType triggerResearchType
        local integer triggerResearchTypeId
        if ( IGNORE_NEXT ) then
            set IGNORE_NEXT = false
        else
            set researchingUnit = GetUnit(GetResearchingUnit())
            set researchingUnitOwner = researchingUnit.owner
            set triggerResearchTypeId = GetResearched()
            set triggerResearchType = GetResearchType(triggerResearchTypeId)
            set goldCost = GetPlayerGoldCost(GetResearchTypeGoldCost( triggerResearchType, GetPlayerTechCount(researchingUnitOwner, triggerResearchTypeId, true) + 1 ), researchingUnitOwner)

            call AddPlayerState( researchingUnitOwner, PLAYER_STATE_RESOURCE_GOLD, R2I( goldCost * GOLD_RESTORATION_FACTOR ) )

            set researchingUnitOwner = null
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitCancelsResearching.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitCancelsUpgrading.j
//TESH.scrollpos=1
//TESH.alwaysfold=0
scope UnitCancelsUpgrading
    globals
        public trigger DUMMY_TRIGGER
        public boolean IGNORE_NEXT = false
        private constant real GOLD_RESTORATION_FACTOR = 1.
    endglobals

    private function TriggerEvents_Static takes integer goldCost, Unit triggerUnit, UnitType triggerUnitType returns nothing
        //call TownHall_UpgradeCancel( goldCost, triggerUnit, triggerUnitType )
    endfunction

    private function Trig takes nothing returns nothing
        local integer goldCost
        local Unit triggerUnit
        local player triggerUnitOwner
        local UnitType triggerUnitType
        if ( IGNORE_NEXT ) then
            set IGNORE_NEXT = false
        else
            set triggerUnit = GetUnit(GetTriggerUnit())
            set goldCost = GetUnitCurrentUpgradeGoldCost(triggerUnit)
            set triggerUnitOwner = triggerUnit.owner
            set triggerUnitType = triggerUnit.type
            call AddPlayerState( triggerUnitOwner, PLAYER_STATE_RESOURCE_GOLD, R2I( goldCost * GOLD_RESTORATION_FACTOR ) )
            call AddUnitGoldSpentInUpgrades(triggerUnit, -goldCost)
            call Upgrade_Remove( triggerUnit )
            call SetUnitScaleWJ( triggerUnit.self, GetUnitScale( triggerUnit ) )

            call TriggerEvents_Static(goldCost, triggerUnit, triggerUnitType)

            set triggerUnitOwner = null
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitCancelsUpgrading.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitChangesForm.j
//TESH.scrollpos=74
//TESH.alwaysfold=0
scope UnitChangesForm
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Unit triggerUnit returns nothing
        call Burrow_FormChange(triggerUnit)

        call Shop_FormChange(triggerUnit, triggerUnit.type.id)
    endfunction

    public function Start takes Unit triggerUnit, UnitType triggerUnitType, UnitType oldTriggerUnitType returns nothing
        local integer heroStatsFactor
        local boolean isTriggerUnitNotIllusion = ( IsUnitIllusionWJ( triggerUnit ) == false )
        local integer iteration
        local integer requiredResearchTypeId
        local integer specificAbility
        local player triggerUnitOwner = triggerUnit.owner
        local unit triggerUnitSelf = triggerUnit.self
        local boolean isTriggerUnitHero = IsUnitType(triggerUnitSelf, UNIT_TYPE_HERO)

        set triggerUnit.type = triggerUnitType

        if ( isTriggerUnitNotIllusion ) then
            call AddUnitArmor( triggerUnit, GetUnitTypeArmor( triggerUnitType ) + GetUnitTypeArmorForPlayer( triggerUnitType, triggerUnitOwner ) - (GetUnitTypeArmor( oldTriggerUnitType ) + GetUnitTypeArmorForPlayer( oldTriggerUnitType, triggerUnitOwner )) )
        endif

        call AddUnitAttackRate( triggerUnit, GetUnitTypeAttackRateForPlayer( triggerUnitType, triggerUnitOwner ) - ( GetUnitTypeAttackRateForPlayer( oldTriggerUnitType, triggerUnitOwner ) ) )

        call SetUnitBlood( triggerUnit, GetUnitTypeBlood(triggerUnitType) )
        call SetUnitBloodExplosion( triggerUnit, GetUnitTypeBloodExplosion(triggerUnitType) )

        call AddUnitCanNotBeRevivedByAmount(triggerUnit, B2I(IsUnitTypeCanNotBeRevived(triggerUnitType)) - B2I(IsUnitTypeCanNotBeRevived(oldTriggerUnitType)))

        call AddUnitCriticalStrike( triggerUnit, GetUnitTypeCriticalStrikeForPlayer( triggerUnitType, triggerUnitOwner ) - GetUnitTypeCriticalStrikeForPlayer( oldTriggerUnitType, triggerUnitOwner ) )

        if ( isTriggerUnitNotIllusion ) then
            call AddUnitDamage( triggerUnit, GetUnitTypeDamage( triggerUnitType ) + GetUnitTypeDamageForPlayer( triggerUnitType, triggerUnitOwner ) - (GetUnitTypeDamage( oldTriggerUnitType ) + GetUnitTypeDamageForPlayer( oldTriggerUnitType, triggerUnitOwner )) )
        endif

        call AddUnitDecayByAmount(triggerUnit, B2I(IsUnitTypeDecay(triggerUnitType)) - B2I(IsUnitTypeDecay(oldTriggerUnitType)))
        call AddUnitDecayTime(triggerUnit, GetUnitTypeDecayTime(triggerUnitType) - GetUnitTypeDecayTime(oldTriggerUnitType))

        call AddUnitImpactZ(triggerUnit, GetUnitTypeImpactZ(triggerUnitType) - GetUnitTypeImpactZ(oldTriggerUnitType))
        call AddUnitOutpactZ(triggerUnit, GetUnitTypeOutpactZ(triggerUnitType) - GetUnitTypeOutpactZ(oldTriggerUnitType))

        if ( isTriggerUnitNotIllusion ) then
            call AddUnitMaxLife( triggerUnit, GetUnitTypeMaxLife( triggerUnitType ) + GetUnitTypeMaxLifeForPlayer( triggerUnitType, triggerUnitOwner ) - (GetUnitTypeMaxLife( oldTriggerUnitType ) + GetUnitTypeMaxLifeForPlayer( oldTriggerUnitType, triggerUnitOwner )) )
            call AddUnitMaxMana( triggerUnit, GetUnitTypeMaxMana( triggerUnitType ) + GetUnitTypeMaxManaForPlayer( triggerUnitType, triggerUnitOwner ) - (GetUnitTypeMaxMana( oldTriggerUnitType ) + GetUnitTypeMaxManaForPlayer( oldTriggerUnitType, triggerUnitOwner )) )

            call AddUnitLifeRegeneration( triggerUnit, GetUnitTypeLifeRegeneration( triggerUnitType ) + GetUnitTypeLifeRegenerationForPlayer( triggerUnitType, triggerUnitOwner ) - (GetUnitTypeLifeRegeneration( oldTriggerUnitType ) + GetUnitTypeLifeRegenerationForPlayer( oldTriggerUnitType, triggerUnitOwner )) )
            call AddUnitManaRegeneration( triggerUnit, GetUnitTypeManaRegeneration( triggerUnitType ) + GetUnitTypeManaRegenerationForPlayer( triggerUnitType, triggerUnitOwner ) - (GetUnitTypeManaRegeneration( oldTriggerUnitType ) + GetUnitTypeManaRegenerationForPlayer( oldTriggerUnitType, triggerUnitOwner )) )
        endif

        call AddUnitSightRange( triggerUnit, GetUnitTypeSightRange(triggerUnitType) - GetUnitTypeSightRange(oldTriggerUnitType) )

        call AddUnitSpeed( triggerUnit, GetUnitTypeSpeed( triggerUnitType ) + GetUnitTypeSpeedForPlayer( triggerUnitType, triggerUnitOwner ) - (GetUnitTypeSpeed( oldTriggerUnitType ) + GetUnitTypeSpeedForPlayer( oldTriggerUnitType, triggerUnitOwner )) )

        if ( isTriggerUnitHero ) then
            set heroStatsFactor = GetHeroLevel( triggerUnitSelf )
            set triggerUnit.level = heroStatsFactor
            set heroStatsFactor = heroStatsFactor - 1
            call SetUnitEP( triggerUnitSelf, GetUnitEP( triggerUnitSelf ) )
            call AddHeroAgility( triggerUnit, triggerUnitType, GetUnitTypeAgility(triggerUnitType) + heroStatsFactor * GetUnitTypeAgilityPerLevel(triggerUnitType) - (GetUnitTypeAgility(oldTriggerUnitType) + heroStatsFactor * GetUnitTypeAgilityPerLevel(oldTriggerUnitType)) )
            call AddHeroIntelligence( triggerUnit, triggerUnitType, GetUnitTypeIntelligence(triggerUnitType) + heroStatsFactor * GetUnitTypeIntelligencePerLevel(triggerUnitType) - (GetUnitTypeIntelligence(oldTriggerUnitType) + heroStatsFactor * GetUnitTypeIntelligencePerLevel(oldTriggerUnitType)) )
            call AddHeroStrength( triggerUnit, triggerUnitType, GetUnitTypeStrength(triggerUnitType) + heroStatsFactor * GetUnitTypeStrengthPerLevel(triggerUnitType) - (GetUnitTypeStrength(oldTriggerUnitType) + heroStatsFactor * GetUnitTypeStrengthPerLevel(oldTriggerUnitType)) )
        endif
        call AddUnitScale(triggerUnit, GetUnitTypeScale(triggerUnitType) - GetUnitTypeScale(oldTriggerUnitType))

        call AddUnitSupplyProduced( triggerUnit, triggerUnitOwner, GetUnitTypeSupplyProduced( triggerUnitType ) - GetUnitTypeSupplyProduced( oldTriggerUnitType ) )
        call AddUnitSupplyUsed( triggerUnit, triggerUnitOwner, GetUnitTypeSupplyUsed( triggerUnitType ) - GetUnitTypeSupplyUsed( oldTriggerUnitType ) )

        call AddUnitVertexColor( triggerUnit, GetUnitTypeVertexColorRed(triggerUnitType) - GetUnitTypeVertexColorRed(oldTriggerUnitType), GetUnitTypeVertexColorGreen(triggerUnitType) - GetUnitTypeVertexColorGreen(oldTriggerUnitType), GetUnitTypeVertexColorBlue(triggerUnitType) - GetUnitTypeVertexColorBlue(oldTriggerUnitType), GetUnitTypeVertexColorAlpha(triggerUnitType) - GetUnitTypeVertexColorAlpha(oldTriggerUnitType), null )

        if ( isTriggerUnitNotIllusion ) then
            set iteration = CountUnitTypeAbilities(triggerUnitType)
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set specificAbility = GetUnitTypeAbility(triggerUnitType, iteration)
                set requiredResearchTypeId = GetAbilityRequiredResearch( specificAbility )
                call UnitAddAbility( triggerUnitSelf, specificAbility )
                if ((requiredResearchTypeId == 0) or (GetPlayerTechCount(triggerUnitOwner, requiredResearchTypeId, true) > 0)) then
                    call UnitLearnsSkill_TriggerEvents( triggerUnit, triggerUnitOwner, triggerUnitType, specificAbility )
                endif
                set iteration = iteration - 1
            endloop
        endif

        call TriggerEvents_Static(triggerUnit)

        set triggerUnitOwner = null
        set triggerUnitSelf = null
    endfunction

    private function Trig takes nothing returns nothing
        local Unit triggerUnit = TRIGGER_UNIT
        local UnitType triggerUnitType = TRIGGER_UNIT_TYPE
        call Start(triggerUnit, triggerUnitType, triggerUnit.type)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitChangesForm.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitChangesOwner.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitChangesOwner
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Unit changingUnit, integer changingUnitTeam returns nothing
        call DivineShield_Activate( changingUnit, changingUnitTeam )
    endfunction

    private function Trig takes nothing returns nothing
        local Unit changingUnit = GetUnit(GetChangingUnit())
        local player changingUnitOwner = GetOwningPlayer(changingUnit.self)
        local integer changingUnitTeam = GetPlayerTeam( changingUnitOwner )

        set changingUnit.owner = changingUnitOwner

        call TriggerEvents_Static(changingUnit, changingUnitTeam)

        set changingUnitOwner = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitChangesOwner.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitChannels.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitChannels
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Unit caster, integer skill, Unit targetUnit returns nothing
        if ( skill == MindBreaker_SPELL_ID ) then
            call MindBreaker_Channel( caster, targetUnit )
        elseif (skill == TownPortal_SPELL_ID) then
            call TownPortal_Channel(caster)
        endif
    endfunction

    private function Trig takes nothing returns nothing
        local Unit caster = GetUnit(GetSpellAbilityUnit())
        local integer skill = GetSpellAbilityId()
        local Unit targetUnit = GetUnit(GetSpellTargetUnit())
        local location targetLocation = GetSpellTargetLoc()
        local real targetX
        local real targetY
        if ( targetLocation != null ) then
            set targetX = GetLocationX( targetLocation )
            set targetY = GetLocationY( targetLocation )
            call RemoveLocationWJ( targetLocation )
            set targetLocation = null
        else
            set targetX = 0
            set targetY = 0
        endif

        call TriggerEvents_Static(caster, skill, targetUnit)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitChannels.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitDecays.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitDecays
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function Trig takes nothing returns nothing
        local unit decayingUnitSelf = GetDecayingUnit()
        local Unit decayingUnit = GetUnit(decayingUnitSelf)
        local real decayTime = GetUnitDecayTime(decayingUnit)
        call UnitSuspendDecay( decayingUnitSelf, true )
        if (decayTime > 0) then
            call SetUnitTimeScale( decayingUnitSelf, 120 / decayTime )
        endif
        set decayingUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitDecays.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitDies.j
//TESH.scrollpos=129
//TESH.alwaysfold=0
scope UnitDies
    globals
        public trigger DUMMY_TRIGGER

        Unit DYING_UNIT
        Unit KILLING_UNIT
    endglobals

    private function TriggerEvents_Dynamic takes Unit dyingUnit, Unit killingUnit, integer priority returns nothing
        local integer dyingUnitId = dyingUnit.id
        local integer iteration = CountEventsById( dyingUnitId, UnitDies_EVENT_KEY, priority )
        local integer killingUnitId = killingUnit.id
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set DYING_UNIT = dyingUnit
            set KILLING_UNIT = killingUnit
            call RunTrigger( GetEventsById(dyingUnitId, UnitDies_EVENT_KEY, priority, iteration) )
            set iteration = iteration - 1
        endloop
        set iteration = CountEventsById( killingUnitId, UnitDies_EVENT_KEY_AS_KILLING_UNIT, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set DYING_UNIT = dyingUnit
            set KILLING_UNIT = killingUnit
            call RunTrigger( GetEventsById(killingUnitId, UnitDies_EVENT_KEY_AS_KILLING_UNIT, priority, iteration) )
            set iteration = iteration - 1
        endloop
    endfunction

    private function TriggerEvents_Static takes boolean deathCausedByEnemy, Unit dyingUnit, player dyingUnitOwner, real dyingUnitX, real dyingUnitY, real dyingUnitZ, Unit killingUnit, player killingUnitOwner, integer priority returns nothing
        if (priority == 0) then
            //! runtextmacro AddEventStaticLine("CamouflageSuit", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ElectroNet", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("ElectroNet_Buff_Buff", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ElixirOfTheGrowth", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("FlyingSheep", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("FriendshipBracelet_Buff_Buff", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("FrostArmor_Slow_Slow", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("FrozenShard_Buff_Buff", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("HealingPotionBloodOrange", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("HeartOfTheHards", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Lens", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Lens_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LifeArmor", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LifeArmor_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("MightyHammer", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("Nethermask_Use_Use", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("PotionOfTheInconspicuousShape", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ScrollOfRage", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Trident_Knockback_Knockback", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("VolatileManaPotion", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("WindBoots", "EVENT_DEATH", "Death( dyingUnit )")
            //////////////////////////////////////////////////////////////////////////////////////////////////
            //! runtextmacro AddEventStaticLine("AcidStrike", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("AdvertisingGift_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("AttackDerivation", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("Bash_OgreBrat_OgreBrat", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Bash_Zombie_Zombie", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Berserk", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("BloodyClaws", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("BondOfSouls", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("BubbleArmor", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Burrow", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ChillyPresence", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ChillyPresence_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("CourageAndHonor", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("CourageAndHonor_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("CripplingWave_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("CrowdPuller", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("CrowdPuller_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("CurseOfTheBloodline", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("DarkCloud", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Defend", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Disarm", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("DivineShield_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("DreadCall", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("EasyPrey", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("EmployHenchman", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Enchant", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("EnergyGap_Heal_Heal", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("EnergyGap_Aura_Aura", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("EnergyGap_Aura_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("FeelingOfSecurity", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("FeelingOfSecurity_Cooldown_Cooldown", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("FieryBoots", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Fireball", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("Frenzy", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("FrostBolt", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("FuneralFeast_Buff_Buff", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("FuneralFeast", "EVENT_CASTER_DEATH", "Caster_Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("Fury", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("GhoulFrenzy", "EVENT_CASTER_DEATH", "Caster_Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("GhoulFrenzy", "EVENT_CASTER_DEATH", "Caster_Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("GhoulFrenzy", "EVENT_SOURCE_DEATH", "Source_Death( killingUnit )")
            //! runtextmacro AddEventStaticLine("HammerThrow", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("HammerThrow_Mana_Mana", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("HealingWard", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("IceBall_Buff_Buff", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("IceBall", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("Immolation", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Inspiration", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Kataikaze", "EVENT_CASTER_DEATH", "Caster_Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Kataikaze", "EVENT_TARGET_DEATH", "Target_Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("KidneyShot", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("KittyJump_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LastGrave_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LayEgg", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LayEgg_Egg_Egg", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Libertine", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LifeDrain", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LifeRegenerationAura", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LifeRegenerationAura_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LifeRegenerationAuraNeutral", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LifeRegenerationAuraNeutral_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LightOfPurge", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("LinearBoomerang_DrawBack_DrawBack", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("MagicalLariat", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("MagicalSuperiority", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ManaRegenerationAura", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ManaRegenerationAura_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ManaRegenerationAuraNeutral", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ManaRegenerationAuraNeutral_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ManaTheft", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Metamorphosis", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("MightAura", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("MightAura_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("MindBreaker", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("NaturalEmbrace", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Net", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("Payday_AttackSilence_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("RapidFire_Buff_Buff", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("RapidFire", "EVENT_CASTER_DEATH", "Caster_Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("RapidFire", "EVENT_SOURCE_DEATH", "Source_Death( killingUnit, killingUnitOwner, dyingUnit )")
            //! runtextmacro AddEventStaticLine("RefillMana", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("RhythmicDrum", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("RhythmicDrum_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Riposte", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Riposte_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Rust", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Sales", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Sales_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("SilverSpores", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Slam", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("SlowPoison", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("SoulVessel", "EVENT_CASTER_DEATH", "Caster_Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("SoulVessel", "EVENT_SOURCE_DEATH", "Source_Death( killingUnit, killingUnitOwner, dyingUnit )")
            //! runtextmacro AddEventStaticLine("SoulVessel_Vessel_Vessel", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("SpellDisconnection", "EVENT_DEATH", "Death( dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ )")
            //! runtextmacro AddEventStaticLine("Stability", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("SuddenFrost", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("SummonFaust", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("SummonFaust_AttackGraphic_AttackGraphic", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("SummonPeq", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ThermalFissure_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("ToadReflection", "EVENT_DEATH", "Death( dyingUnit )")
            ////! runtextmacro AddEventStaticLine("TonelessMist", "EVENT_DEATH", "Death( dyingUnit )")
            ////! runtextmacro AddEventStaticLine("TonelessMist_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("UnholyArmor", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("UnholyArmor_Target_Target", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("UtilizationOfRests", "EVENT_CASTER_DEATH", "Caster_Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("UtilizationOfRests_Servant_Servant", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("VioletDefense", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("VividStrikes", "EVENT_DEATH", "Death( dyingUnit )")
            ////! runtextmacro AddEventStaticLine("WhipLash", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Whirlwind", "EVENT_DEATH", "Death( dyingUnit )")
            //////////////////////////////////////////////////////////////////////////////////////////////////
            //! runtextmacro AddEventStaticLine("Grass", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Marble", "EVENT_DEATH", "Death( dyingUnit )")
            //////////////////////////////////////////////////////////////////////////////////////////////////
            //! runtextmacro AddEventStaticLine("Creeps_Market_Market", "EVENT_DEATH", "Death( dyingUnit )")
            //! runtextmacro AddEventStaticLine("Creeps_MercenaryCamp_MercenaryCamp", "EVENT_DEATH", "Death( dyingUnit )")
            //////////////////////////////////////////////////////////////////////////////////////////////////
            //! runtextmacro AddEventStaticLine("Lightning_AddLightningBetweenUnits_AddLightningBetweenUnits_Post", "EVENT_DEATH", "Death(dyingUnit, dyingUnitX, dyingUnitY, dyingUnitZ)")
            //! runtextmacro AddEventStaticLine("UnitRevaluation_RevaluatingUnit", "EVENT_DEATH", "Death(dyingUnit)")
            //////////////////////////////////////////////////////////////////////////////////////////////////
            //! runtextmacro AddEventStaticLine("Unit_Order_ImmediateTimed_ImmediateTimed", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("Unit_Order_TargetTimed_TargetTimed", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("Upgrade", "EVENT_DEATH", "Death( dyingUnit )")

            //! runtextmacro AddEventStaticLine("Unit_Stun_Thunderbolt_Cancel_Cancel", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("Unit_Stun_Timed_Timed", "EVENT_DEATH", "Death(dyingUnit)")
        elseif (priority == 1) then
            //! runtextmacro AddEventStaticLine("Unit_Stun_Type0_Type0", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("Unit_Stun_Type1_Type1", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("Unit_Stun_Type2_Type2", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("Unit_Stun_Type3_Type3", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("Unit_Stun_Type4_Type4", "EVENT_DEATH", "Death(dyingUnit)")
            //! runtextmacro AddEventStaticLine("Unit_Stun_Type5_Type5", "EVENT_DEATH", "Death(dyingUnit)")
        endif
    endfunction

    private function TriggerEvents takes boolean deathCausedByEnemy, Unit dyingUnit, player dyingUnitOwner, UnitType dyingUnitType, real dyingUnitX, real dyingUnitY, real dyingUnitZ, boolean isDyingUnitStructure, Unit killingUnit, player killingUnitOwner, UnitType killingUnitType returns nothing
        local integer iteration = 0
        call SetUnitDead(dyingUnit, true)

        loop
            call TriggerEvents_Dynamic(dyingUnit, killingUnit, iteration)
            call TriggerEvents_Static(deathCausedByEnemy, dyingUnit, dyingUnitOwner, dyingUnitX, dyingUnitY, dyingUnitZ, killingUnit, killingUnitOwner, iteration)
            set iteration = iteration + 1
            exitwhen (iteration > 1)
        endloop

        call Cannibalism_Death( dyingUnit, dyingUnitX, dyingUnitY )
        call FuneralFeast_Source_Death( deathCausedByEnemy, killingUnitOwner, dyingUnit, dyingUnitOwner, dyingUnitX, dyingUnitY, dyingUnitZ )
        //////////////////////////////////////////////////////////////////////////////////////////////////
        call MasterWizard_Death(killingUnit, killingUnitOwner)
        call TownHall_Death( dyingUnit, dyingUnitType )
        call UnitRevaluation_Source_Death( deathCausedByEnemy, dyingUnitOwner, isDyingUnitStructure, killingUnit, killingUnitOwner, killingUnitType )
        call Worker_Death( dyingUnitOwner, dyingUnitType )
        //////////////////////////////////////////////////////////////////////////////////////////////////
        call Spawn_Death( dyingUnitOwner, dyingUnitType )
    endfunction

    public function Decay takes Unit dyingUnit, player dyingUnitOwner returns nothing
        local unit dyingUnitSelf = dyingUnit.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)

        call TriggerEvents(false, dyingUnit, dyingUnit.owner, dyingUnit.type, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY), IsUnitType(dyingUnitSelf, UNIT_TYPE_STRUCTURE), NULL, null, NULL)

        set dyingUnitSelf = null
    endfunction

    public function BeforeDying takes Unit dyingUnit, Unit killingUnit returns nothing
        local unit dyingUnitSelf = dyingUnit.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        local player killingUnitOwner
        local UnitType killingUnitType

        if (killingUnit == NULL) then
            set killingUnitOwner = null
            set killingUnitType = NULL
        else
            set killingUnitOwner = killingUnit.owner
            set killingUnitType = killingUnit.type
        endif

        call TriggerEvents(false, dyingUnit, dyingUnit.owner, dyingUnit.type, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY), IsUnitType(dyingUnitSelf, UNIT_TYPE_STRUCTURE), killingUnit, killingUnitOwner, killingUnitType)

        set dyingUnitSelf = null
        set killingUnitOwner = null
    endfunction

    private function Trig takes nothing returns nothing
        local boolean deathCausedByEnemy
        local unit dyingUnitSelf = GetDyingUnit()
        local Unit dyingUnit = GetUnit(dyingUnitSelf)
        local boolean decays = (GetUnitDecay(dyingUnit) > 0)
        local player dyingUnitOwner = dyingUnit.owner
        local UnitType dyingUnitType = dyingUnit.type
        local real dyingUnitX = GetUnitX( dyingUnitSelf )
        local real dyingUnitY = GetUnitY( dyingUnitSelf )
        local real dyingUnitZ = GetUnitZ( dyingUnitSelf, dyingUnitX, dyingUnitY )
        local boolean explodes = (GetUnitExplode(dyingUnit) > 0)
        local boolean isDyingUnitIllusion = IsUnitIllusionWJ( dyingUnit )
        local boolean isDyingUnitStructure = IsUnitType( dyingUnitSelf, UNIT_TYPE_STRUCTURE )
        local unit killingUnitSelf = GetKillingUnit()
        local Unit killingUnit = GetUnit(killingUnitSelf)
        local boolean isKillingUnitNull = ( killingUnit == NULL )
        local integer iteration
        local player killingUnitOwner
        local integer killingUnitTeam
        local UnitType killingUnitType
        local player specificPlayer
        if ( isKillingUnitNull ) then
            set deathCausedByEnemy = false
            set killingUnitOwner = null
            set killingUnitTeam = -1
            set killingUnitType = NULL
        else
            set deathCausedByEnemy = IsUnitEnemy( killingUnitSelf, dyingUnitOwner )
            set killingUnitOwner = killingUnit.owner
            set killingUnitTeam = GetPlayerTeam( killingUnitOwner )
            set killingUnitType = killingUnit.type
        endif
        if ( explodes ) then
            call DestroyEffectWJ( AddSpecialEffectWJ( GetUnitBloodExplosion( dyingUnit ), dyingUnitX, dyingUnitY ) )
        elseif (decays) then
            call RemoveUnitTimedEx(dyingUnit, GetUnitDecayTime(dyingUnit))
        endif

        if ( isDyingUnitIllusion == false ) then
            if (isKillingUnitNull == false) then
                call Drop_Death(deathCausedByEnemy, dyingUnit, dyingUnitOwner, dyingUnitType, dyingUnitX, dyingUnitY, dyingUnitZ, killingUnit, killingUnitOwner, killingUnitTeam)
                call Experience_Death(deathCausedByEnemy, dyingUnit, dyingUnitType, dyingUnitX, dyingUnitY, killingUnitOwner, killingUnitTeam)
            endif
            call Infoboard_Death(deathCausedByEnemy, dyingUnit, killingUnit)
        endif

        call TriggerEvents(deathCausedByEnemy, dyingUnit, dyingUnitOwner, dyingUnitType, dyingUnitX, dyingUnitY, dyingUnitZ, isDyingUnitStructure, killingUnit, killingUnitOwner, killingUnitType)

        if ( IsUnitType( dyingUnitSelf, UNIT_TYPE_HERO ) == false ) then
            if ( isDyingUnitStructure ) then
                call SetUnitSupplyProduced( dyingUnit, dyingUnitOwner, 0 )
            endif
            call SetUnitSupplyUsed( dyingUnit, dyingUnitOwner, 0 )
        endif

        //////////////////////////////////////////////////////////////////////////////////////////////////
        set iteration = MAX_PLAYER_INDEX
        loop
            set specificPlayer = Player( iteration )
            if ( IsUnitSelected( dyingUnitSelf, specificPlayer ) ) then
                call SelectUnitWJ( dyingUnitSelf, false, specificPlayer )
            endif
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set specificPlayer = null

        //////////////////////////////////////////////////////////////////////////////////////////////////
        set dyingUnit.orderTarget = null
        set dyingUnit.orderX = 0
        set dyingUnit.orderY = 0
        //////////////////////////////////////////////////////////////////////////////////////////////////

        if ( decays ) then
            call SpecialDrops_Source_Death(deathCausedByEnemy, isDyingUnitStructure, dyingUnitX, dyingUnitY)
            if ( explodes ) then
                call RemoveUnitEx( dyingUnit )
            else
                call UtilizationOfRests_Source_Death( dyingUnit, dyingUnitX, dyingUnitY )
                //////////////////////////////////////////////////////////////////////////////////////////////////
                if ( IsUnitType( dyingUnitSelf, UNIT_TYPE_TOWNHALL ) ) then
                    call KillPlayer( dyingUnitOwner )
                endif
            endif
        endif

        set dyingUnitOwner = null
        set dyingUnitSelf = null
        set killingUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitDies.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitDropsItem.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitDropsItem
    globals
        public trigger DUMMY_TRIGGER
        public boolean IGNORE_NEXT = false
    endglobals

    private function TriggerEvents_Static takes Item manipulatedItem, integer manipulatedItemTypeId, Unit manipulatingUnit returns nothing
        if ( manipulatedItemTypeId == AstralGauntlets_ITEM_ID ) then
            call AstralGauntlets_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == BeltOfTheCelt_ITEM_ID ) then
            call BeltOfTheCelt_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == ChaosSword_ITEM_ID ) then
            call ChaosSword_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == FenixsFeather_ITEM_ID ) then
            call FenixsFeather_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == FrostArmor_ITEM_ID ) then
            call FrostArmor_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == FrozenShard_ITEM_ID ) then
            call FrozenShard_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == GexxoSlippers_ITEM_ID ) then
            call GexxoSlippers_Drop(manipulatingUnit)
        elseif ( manipulatedItemTypeId == GiantAxe_ITEM_ID ) then
            call GiantAxe_Drop(manipulatingUnit)
        elseif( manipulatedItemTypeId == GloveOfTheBeast_ITEM_ID ) then
            call GloveOfTheBeast_Drop( manipulatingUnit )
        elseif( manipulatedItemTypeId == GoldenRing_ITEM_ID ) then
            call GoldenRing_Drop(manipulatingUnit)
        elseif ( manipulatedItemTypeId == HeartOfTheHards_ITEM_ID ) then
            call HeartOfTheHards_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == HeartStone_ITEM_ID ) then
            call HeartStone_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == JeweledDaggerOfGreed_ITEM_ID ) then
            call JeweledDaggerOfGreed_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == LifeArmor_ITEM_ID ) then
            call LifeArmor_Drop( manipulatingUnit )
        elseif( (manipulatedItemTypeId == Lollipop_ITEM_ID) or (manipulatedItemTypeId == Lollipop_MANUFACTURED_ITEM_ID) ) then
            call Lollipop_Drop( manipulatingUnit )
        elseif( manipulatedItemTypeId == MedaillonOfTheStrivingGod_ITEM_ID ) then
            call MedaillonOfTheStrivingGod_Drop( manipulatingUnit, manipulatedItem )
        elseif( manipulatedItemTypeId == MightyHammer_ITEM_ID ) then
            call MightyHammer_Drop( manipulatingUnit )
        elseif( manipulatedItemTypeId == Nethermask_ITEM_ID ) then
            call Nethermask_Drop( manipulatingUnit, manipulatedItem )
        elseif( manipulatedItemTypeId == OrbOfWisdom_ITEM_ID ) then
            call OrbOfWisdom_Drop( manipulatingUnit, manipulatedItem )
        elseif ( manipulatedItemTypeId == PrismaticCape_ITEM_ID ) then
            call PrismaticCape_Drop( manipulatedItem, manipulatingUnit )
        elseif ( manipulatedItemTypeId == RhythmicDrum_ITEM_ID ) then
            call RhythmicDrum_Drop( manipulatingUnit )
        elseif( manipulatedItemTypeId == RobeOfThePope_ITEM_ID ) then
            call RobeOfThePope_Drop( manipulatingUnit )
        elseif( manipulatedItemTypeId == SpidermanSocks_ITEM_ID ) then
            call SpidermanSocks_Drop( manipulatingUnit )
        elseif( manipulatedItemTypeId == Trident_ITEM_ID ) then
            call Trident_Drop( manipulatingUnit )
        elseif ( manipulatedItemTypeId == WindBoots_ITEM_ID ) then
            call WindBoots_Drop( manipulatingUnit )
        endif
    endfunction

    private function Trig takes nothing returns nothing
        local Item manipulatedItem
        local Unit manipulatingUnit
        local integer manipulatedItemTypeId
        if ( IGNORE_NEXT ) then
            set IGNORE_NEXT = false
        else
            set manipulatedItem = GetItem(GetManipulatedItem())
            set manipulatedItemTypeId = manipulatedItem.type.id
            set manipulatingUnit = GetUnit(GetManipulatingUnit())

            call TriggerEvents_Static(manipulatedItem, manipulatedItemTypeId, manipulatingUnit)
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitDropsItem.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesCasting.j
//TESH.scrollpos=18
//TESH.alwaysfold=0
scope UnitFinishesCasting
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Dynamic takes Unit caster, integer priority, integer skill, real targetX, real targetY returns nothing
        local integer iteration = CountEventsById( skill, UnitFinishesCasting_EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set CASTER = caster
            set SKILL = skill
            set TARGET_X = targetX
            set TARGET_Y = targetY
            call RunTrigger( GetEventsById(skill, UnitFinishesCasting_EVENT_KEY, priority, iteration ) )
            set iteration = iteration - 1
        endloop
    endfunction

    private function TriggerEvents_Static takes Unit caster, integer priority, integer skill, real targetX, real targetY returns nothing
        local unit casterSelf = caster.self
        if (priority == 0) then
            if (false) then
            endif
            //! runtextmacro AddEventConditionalStaticLine("AirPassage", "EVENT_ENDCAST", "EndCast( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Barrage", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("BondOfSouls", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Burrow", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FieryBoots", "EVENT_ACTIVATION_ENDCAST", "Activation_EndCast( caster )", "skill", "ACTIVATION_SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FieryBoots", "EVENT_DEACTIVATION_ENDCAST", "Deactivation_EndCast( caster )", "skill", "DEACTIVATION_SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LastGrave", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LifeDrain", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LightOfPurge", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LittleThunderstorm", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("MagicalLariat", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Meditation", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Payday", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("RefillMana", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SelfHeal", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Suicide", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("TownPortal", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("WonderSeeds", "EVENT_ENDCAST", "EndCast( caster )", "skill", "SPELL_ID")
            if (false) then
            endif
        endif
        set casterSelf = null
    endfunction

    private function TriggerEvents takes Unit caster, integer skill, real targetX, real targetY returns nothing
        local integer iteration = 0

        loop
            call TriggerEvents_Dynamic(caster, iteration, skill, targetX, targetY)
            call TriggerEvents_Static(caster, iteration, skill, targetX, targetY)
            set iteration = iteration + 1
            exitwhen (iteration > 0)
        endloop
    endfunction

    private function Trig takes nothing returns nothing
        local Unit caster = GetUnit(GetSpellAbilityUnit())
        local unit casterSelf = caster.self
        local integer skill = GetSpellAbilityId()
        local real targetX = TARGET_X
        local real targetY = TARGET_Y

        if (GetUnitAbilityLevel(casterSelf, INSTANT_CAST_BUFF_ID) > 0) then
            call UnitRemoveAbility(casterSelf, INSTANT_CAST_BUFF_ID)
        endif
        set casterSelf = null

        call TriggerEvents(caster, skill, targetX, targetY)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesCasting.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesConstructing.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitFinishesConstructing
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Unit constructedStructure returns nothing
        call Brick_ConstructingFinish( constructedStructure )
        call Grass_ConstructingFinish( constructedStructure )
        call Marble_ConstructingFinish( constructedStructure )
    endfunction

    private function Trig takes nothing returns nothing
        local Unit constructedStructure = GetUnit(GetConstructedStructure())

        call TriggerEvents_Static(constructedStructure)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesConstructing.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesDecaying.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitFinishesDecaying
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    scope End
        private function End_TriggerEvents_Dynamic takes integer priority, Unit triggerUnit returns nothing
            local integer triggerUnitId = triggerUnit.id
            local integer iteration = CountEventsById( triggerUnitId, UnitFinishesDecaying_End_End_EVENT_KEY, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set TRIGGER_UNIT = triggerUnit
                call RunTrigger( GetEventsById( triggerUnitId, UnitFinishesDecaying_End_End_EVENT_KEY, priority, iteration ) )
                set iteration = iteration - 1
            endloop
        endfunction

        private function End_TriggerEvents_Static takes integer priority, Unit triggerUnit returns nothing
            if (priority == 0) then
                //! runtextmacro AddEventStaticLine("IllusionaryStaff", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Lens", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")

                //! runtextmacro AddEventStaticLine("AttackDerivation", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Disarm", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("DiversionShot", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Feedback", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("LightningAttack", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("MysticalAttack", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Neutralization", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Pulverize", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("SlowPoison", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
                //! runtextmacro AddEventStaticLine("StrongArm", "EVENT_DECAY_END", "DecayEnd( triggerUnit )")
            endif
        endfunction

        private function End_TriggerEvents takes Unit triggerUnit returns nothing
            local integer iteration = 0

            loop
                call End_TriggerEvents_Dynamic(iteration, triggerUnit)
                call End_TriggerEvents_Static(iteration, triggerUnit)
                set iteration = iteration + 1
                exitwhen (iteration > 0)
            endloop
        endfunction

        public function End_Start takes Unit triggerUnit returns nothing
            local unit triggerUnitSelf = triggerUnit.self

            call End_TriggerEvents(triggerUnit)

            if ( GetUnitRemainingReferences( triggerUnit ) > 0 ) then
                set triggerUnit.waitsForRemoval = true
            else
                call triggerUnit.destroy()
                call RemoveUnitWJ( triggerUnitSelf )
            endif
            set triggerUnitSelf = null
        endfunction
    endscope

    private function TriggerEvents_Dynamic takes integer priority, Unit triggerUnit returns nothing
        local integer triggerUnitId = triggerUnit.id
        local integer iteration = CountEventsById( triggerUnitId, EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetEventsById( triggerUnitId, EVENT_KEY, priority, iteration ) )
            set iteration = iteration - 1
        endloop
    endfunction

    private function TriggerEvents_Static takes integer priority, Unit triggerUnit returns nothing
        if (priority == 0) then
            //! runtextmacro AddEventStaticLine("FriendshipBracelet", "EVENT_DECAY", "Decay(triggerUnit)")
            //! runtextmacro AddEventStaticLine("Reincarnation", "EVENT_DECAY", "Decay(triggerUnit)")
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //! runtextmacro AddEventStaticLine("Unit_RemoveUnit_TimedEx_TimedEx", "EVENT_DECAY", "Decay(triggerUnit)")
            //! runtextmacro AddEventStaticLine("Unit_Scale_Timed_Timed", "EVENT_DECAY", "Decay(triggerUnit)")
            //! runtextmacro AddEventStaticLine("Unit_VertexColor_Timed_Timed", "EVENT_DECAY", "Decay(triggerUnit)")
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //! runtextmacro AddEventStaticLine("CripplingWave", "EVENT_DECAY", "Decay(triggerUnit)")
        endif
    endfunction

    private function TriggerEvents takes Unit triggerUnit returns nothing
        local integer iteration = 0

        loop
            call TriggerEvents_Dynamic(iteration, triggerUnit)
            call TriggerEvents_Static(iteration, triggerUnit)
            set iteration = iteration + 1
            exitwhen (iteration > 0)
        endloop
    endfunction

    private function Trig takes nothing returns nothing
        local Unit triggerUnit = TRIGGER_UNIT
        local player triggerUnitOwner = triggerUnit.owner
        local unit triggerUnitSelf = triggerUnit.self

        call GroupRemoveUnit( ALL_GROUP, triggerUnitSelf )

        call ClearUnitRequestQueue(triggerUnit)
        if ( IsUnitType(triggerUnitSelf, UNIT_TYPE_STRUCTURE) ) then
            call SetUnitSupplyProduced( triggerUnit, triggerUnitOwner, 0 )
        endif
        call SetUnitSupplyUsed( triggerUnit, triggerUnitOwner, 0 )

        if (IsUnitDead(triggerUnit) == false) then
            call UnitDies_Decay(triggerUnit, triggerUnitOwner)
        endif

        call TriggerEvents(triggerUnit)

        call End_End_Start(triggerUnit)

        set triggerUnitOwner = null
        set triggerUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesDecaying.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesResearching.j
//TESH.scrollpos=18
//TESH.alwaysfold=0
scope UnitFinishesResearching
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    scope LearnRequiredResearchAbilities
        globals
            private group LearnRequiredResearchAbilities_ENUM_GROUP
            private boolexpr LearnRequiredResearchAbilities_TARGET_CONDITIONS
        endglobals

        private function LearnRequiredResearchAbilities_TargetConditions takes nothing returns boolean
            set FILTER_UNIT = GetUnit(GetFilterUnit())
            if (FILTER_UNIT.owner != TEMP_PLAYER) then
                return false
            endif
            if (FILTER_UNIT.type != TEMP_UNIT_TYPE) then
                return false
            endif
            if (IsUnitIllusionWJ(FILTER_UNIT)) then
                return false
            endif
            return true
        endfunction

        public function LearnRequiredResearchAbilities_Start takes player researchingUnitOwner, integer triggerResearchTypeId returns nothing
            local unit enumUnit
            local UnitType enumUnitType
            local integer iteration = CountRequiredResearchAbilities( triggerResearchTypeId )
            local integer iteration2
            local integer specificAbility
            loop
                exitwhen (iteration < 0)
                set iteration2 = CountResearchTypeIdUnitTypes( triggerResearchTypeId )
                set specificAbility = GetRequiredResearchAbility( triggerResearchTypeId, iteration )
                loop
                    exitwhen (iteration2 < 0)
                    set enumUnitType = GetResearchTypeIdUnitType( triggerResearchTypeId, iteration2 )
                    set TEMP_PLAYER = researchingUnitOwner
                    set TEMP_UNIT_TYPE = enumUnitType
                    call GroupEnumUnitsInRect( LearnRequiredResearchAbilities_ENUM_GROUP, WORLD_RECT, LearnRequiredResearchAbilities_TARGET_CONDITIONS )
                    loop
                        set enumUnit = FirstOfGroup( LearnRequiredResearchAbilities_ENUM_GROUP )
                        exitwhen (enumUnit == null)
                        call GroupRemoveUnit( LearnRequiredResearchAbilities_ENUM_GROUP, enumUnit )
                        call UnitLearnsSkill_TriggerEvents( GetUnit( enumUnit ), researchingUnitOwner, enumUnitType, specificAbility )
                    endloop
                    set iteration2 = iteration2 - 1
                endloop
                set iteration = iteration - 1
            endloop
        endfunction

        public function LearnRequiredResearchAbilities_Init takes nothing returns nothing
            set LearnRequiredResearchAbilities_ENUM_GROUP = CreateGroupWJ()
            set LearnRequiredResearchAbilities_TARGET_CONDITIONS = ConditionWJ( function LearnRequiredResearchAbilities_TargetConditions )
        endfunction
    endscope

    private function TriggerEvents_Static takes player researchingUnitOwner, integer researchLevel, integer triggerResearchTypeId returns nothing
        call Infoboard_Additionboard_Additionboard_ResearchFinish(researchingUnitOwner)
        if ( triggerResearchTypeId == BigGun_RESEARCH_ID ) then
            call BigGun_ResearchFinish( researchingUnitOwner )
        elseif ( triggerResearchTypeId == CriticalStrikes_RESEARCH_ID ) then
            call CriticalStrikes_ResearchFinish( researchLevel, researchingUnitOwner )
        elseif ( triggerResearchTypeId == DoubleHead_RESEARCH_ID ) then
            call DoubleHead_ResearchFinish( researchingUnitOwner )
        elseif ( triggerResearchTypeId == FeelingOfSecurity_RESEARCH_ID ) then
            call FeelingOfSecurity_Cooldown_Cooldown_ResearchFinish( researchingUnitOwner )
        elseif ( triggerResearchTypeId == ImprovedRaiseDead_RESEARCH_ID ) then
            call ImprovedRaiseDead_ResearchFinish( researchLevel, researchingUnitOwner )
        elseif ( triggerResearchTypeId == MassProduction_RESEARCH_ID ) then
            call MassProduction_ResearchFinish( researchLevel, researchingUnitOwner )
        elseif ( triggerResearchTypeId == RegenerativeHerbs_RESEARCH_ID ) then
            call RegenerativeHerbs_ResearchFinish( researchLevel, researchingUnitOwner )
        elseif ( triggerResearchTypeId == ShiftInventory_RESEARCH_ID ) then
            call ShiftInventory_ResearchFinish( researchingUnitOwner )
        elseif ( triggerResearchTypeId == SparklingScales_RESEARCH_ID ) then
            call SparklingScales_ResearchFinish( researchLevel, researchingUnitOwner )
        elseif ( UpgradeArmor_ResearchFinish_Conditions(triggerResearchTypeId) ) then
            call UpgradeArmor_ResearchFinish( researchLevel, researchingUnitOwner )
        elseif ( UpgradeAttackRate_ResearchFinish_Conditions(triggerResearchTypeId) ) then
            call UpgradeAttackRate_ResearchFinish( researchLevel, researchingUnitOwner )
        elseif ( UpgradeDamage_ResearchFinish_Conditions(triggerResearchTypeId) ) then
            call UpgradeDamage_ResearchFinish( researchLevel, researchingUnitOwner )
        elseif ( UpgradePower_ResearchFinish_Conditions(triggerResearchTypeId) ) then
            call UpgradePower_ResearchFinish( researchLevel, researchingUnitOwner )
        elseif ( triggerResearchTypeId == UpgradeSpeed_RESEARCH_ID ) then
            call UpgradeSpeed_ResearchFinish( researchLevel, researchingUnitOwner )
        endif

        call LearnRequiredResearchAbilities_LearnRequiredResearchAbilities_Start( researchingUnitOwner, triggerResearchTypeId )
    endfunction

    private function Trig takes nothing returns nothing
        local Unit researchingUnit = GetUnit(GetResearchingUnit())
        local player researchingUnitOwner = researchingUnit.owner
        local integer researchTypeId = GetResearched()
        local integer researchLevel = GetPlayerTechCount( researchingUnitOwner, researchTypeId, true )

        call TriggerEvents_Static(researchingUnitOwner, researchLevel, researchTypeId)

        set researchingUnitOwner = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        call LearnRequiredResearchAbilities_LearnRequiredResearchAbilities_Init()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesResearching.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesReviving.j
//TESH.scrollpos=5
//TESH.alwaysfold=0
scope UnitFinishesReviving
    globals
        public trigger DUMMY_TRIGGER
        //! runtextmacro CreateEventKey("", "", "true")

        Unit REVIVING_UNIT
    endglobals

    private function TriggerEvents_Dynamic takes integer priority, Unit revivingUnit returns nothing
        local integer iteration = CountEventsById( revivingUnit, UnitFinishesReviving_EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set REVIVING_UNIT = revivingUnit
            call RunTrigger( GetEventsById( revivingUnit, UnitFinishesReviving_EVENT_KEY, priority, iteration ) )
            set iteration = iteration - 1
        endloop
    endfunction

    private function TriggerEvents_Static takes integer priority, Unit revivingUnit, player revivingUnitOwner, integer revivingUnitType returns nothing
        if (priority == 0) then
            //! runtextmacro AddEventStaticLine("LifeArmor", "EVENT_REVIVE", "Revive( revivingUnit )")
            //! runtextmacro AddEventStaticLine("RhythmicDrum", "EVENT_REVIVE", "Revive( revivingUnit )")
            ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
            //! runtextmacro AddEventStaticLine("ChillyPresence", "EVENT_REVIVE", "Revive( revivingUnit )")
            //! runtextmacro AddEventStaticLine("CourageAndHonor", "EVENT_REVIVE", "Revive( revivingUnit )")
            //! runtextmacro AddEventStaticLine("EnergyGap_Aura_Aura", "EVENT_REVIVE", "Revive( revivingUnit )")
            //! runtextmacro AddEventStaticLine("Libertine", "EVENT_REVIVE", "Revive( revivingUnit )")
            //! runtextmacro AddEventStaticLine("MagicalSuperiority", "EVENT_REVIVE", "Revive( revivingUnit )")
            //! runtextmacro AddEventStaticLine("Sales", "EVENT_REVIVE", "Revive( revivingUnit )")
            //! runtextmacro AddEventStaticLine("UnholyArmor", "EVENT_REVIVE", "Revive( revivingUnit )")
        endif
    endfunction

    private function TriggerEvents takes Unit revivingUnit, player revivingUnitOwner, integer revivingUnitType returns nothing
        local integer iteration = 0

        loop
            call TriggerEvents_Dynamic(iteration, revivingUnit)
            call TriggerEvents_Static(iteration, revivingUnit, revivingUnitOwner, revivingUnitType)
            set iteration = iteration + 1
            exitwhen (iteration > 0)
        endloop
    endfunction

    private function Trig takes nothing returns nothing
        local unit revivingUnitSelf = GetRevivingUnit()
        local Unit revivingUnit = GetUnit(revivingUnitSelf)
        local player revivingUnitOwner = revivingUnit.owner
        local integer revivingUnitTeam = GetPlayerTeam( revivingUnitOwner )
        local UnitType revivingUnitType = revivingUnit.type
        call SetUnitDead(revivingUnit, false)
        call UnitIsActivated_Start( revivingUnit )

        call TriggerEvents(revivingUnit, revivingUnitOwner, revivingUnitType)

        call UnitIsActivated_Start(revivingUnit)

        set revivingUnitOwner = null
        set revivingUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesReviving.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesTraining.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitFinishesTraining
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Unit rax, Unit trainedUnit returns nothing
        local UnitType trainedUnitType = trainedUnit.type
        call Spawn_FinishTraining( rax, trainedUnit.self, trainedUnit.owner, trainedUnitType, trainedUnitType.id )
    endfunction

    private function Trig takes nothing returns nothing
        local Unit rax = GetUnit(GetTriggerUnit())
        local Unit trainedUnit = GetTrainedUnitEx()

        call TriggerEvents_Static(rax, trainedUnit)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesTraining.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesUpgrading.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitFinishesUpgrading
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Unit triggerUnit, player triggerUnitOwner, UnitType triggerUnitType, real triggerUnitX, real triggerUnitY returns nothing
        call Miscellaneous_Altar_Altar_UpgradeFinish( triggerUnit, triggerUnitOwner, triggerUnitType, triggerUnitX, triggerUnitY )
        call TownHall_UpgradeFinish( triggerUnit, triggerUnitOwner, triggerUnitType )
    endfunction

    private function Trig takes nothing returns nothing
        local unit triggerUnitSelf = GetTriggerUnit()
        local Unit triggerUnit = GetUnit(triggerUnitSelf)
        local real triggerUnitMaxLife = GetUnitState( triggerUnitSelf, UNIT_STATE_MAX_LIFE )
        local boolean resetLife = ( triggerUnitMaxLife != 0 )
        local real triggerUnitLifeRelative
        local player triggerUnitOwner = triggerUnit.owner
        local UnitType triggerUnitType = GetUnitType(GetUnitTypeId(triggerUnitSelf))
        local real triggerUnitX = GetUnitX( triggerUnitSelf )
        local real triggerUnitY = GetUnitY( triggerUnitSelf )
        if ( resetLife ) then
            set triggerUnitLifeRelative = GetUnitState( triggerUnitSelf, UNIT_STATE_LIFE ) / triggerUnitMaxLife
        endif
        call Upgrade_Remove( triggerUnit )
        call UnitChangesForm_Start(triggerUnit, triggerUnitType, triggerUnit.type)

        call TriggerEvents_Static(triggerUnit, triggerUnitOwner, triggerUnitType, triggerUnitX, triggerUnitY)

        if ( resetLife ) then
            call SetUnitState( triggerUnitSelf, UNIT_STATE_LIFE, triggerUnitLifeRelative * GetUnitState( triggerUnitSelf, UNIT_STATE_MAX_LIFE ) )
        endif
        set triggerUnitOwner = null
        set triggerUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitFinishesUpgrading.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitGainsLevel.j
//TESH.scrollpos=3
//TESH.alwaysfold=0
scope UnitGainsLevel
    globals
        public trigger DUMMY_TRIGGER
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\Levelup\\LevelupCaster.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private function TriggerEvents_Static takes Unit leveler, player levelerOwner, integer newLevel returns nothing
        call EnergyGap_Aura_Aura_LevelGain_Before( leveler )

        call Infoboard_LevelGain( newLevel, leveler, levelerOwner )
    endfunction

    private function Trig takes nothing returns nothing
        local unit levelerSelf = GetLevelingUnit()
        local Unit leveler = GetUnit(levelerSelf)
        local UnitType levelerType = leveler.type
        local integer newLevel = GetHeroLevel( levelerSelf )
        local integer levelsRaisedAmount = newLevel - leveler.level
        if ( IsUnitIllusionWJ( leveler ) == false ) then
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, levelerSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
        endif
        set levelerSelf = null
        set leveler.level = newLevel

        call TriggerEvents_Static(leveler, leveler.owner, newLevel)

        call AddHeroAgility( leveler, levelerType, levelsRaisedAmount * GetUnitTypeAgilityPerLevel(levelerType) )
        call AddHeroIntelligence( leveler, levelerType, levelsRaisedAmount * GetUnitTypeIntelligencePerLevel(levelerType) )
        call AddHeroStrength( leveler, levelerType, levelsRaisedAmount * GetUnitTypeStrengthPerLevel(levelerType) )
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitGainsLevel.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitGetsOrder.j
//TESH.scrollpos=59
//TESH.alwaysfold=0
scope UnitGetsOrder
    globals
        public trigger DUMMY_TRIGGER

        string ERROR_MSG
        public boolean IGNORE_NEXT = false
        Unit ORDERED_UNIT
        integer TRIGGER_ORDER
    endglobals

    private function GetUnitAbilityFromOrder takes unit orderedUnit, integer whichOrder returns integer
        local integer iteration = CountOrderAbilities(whichOrder)
        local integer specificAbility
        loop
            exitwhen ( iteration < 0 )
            set specificAbility = GetOrderAbility(whichOrder, iteration)
            if ( GetUnitAbilityLevel( orderedUnit, specificAbility ) > 0 ) then
                return specificAbility
            endif
            set iteration = iteration - 1
        endloop
        return 0
    endfunction

    scope Executed
        private function Executed_TriggerEvents_Dynamic takes integer abilityOrderId, Unit orderedUnit, real orderX, real orderY, integer priority, Unit targetUnit, integer triggerOrder returns nothing
            local integer orderedUnitId = orderedUnit.id
            local integer iteration = CountEventsById( abilityOrderId, UnitGetsOrder_Executed_Executed_EVENT_KEY, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set ORDERED_UNIT = orderedUnit
                set TARGET_UNIT = targetUnit
                set TARGET_X = orderX
                set TARGET_Y = orderY
                call RunTrigger( GetEventsById( abilityOrderId, UnitGetsOrder_Executed_Executed_EVENT_KEY, priority, iteration ) )
                set iteration = iteration - 1
            endloop
            set iteration = CountEventsById( orderedUnitId, UnitGetsOrder_Executed_Executed_EVENT_KEY, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set ORDERED_UNIT = orderedUnit
                set TARGET_UNIT = targetUnit
                set TARGET_X = orderX
                set TARGET_Y = orderY
                set TRIGGER_ORDER = triggerOrder
                call RunTrigger( GetEventsById( orderedUnitId, UnitGetsOrder_Executed_Executed_EVENT_KEY, priority, iteration ) )
                set iteration = iteration - 1
            endloop
            set iteration = CountEventsById(triggerOrder, UnitGetsOrder_Executed_Executed_EVENT_KEY, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set ORDERED_UNIT = orderedUnit
                set TARGET_UNIT = targetUnit
                set TARGET_X = orderX
                set TARGET_Y = orderY
                call RunTrigger( GetEventsById( triggerOrder, UnitGetsOrder_Executed_Executed_EVENT_KEY, priority, iteration ) )
                set iteration = iteration - 1
            endloop
        endfunction

        private function Executed_TriggerEvents_Static takes Unit orderedUnit, real orderX, real orderY, integer priority, integer skill, integer triggerOrder returns nothing
            if (priority == 0) then
                //! runtextmacro AddEventStaticLine("Unit_Order_ImmediateTimed_ImmediateTimed", "EVENT_ORDER_EXECUTE", "OrderExecute( orderedUnit )")
                //! runtextmacro AddEventStaticLine("Unit_Order_TargetTimed_TargetTimed", "EVENT_ORDER_EXECUTE", "OrderExecute( orderedUnit )")
                if (false) then
                endif
                //! runtextmacro AddEventConditionalStaticLine("Unit_Stun_Ensnare_Cancel_Cancel", "EVENT_ORDER_EXECUTE", "OrderExecute( orderedUnit )", "triggerOrder", "ORDER_ID")"
                //! runtextmacro AddEventConditionalStaticLine("Unit_Stun_Thunderbolt_Cancel_Cancel", "EVENT_ORDER_EXECUTE", "OrderExecute( orderedUnit )", "triggerOrder", "ORDER_ID")"
                if (false) then
                endif
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                //! runtextmacro AddEventStaticLine("CamouflageSuit", "EVENT_ORDER_EXECUTE", "OrderExecute( orderedUnit, triggerOrder )")
                ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////
                //! runtextmacro AddEventStaticLine("Whirlwind", "EVENT_ORDER_EXECUTE2", "OrderExecute2( orderedUnit )")
                if (false) then
                endif
                //! runtextmacro AddEventStaticConditionLine("Defend", "EVENT_ORDER_EXECUTE", "skill", "SPELL_ID")
                    if (false) then
                    endif
                    //! runtextmacro AddEventConditionalStaticLine("Defend", "EVENT_ACTIVATION_ORDER_EXECUTE", "Activation_OrderExecute( orderedUnit )", "triggerOrder", "ACTIVATION_ORDER_ID")"
                    //! runtextmacro AddEventConditionalStaticLine("Defend", "EVENT_DEACTIVATION_ORDER_EXECUTE", "Deactivation_OrderExecute( orderedUnit )", "triggerOrder", "DEACTIVATION_ORDER_ID")"
                    if (false) then
                    endif
                //! runtextmacro AddEventConditionalStaticLine("FieryBoots", "EVENT_ORDER_EXECUTE", "OrderExecute( orderedUnit )", "skill", "ACTIVATION_SPELL_ID")"
                //! runtextmacro AddEventConditionalStaticLine("Whirlwind", "EVENT_ORDER_EXECUTE", "OrderExecute( orderedUnit )", "skill", "SPELL_ID")"
                if (false) then
                endif
            endif
        endfunction

        private function Executed_TriggerEvents takes integer abilityOrderId, Unit orderedUnit, real orderX, real orderY, integer skill, Unit targetUnit, integer triggerOrder returns nothing
            local integer iteration = 0

            loop
                call Executed_TriggerEvents_Dynamic(abilityOrderId, orderedUnit, orderX, orderY, iteration, targetUnit, triggerOrder)
                call Executed_TriggerEvents_Static(orderedUnit, orderX, orderY, iteration, skill, triggerOrder)
                set iteration = iteration + 1
                exitwhen (iteration > 0)
            endloop
        endfunction

        public function Executed_Start takes integer abilityOrderId, integer goldCost, Unit orderedUnit, player orderedUnitOwner, real orderX, real orderY, integer skill, Unit targetUnit, integer triggerOrder returns nothing
            set orderedUnit.orderTarget = targetUnit.self
            set orderedUnit.orderX = orderX
            set orderedUnit.orderY = orderY
            if (goldCost > 0) then
                call AddPlayerState( orderedUnitOwner, PLAYER_STATE_RESOURCE_GOLD, -goldCost )
            endif

            call Executed_TriggerEvents(abilityOrderId, orderedUnit, orderX, orderY, skill, targetUnit, triggerOrder)
        endfunction
    endscope

    private function TriggerEvents_Dynamic takes integer abilityOrderId, Unit orderedUnit, real orderX, real orderY, integer priority, integer skill, Unit targetUnit, integer triggerOrder returns string
        local string errorMsg = null
        local integer iteration = CountEventsById(abilityOrderId, UnitGetsOrder_EVENT_KEY, priority )
        local integer orderedUnitId = orderedUnit.id
        set ERROR_MSG = null
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set ORDERED_UNIT = orderedUnit
            set TARGET_UNIT = targetUnit
            set TARGET_X = orderX
            set TARGET_Y = orderY
            call RunTrigger( GetEventsById( abilityOrderId, UnitGetsOrder_EVENT_KEY, priority, iteration ) )
            //! runtextmacro StringSetIf("errorMsg", "ERROR_MSG", "errorMsg == null")
            set iteration = iteration - 1
        endloop
        set iteration = CountEventsById(orderedUnitId, UnitGetsOrder_EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set ORDERED_UNIT = orderedUnit
            set TARGET_UNIT = targetUnit
            set TARGET_X = orderX
            set TARGET_Y = orderY
            call RunTrigger( GetEventsById(orderedUnitId, UnitGetsOrder_EVENT_KEY, priority, iteration ) )
            //! runtextmacro StringSetIf("errorMsg", "ERROR_MSG", "errorMsg == null")
            set iteration = iteration - 1
        endloop
        set iteration = CountEventsById(triggerOrder, UnitGetsOrder_EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set ORDERED_UNIT = orderedUnit
            set TARGET_UNIT = targetUnit
            set TARGET_X = orderX
            set TARGET_Y = orderY
            call RunTrigger( GetEventsById( triggerOrder, UnitGetsOrder_EVENT_KEY, priority, iteration ) )
            //! runtextmacro StringSetIf("errorMsg", "ERROR_MSG", "errorMsg == null")
            set iteration = iteration - 1
        endloop
        return errorMsg
    endfunction

    private function TriggerEvents_Static takes Unit orderedUnit, player orderedUnitOwner, real orderX, real orderY, integer priority, integer skill, Unit targetUnit, integer triggerOrder returns string
        local string errorMsg = null
        local unit orderedUnitSelf
        local unit targetUnitSelf
        if (priority == 0) then
            //! runtextmacro AddEventStaticLineSet("errorMsg", "KittyJump", "EVENT_ORDER", "Order2( orderedUnit )")
            if (errorMsg == null) then
                //! runtextmacro AddEventStaticLineSet("errorMsg", "WindBoots", "EVENT_ORDER", "Order( orderedUnit )")
            endif
        endif
        if ( errorMsg == null ) then
            if ( skill != 0 ) then
                set orderedUnitSelf = orderedUnit.self
                set targetUnitSelf = targetUnit.self
                if (priority == 0) then
                    if (false) then
                    endif
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "AcidStrike", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventStaticConditionLine("AdvancedTraining", "EVENT_ORDER", "skill", "SPELL_ID")
                        if (false) then
                        endif
                        //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "AdvancedTraining", "EVENT_ACTIVATION_ORDER", "Activation_Order( orderedUnitOwner, targetUnit )", "triggerOrder", "ACTIVATION_ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "AdvancedTraining", "EVENT_DEACTIVATION_ORDER", "Deactivation_Order( orderedUnitOwner, targetUnit )", "triggerOrder", "DEACTIVATION_ORDER_ID")
                        if (false) then
                        endif
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "AirPassage", "EVENT_ORDER", "Order( orderX, orderY )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "Barrage", "EVENT_ORDER", "Order( orderedUnit, orderX, orderY )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "BondOfSouls", "EVENT_ORDER", "Order( orderedUnit, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventStaticConditionLine("BubbleArmor", "EVENT_ORDER", "skill", "SPELL_ID")
                        if (false) then
                        endif
                        //! runtextmacro AddEventConditionalStaticLine("BubbleArmor", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "triggerOrder", "ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("BubbleArmor_Automatic_Automatic", "EVENT_ACTIVATION_ORDER", "Activation_Order( orderedUnit )", "triggerOrder", "ACTIVATION_ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("BubbleArmor_Automatic_Automatic", "EVENT_DEACTIVATION_ORDER", "Deactivation_Order( orderedUnit )", "triggerOrder", "DEACTIVATION_ORDER_ID")
                        if (false) then
                        endif
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "ChainLightning", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "CripplingWave", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnitSelf )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "DarkCloud", "EVENT_ORDER", "Order( orderedUnit, targetUnitSelf )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "Downgrade", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "EasyPrey", "EVENT_ORDER", "Order( targetUnitSelf )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "EasyPrey", "Arrow_Arrow_EVENT_ORDER", "Arrow_Arrow_Order( targetUnitSelf )", "skill", "ARROW_SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "EmployHenchman", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "Enchant", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "EarlyPromotion", "EVENT_ORDER", "Order( orderedUnitOwner, orderX, orderY )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "EsteemInCoins", "EVENT_ORDER", "Order( orderedUnitOwner )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventStaticConditionLine("Fireball", "EVENT_ORDER", "skill", "SPELL_ID")
                        if (false) then
                        endif
                        //! runtextmacro AddEventConditionalStaticLine("Fireball", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "triggerOrder", "ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("Fireball_Automatic_Automatic", "EVENT_ACTIVATION_ORDER", "Activation_Order( orderedUnit )", "triggerOrder", "ACTIVATION_ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("Fireball_Automatic_Automatic", "EVENT_DEACTIVATION_ORDER", "Deactivation_Order( orderedUnit )", "triggerOrder", "DEACTIVATION_ORDER_ID")
                        if (false) then
                        endif
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "FleshBomb", "EVENT_ORDER", "Order( targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "FrostBolt", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventStaticConditionLine("Fury", "EVENT_ORDER", "skill", "SPELL_ID")
                        if (false) then
                        endif
                        //! runtextmacro AddEventConditionalStaticLine("Fury", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "triggerOrder", "ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("Fury_Automatic_Automatic", "EVENT_ACTIVATION_ORDER", "Activation_Order( orderedUnit )", "triggerOrder", "ACTIVATION_ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("Fury_Automatic_Automatic", "EVENT_DEACTIVATION_ORDER", "Deactivation_Order( orderedUnit )", "triggerOrder", "DEACTIVATION_ORDER_ID")
                        if (false) then
                        endif
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "HammerThrow", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "Heal", "EVENT_ORDER", "Order( targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "IceBall", "EVENT_ORDER", "Order( targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventStaticConditionLine("Inspiration", "EVENT_ORDER", "skill", "SPELL_ID")
                        if (false) then
                        endif
                        //! runtextmacro AddEventConditionalStaticLine("Inspiration", "EVENT_ORDER", "Order( orderedUnit, targetUnit )", "triggerOrder", "ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("Inspiration_Automatic_Automatic", "EVENT_ACTIVATION_ORDER", "Activation_Order( orderedUnit )", "triggerOrder", "ACTIVATION_ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("Inspiration_Automatic_Automatic", "EVENT_DEACTIVATION_ORDER", "Deactivation_Order( orderedUnit )", "triggerOrder", "DEACTIVATION_ORDER_ID")
                        if (false) then
                        endif
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "KidneyShot", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnitSelf )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "KittyJump", "EVENT_ORDER", "Order( GetUnitX(orderedUnitSelf), GetUnitY(orderedUnitSelf), orderX, orderY )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "LifeDrain", "EVENT_ORDER", "Order( targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "LightOfPurge", "EVENT_ORDER", "Order( orderedUnit, orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "MagicalLariat", "EVENT_ORDER", "Order( orderedUnit, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "ManaTheft", "EVENT_ORDER", "Order( targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "MindBreaker", "EVENT_ORDER", "Order( targetUnitSelf )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "NaturalEmbrace", "EVENT_ORDER", "Order( targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "Net", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventStaticConditionLine("RaiseDead", "EVENT_ORDER", "skill", "SPELL_ID")
                        if (false) then
                        endif
                        //! runtextmacro AddEventConditionalStaticLine("RaiseDead", "EVENT_ORDER", "Order( GetUnitX(orderedUnitSelf), GetUnitY(orderedUnitSelf) )", "triggerOrder", "ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("RaiseDead_Automatic_Automatic", "EVENT_ACTIVATION_ORDER", "Activation_Order( orderedUnit )", "triggerOrder", "ACTIVATION_ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("RaiseDead_Automatic_Automatic", "EVENT_DEACTIVATION_ORDER", "Deactivation_Order( orderedUnit )", "triggerOrder", "DEACTIVATION_ORDER_ID")
                        if (false) then
                        endif
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "RefillMana", "EVENT_ORDER", "Order( orderedUnit, orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "RequestReinforcements", "EVENT_ORDER", "Order( orderedUnit, orderedUnitOwner, orderX, orderY )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "Resurrection", "EVENT_ORDER", "Order( orderedUnitSelf, orderedUnitOwner, GetUnitX(orderedUnitSelf), GetUnitY(orderedUnitSelf) )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "Rust", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "SilverSpores", "EVENT_ORDER", "Order( orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "SpellDisconnection", "EVENT_ORDER", "Order( orderedUnit, orderedUnitOwner, targetUnit )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventConditionalStaticLineSet("errorMsg", "SummonInfernal", "EVENT_ORDER", "Order( orderX, orderY )", "skill", "SPELL_ID")
                    //! runtextmacro AddEventStaticConditionLine("VioletDefense", "EVENT_ORDER", "skill", "SPELL_ID")
                        if (false) then
                        endif
                        //! runtextmacro AddEventConditionalStaticLine("VioletDefense", "EVENT_ORDER", "Order( orderedUnit, targetUnit )", "triggerOrder", "ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("VioletDefense_Automatic_Automatic", "EVENT_ACTIVATION_ORDER", "Activation_Order( orderedUnitOwner, targetUnit )", "triggerOrder", "ACTIVATION_ORDER_ID")
                        //! runtextmacro AddEventConditionalStaticLine("VioletDefense_Automatic_Automatic", "EVENT_DEACTIVATION_ORDER", "Deactivation_Order( orderedUnitOwner, targetUnit )", "triggerOrder", "DEACTIVATION_ORDER_ID")
                        if (false) then
                        endif
                    endif
                if (false) then
                endif
                set orderedUnitSelf = null
                set targetUnitSelf = null
            endif
        endif
        return errorMsg
    endfunction

    public function TriggerEvents takes integer abilityOrderId, Unit orderedUnit, player orderedUnitOwner, real orderX, real orderY, integer skill, Unit targetUnit, integer triggerOrder returns string
        local string errorMsg = null
        local integer iteration = 0

        loop
            //! runtextmacro StringSetIf("errorMsg", "TriggerEvents_Dynamic(abilityOrderId, orderedUnit, orderX, orderY, iteration, skill, targetUnit, triggerOrder)", "errorMsg == null")
            //! runtextmacro StringSetIf("errorMsg", "TriggerEvents_Static(orderedUnit, orderedUnitOwner, orderX, orderY, iteration, skill, targetUnit, triggerOrder)", "errorMsg == null")
            set iteration = iteration + 1
            exitwhen (iteration > 0)
        endloop

        return errorMsg
    endfunction

    private function Trig_BuyConditions takes integer someObjectId returns boolean
        if (IsItemType( someObjectId ) == false) then
            return false
        endif
        if (IsUnitTypeWJ( someObjectId ) == false) then
            return false
        endif
        if (IsResearchType( someObjectId ) == false) then
            return false
        endif
        return true
    endfunction

    private function Trig takes nothing returns nothing
        local integer abilityOrderId
        local string errorMsg
        local integer goldCost
        local real manaCost
        local Unit orderedUnit
        local unit orderedUnitSelf
        local player orderedUnitOwner
        local real orderX
        local real orderY
        local integer skill
        local Unit targetUnit
        local integer triggerOrder
        if ( IGNORE_NEXT ) then
            set IGNORE_NEXT = false
        else
            set errorMsg = null
            set orderedUnitSelf = GetOrderedUnit()
            set orderedUnit = GetUnit(orderedUnitSelf)
            set orderedUnitOwner = orderedUnit.owner
            set triggerOrder = GetIssuedOrderId()
            if ( Trig_BuyConditions( triggerOrder ) ) then
                set goldCost = GetPlayerGoldCost(GetObjectGoldCost(orderedUnitOwner, triggerOrder), orderedUnitOwner)
                if ( goldCost > 0 ) then
                    if ( GetPlayerState( orderedUnitOwner, PLAYER_STATE_RESOURCE_GOLD ) < goldCost ) then
                        set errorMsg = ErrorStrings_TOO_LESS_GOLD
//                    set PlayerChangesLumberAmount_IGNORE_NEXT = true
                    endif
                endif
            else
                set goldCost = 0
                set orderX = GetOrderPointX()
                set orderY = GetOrderPointY()
                set targetUnit = GetUnit(GetOrderTargetUnit())
                set skill = GetUnitAbilityFromOrder( orderedUnitSelf, triggerOrder )
                set abilityOrderId = GetAbilityOrderId( skill, triggerOrder )

                set errorMsg = TriggerEvents(abilityOrderId, orderedUnit, orderedUnitOwner, orderX, orderY, skill, targetUnit, triggerOrder)
            endif

            if ( errorMsg == null ) then
                call Executed_Executed_Start(abilityOrderId, goldCost, orderedUnit, orderedUnitOwner, orderX, orderY, skill, targetUnit, triggerOrder)
            else
                call StopUnit( orderedUnit )
                if ( IsUnitSelected( orderedUnitSelf, orderedUnitOwner ) ) then
                    call Error( orderedUnitOwner, errorMsg )
                endif
            endif
            set orderedUnitOwner = null
            set orderedUnitSelf = null
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitGetsOrder.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsActivated.j
//TESH.scrollpos=9
//TESH.alwaysfold=0
scope UnitIsActivated
    globals
        private trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Dynamic takes integer priority, Unit triggerUnit, integer triggerUnitTeam returns nothing
        local integer triggerUnitId = triggerUnit.id
        local string triggerUnitTeamString = GetTeamString(triggerUnitTeam)
        local integer iteration = CountSavedEvents( triggerUnitTeamString, UnitIsActivated_EVENT_STRING_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetSavedEvents( triggerUnitTeamString, UnitIsActivated_EVENT_STRING_KEY, priority, iteration ) )
            set iteration = iteration - 1
        endloop
        set iteration = CountEventsById( triggerUnit, UnitIsActivated_EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetEventsById( triggerUnit, UnitIsActivated_EVENT_KEY, priority, iteration ) )
            set iteration = iteration - 1
        endloop
    endfunction

    private function TriggerEvents_Static takes integer priority, Unit triggerUnit, integer triggerUnitTeam returns nothing
        if (priority == 0) then
            //! runtextmacro AddEventStaticLine("DivineShield", "EVENT_ACTIVATE", "Activate( triggerUnit, triggerUnitTeam )")
            //! runtextmacro AddEventStaticLine("Grass", "EVENT_ACTIVATE", "Activate( triggerUnit )")
            //! runtextmacro AddEventStaticLine("Marble", "EVENT_ACTIVATE", "Activate( triggerUnit )")
        endif
    endfunction

    private function TriggerEvents takes Unit triggerUnit, integer triggerUnitTeam returns nothing
        local integer iteration = 0

        loop
            call TriggerEvents_Dynamic(iteration, triggerUnit, triggerUnitTeam)
            call TriggerEvents_Static(iteration, triggerUnit, triggerUnitTeam)
            set iteration = iteration + 1
            exitwhen (iteration > 0)
        endloop
    endfunction

    public function Start takes Unit triggerUnit returns nothing
        call TriggerEvents(triggerUnit, GetPlayerTeam(triggerUnit.owner))
    endfunction

    private function Trig takes nothing returns nothing
        local Unit triggerUnit = TRIGGER_UNIT

        call Start(triggerUnit)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsActivated.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsAttacked.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitIsAttacked
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Unit attacker, Unit triggerUnit returns nothing
        local unit triggerUnitSelf = triggerUnit.self
        call ReleaseUnitShredder_Attack( attacker, triggerUnit )
        call SilverSpores_Attack( attacker )
        call Whirlwind_Attack( attacker, triggerUnitSelf )
        set triggerUnitSelf = null
    endfunction

    private function Trig takes nothing returns nothing
        local Unit attacker = GetUnit(GetAttacker())
        local Unit triggerUnit = GetUnit(GetTriggerUnit())

        call TriggerEvents_Static(attacker, triggerUnit)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsAttacked.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsBeforeDying.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitIsBeforeDying
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Static takes Unit dyingUnit, Unit killingUnit returns nothing
        call Barrage_Explosion_Explosion_BeforeDying( killingUnit, dyingUnit )
        call FleshBomb_BeforeDying( dyingUnit )
        if (Reincarnation_BeforeDying( dyingUnit )) then
            call UnitDies_BeforeDying(dyingUnit, killingUnit)
        endif
    endfunction

    private function Trig takes nothing returns nothing
        local Unit dyingUnit = GetUnit(GetTriggerUnit())
        local Unit killingUnit = TRIGGER_UNIT
        if ( IsUnitDead(dyingUnit) == false ) then
            call TriggerEvents_Static(dyingUnit, killingUnit)
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsBeforeDying.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsDispelled.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitIsDispelled
    globals
        public trigger DUMMY_TRIGGER
        private constant string TRIGGER_UNIT_EFFECT_PATH = "Abilities\\Spells\\Human\\DispelMagic\\DispelMagicTarget.mdl"
        private constant string TRIGGER_UNIT_EFFECT_ATTACHMENT_POINT = "origin"

        public boolean NEGATIVE_BUFFS
        public boolean POSITIVE_BUFFS
        public boolean SHOW_GRAPHICS
    endglobals

    private function TriggerEvents_Dynamic takes boolean negativeBuffs, boolean positiveBuffs, integer priority, Unit triggerUnit returns nothing
        local integer iteration
        local integer triggerUnitId = triggerUnit.id
        if ( negativeBuffs ) then
            set iteration = CountEventsById(triggerUnitId, UnitIsDispelled_EVENT_KEY_NEGATIVE, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set TRIGGER_UNIT = triggerUnit
                call RunTrigger( GetEventsById(triggerUnitId, UnitIsDispelled_EVENT_KEY_NEGATIVE, priority, iteration ) )
                set iteration = iteration - 1
            endloop
        endif
        if ( positiveBuffs ) then
            set iteration = CountEventsById(triggerUnitId, UnitIsDispelled_EVENT_KEY_POSITIVE, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set TRIGGER_UNIT = triggerUnit
                call RunTrigger( GetEventsById( triggerUnitId, UnitIsDispelled_EVENT_KEY_POSITIVE, priority, iteration ) )
                set iteration = iteration - 1
            endloop
        endif
    endfunction

    private function TriggerEvents_Static takes boolean negativeBuffs, boolean positiveBuffs, integer priority, Unit triggerUnit returns nothing
        if ( negativeBuffs ) then
            if (priority == 0) then
                //! runtextmacro AddEventStaticLine("AdvertisingGift_Target_Target", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("CurseOfTheBloodline", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("DarkCloud", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Disarm", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("DreadCall", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("EasyPrey", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("IceBall_Buff_Buff", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("NaturalEmbrace", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Rust", "EVENT_DISPEL", "Dispel( triggerUnit )")
            endif
        endif
        if ( positiveBuffs ) then
            if (priority == 0) then
                //! runtextmacro AddEventStaticLine("Berserk", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("BubbleArmor", "EVENT_DISPEL", "Dispel( triggerUnit )")
                ////! runtextmacro AddEventStaticLine("Enchant", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("FeelingOfSecurity", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("FleshBomb", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Frenzy", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Fury", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("GhoulFrenzy", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("HealingPotionBloodOrange", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Inspiration", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("PotionOfTheInconspicuousShape", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("ScrollOfRage", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("SilverSpores", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("Stability", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("ThermalFissure_Target_Target", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("VioletDefense", "EVENT_DISPEL", "Dispel( triggerUnit )")
                ////! runtextmacro AddEventStaticLine("VividStrikes", "EVENT_DISPEL", "Dispel( triggerUnit )")
                //! runtextmacro AddEventStaticLine("WhipLash", "EVENT_DISPEL", "Dispel( triggerUnit )")
            endif
        endif
    endfunction

    private function TriggerEvents takes boolean negativeBuffs, boolean positiveBuffs, Unit triggerUnit returns nothing
        local integer iteration = 0

        loop
            call TriggerEvents_Dynamic(negativeBuffs, positiveBuffs, iteration, triggerUnit)
            call TriggerEvents_Static(negativeBuffs, positiveBuffs, iteration, triggerUnit)
            set iteration = iteration + 1
            exitwhen (iteration>  0)
        endloop
    endfunction

    private function Trig takes nothing returns nothing
        local boolean negativeBuffs = NEGATIVE_BUFFS
        local boolean positiveBuffs = POSITIVE_BUFFS
        local boolean showGraphics = SHOW_GRAPHICS
        local Unit triggerUnit = TRIGGER_UNIT
        if (showGraphics) then
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( TRIGGER_UNIT_EFFECT_PATH, triggerUnit.self, TRIGGER_UNIT_EFFECT_ATTACHMENT_POINT ) )
        endif

        call TriggerEvents(negativeBuffs, positiveBuffs, triggerUnit)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsDispelled.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsMoveChecked.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitIsMoveChecked
    globals
        public trigger DUMMY_TRIGGER

        public real X
        public real Y
        public real Z
    endglobals

    private function TriggerEvents_Static takes Unit triggerUnit, real x, real y, real z returns nothing
        call KittyJump_MoveCheck( triggerUnit, x, y, z )
    endfunction

    private function Trig takes nothing returns nothing
        local Unit triggerUnit = TRIGGER_UNIT
        local real x = X
        local real y = Y
        local real z = Z
        call TriggerEvents_Static(triggerUnit, x, y, z)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsMoveChecked.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsRevaluated.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitIsRevaluated
    globals
        public trigger DUMMY_TRIGGER

        public integer LEVEL
        public integer OLD_LEVEL
    endglobals

    private function TriggerEvents_Static takes Unit triggerUnit, integer level returns nothing
        call UnitRevaluation_Revaluate( triggerUnit, level )
    endfunction

    private function Trig takes nothing returns nothing
        local integer level = LEVEL
        local integer oldLevel = OLD_LEVEL
        local Unit triggerUnit = TRIGGER_UNIT

        call TriggerEvents_Static(triggerUnit, level)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitIsRevaluated.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitLearnsSkill.j
//TESH.scrollpos=62
//TESH.alwaysfold=0
scope UnitLearnsSkill
    globals
        public trigger DUMMY_TRIGGER

        Unit LEARNER
        integer SKILL
    endglobals

    private function TriggerEvents_Dynamic takes Unit learner, integer priority, integer skill returns nothing
        local integer iteration = CountEventsById( skill, UnitLearnsSkill_EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set LEARNER = learner
            set SKILL = skill
            call RunTrigger( GetEventsById( skill, UnitLearnsSkill_EVENT_KEY, priority, iteration ) )
            set iteration = iteration - 1
        endloop
    endfunction

    public function TriggerEvents_Static takes Unit learner, player learnerOwner, UnitType learnerType, integer priority, integer skill returns nothing
        if (priority == 0) then
            if (false) then
            //! runtextmacro AddEventConditionalStaticLine("AdvancedTraining", "EVENT_LEARN", "Learn( learner, learnerType )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("AttackDerivation", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("AxeMaster", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Bash_OgreBrat_OgreBrat", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Bash_Zombie_Zombie", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("BloodyClaws", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Cannibalism", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ChillyPresence", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CourageAndHonor", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CriticalStrike_Myrmidon_Myrmidon", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CriticalStrike_TerrorWolf_TerrorWolf", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Disarm", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("DivineArmor", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("EasyPrey", "Arrow_Arrow_EVENT_LEARN", "Arrow_Arrow_Learn( learner )", "skill", "ARROW_SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("EnergyGap_Aura_Aura", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("EnergyGap_Heal_Heal", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Evasion", "EVENT_LEARN", "Learn( learner, skill )", "skill", "BERSERKER_SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Evasion", "EVENT_LEARN", "Learn( learner, skill )", "skill", "RAIDER_SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Evasion", "EVENT_LEARN", "Learn( learner, skill )", "skill", "SILVER_TAIL_SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Feedback", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Fertilizer", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FreeRoad", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FuneralFeast", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("GhoulFrenzy", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Immolation", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Invulnerability", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LayEgg", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Libertine", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LifeRegenerationAura", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LifeRegenerationAuraNeutral", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("MagicalSuperiority", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ManaRegenerationAura", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ManaRegenerationAuraNeutral", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("MightAura", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("MysticalAttack", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Neutralization", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Pulverize", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Riposte", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Sales", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SlowPoison", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("StrongArm", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SuddenFrost", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SummonFaust_AttackGraphic_AttackGraphic", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("UnholyArmor", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("UtilizationOfRests", "EVENT_LEARN", "Learn( learner )", "skill", "SPELL_ID")
            endif
        endif
    endfunction

    public function TriggerEvents takes Unit learner, player learnerOwner, UnitType learnerType, integer skill returns nothing
        local integer iteration = 0

        loop
            call TriggerEvents_Dynamic(learner, iteration, skill)
            call TriggerEvents_Static(learner, learnerOwner, learnerType, iteration, skill)
            set iteration = iteration + 1
            exitwhen (iteration > 0)
        endloop
    endfunction

    private function Trig takes nothing returns nothing
        local Unit learner = GetUnit(GetLearningUnit())
        local player learnerOwner = learner.owner
        local UnitType learnerType = learner.type
        local integer skill = GetLearnedSkill()
        local integer skillLevel = GetLearnedSkillLevel()

        call TriggerEvents( learner, learnerOwner, learnerType, skill )

        set learnerOwner = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitLearnsSkill.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitPawnsItem.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitPawnsItem
    globals
        public trigger DUMMY_TRIGGER
        private constant real GOLD_RESTORATION_FACTOR = 0.5
    endglobals

    private function Trig takes nothing returns nothing
        local unit sellingUnitSelf = GetSellingUnit()
        local Unit sellingUnit = GetUnit(sellingUnitSelf)
        local player sellingUnitOwner = sellingUnit.owner
        local real sellingUnitX = GetUnitX( sellingUnitSelf )
        local real sellingUnitY = GetUnitY( sellingUnitSelf )
        local real sellingUnitZ = GetUnitZ( sellingUnitSelf, sellingUnitX, sellingUnitY ) + GetUnitImpactZ(sellingUnit)
        local Item soldItem = GetItem(GetSoldItem())
        local integer goldToReturn = R2I( GetItemGoldCost( soldItem ) * GOLD_RESTORATION_FACTOR )
        local texttag goldToReturnTextTag = CreateRisingTextTag( "+" + I2S( goldToReturn ), 0.024, sellingUnitX, sellingUnitY, sellingUnitZ, 80, 255, 204, 0, 255, 0, 3 )
        call AddPlayerState( sellingUnitOwner, PLAYER_STATE_RESOURCE_GOLD, goldToReturn )
        if ( goldToReturnTextTag != null ) then
            call LimitTextTagVisibilityToPlayer( goldToReturnTextTag, sellingUnitOwner )
            set goldToReturnTextTag = null
        endif
        set PlayerChangesLumberAmount_IGNORE_NEXT = true
        set sellingUnitOwner = null
        set sellingUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitPawnsItem.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitSellsItem.j
//TESH.scrollpos=33
//TESH.alwaysfold=0
scope UnitSellsItem
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    scope Executed
        private function Executed_TriggerEvents takes Unit shop, player buyingUnitOwner, Item soldItem, ItemType soldItemType returns nothing
            local integer soldItemTypeId = soldItemType.id
            if (soldItemTypeId != ShopInformation_ITEM_ID) then
                call Infoboard_Additionboard_Additionboard_SellItemExecute(buyingUnitOwner, soldItem.self)
            endif
            if (soldItemTypeId == ShopInformation_ITEM_ID) then
                call ShopInformation_SellItemExecute(shop, soldItem, buyingUnitOwner)
            endif
        endfunction

        public function Executed_Start takes Unit shop, player buyingUnitOwner, Item soldItem, ItemType soldItemType returns nothing
            call Executed_TriggerEvents(shop, buyingUnitOwner, soldItem, soldItemType)
        endfunction
    endscope

    private function Trig takes nothing returns nothing
        local unit buyingUnitSelf = GetBuyingUnit()
        local Unit buyingUnit = GetUnit(buyingUnitSelf)
        local player buyingUnitOwner = buyingUnit.owner
        local string errorMsg = null
        local integer lumberCost = 0
        local Item soldItem
        local item soldItemSelf = GetSoldItem()
        local ItemType soldItemType = GetItemTypeWJ(GetItemTypeId(soldItemSelf))
        local integer goldCost = GetPlayerGoldCost(GetItemTypeGoldCost( soldItemType ), buyingUnitOwner)
        local Unit shop = GetUnit(GetSellingUnit())
        local player shopOwner = shop.owner
        local UnitType shopType = shop.type
        local integer specificItemTypeId
        local boolean success
        if ( GetPlayerState( buyingUnitOwner, PLAYER_STATE_RESOURCE_GOLD ) < goldCost ) then
            set errorMsg = ErrorStrings_TOO_LESS_GOLD
        else
            if ( GetPlayerRaceWJ(buyingUnitOwner) == NULL ) then
                set errorMsg = ErrorStrings_NEEDS_RACE
            elseif ( IsUnitEnemy( buyingUnitSelf, shopOwner ) ) then
                set errorMsg = ErrorStrings_SHOP_BELONGS_TO_ENEMY
            endif
        endif
        set success = (errorMsg == null)
        if ( success ) then
            call AddPlayerState( buyingUnitOwner, PLAYER_STATE_RESOURCE_GOLD, -goldCost )
            set soldItem = InitItemEx( soldItemSelf )
            call SetItemGoldCost(soldItem, goldCost)

            call Executed_Executed_Start(shop, buyingUnitOwner, soldItem, soldItemType)
        else
            set UnitAcquiresItem_REMOVE_NEXT = true
            call Error( buyingUnitOwner, errorMsg )
        endif

        call Shop_ItemSupply_Refresh_Refresh_ItemSell(shop, soldItemType, success)

        set buyingUnitOwner = null
        set buyingUnitSelf = null
        set shopOwner = null
        set soldItemSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitSellsItem.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitSellsUnit.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitSellsUnit
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    scope Executed
        private function Executed_TriggerEvents_Static takes Unit shop, Unit soldUnit, player soldUnitOwner, unit soldUnitSelf, UnitType soldUnitType returns nothing
            local integer soldUnitTypeId = soldUnitType.id
            if (soldUnitTypeId != ShopInformation_UNIT_ID) then
                call Infoboard_Additionboard_Additionboard_SellUnitExecute(soldUnitOwner)
            endif
            if (soldUnitTypeId == UNIT_SHREDDER_RELEASED_UNIT_ID) then
                call ReleaseUnitShredder_SellUnitExecute( soldUnitOwner, shop, soldUnitSelf )
            elseif (soldUnitTypeId == ShopInformation_UNIT_ID) then
                call ShopInformation_SellUnitExecute( shop, soldUnitSelf, soldUnitOwner )
            elseif (soldUnitTypeId == RESERVE_UNIT_ID) then
                call Reserve_SellUnitExecute( soldUnit, soldUnitType )
            endif
        endfunction

        public function Executed_Start takes integer goldCost, Unit shop, Unit soldUnit, player soldUnitOwner, unit soldUnitSelf, UnitType soldUnitType returns nothing
            call AddPlayerState( soldUnitOwner, PLAYER_STATE_RESOURCE_GOLD, -goldCost )

            call Executed_TriggerEvents_Static(shop, soldUnit, soldUnitOwner, soldUnitSelf, soldUnitType)
        endfunction
    endscope

    private function TriggerEvents_Static takes player soldUnitOwner, UnitType soldUnitType returns string
        local string errorMsg = null
        local integer soldUnitTypeId = soldUnitType.id
        if (soldUnitTypeId == WORKER_UNIT_ID) then
            set errorMsg = Worker_SellUnit( soldUnitOwner )
        endif
        return errorMsg
    endfunction

    private function Trig takes nothing returns nothing
        local unit buyingUnit = GetBuyingUnit()
        local string errorMsg = null
        local unit shopSelf = GetSellingUnit()
        local Unit shop = GetUnit(shopSelf)
        local player shopOwner = shop.owner
        local Unit soldUnit
        local unit soldUnitSelf = GetSoldUnit()
        local player soldUnitOwner = GetOwningPlayer(soldUnitSelf)
        local integer soldUnitType = GetUnitType(GetUnitTypeId(soldUnitSelf))
        local integer goldCost = GetPlayerGoldCost(GetUnitTypeGoldCost( soldUnitType ), soldUnitOwner)
        local boolean success
        local integer supplyUsed
        if ( GetPlayerState( soldUnitOwner, PLAYER_STATE_RESOURCE_GOLD ) < goldCost ) then
            set errorMsg = ErrorStrings_TOO_LESS_GOLD
        else
            set supplyUsed = GetUnitTypeSupplyUsed( soldUnitType )
            if ( GetPlayerRaceWJ(soldUnitOwner) == NULL ) then
                set errorMsg = ErrorStrings_NEEDS_RACE
            elseif ( IsUnitEnemy( soldUnitSelf, shopOwner ) ) then
                set errorMsg = ErrorStrings_SHOP_BELONGS_TO_ENEMY
            endif
        endif
        if (errorMsg == null) then
            set errorMsg = TriggerEvents_Static(soldUnitOwner, soldUnitType)
        endif
        set success = (errorMsg == null)
        if ( success ) then
            if (IsUnitTypeCanNotBeInited(soldUnitType)) then
                set soldUnit = NULL
            else
                set soldUnit = InitUnitEx( soldUnitSelf )
            endif

            call Executed_Executed_Start(goldCost, shop, soldUnit, soldUnitOwner, soldUnitSelf, soldUnitType)
        else
            call RemoveUnitWJ( soldUnitSelf )
            call Error( soldUnitOwner, errorMsg )
        endif
        call Shop_UnitSupply_Refresh_Refresh_UnitSell(shop, soldUnitType, success)

        set buyingUnit = null
        set shopOwner = null
        set shopSelf = null
        set soldUnitOwner = null
        set soldUnitSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitSellsUnit.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitStartsEffectOfAbility.j
//TESH.scrollpos=137
//TESH.alwaysfold=0
scope UnitStartsEffectOfAbility
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents_Dynamic takes Unit caster, integer priority, integer skill, Unit targetUnit, real targetX, real targetY returns nothing
        local integer iteration = CountEventsById( skill, UnitStartsEffectOfAbility_EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set CASTER = caster
            set TARGET_UNIT = targetUnit
            set TARGET_X = targetX
            set TARGET_Y = targetY
            call RunTrigger( GetEventsById( skill, UnitStartsEffectOfAbility_EVENT_KEY, priority, iteration ) )
            set iteration = iteration - 1
        endloop
    endfunction

    private function TriggerEvents_Static takes Unit caster, real casterX, real casterY, real casterZ, integer priority, integer skill, Unit targetUnit, real targetX, real targetY returns nothing
        if (priority == 0) then
            if (false) then
            endif
            //! runtextmacro AddEventConditionalStaticLine("AcidStrike", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("AdvertisingGift", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Barrage", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Berserk", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("BondOfSouls", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("BubbleArmor", "EVENT_CAST", "SpellEffect( targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Burrow", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CamouflageSuit", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CareBear", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CashDiscount", "EVENT_CAST", "SpellEffect( caster.owner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ChainLightning", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ChimeraEgg", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ChooseHero", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ChooseRandomHero", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ChooseRandomHeroFromSelection", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CripplingWave", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CrowdPuller", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CurseOfTheBloodline", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("DarkCloud", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("DiversionaryTactics", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("DivineShield", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Downgrade", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("EarlyPromotion", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("EasyPrey", "EVENT_CAST", "SpellEffect( GetUnitAbilityLevel( caster.self, EasyPrey_SPELL_ID ), caster, EasyPrey_SPELL_ID, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ElectroNet", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ElixirOfTheGrowth", "EVENT_CAST", "SpellEffect( caster, casterX, casterY, casterZ )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Enchant", "EVENT_CAST", "SpellEffect( target )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ExperimentalElixir", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FeelingOfSecurity", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FeelingOfSecurity", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "UPGRADED_SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Fireball", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FireBurst", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FleshBomb", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FlyingSheep", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Frenzy", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FrostBolt", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("FrostNova", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Fury", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("GhostTakeOver", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("HammerThrow", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Harmagedon", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Harmagedon2", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Heal", "EVENT_CAST", "SpellEffect( targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("HealingPotion", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("HealingPotionBloodOrange", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("HealingWard", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("HeartOfTheHards", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("HindranceOfLearning", "EVENT_CAST", "SpellEffect( caster.owner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Hurricane", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("IceBall", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("IllusionaryStaff", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Inspiration", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Kataikaze", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("KidneyShot", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("KittyJump", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LastGrave", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Lens", "EVENT_CAST", "SpellEffect( targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LifeDrain", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LightOfPurge", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("LittleThunderstorm", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("MagicalLariat", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ManaTheft", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("MecaPenguin", "EVENT_CAST", "SpellEffect( caster, targetXm targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Meditation", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Metamorphosis", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("MightyHammer", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("MindBreaker", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("NaturalEmbrace", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Net", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Nethermask_Use_Use", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("NextHero", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Payday", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("PoisonFountain", "EVENT_CAST", "SpellEffect( caster.owner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("PotionOfTheInconspicuousShape", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("PreviousHero", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("RaiseDead", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("RefillMana", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("RegenerationPotion", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("RequestReinforcements", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Resurrection", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Rust", "EVENT_CAST", "SpellEffect( targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ScrollOfRage", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SelfHeal", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ShiftInventory", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ShiftInventory_Off_Off", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ShockWave", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SilverSpores", "EVENT_CAST", "SpellEffect( targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Slam", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SpellDisconnection", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SpiderEgg", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("StaffOfAbolition", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Stability", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Suicide", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SummonFaust", "EVENT_CAST", "SpellEffect( caster.owner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SummonInfernal", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SummonPeq", "EVENT_CAST", "SpellEffect( caster.owner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SummonPeqqiBeast", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("SwitchShops", "EVENT_CAST", "SpellEffect( caster.owner )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ThermalFissure", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("ToadReflection", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("Trap", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("VioletDefense", "EVENT_CAST", "SpellEffect( caster, targetUnit )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("VividStrikes", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("VolatileManaPotion", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("WhipLash", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("WindBoots", "EVENT_CAST", "SpellEffect( caster, targetX, targetY )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CamouflageSuit", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            //! runtextmacro AddEventConditionalStaticLine("CamouflageSuit", "EVENT_CAST", "SpellEffect( caster )", "skill", "SPELL_ID")
            if (false) then
            endif

            //! runtextmacro AddEventStaticLine("SoulVessel", "EVENT_CAST", "SpellEffect( caster )")
        endif
    endfunction

    private function TriggerEvents takes Unit caster, real casterX, real casterY, real casterZ, integer skill, Unit targetUnit, real targetX, real targetY returns nothing
        local integer iteration = 0

        loop
            call TriggerEvents_Dynamic(caster, iteration, skill, targetUnit, targetX, targetY)
            call TriggerEvents_Static(caster, casterX, casterY, casterZ, iteration, skill, targetUnit, targetX, targetY)
            set iteration = iteration + 1
            exitwhen (iteration > 0)
        endloop
    endfunction

    private function Trig takes nothing returns nothing
        local unit casterSelf = GetSpellAbilityUnit()
        local Unit caster = GetUnit(casterSelf)
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster)
        local boolean isCasterHero = IsUnitType( casterSelf, UNIT_TYPE_HERO )
        local integer skill = GetSpellAbilityId()
        local Unit targetUnit = GetUnit(GetSpellTargetUnit())
        local location targetLocation = GetSpellTargetLocWJ()
        local real targetX
        local real targetY
        if ( targetLocation != null ) then
            set targetX = GetLocationX( targetLocation )
            set targetY = GetLocationY( targetLocation )
            call RemoveLocationWJ( targetLocation )
            set targetLocation = null
        else
            set targetX = 0
            set targetY = 0
        endif

        call TriggerEvents(caster, casterX, casterY, casterZ, skill, targetUnit, targetX, targetY)

        if ( targetUnit != null ) then
            if ( IsUnitAlly( casterSelf, targetUnit.owner ) == false ) then
                set UnitTakesDamage_NEXT_DAMAGE_IS_SPELL = true
            endif
        endif
        set casterSelf = null
        if ( isCasterHero and (skill != ShiftInventory_SPELL_ID) and (skill != ShiftInventory_Off_Off_SPELL_ID) ) then
            call CreateRisingTextTag( GetObjectName( skill ), 0.023, casterX, casterY, casterZ, 80, 255, 0, 255, 255, 1, 4 )
        endif
        set TARGET_X = targetX
        set TARGET_Y = targetY
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitStartsEffectOfAbility.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitTakesAnyDamage.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope UnitTakesAnyDamage
    globals
        public trigger DUMMY_TRIGGER
    endglobals

    private function TriggerEvents takes real damageAmount, Unit damageSource, Unit triggerUnit returns nothing
        set damageAmount = Lens_Target_Target_AnyDamage(damageAmount, damageSource, triggerUnit)

        set DAMAGE_AMOUNT = damageAmount
    endfunction

    private function Trig takes nothing returns nothing
        local real damageAmount = DAMAGE_AMOUNT
        local Unit damageSource = DAMAGE_SOURCE
        local Unit triggerUnit = TRIGGER_UNIT

        call TriggerEvents(damageAmount, damageSource, triggerUnit)
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitTakesAnyDamage.j

//file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitTakesDamage.j
//TESH.scrollpos=6
//TESH.alwaysfold=0
scope UnitTakesDamage
    globals
        private constant real ARMOR_REDUCTION_FACTOR = 0.04
        public trigger DUMMY_TRIGGER
        private group ENUM_GROUP
        private constant integer SPECIAL_ATTACK_SPELL_ID = 'A040'
        private boolexpr SPLASH_TARGET_CONDITIONS

        public boolean NEXT_DAMAGE_IS_SPELL = false

        real DAMAGE_AMOUNT = 0
        boolean DAMAGE_BLOCKED
        integer DAMAGE_BLOCKED_AMOUNT = 0
        Unit DAMAGE_SOURCE
        real UNBLOCKABLE_DAMAGE_AMOUNT = 0
    endglobals

    private function TriggerEvents_Dynamic takes integer blocked, real damageAmount, Unit damageSource, boolean isPrimaryTarget, integer priority, Unit triggerUnit, real unblockableDamageAmount returns nothing
        local integer damageSourceId = damageSource.id
        local integer triggerUnitId = triggerUnit.id
        local integer iteration = CountEventsById( triggerUnitId, UnitTakesDamage_EVENT_KEY_FOR_BLOCKING, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set DAMAGE_AMOUNT = damageAmount
            set DAMAGE_SOURCE = damageSource
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetEventsById( triggerUnitId, UnitTakesDamage_EVENT_KEY_FOR_BLOCKING, priority, iteration ) )
            set blocked = blocked + B2I(DAMAGE_BLOCKED)
            set iteration = iteration - 1
        endloop

        ////////// Primary

        if ( isPrimaryTarget ) then
            set iteration = CountEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set DAMAGE_AMOUNT = damageAmount
                set DAMAGE_SOURCE = damageSource
                set TRIGGER_UNIT = triggerUnit
                call RunTrigger( GetEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE, priority, iteration ) )
                set iteration = iteration - 1
            endloop
            set iteration = CountEventsById( triggerUnitId, UnitTakesDamage_EVENT_KEY_PRIMARY, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set DAMAGE_AMOUNT = damageAmount
                set DAMAGE_SOURCE = damageSource
                set TRIGGER_UNIT = triggerUnit
                call RunTrigger( GetEventsById( triggerUnitId, UnitTakesDamage_EVENT_KEY_PRIMARY, priority, iteration ) )
                set iteration = iteration - 1
            endloop
            set iteration = CountEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_DAMAGE_AS_DAMAGE_SOURCE, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set DAMAGE_AMOUNT = damageAmount
                set DAMAGE_SOURCE = damageSource
                set TRIGGER_UNIT = triggerUnit
                call RunTrigger( GetEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_DAMAGE_AS_DAMAGE_SOURCE, priority, iteration ) )
                set damageAmount = DAMAGE_AMOUNT
                set iteration = iteration - 1
            endloop
            set iteration = CountEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_UNBLOCKABLE_AS_DAMAGE_SOURCE, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set DAMAGE_AMOUNT = unblockableDamageAmount
                set DAMAGE_SOURCE = damageSource
                set TRIGGER_UNIT = triggerUnit
                call RunTrigger( GetEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_UNBLOCKABLE_AS_DAMAGE_SOURCE, priority, iteration ) )
                set unblockableDamageAmount = DAMAGE_AMOUNT
                set iteration = iteration - 1
            endloop
            set iteration = CountEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_PRIMARY_UNBLOCKED_AS_DAMAGE_SOURCE, priority )
            loop
                exitwhen ( iteration < TABLE_STARTED )
                set DAMAGE_AMOUNT = damageAmount
                set DAMAGE_SOURCE = damageSource
                set TRIGGER_UNIT = triggerUnit
                call RunTrigger( GetEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_PRIMARY_UNBLOCKED_AS_DAMAGE_SOURCE, priority, iteration ) )
                set iteration = iteration - 1
            endloop
        endif

        ////////// Primary End

        set iteration = CountEventsById( triggerUnitId, UnitTakesDamage_EVENT_KEY_FOR_DAMAGE, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set DAMAGE_AMOUNT = damageAmount
            set DAMAGE_SOURCE = damageSource
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetEventsById( triggerUnitId, UnitTakesDamage_EVENT_KEY_FOR_DAMAGE, priority, iteration ) )
            set damageAmount = DAMAGE_AMOUNT
            set iteration = iteration - 1
        endloop
        set iteration = CountEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_FOR_DAMAGE_AS_DAMAGE_SOURCE, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set DAMAGE_AMOUNT = damageAmount
            set DAMAGE_SOURCE = damageSource
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_FOR_DAMAGE_AS_DAMAGE_SOURCE, priority, iteration ) )
            set damageAmount = DAMAGE_AMOUNT
            set iteration = iteration - 1
        endloop
        set iteration = CountEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_AS_DAMAGE_SOURCE, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set DAMAGE_SOURCE = damageSource
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_AS_DAMAGE_SOURCE, priority, iteration ) )
            set iteration = iteration - 1
        endloop
        set iteration = CountEventsById( triggerUnitId, UnitTakesDamage_EVENT_KEY, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set DAMAGE_SOURCE = damageSource
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetEventsById( triggerUnitId, UnitTakesDamage_EVENT_KEY, priority, iteration ) )
            set iteration = iteration - 1
        endloop
        set iteration = CountEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_UNBLOCKED_AS_DAMAGE_SOURCE, priority )
        loop
            exitwhen ( iteration < TABLE_STARTED )
            set DAMAGE_AMOUNT = damageAmount
            set DAMAGE_SOURCE = damageSource
            set TRIGGER_UNIT = triggerUnit
            call RunTrigger( GetEventsById( damageSourceId, UnitTakesDamage_EVENT_KEY_UNBLOCKED_AS_DAMAGE_SOURCE, priority, iteration ) )
            set iteration = iteration - 1
        endloop

        set DAMAGE_AMOUNT = damageAmount
        set DAMAGE_BLOCKED_AMOUNT = blocked
        set UNBLOCKABLE_DAMAGE_AMOUNT = unblockableDamageAmount
    endfunction

    private function TriggerEvents_Static takes integer blocked, real damageAmount, Unit damageSource, boolean isPrimaryTarget, integer priority, Unit triggerUnit, real unblockableDamageAmount returns nothing
        set blocked = blocked + B2I(BubbleArmor_Damage( triggerUnit ))
        if ( isPrimaryTarget ) then
            if (priority == 0) then
                //! runtextmacro AddEventStaticLineSet("unblockableDamageAmount", "AstralGauntlets", "EVENT_DAMAGE", "Damage( damageSource, unblockableDamageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLine("AttackDerivation", "EVENT_DAMAGE", "Damage( damageSource, damageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLine("Bash_OgreBrat_OgreBrat", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("Bash_Zombie_Zombie", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
            endif
            if ( blocked == 0 ) then
                if (priority == 0) then
                    //! runtextmacro AddEventStaticLine("BloodyClaws", "EVENT_DAMAGE", "Damage( damageSource, damageAmount, triggerUnit )")
                endif
            endif
            if (priority == 0) then
                //! runtextmacro AddEventStaticLine("Disarm", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("DivineArmor", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLineSet("damageAmount", "EasyPrey_Arrow_Arrow", "EVENT_DAMAGE", "Damage( damageSource, damageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLine("Enchant", "EVENT_DAMAGE", "Damage( damageAmount, damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("EnergyGap_Heal_Heal", "EVENT_DAMAGE", "Damage( damageSource, damageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLine("FenixsFeather", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLineSet("unblockableDamageAmount", "Feedback", "EVENT_DAMAGE", "Damage( damageSource, unblockableDamageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLine("FeelingOfSecurity", "EVENT_DAMAGE", "Damage( triggerUnit )")
                //! runtextmacro AddEventStaticLine("FrostArmor", "EVENT_DAMAGE", "Damage( triggerUnit, damageSource )")
                //! runtextmacro AddEventStaticLine("FrozenShard", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("GiantAxe", "EVENT_DAMAGE", "Damage( damageAmount, damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("GloveOfTheBeast", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("HealingPotionBloodOrange", "EVENT_DAMAGE", "Damage( damageSource, damageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLineSet("damageAmount", "IllusionaryStaff", "EVENT_DAMAGE", "Damage( damageSource, damageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLineSet("unblockableDamageAmount", "MysticalAttack", "EVENT_DAMAGE", "Damage( damageSource, unblockableDamageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLineSet("unblockableDamageAmount", "Neutralization", "EVENT_DAMAGE", "Damage( damageSource, unblockableDamageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLine("Pulverize", "EVENT_DAMAGE", "Damage( damageSource, damageAmount, triggerUnit )")
                //! runtextmacro AddEventStaticLine("Riposte_Target_Target", "EVENT_DAMAGE", "Damage( damageAmount, damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("SlowPoison", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("StrongArm", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("SuddenFrost", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLine("Trident", "EVENT_DAMAGE", "Damage( damageSource, triggerUnit )")
                //! runtextmacro AddEventStaticLineSet("unblockableDamageAmount", "VividStrikes", "EVENT_DAMAGE", "Damage( damageSource, unblockableDamageAmount, triggerUnit )")
            endif
        endif
        if (priority == 0) then
            //! runtextmacro AddEventStaticLineSet("damageAmount", "Berserk", "EVENT_DAMAGE", "Damage( triggerUnit, damageAmount )")
            //! runtextmacro AddEventStaticLineSet("damageAmount", "Defend", "EVENT_DAMAGE", "Damage( triggerUnit, damageAmount, damageSource )")
            //! runtextmacro AddEventStaticLine("SummonFaust_AttackGraphic_AttackGraphic", "EVENT_DAMAGE", "Damage( damageSource.self, triggerUnit.self )")
            //! runtextmacro AddEventStaticLine("Meditation", "EVENT_DAMAGE", "Damage( triggerUnit )")
            //! runtextmacro AddEventStaticLine("ThermalFissure_Target_Target", "EVENT_DAMAGE", "Damage( triggerUnit )")
        endif
        if ( blocked == 0 ) then
            if (priority == 0) then
                //! runtextmacro AddEventStaticLine("CurseOfTheBloodline", "EVENT_DAMAGE", "Damage( damageAmount, triggerUnit, damageSource )")
            endif
        endif

        if ( isPrimaryTarget ) then
            if (priority == 1) then
                ////! runtextmacro AddEventStaticLineSet("damageAmount", "FriendshipBracelet_Buff_Buff_Damage", "EVENT_DAMAGE", "Damage( damageAmount, damageSource, triggerUnit )")
            endif
        endif

        set DAMAGE_AMOUNT = damageAmount
        set DAMAGE_BLOCKED_AMOUNT = blocked
        set UNBLOCKABLE_DAMAGE_AMOUNT = unblockableDamageAmount
    endfunction

    private function TriggerEvents takes real damageAmount, Unit damageSource, boolean isPrimaryTarget, Unit triggerUnit returns nothing
        local integer blocked = 0
        local integer iteration = 0
        local real unblockableDamageAmount = 0

        loop
            call TriggerEvents_Dynamic(blocked, damageAmount, damageSource, isPrimaryTarget, iteration, triggerUnit, unblockableDamageAmount)
            set blocked = DAMAGE_BLOCKED_AMOUNT
            set damageAmount = DAMAGE_AMOUNT
            set unblockableDamageAmount = UNBLOCKABLE_DAMAGE_AMOUNT
            call TriggerEvents_Static(blocked, damageAmount, damageSource, isPrimaryTarget, iteration, triggerUnit, unblockableDamageAmount)
            set blocked = DAMAGE_BLOCKED_AMOUNT
            set damageAmount = DAMAGE_AMOUNT
            set unblockableDamageAmount = UNBLOCKABLE_DAMAGE_AMOUNT
            set iteration = iteration + 1
            exitwhen (iteration > 0)
        endloop
    endfunction

    private function DealDamage takes Unit damageSource, UnitType damageSourceType, boolean isPrimaryTarget, real relativeDamage, Unit triggerUnit returns nothing
        local real armorAmount = GetUnitArmorTotal( triggerUnit )
        local real armorBreakRelative = GetUnitArmorBreakRelativeBonus(damageSource)
        local boolean causesDeath
        local real currentLife = GetUnitState( triggerUnit.self, UNIT_STATE_LIFE )
        local real damageAmount = GetUnitDamageTotal( damageSource )
        local integer damageDicesSides = GetUnitTypeDamageDicesSides( damageSourceType )
        local unit damageSourceSelf
        local real damageSourceX
        local real damageSourceY
        local boolean isNotBlocked = true
        local integer iteration = GetUnitTypeDamageDices( damageSourceType )
        local integer triggerUnitType = triggerUnit.type
        local real armorMultiplier = GetAttackMultiplier( GetUnitTypeDamageType( damageSourceType ), GetUnitTypeArmorType( triggerUnitType ) )
        if (armorAmount > 0) then
            set armorAmount = Max(0, armorAmount * (1 - armorBreakRelative))
        endif
        loop
            exitwhen ( iteration < 0 )
            set damageAmount = damageAmount + GetRandomInt( 1, damageDicesSides )
            set iteration = iteration - 1
        endloop
        if ( armorAmount < 0 ) then
            set damageAmount = damageAmount * ( 2 - Pow( ( 1 - ARMOR_REDUCTION_FACTOR ), -armorAmount ) )
        else
            set damageAmount = damageAmount / ( 1 + ARMOR_REDUCTION_FACTOR * armorAmount )
        endif
        if (armorMultiplier < 1) then
            set armorMultiplier = Max( 0, armorMultiplier * (1 - armorBreakRelative) )
        endif

        set damageAmount = damageAmount * armorMultiplier
        set damageAmount = damageAmount * ( 1 + GetUnitDamageRelativeBonus( damageSource ) - Max(0, GetUnitArmorRelativeBonus( triggerUnit ) - armorBreakRelative) )
        set damageAmount = damageAmount * relativeDamage

        call TriggerEvents(damageAmount, damageSource, isPrimaryTarget, triggerUnit)

        set damageAmount = DAMAGE_AMOUNT

        set damageAmount = Air_Damage( damageSource, damageAmount, triggerUnit )

        if ( damageAmount > 0 ) then
            if ( ( GetRandomReal( 0.01, 1 ) <= GetUnitCriticalStrike( damageSource ) - GetUnitCriticalStrikeDefense( triggerUnit ) ) and ( GetUnitCriticalStrikeImmunity( triggerUnit ) == 0 ) ) then
                set damageAmount = damageAmount * CRITICAL_STRIKE_DAMAGE_FACTOR
                set damageSourceSelf = damageSource.self
                set damageSourceX = GetUnitX(damageSourceSelf)
                set damageSourceY = GetUnitY(damageSourceSelf)
                call CreateRisingTextTag( I2S( R2I( damageAmount ) ) + "!", 0.026, damageSourceX, damageSourceY, GetUnitZ( damageSourceSelf, damageSourceX, damageSourceY ), 80, 255, 0, 0, 255, 0, 3 )
                set damageSourceSelf = null
            endif

            set isNotBlocked = (DAMAGE_BLOCKED_AMOUNT == 0)
            set causesDeath = ( ( damageAmount >= currentLife - LIMIT_OF_DEATH ) and isNotBlocked )
            if ( isNotBlocked ) then
                set damageAmount = damageAmount + UNBLOCKABLE_DAMAGE_AMOUNT
                call UnitDamageUnitEx( damageSource, triggerUnit, damageAmount, null )
            else
                call UnitDamageUnitEx( damageSource, triggerUnit, UNBLOCKABLE_DAMAGE_AMOUNT, null )
            endif
        endif
    endfunction

    private function SplashTargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( ( TEMP_BOOLEAN == false ) and ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) ) then
            return false
        endif
        if ( ( TEMP_BOOLEAN2 == false ) and ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) ) then
            return false
        endif
        if ( ( TEMP_BOOLEAN3 == false ) and ( IsUnitEnemy( FILTER_UNIT_SELF, TEMP_PLAYER ) ) ) then
            return false
        endif
        if ( ( TEMP_BOOLEAN4 == false ) and ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_GROUND ) ) ) then
            return false
        endif
        if ( GetUnitInvulnerability(GetUnit(FILTER_UNIT_SELF)) > 0 ) then
            return false
        endif
        return true
    endfunction

    scope ArtilleryAttack
        globals
            public trigger ArtilleryAttack_DUMMY_TRIGGER
        endglobals

        private function ArtilleryAttack_Trig takes nothing returns nothing
            local Unit damageSource = TRIGGER_UNIT
            local UnitType damageSourceType = damageSource.type
            local Unit enumUnit
            local unit enumUnitSelf
            local real targetX = TARGET_X
            local real targetY = TARGET_Y
            local real splashAreaRange = damageSourceType.splashAreaRange
            call DiversionShot_Damage( damageSource, targetX, targetY )
            set TEMP_UNIT = damageSource
            set TEMP_PLAYER = damageSource.owner
            set TEMP_BOOLEAN = damageSourceType.splashAffectionAir
            set TEMP_BOOLEAN2 = damageSourceType.splashAffectionAlly
            set TEMP_BOOLEAN3 = damageSourceType.splashAffectionEnemy
            set TEMP_BOOLEAN4 = damageSourceType.splashAffectionGround
            call GroupEnumUnitsInRangeWJ( ENUM_GROUP, targetX, targetY, splashAreaRange, SPLASH_TARGET_CONDITIONS )
            set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
            if (enumUnitSelf != null) then
                loop
                    set enumUnit = GetUnit(enumUnitSelf)
                    call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                    call DealDamage( damageSource, damageSourceType, false, ( 1 - DistanceByCoordinates( GetUnitX( enumUnitSelf ), GetUnitY( enumUnitSelf ), targetX, targetY ) / splashAreaRange ), enumUnit )
                    set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnitSelf == null )
                endloop
            endif
        endfunction

        public function ArtilleryAttack_Init takes nothing returns nothing
            set ArtilleryAttack_DUMMY_TRIGGER = CreateTriggerWJ()
            call AddTriggerCode(ArtilleryAttack_DUMMY_TRIGGER, function ArtilleryAttack_Trig)
        endfunction
    endscope

    private function Trig takes nothing returns nothing
        local real attackAngle
        local real damageAmount
        local Unit damageSource
        local player damageSourceOwner
        local unit damageSourceSelf
        local UnitType damageSourceType
        local real damageSourceX
        local real damageSourceY
        local unit enumUnit
        local real enumUnitX
        local real enumUnitY
        local boolean hasSplash
        local real splashAreaRange
        local real splashDamageFactor
        local real splashWindowAngleHalf
        local Unit triggerUnit
        local unit triggerUnitSelf
        local real triggerUnitX
        local real triggerUnitY
        if ( NEXT_DAMAGE_IS_SPELL ) then
            set NEXT_DAMAGE_IS_SPELL = false
        else
            set damageAmount = GetEventDamage()
            if ( damageAmount != 0 ) then
                set damageSourceSelf = GetEventDamageSource()
                if ( damageSourceSelf != null ) then
                    set damageSource = GetUnit(damageSourceSelf)
                    set damageSourceType = damageSource.type
                    set triggerUnitSelf = GetTriggerUnit()
                    set triggerUnit = GetUnit(triggerUnitSelf)
                    if ( IsUnitTypeSpecialAttack(damageSourceType) ) then
                        call ArtilleryAttack_Damage( damageSource, triggerUnit )
                        call LightningAttack_Damage( damageSource, triggerUnit )
                        call LinearBoomerang_Damage( damageSource, triggerUnit )
                    else
                        set damageSourceOwner = damageSource.owner
                        call DealDamage( damageSource, damageSourceType, true, 1, triggerUnit )
                        if ( IsUnitTypeSplashForPlayer(damageSourceType, damageSourceOwner) ) then
                            set damageSourceX = GetUnitX( damageSourceSelf )
                            set damageSourceY = GetUnitY( damageSourceSelf )
                            set splashAreaRange = damageSourceType.splashAreaRange
                            set splashWindowAngleHalf = damageSourceType.splashWindowAngle / 2
                            set triggerUnitX = GetUnitX( triggerUnitSelf )
                            set triggerUnitY = GetUnitY( triggerUnitSelf )
                            set attackAngle = Atan2( triggerUnitY - damageSourceY, triggerUnitX - damageSourceX )
                            set TEMP_BOOLEAN = damageSourceType.splashAffectionAir
                            set TEMP_BOOLEAN2 = damageSourceType.splashAffectionAlly
                            set TEMP_BOOLEAN3 = damageSourceType.splashAffectionEnemy
                            set TEMP_BOOLEAN4 = damageSourceType.splashAffectionGround
                            set TEMP_PLAYER = damageSourceOwner
                            set TEMP_UNIT = damageSource
                            call GroupEnumUnitsInRangeWJ( ENUM_GROUP, triggerUnitX, triggerUnitY, splashAreaRange, SPLASH_TARGET_CONDITIONS )
                            set enumUnit = FirstOfGroup( ENUM_GROUP )
                            if (enumUnit != null) then
                                set splashDamageFactor = damageSourceType.splashDamageFactor
                                loop
                                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                                    if ( ( enumUnit != triggerUnitSelf ) and ( Absolute( Atan2( GetUnitY( enumUnit ) - damageSourceY, GetUnitX( enumUnit ) - damageSourceX ) - attackAngle ) <= splashWindowAngleHalf ) ) then
                                        call DealDamage( damageSource, damageSourceType, false, ( 1 - Pow( DistanceByCoordinates( GetUnitX( enumUnit ), GetUnitY( enumUnit ), triggerUnitX, triggerUnitY ) / splashAreaRange, 2 ) ) * splashDamageFactor, GetUnit(enumUnit) )
                                    endif
                                    set enumUnit = FirstOfGroup( ENUM_GROUP )
                                    exitwhen ( enumUnit == null )
                                endloop
                            endif
                        endif
                        set damageSourceOwner = null
                    endif
                    set damageSourceSelf = null
                    set triggerUnitSelf = null
                endif
            endif
        endif
    endfunction

    public function Init takes nothing returns nothing
        set DUMMY_TRIGGER = CreateTriggerWJ()
        set ENUM_GROUP = CreateGroupWJ()
        set SPLASH_TARGET_CONDITIONS = ConditionWJ(function SplashTargetConditions)
        call AddTriggerCode( DUMMY_TRIGGER, function Trig )
        call InitAbility(SPECIAL_ATTACK_SPELL_ID)
        call ArtilleryAttack_ArtilleryAttack_Init()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Events\UnitTakesDamage.j

//file: D:\Warcraft III\Mapping\WFW\Data\Header\FogModifier.j
//! runtextmacro Scope("FogModifier")
    globals
        fogmodifier TEMP_FOG_MODIFIER
    endglobals

    function CreateFogModifierCircleWJ takes player whichPlayer, fogstate whichFogState, real x, real y, real radius, boolean useSharedVision, boolean afterUnits returns fogmodifier
        local fogmodifier newFogModifier = CreateFogModifierRadius( whichPlayer, whichFogState, x, y, radius, useSharedVision, afterUnits )
        call AddObject( newFogModifier, "FogModifier" )
    ///    call AddSavedIntegerToTable( "Objects", "FogModifiers", newFogModifierId )
        set TEMP_FOG_MODIFIER = newFogModifier
        set newFogModifier = null
        return TEMP_FOG_MODIFIER
    endfunction

    function CreateFogModifierRectWJ takes player whichPlayer, fogstate whichFogState, rect whichRect, boolean useSharedVision, boolean afterUnits returns fogmodifier
        local fogmodifier newFogModifier = CreateFogModifierRect( whichPlayer, whichFogState, whichRect, useSharedVision, afterUnits )
        call AddObject( newFogModifier, "FogModifierRect" )
    ///    call AddSavedIntegerToTable( "Objects", "FogModifiers", newFogModifierId )
        set TEMP_FOG_MODIFIER = newFogModifier
        set newFogModifier = null
        return TEMP_FOG_MODIFIER
    endfunction

    function EnableFogModifierWJ takes fogmodifier whichFogModifier, boolean flag returns nothing
        if ( flag ) then
            call FogModifierStart( whichFogModifier )
        else
            call FogModifierStop( whichFogModifier )
        endif
    endfunction

    function DestroyFogModifierWJ takes fogmodifier whichFogModifier returns nothing
        ///call RemoveSavedIntegerFromTable( "Objects", "FogModifiers", whichFogModifierId )
        call RemoveObject( whichFogModifier, "FogModifier" )
        call DestroyFogModifier( whichFogModifier )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Header\FogModifier.j

//file: D:\Warcraft III\Mapping\WFW\Data\Header\Miscellaneous.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Miscellaneous")
    function ClearSelectionWJ takes player whichPlayer returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call ClearSelection()
        endif
    endfunction

    function SelectUnitWJ takes unit whichUnit, boolean flag, player whichPlayer returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call SelectUnit( whichUnit, flag )
        endif
    endfunction

    function ClearTextMessagesWJ takes player whichPlayer returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call ClearTextMessages()
        endif
    endfunction

    //! runtextmacro Scope("Terrain")
        globals
            constant real CELL_SIZE = 32
            constant real TERRAIN_POINT_SIZE = CELL_SIZE * 4
            constant real TERRAIN_POINT_SIZE_HALF = TERRAIN_POINT_SIZE / 2
            Tileset TILESET_CITYSCAPE
            Tileset TILESET_NORTHREND
            Tileset TILESET_SUNKEN_RUINS
            Tileset TILESET_BARRENS
            Tileset TILESET_DUNGEON

            private constant integer Terrain_MAX_TILES_PER_SET = 12
            private integer array Terrain_TILES
            private integer array Terrain_TILES_COUNT
        endglobals

        struct Tileset
            integer count
            integer array whichTypesId[Terrain_MAX_TILES_PER_SET]
        endstruct

        function SetTerrainPointPathable takes real x, real y, pathingtype whichPathingType, boolean flag returns nothing
            local real xend = x + CELL_SIZE
            local real yend = y + CELL_SIZE
            local real xstart = x - CELL_SIZE * 2
            set y = y - CELL_SIZE * 2
            loop
                exitwhen ( y > yend )
                set x = xstart
                loop
                    exitwhen ( x > xend )
                    call SetTerrainPathable( x, y, whichPathingType, flag )
                    set x = x + CELL_SIZE
                endloop
                set y = y + CELL_SIZE
            endloop
        endfunction

        function SetTerrainTypeWJ takes real x, real y, integer whichTerrainTypeId returns nothing
            call SetTerrainType( x, y, whichTerrainTypeId, 0, 1, 0 )
        endfunction

        //! runtextmacro Scope("SetTerrainTypeEx")
            function SetTerrainTypeEx takes real x, real y, integer whichTerrainTypeId returns nothing
                set x = RoundTo( x, 128 )
                set y = RoundTo( y, 128 )
                set TerrainChanges_TRIGGER_TERRAIN_TYPE_ID = whichTerrainTypeId
                set TerrainChanges_X = x
                set TerrainChanges_Y = y
                call RunTrigger(TerrainChanges_DUMMY_TRIGGER)
            endfunction

            function SetTerrainTypeExWithSize takes real x, real y, integer whichTerrainType, integer size returns nothing
                local real xend = x + R2I( size / 2 ) * 128
                local real xstart = xend - size * 128
                local real yend
                set y = y - R2I( size / 2 ) * 128
                set yend = y + size * 128
                loop
                    exitwhen ( y > yend )
                    set x = xstart
                    loop
                        exitwhen ( x > xend )
                        call SetTerrainTypeEx( x, y, whichTerrainType )
                        set x = x + 128
                    endloop
                    set y = y + 128
                endloop
            endfunction
        //! runtextmacro Endscope()

        function CountTerrainTilesInSet takes Tileset tileset returns integer
            return tileset.count
        endfunction

        function GetTerrainTileFromSet takes Tileset tileset, integer index returns integer
            return tileset.whichTypesId[index]
        endfunction

        private function Terrain_AddTileToSet takes Tileset tileset, integer whichTerrainTypeId returns nothing
            local integer count = tileset.count + 1
            set tileset.whichTypesId[count] = whichTerrainTypeId
            set tileset.count = count
        endfunction

        private function Terrain_InitTileset takes nothing returns Tileset
            local Tileset d = Tileset.create()
            set d.count = -1
            return d
        endfunction

        public function Terrain_Init takes nothing returns nothing
            local Tileset d = Terrain_InitTileset()

            set TILESET_CITYSCAPE = d
            call Terrain_AddTileToSet( d, 'Ydrt' )
            call Terrain_AddTileToSet( d, 'Ydtr' )
            call Terrain_AddTileToSet( d, 'Ybtl' )
            call Terrain_AddTileToSet( d, 'Ysqd' )
            call Terrain_AddTileToSet( d, 'Yrtl' )
            call Terrain_AddTileToSet( d, 'Ygsb' )

            set d = Terrain_InitTileset()
            set TILESET_NORTHREND = d
            call Terrain_AddTileToSet( d, 'Ndrt' )
            call Terrain_AddTileToSet( d, 'Ndrd' )
            call Terrain_AddTileToSet( d, 'Ibsq' )
            call Terrain_AddTileToSet( d, 'Irbk' )
            call Terrain_AddTileToSet( d, 'Irbk' )
            call Terrain_AddTileToSet( d, 'Nsnw' )

            set d = Terrain_InitTileset()
            set TILESET_SUNKEN_RUINS = d
            call Terrain_AddTileToSet( d, 'Zdrt' )
            call Terrain_AddTileToSet( d, 'Zdtr' )
            call Terrain_AddTileToSet( d, 'Zbks' )
            call Terrain_AddTileToSet( d, 'Zbkl' )
            call Terrain_AddTileToSet( d, 'Ztil' )
            call Terrain_AddTileToSet( d, 'Zgrs' )

            set d = Terrain_InitTileset()
            set TILESET_BARRENS = d
            call Terrain_AddTileToSet( d, 'Bdrt' )
            call Terrain_AddTileToSet( d, 'Bdrh' )
            call Terrain_AddTileToSet( d, 'Bdrr' )
            call Terrain_AddTileToSet( d, 'Bdsd' )
            call Terrain_AddTileToSet( d, 'Bflr' )
            call Terrain_AddTileToSet( d, 'Bgrr' )

            set d = Terrain_InitTileset()
            set TILESET_DUNGEON = d
            call Terrain_AddTileToSet( d, 'Ddrt' )
            call Terrain_AddTileToSet( d, 'Ddkr' )
            call Terrain_AddTileToSet( d, 'Dbrk' )
            call Terrain_AddTileToSet( d, 'Drds' )
            call Terrain_AddTileToSet( d, 'Dlvc' )
            call Terrain_AddTileToSet( d, 'Dlav' )
        endfunction
    //! runtextmacro Endscope()

    function CountUnitDispelableBuffs takes Unit whichUnit, boolean positiveBuffs, boolean negativeBuffs returns integer
        local integer result = 0
        local integer whichUnitId = whichUnit.id
        if ( positiveBuffs ) then
            set result = result + CountIntegersInTableById(whichUnitId, UnitIsDispelled_EVENT_KEY_POSITIVE) - TABLE_EMPTY
        endif
        if ( negativeBuffs ) then
            set result = result + CountIntegersInTableById(whichUnitId, UnitIsDispelled_EVENT_KEY_NEGATIVE) - TABLE_EMPTY
        endif
        return result
    endfunction

    function DisplayTextTimedWJ takes string text, real time, player whichPlayer returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call DisplayTimedTextToPlayer( whichPlayer, 0, 0, time, text )
        endif
    endfunction

    //! runtextmacro Scope("DisplayTextTimed")
        private struct DisplayTextTimed_Data
            real duration
            timer durationTimer
            timer intervalTimer
            integer position
            player whichPlayer
            string text
        endstruct

        private function Ending takes DisplayTextTimed_Data d, timer durationTimer, player whichPlayer returns nothing
            local timer intervalTimer = d.intervalTimer
            call FlushAttachedInteger( durationTimer, DisplayTextTimed_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call FlushAttachedInteger( intervalTimer, DisplayTextTimed_SCOPE_ID )
            call DestroyTimerWJ( intervalTimer )
            set intervalTimer = null
            call FlushAttachedInteger( whichPlayer, DisplayTextTimed_SCOPE_ID )
        endfunction

        private function EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local DisplayTextTimed_Data d = GetAttachedInteger(durationTimer, DisplayTextTimed_SCOPE_ID)
            call Ending( d, durationTimer, d.whichPlayer )
            set durationTimer = null
        endfunction

        public function Abort takes player whichPlayer returns nothing
            local DisplayTextTimed_Data d = GetAttachedInteger( whichPlayer, DisplayTextTimed_SCOPE_ID )
            if ( d != NULL ) then
                call Ending( d, d.durationTimer, whichPlayer )
            endif
            call ClearTextMessagesWJ( whichPlayer )
        endfunction

        private function NextCharacter takes nothing returns nothing
            local timer intervalTimer = GetExpiredTimer()
            local DisplayTextTimed_Data d = GetAttachedInteger( intervalTimer, DisplayTextTimed_SCOPE_ID )
            local integer position = d.position + 1
            local string text = d.text
            local player whichPlayer = d.whichPlayer
            set intervalTimer = null
            if ( SubString( text, position, position + ColorStrings_START_LENGTH ) == ColorStrings_START ) then
                set position = position + ColorStrings_START_LENGTH + ColorStrings_BODY_LENGTH
            elseif ( SubString( text, position, position + ColorStrings_RESET_LENGTH ) == ColorStrings_RESET ) then
                set position = position + ColorStrings_RESET_LENGTH
            endif
            call ClearTextMessagesWJ( whichPlayer )
            call DisplayTextTimedWJ( SubString( text, 0, position + 1 ), d.duration, whichPlayer )
            set whichPlayer = null
            set d.position = position
        endfunction

        function DisplayTextTimed takes string text, real time, real duration, player whichPlayer returns nothing
            local DisplayTextTimed_Data d
            local timer durationTimer
            local timer intervalTimer
            local integer iteration
            local integer length
            call ClearTextMessagesWJ( whichPlayer )
            if ( text != "" ) then
                set iteration = 0
                set length = StringLength( text )
                loop
                    exitwhen ( iteration >= length )
                    if ( SubString( text, iteration, iteration + ColorStrings_START_LENGTH ) == ColorStrings_START ) then
                        set length = length - ColorStrings_START_LENGTH - ColorStrings_BODY_LENGTH
                    elseif ( SubString( text, iteration, iteration + ColorStrings_RESET_LENGTH ) == ColorStrings_RESET ) then
                        set length = length - ColorStrings_RESET_LENGTH
                    endif
                    set iteration = iteration + 1
                endloop
                if ( length > 0 ) then
                    set d = GetAttachedInteger( whichPlayer, DisplayTextTimed_SCOPE_ID )
                    if ( d == NULL ) then
                        set d = DisplayTextTimed_Data.create()
                        set durationTimer = CreateTimerWJ()
                        set intervalTimer = CreateTimerWJ()
                        set d.durationTimer = durationTimer
                        set d.intervalTimer = intervalTimer
                        set d.whichPlayer = whichPlayer
                        call AttachInteger( durationTimer, DisplayTextTimed_SCOPE_ID, d )
                        call AttachInteger( intervalTimer, DisplayTextTimed_SCOPE_ID, d )
                        call AttachInteger( whichPlayer, DisplayTextTimed_SCOPE_ID, d )
                    else
                        set durationTimer = d.durationTimer
                        set intervalTimer = d.intervalTimer
                    endif
                    set d.duration = duration
                    set d.position = -1
                    set d.text = text
                    call TimerStart( intervalTimer, time / length, true, function NextCharacter )
                    set intervalTimer = null
                    call TimerStart( durationTimer, time, false, function EndingByTimer )
                    set durationTimer = null
                endif
            endif
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Altar")
        globals
            private constant real Altar_HEIGHT = 150.
            private constant real Altar_SLOPE_ANGLE = 30 * DEG_TO_RAD
        endglobals

        //! runtextmacro Scope("Selection")
            globals
                private constant integer Selection_MAX_TYPES = 12
            endglobals

            public struct Selection_Data
                integer count = -1
                string array description[Selection_MAX_TYPES]
                integer array dummyUnitTypesId[Selection_MAX_TYPES]
                integer array whichUnitTypesId[Selection_MAX_TYPES]
            endstruct

            globals
                public Selection_Data array Selection_SELECTIONS
                public integer Selection_SELECTIONS_COUNT = -1
            endglobals

            public function Selection_GetAltarSelection takes integer altarTypeId returns Selection_Data
                return GetAttachedIntegerById(altarTypeId, Selection_SCOPE_ID)
            endfunction

            private function Selection_InitHero takes Selection_Data d, string name, string description, integer dummyUnitTypeId, integer whichUnitTypeId returns nothing
                local integer count = d.count + 1
                set d.count = count
                set d.description[count] = ColorStrings_GOLD + name + ":" + ColorStrings_RESET + " " + description
                set d.dummyUnitTypesId[count] = dummyUnitTypeId
                set d.whichUnitTypesId[count] = whichUnitTypeId
                call InitUnitType(dummyUnitTypeId)
            endfunction

            private function CreateSelection takes nothing returns Selection_Data
                local Selection_Data d = Selection_Data.create()
                set Selection_SELECTIONS_COUNT = Selection_SELECTIONS_COUNT + 1
                set Selection_SELECTIONS[Selection_SELECTIONS_COUNT] = d
                return d
            endfunction

            public function Selection_Init takes nothing returns nothing
                local Selection_Data d = CreateSelection()

                call Selection_InitHero(d, "Witch", "Mighty sorceress that importunes her enemies with a large spectrum of magical abilities.", 'H002', WITCH_UNIT_ID)
                call Selection_InitHero(d, "Paladin", "Devoted servant of light that particularly excels through his supporting skills.", 'H00L', PALADIN_UNIT_ID)
                call Selection_InitHero(d, "Berserker", "Great axe warrior and feared hunter of the Arathi. His eagerness in fight equals that of the Paladin and his brute strength is unmatched.", 'O00C', BERSERKER_UNIT_ID)
                call Selection_InitHero(d, "Medicine Man", "Shaman that is close to the natural forces and spirits and who conjures them in battles for assistance.", 'O00D', MEDICINE_MAN_UNIT_ID)
                call Selection_InitHero(d, "Dark Knight", "Obscure warrior with likewise gloomy abilities. Some people think of him as an emo - but he actually listens to pop.", 'U00C', DARK_KNIGHT_UNIT_ID)
                call Selection_InitHero(d, "Lich", "A frigid harbinger of death which nourishes from the lifeblood of the mortals - and strawberry juice.", 'U00D', LICH_UNIT_ID)
                //call Selection_InitHero(d, "Botanist", "Studied gardener from Eden, whose plants Pflanzen back him out of thankfulness for his daily care.", 'E00D', BOTANIST_UNIT_ID)
                call Selection_InitHero(d, "Headhuntress", "Excellent archer, that rides on a white tiger. Driven by greed, she does everything for the right sum of gold.", 'E00E', HEADHUNTRESS_UNIT_ID)
                //call Selection_InitHero(d, "Fanatical Mechanician", "He is an expert on the field of engineering. But since - due of his exaggerated ambitions for weapon systems - he was declared as certifiably insane, his diploma is just a forgery.", 'N017', FANATICAL_MECHANIC_UNIT_ID)
                call Selection_InitHero(d, "Travelling Trader", "A goblin and his ogreish brother, that take a trip around the world to obtain the best profit - and someone who could remove the glue which keeps them together.", 'N012', TRAVELLING_TRADER_UNIT_ID)
                call AttachIntegerById(ALTAR_UNIT_ID, Selection_SCOPE_ID, d)
            endfunction
        //! runtextmacro Endscope()

        private struct Altar_Data
            Unit altar
            real angle
            real length
            unit array dummyUnits[12]
            integer dummyUnitsCount
            boolean isSelected
            Selection_Selection_Data selection
            integer unitIndex
        endstruct

        private function Altar_UpdateHeroes takes Unit altar, player altarOwner, Altar_Data d returns nothing
            local playercolor altarColor = GetPlayerColor(altarOwner)
            local unit altarSelf = altar.self
            local real altarX = GetUnitX( altarSelf )
            local real altarY = GetUnitY( altarSelf )
            local Selection_Selection_Data currentSelection = d.selection
            local unit currentUnit
            local real length = d.length
            local real newX
            local real newY
            local real slopeAngle
            local real sourceZ = GetUnitZ( altarSelf, altarX, altarY ) + Altar_HEIGHT
            local integer unitIndex = d.unitIndex
            local integer unitTypesInSelectionCount = currentSelection.count
            local real angleAdd = -2 * PI / (unitTypesInSelectionCount + 1)
            local real angle = d.angle + angleAdd
            local integer iteration = unitTypesInSelectionCount
            local real xPart
            local real yPart
            set altarSelf = null
            loop
                set xPart = Cos( angle )
                set yPart = Sin( angle )
                set slopeAngle = xPart / ( Absolute( xPart ) + Absolute( yPart ) ) * Altar_SLOPE_ANGLE
                set currentUnit = d.dummyUnits[iteration]
                set newX = altarX + length * xPart * Cos( slopeAngle )
                set newY = altarY + length * yPart
                call SetUnitX( currentUnit, newX )
                call SetUnitY( currentUnit, newY )
                call SetUnitZ( currentUnit, newX, newY, sourceZ + length * Sin( slopeAngle ) )
                call SetUnitFacingWJ( currentUnit, angle )
                if ( iteration == unitIndex ) then
                    call SetUnitColor( currentUnit, altarColor )
                    call SetUnitScale( currentUnit, 0.95, 0.95, 0.95 )
                    if (GetLocalPlayer() == altarOwner) then
                        call SetUnitVertexColor( currentUnit, 255, 255, 255, 255 )
                    endif
                else
                    call SetUnitColor( currentUnit, NEUTRAL_PASSIVE_PLAYER_COLOR )
                    call SetUnitScale( currentUnit, 0.85, 0.85, 0.85 )
                    if (GetLocalPlayer() == altarOwner) then
                        call SetUnitVertexColor( currentUnit, 255, 255, 255, 127 )
                    endif
                endif
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
                set angle = angle + angleAdd
            endloop
            set altarColor = null
            set altarOwner = null
            set currentUnit = null
        endfunction

        private function Altar_UpdateDescription takes Unit altar, player altarOwner, Selection_Selection_Data d, integer unitIndex returns nothing
            call DisplayTextTimed( d.description[unitIndex], 5, 60, altarOwner )
        endfunction

        //! runtextmacro Scope("SetUnitIndex")
            globals
                private constant real SetUnitIndex_DURATION = 1.
                private constant real SetUnitIndex_START_ANGLE = 1.5 * PI
                private constant real SetUnitIndex_UPDATE_TIME = 0.01
                private constant integer SetUnitIndex_WAVES_AMOUNT = R2I(SetUnitIndex_DURATION / SetUnitIndex_UPDATE_TIME)
            endglobals

            private struct SetUnitIndex_Data
                real angleAdd
                real angleAddAdd
                Altar_Data d
                timer durationTimer
                real remainingAngle
                timer updateTimer
            endstruct

            private function SetUnitIndex_Ending takes Unit altar, Altar_Data d, SetUnitIndex_Data e, timer durationTimer returns nothing
                local player altarOwner
                local real angle
                local Selection_Selection_Data currentSelection = d.selection
                local UnitType currentUnitType
                local boolean isAltarSelected = d.isSelected
                local integer iteration = 0
                local integer unitIndex = d.unitIndex
                local integer currentUnitTypeId = currentSelection.whichUnitTypesId[unitIndex]
                local integer unitTypesInSelectionCount = currentSelection.count
                local timer updateTimer = e.updateTimer
                call e.destroy()
                call FlushAttachedIntegerById( altar.id, SetUnitIndex_SCOPE_ID )
                call FlushAttachedInteger( durationTimer, SetUnitIndex_SCOPE_ID )
                call DestroyTimerWJ( durationTimer )
                call FlushAttachedInteger( updateTimer, SetUnitIndex_SCOPE_ID )
                call DestroyTimerWJ( updateTimer )
                set updateTimer = null
                set d.angle = SetUnitIndex_START_ANGLE - unitIndex * ( 2 * PI / (unitTypesInSelectionCount + 1) )
                if ( isAltarSelected ) then
                    set altarOwner = altar.owner
                    set currentUnitType = GetUnitType(currentUnitTypeId)
                    call Altar_UpdateHeroes( altar, altarOwner, d )
                    call PlaySoundFromTypeForPlayer( GetUnitTypePissedSound(currentUnitType, GetRandomInt(0, CountUnitTypePissedSounds(currentUnitType))), altarOwner )
                endif
            endfunction

            public function SetUnitIndex_EndingByRemove takes Unit altar, Altar_Data d returns nothing
                local SetUnitIndex_Data e = GetAttachedIntegerById(altar.id, SetUnitIndex_SCOPE_ID)
                if (e != NULL) then
                    call SetUnitIndex_Ending(altar, d, e, e.durationTimer)
                endif
            endfunction

            private function SetUnitIndex_EndingByTimer takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local SetUnitIndex_Data e = GetAttachedInteger(durationTimer, SetUnitIndex_SCOPE_ID)
                local Altar_Data d = e.d
                call SetUnitIndex_Ending( d.altar, d, e, durationTimer )
                set durationTimer = null
            endfunction

            private function SetUnitIndex_Update takes nothing returns nothing
                local integer currentUnit
                local integer iteration = 0
                local timer updateTimer = GetExpiredTimer()
                local SetUnitIndex_Data e = GetAttachedInteger(updateTimer, SetUnitIndex_SCOPE_ID)
                local Altar_Data d = e.d
                local Unit altar = d.altar
                local real angleAdd = e.angleAdd + e.angleAddAdd
                local real currentAngle = d.angle + angleAdd
                local real remainingAngle = e.remainingAngle - angleAdd
                set updateTimer = null
                set d.angle = currentAngle
                set e.angleAdd = angleAdd
                set e.remainingAngle = remainingAngle
                call Altar_UpdateHeroes( altar, altar.owner, d )
            endfunction

            public function SetUnitIndex_Start takes Unit altar, player altarOwner, Altar_Data d, integer unitIndex, boolean turnsLeft returns nothing
                local integer altarId = altar.id
                local real angleAdd
                local real angleDifference2
                local real currentAngle
                local Selection_Selection_Data currentSelection = d.selection
                local SetUnitIndex_Data e = GetAttachedIntegerById(altarId, SetUnitIndex_SCOPE_ID)
                local timer durationTimer
                local integer oldUnitIndex
                local integer unitTypesInSelectionCount = currentSelection.count
                local real angleDifference = 2 * PI / (unitTypesInSelectionCount + 1)
                local timer updateTimer
                set oldUnitIndex = d.unitIndex
                if ( e == NULL ) then
                    set currentAngle = SetUnitIndex_START_ANGLE - oldUnitIndex * angleDifference
                    set e = SetUnitIndex_Data.create()
                    set durationTimer = CreateTimerWJ()
                    set updateTimer = CreateTimerWJ()
                    set d.angle = currentAngle
                    set e.durationTimer = durationTimer
                    set e.updateTimer = updateTimer
                    call AttachIntegerById( altarId, SetUnitIndex_SCOPE_ID, e )
                    call AttachInteger( durationTimer, SetUnitIndex_SCOPE_ID, e )
                    call AttachInteger( updateTimer, SetUnitIndex_SCOPE_ID, e )
                else
                    set durationTimer = e.durationTimer
                    set updateTimer = e.updateTimer
                endif

                set angleDifference2 = ( oldUnitIndex - unitIndex ) * angleDifference
                if ( turnsLeft ) then
                    if ( angleDifference2 < 0 ) then
                        set angleDifference2 = angleDifference2 + 2 * PI
                    endif
                else
                    if ( angleDifference2 > 0 ) then
                        set angleDifference2 = angleDifference2 - 2 * PI
                    endif
                endif
                set angleDifference2 = e.remainingAngle + angleDifference2
                set angleAdd = 2 * angleDifference2 / SetUnitIndex_WAVES_AMOUNT

                set d.unitIndex = unitIndex
                set e.d = d
                set e.angleAdd = angleAdd
                set e.angleAddAdd = -angleAdd / SetUnitIndex_WAVES_AMOUNT
                set e.remainingAngle = angleDifference2

                call Altar_UpdateDescription( altar, altarOwner, currentSelection, unitIndex )
                call Altar_UpdateHeroes( altar, altarOwner, d )

                call TimerStart( updateTimer, SetUnitIndex_UPDATE_TIME, true, function SetUnitIndex_Update )
                set updateTimer = null
                call TimerStart( durationTimer, SetUnitIndex_DURATION, false, function SetUnitIndex_EndingByTimer )
                set durationTimer = null
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("ShowHeroes")
            globals
                private constant real ShowHeroes_DURATION = 1.
                private constant real ShowHeroes_UPDATE_TIME = 0.01
                private constant real ShowHeroes_LENGTH_ADD_START = 500 * ShowHeroes_UPDATE_TIME
                private constant real ShowHeroes_LENGTH_ADD_ADD = -ShowHeroes_LENGTH_ADD_START / (ShowHeroes_DURATION / ShowHeroes_UPDATE_TIME)
            endglobals

            private struct ShowHeroes_Data
                Altar_Data d
                real lengthAdd
                timer durationTimer
                timer updateTimer
            endstruct

            private function ShowHeroes_Ending takes Unit altar, ShowHeroes_Data d, timer durationTimer returns nothing
                local timer updateTimer = d.updateTimer
                call d.destroy()
                call FlushAttachedIntegerById( altar.id, ShowHeroes_SCOPE_ID )
                call FlushAttachedInteger( durationTimer, ShowHeroes_SCOPE_ID )
                call DestroyTimerWJ( durationTimer )
                call FlushAttachedInteger( updateTimer, ShowHeroes_SCOPE_ID )
                call DestroyTimerWJ( updateTimer )
                set updateTimer = null
            endfunction

            public function ShowHeroes_EndingByRemove takes Unit altar returns nothing
                local ShowHeroes_Data d = GetAttachedIntegerById(altar.id, ShowHeroes_SCOPE_ID)
                if (d != NULL) then
                    call ShowHeroes_Ending(altar, d, d.durationTimer)
                endif
            endfunction

            private function ShowHeroes_EndingByTimer takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local ShowHeroes_Data e = GetAttachedInteger(durationTimer, ShowHeroes_SCOPE_ID)
                local Altar_Data d = e.d
                call ShowHeroes_Ending( d.altar, e, durationTimer )
                set durationTimer = null
            endfunction

            private function ShowHeroes_Update takes nothing returns nothing
                local timer updateTimer = GetExpiredTimer()
                local ShowHeroes_Data e = GetAttachedInteger(updateTimer, ShowHeroes_SCOPE_ID)
                local Altar_Data d = e.d
                local Unit altar = d.altar
                local real lengthAdd = e.lengthAdd + ShowHeroes_LENGTH_ADD_ADD
                local real length = d.length + lengthAdd
                set updateTimer = null
                set d.length = length
                set e.lengthAdd = lengthAdd
                call Altar_UpdateHeroes( altar, altar.owner, d )
            endfunction

            public function ShowHeroes_Start takes Unit altar, Altar_Data d, boolean flag returns nothing
                local integer altarId = altar.id
                local player altarOwner = altar.owner
                local Selection_Selection_Data currentSelection = d.selection
                local timer durationTimer
                local ShowHeroes_Data e = GetAttachedIntegerById(altarId, ShowHeroes_SCOPE_ID)
                local integer unitTypesInSelectionCount = currentSelection.count
                local integer iteration = unitTypesInSelectionCount
                local timer updateTimer
                set d.length = 0
                set d.isSelected = flag
                if ( flag ) then
                    loop
                        call SetUnitOwner( d.dummyUnits[iteration], altarOwner, false )
                        set iteration = iteration - 1
                        exitwhen ( iteration < 0 )
                    endloop
                    call Altar_UpdateHeroes( altar, altarOwner, d )
                    if ( e == NULL ) then
                        set e = ShowHeroes_Data.create()
                        set durationTimer = CreateTimerWJ()
                        set updateTimer = CreateTimerWJ()
                        set e.d = d
                        set e.durationTimer = durationTimer
                        set e.updateTimer = updateTimer
                        call AttachIntegerById( altarId, ShowHeroes_SCOPE_ID, e )
                        call AttachInteger( durationTimer, ShowHeroes_SCOPE_ID, e )
                        call AttachInteger( updateTimer, ShowHeroes_SCOPE_ID, e )
                    else
                        set durationTimer = e.durationTimer
                        set updateTimer = e.updateTimer
                    endif
                    set e.lengthAdd = ShowHeroes_LENGTH_ADD_START

                    call Altar_UpdateDescription( altar, altarOwner, d, d.unitIndex )

                    call TimerStart( updateTimer, ShowHeroes_UPDATE_TIME, true, function ShowHeroes_Update )
                    set updateTimer = null
                    call TimerStart( durationTimer, ShowHeroes_DURATION, false, function ShowHeroes_EndingByTimer )
                    set durationTimer = null
                else
                    loop
                        call SetUnitOwner( d.dummyUnits[iteration], NEUTRAL_PASSIVE_PLAYER, false )
                        set iteration = iteration - 1
                        exitwhen ( iteration < 0 )
                    endloop
                    call DisplayTextTimed_Abort( altarOwner )
                    if ( e != NULL ) then
                        call ShowHeroes_Ending( altar, e, e.durationTimer )
                    endif
                endif
                set altarOwner = null
            endfunction
        //! runtextmacro Endscope()

        public function Altar_Ending takes Unit altar returns nothing
            local integer altarId = altar.id
            local player altarOwner
            local Altar_Data d = GetAttachedIntegerById(altarId, Altar_SCOPE_ID)
            local unit array dummyUnits
            local integer dummyUnitsCount = d.dummyUnitsCount
            local boolean isSelected = d.isSelected
            local integer iteration = dummyUnitsCount
            loop
                set dummyUnits[iteration] = d.dummyUnits[iteration]
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            loop
                set iteration = iteration + 1
                call ShowUnit(dummyUnits[iteration], true)
                call RemoveUnitWJ( dummyUnits[iteration] )
                set dummyUnits[iteration] = null
                exitwhen ( iteration == dummyUnitsCount )
            endloop
            call SetUnitIndex_SetUnitIndex_EndingByRemove( altar, d )
            call ShowHeroes_ShowHeroes_EndingByRemove( altar )

            if ( isSelected ) then
                set altarOwner = altar.owner
                call DisplayTextTimed_Abort( altarOwner )
                call SetCameraBoundsToRectWJ(CAMERA_BOUNDS_RECT, altarOwner)
                set altarOwner = null
            endif
            call d.destroy()
            call FlushAttachedIntegerById( altarId, Altar_SCOPE_ID )
            call RemoveUnitEx( altar )
        endfunction

        public function Altar_Deselect takes player triggerPlayer, Unit altar returns nothing
            local Altar_Data d = GetAttachedIntegerById(altar.id, Altar_SCOPE_ID)
            if ( d != NULL ) then
                if ( triggerPlayer == altar.owner ) then
                    call ShowHeroes_ShowHeroes_Start( altar, d, false )
                endif
            endif
        endfunction

        public function Altar_Select takes player triggerPlayer, Unit altar returns nothing
            local Altar_Data d = GetAttachedIntegerById(altar.id, Altar_SCOPE_ID)
            if ( d != NULL ) then
                if ( triggerPlayer == altar.owner ) then
                    call ShowHeroes_ShowHeroes_Start( altar, d, true )
                endif
            endif
        endfunction

        public function Altar_ChooseHero takes Unit caster, player owner, real x, real y returns Unit
            local Altar_Data d = GetAttachedIntegerById(caster.id, Altar_SCOPE_ID)
            return CreateUnitEx( owner, Selection_Selection_GetAltarSelection(caster.type.id).whichUnitTypesId[d.unitIndex], x, y, STANDARD_ANGLE )
        endfunction

        public function Altar_ChooseRandomHero takes player owner, real x, real y returns Unit
            local Selection_Selection_Data selection = Selection_Selection_SELECTIONS[GetRandomInt(0, Selection_Selection_SELECTIONS_COUNT)]
            return CreateUnitEx( owner, selection.whichUnitTypesId[GetRandomInt(0, selection.count)], x, y, STANDARD_ANGLE )
        endfunction

        public function Altar_ChooseRandomHeroFromSelection takes Unit caster, player owner, real x, real y returns Unit
            local Selection_Selection_Data selection = Selection_Selection_GetAltarSelection(caster.type.id)
            return CreateUnitEx( owner, selection.whichUnitTypesId[GetRandomInt(0, selection.count)], x, y, STANDARD_ANGLE )
        endfunction

        public function Altar_NextHero takes Unit caster returns nothing
            local Altar_Data d = GetAttachedIntegerById(caster.id, Altar_SCOPE_ID)
            local integer unitIndex = d.unitIndex
            if ( unitIndex == d.selection.count ) then
                set unitIndex = 0
            else
                set unitIndex = unitIndex + 1
            endif
            call SetUnitIndex_SetUnitIndex_Start( caster, caster.owner, d, unitIndex, false )
        endfunction

        public function Altar_PreviousHero takes Unit caster returns nothing
            local Altar_Data d = GetAttachedIntegerById(caster.id, Altar_SCOPE_ID)
            local integer unitIndex = d.unitIndex
            if ( unitIndex == 0 ) then
                set unitIndex = d.selection.count
            else
                set unitIndex = unitIndex - 1
            endif
            call SetUnitIndex_SetUnitIndex_Start( caster, caster.owner, d, unitIndex, true )
        endfunction

        private function Altar_Start takes Unit altar, player altarOwner, real altarX, real altarY returns nothing
            local integer altarId = altar.id
            local unit altarSelf = altar.self
            local real altarZ = GetUnitZ( altarSelf, altarX, altarY ) + Altar_HEIGHT
            local Selection_Selection_Data currentSelection = Selection_Selection_GetAltarSelection(GetUnitTypeId(altarSelf))
            local unit currentUnit
            local Altar_Data d = GetAttachedIntegerById(altarId, Altar_SCOPE_ID)
            local integer iteration
            local integer unitTypesInSelectionCount = currentSelection.count
            if (d == NULL) then
                set d = Altar_Data.create()
                set d.altar = altar
                call AttachIntegerById(altarId, Altar_SCOPE_ID, d)
            else
                set iteration = d.dummyUnitsCount
                loop
                    set currentUnit = d.dummyUnits[iteration]
                    call ShowUnit(currentUnit, true)
                    call RemoveUnitWJ( currentUnit )
                    set iteration = iteration - 1
                    exitwhen ( iteration < 0 )
                endloop
            endif
            set iteration = unitTypesInSelectionCount
            set d.dummyUnitsCount = unitTypesInSelectionCount
            set d.selection = currentSelection
            set d.unitIndex = 0
            call UnitAddAbility( altarSelf, ChooseRandomHero_SPELL_ID )
            call UnitAddAbility( altarSelf, ChooseHero_SPELL_ID )
            call UnitAddAbility( altarSelf, ChooseRandomHeroFromSelection_SPELL_ID )
            call UnitAddAbility( altarSelf, PreviousHero_SPELL_ID )
            call UnitAddAbility( altarSelf, NextHero_SPELL_ID )
            set altarSelf = null
            loop
                set currentUnit = CreateUnitWJ( altarOwner, currentSelection.dummyUnitTypesId[iteration], altarX, altarY, altarZ )
                set d.dummyUnits[iteration] = currentUnit
                if (GetLocalPlayer() != altarOwner) then
                    call ShowUnit(currentUnit, false)
                endif
                call UnitAddAbility(currentUnit, INVISIBILITY_SPELL_ID)
                call AddUnitLocust( currentUnit )
                call RemoveUnitMoveability( currentUnit )
                call SetUnitPathing( currentUnit, false )
                if ( GetLocalPlayer() == altarOwner ) then
                    call SetUnitVertexColor( currentUnit, 255, 255, 255, 127 )
                else
                    call SetUnitVertexColor( currentUnit, 0, 0, 0, 0 )
                endif
                call InitUnitZ(currentUnit)
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            call SetUnitIndex_SetUnitIndex_Start( altar, altarOwner, d, GetRandomInt( 0, unitTypesInSelectionCount ), false )
            //call ShowHeroes_ShowHeroes_Start( altar, d, true )
        endfunction

        public function Altar_UpgradeFinish takes Unit altar, player altarOwner, integer altarTypeId, real altarX, real altarY returns nothing
            if ( GetAttachedBooleanById( altarTypeId, Altar_SCOPE_ID ) ) then
                call Altar_Start(altar, altarOwner, altarX, altarY)
            endif
        endfunction

        function CreateAltar takes player altarOwner returns Unit
            local integer altarOwnerId = GetPlayerId(altarOwner)
            local real x = ALTAR_X[altarOwnerId]
            local real y = ALTAR_Y[altarOwnerId]
            local Unit altar = CreateUnitEx( altarOwner, ALTAR_UNIT_ID, x, y, STANDARD_ANGLE )
            local unit altarSelf = altar.self
            call SetCameraBoundsToPointWJ(x, y, altarOwner)
            call SetUnitPathing( altarSelf, false )
            call UnitAddAbility( altarSelf, INVISIBILITY_SPELL_ID )
            call Altar_Start( altar, altarOwner, x, y )
            call ClearSelectionWJ( altarOwner )
            call SelectUnitWJ( altarSelf, true, altarOwner )
            set altarSelf = null
            call PanCameraTimedWJ( altarOwner, x, y, 2 )
            return altar
        endfunction

        public function Altar_Init takes nothing returns nothing
            call AttachBooleanById(ALTAR_UNIT_ID, Altar_SCOPE_ID, true)
            call Selection_Selection_Init()
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Spawn")
        private struct Spawn_Data
            boolean advancedTrainingUsed
            Unit rax
            timer spawnTimer
            UnitType spawnType
            player whichPlayer
        endstruct

        //! runtextmacro CreateSimpleUnitTypeState("spawnBonus", "SpawnBonus", "integer")

        //! runtextmacro CreateSimpleUnitTypeState("spawnStage", "SpawnStage", "integer")

        //! runtextmacro CreateSimpleUnitTypeState("spawnTime", "SpawnTime", "real")
        //! runtextmacro CreateSimpleUnitTypeStateForPlayer("spawnTime", "SpawnTime", "real")

        //! runtextmacro CreateSimpleUnitTypeState("spawnTypeId", "SpawnTypeId", "integer")

        ////////////////////////////////////////////////////////////////////////////////////////////////

        public function Spawn_Destroy takes Unit rax returns nothing
            local integer raxId = rax.id
            local Spawn_Data d = GetAttachedIntegerById(raxId, Spawn_SCOPE_ID)
            local timer spawnTimer
            if ( d != NULL ) then
                set spawnTimer = d.spawnTimer
                call d.destroy()
                call FlushAttachedIntegerById(raxId, Spawn_SCOPE_ID)
                call FlushAttachedInteger( spawnTimer, Spawn_SCOPE_ID )
                call DestroyTimerWJ(spawnTimer)
                set spawnTimer = null
            endif
        endfunction

        private function Spawn_Interval takes Spawn_Data d, Unit rax, UnitType spawnType, player whichPlayer, integer whichPlayerId returns nothing
            local Unit newUnit
            local unit newUnitSelf
            local location rallyPoint
            local unit rallyUnitSelf
            local unit raxSelf = rax.self
            local UnitType raxType
            local integer spawnAmount
            local integer spawnTypeId = spawnType.id
            local integer iteration = 1 + GetUnitTypeSpawnBonus( spawnType )
            local integer whichPlayerGold
            local real x = GetUnitX(raxSelf)
            local real y = GetUnitY(raxSelf)
            loop 
                exitwhen (GetPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_FOOD_USED ) + GetUnitTypeSupplyUsed( spawnType ) > GetPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_FOOD_CAP ))
                set newUnit = CreateUnitEx( whichPlayer, spawnTypeId, x, y, STANDARD_ANGLE )
                set newUnitSelf = newUnit.self
                set rallyUnitSelf = GetUnitRallyUnit( raxSelf )
                if ( rallyUnitSelf == null ) then
                    set rallyPoint = GetUnitRallyPoint( raxSelf )
                    call IssuePointOrderById( newUnitSelf, ATTACK_ORDER_ID, GetLocationX( rallyPoint ), GetLocationY( rallyPoint ) )
                    call RemoveLocationWJ( rallyPoint )
                elseif ( rallyUnitSelf != raxSelf ) then
                    call IssueTargetOrderById( newUnitSelf, PATROL_ORDER_ID, rallyUnitSelf )
                endif
                set iteration = iteration - 1
                exitwhen ( iteration < 1 )
            endloop
            if ( d.advancedTrainingUsed ) then
                if ( iteration > 0 ) then
                    call AddPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_GOLD, iteration / spawnAmount * AdvancedTraining_BONUS_TIME_GOLD_COST )
                endif
            endif
            if (rax.automaticAbility == AdvancedTraining_SPELL_ID) then
                set whichPlayerGold = GetPlayerState(whichPlayer, PLAYER_STATE_RESOURCE_GOLD)
                if ( (whichPlayerGold >= AdvancedTraining_BONUS_SPAWN_GOLD_COST) and (iteration == 0) ) then
                    set raxType = rax.type
                    set spawnAmount = 1 + GetUnitTypeSpawnBonus( spawnType )
                    set spawnTypeId = GetUnitTypeSpawnTypeId(GetRaceTownHall(GetUnitTypeRace(raxType), GetRandomInt(0, GetUnitTypeSpawnStage(raxType))))
                    set spawnType = GetUnitType(spawnTypeId)
                    set iteration = spawnAmount
                    loop
                        exitwhen (GetPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_FOOD_USED ) + GetUnitTypeSupplyUsed( spawnType ) > GetPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_FOOD_CAP ))
                        set newUnit = CreateUnitEx( whichPlayer, spawnTypeId, x, y, STANDARD_ANGLE )
                        set newUnitSelf = newUnit.self
                        set rallyUnitSelf = GetUnitRallyUnit( raxSelf )
                        if ( rallyUnitSelf == null ) then
                            set rallyPoint = GetUnitRallyPoint( raxSelf )
                            call IssuePointOrderById( newUnitSelf, ATTACK_ORDER_ID, GetLocationX( rallyPoint ), GetLocationY( rallyPoint ) )
                            call RemoveLocationWJ( rallyPoint )
                        elseif ( rallyUnitSelf != raxSelf ) then
                            call IssueTargetOrderById( newUnitSelf, PATROL_ORDER_ID, rallyUnitSelf )
                        endif
                        set iteration = iteration - 1
                        exitwhen (iteration < 1)
                    endloop
                    if (iteration != spawnAmount) then
                        call SetPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_GOLD, whichPlayerGold - (1 - iteration / spawnAmount) * R2I(AdvancedTraining_BONUS_SPAWN_GOLD_COST) )
                    endif
                endif
            endif
            set newUnitSelf = null
            set rallyPoint = null
            set rallyUnitSelf = null
            set raxSelf = null
        endfunction

        private function Spawn_IntervalByTimer takes nothing returns nothing
            local timer spawnTimer = GetExpiredTimer()
            local Spawn_Data d = GetAttachedInteger(spawnTimer, Spawn_SCOPE_ID)
            local Unit rax = d.rax
            local UnitType spawnType = d.spawnType
            local player whichPlayer = d.whichPlayer
            local real spawnTime = GetUnitTypeSpawnTime( spawnType ) + GetUnitTypeSpawnTimeForPlayer(spawnType, whichPlayer)
            local integer whichPlayerGold
            local integer whichPlayerId = GetPlayerId(whichPlayer)
            call Spawn_Interval(d, rax, spawnType, whichPlayer, whichPlayerId)
            if ( rax.automaticAbility == AdvancedTraining_SPELL_ID ) then
                set whichPlayerGold = GetPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_GOLD )
                if ( whichPlayerGold < AdvancedTraining_BONUS_TIME_GOLD_COST ) then
                    set d.advancedTrainingUsed = false
                else
                    set spawnTime = spawnTime * ( 1 - AdvancedTraining_BONUS_TIME_FACTOR )
                    set d.advancedTrainingUsed = true
                    call SetPlayerState( whichPlayer, PLAYER_STATE_RESOURCE_GOLD, whichPlayerGold - AdvancedTraining_BONUS_TIME_GOLD_COST )
                endif
            else
                set d.advancedTrainingUsed = false
            endif
            set whichPlayer = null
            call TimerStart( spawnTimer, spawnTime, false, function Spawn_IntervalByTimer )
            set spawnTimer = null
        endfunction

        public function Spawn_Start takes Unit rax, integer spawnTypeId, player whichPlayer returns nothing
            local integer raxId = rax.id
            local Spawn_Data d = GetAttachedIntegerById(raxId, Spawn_SCOPE_ID)
            local timer spawnTimer
            local UnitType spawnType = GetUnitType(spawnTypeId)
            if ( d == NULL ) then
                set d = Spawn_Data.create()
                set spawnTimer = CreateTimerWJ()
                set d.rax = rax
                set d.spawnTimer = spawnTimer
                set d.whichPlayer = whichPlayer
                call AttachIntegerById(raxId, Spawn_SCOPE_ID, d)
                call AttachInteger( spawnTimer, Spawn_SCOPE_ID, d )
            else
                set spawnTimer = d.spawnTimer
            endif
            set d.spawnType = spawnType
            call TimerStart( spawnTimer, GetUnitTypeSpawnTime( spawnType ) + GetUnitTypeSpawnTimeForPlayer(spawnType, whichPlayer), false, function Spawn_IntervalByTimer )
            set spawnTimer = null
        endfunction

        public function Spawn_StartByDeath takes Unit rax, player whichPlayer returns nothing
            local Spawn_Data d = GetAttachedIntegerById(rax.id, Spawn_SCOPE_ID)
            local UnitType spawnType = GetUnitType(GetUnitTypeSpawnTypeId(rax))
            local real spawnTime = GetUnitTypeSpawnTime( spawnType ) + GetUnitTypeSpawnTimeForPlayer(spawnType, whichPlayer)
            local timer spawnTimer
            if ( d != NULL ) then
                set spawnTimer = d.spawnTimer
            endif
            if (spawnTime > TimerGetRemaining(spawnTimer)) then
                call TimerStart( spawnTimer, spawnTime, false, function Spawn_IntervalByTimer )
            endif
            set spawnTimer = null
        endfunction
    //! runtextmacro Endscope()

    function Error takes player whichPlayer, string text returns nothing
        call PlaySoundFromTypeForPlayer( ERROR_SOUND_TYPE, whichPlayer )
        call DisplayTextTimedWJ( ColorStrings_GOLD + text + ColorStrings_RESET, 2, whichPlayer )
    endfunction

    function EndDialog takes player whichPlayer returns nothing
        local dialog endDialog = CreateDialogWJ()
        call DialogSetMessage( endDialog, "Muchos arigatou pour playing" )
        call AddDialogQuitButtonWJ( endDialog, false, "Ride into the sunset", 0 )
    //    call DisplayDialogWJ( endDialog, whichPlayer, true )
        set endDialog = null
    endfunction

    function SetCineFilterTextureWJ takes player whichPlayer, string whichPath returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call SetCineFilterTexture( whichPath )
        endif
    endfunction

    function SetCineFilterBlendModeWJ takes player whichPlayer, blendmode whichBlendMode returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call SetCineFilterBlendMode( whichBlendMode )
        endif
    endfunction

    function SetCineFilterTexMapFlagsWJ takes player whichPlayer, texmapflags whichTexMapFlags returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call SetCineFilterTexMapFlags( whichTexMapFlags )
        endif
    endfunction

    function SetCineFilterUVWJ takes player whichPlayer, real minU, real minV, real maxU, real maxV returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call SetCineFilterEndUV( minU, minV, maxU, maxV )
        endif
    endfunction

    function SetCineFilterColorWJ takes player whichPlayer, real red, real green, real blue, real alpha returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call SetCineFilterEndColor( R2I( red ), R2I( green ), R2I( blue ), R2I( alpha ) )
        endif
    endfunction

    function DisplayCineFilterWJ takes player whichPlayer, boolean flag returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call DisplayCineFilter( flag )
        endif
    endfunction

    function KillPlayer takes player whichPlayer returns nothing
        set TRIGGER_PLAYER = whichPlayer
        call RunTrigger( PlayerDies_DUMMY_TRIGGER )
    endfunction

    function ClearMapMusicWJ takes player whichPlayer returns nothing
        if ( GetLocalPlayer() == whichPlayer ) then
            call ClearMapMusic()
        endif
    endfunction

    function SetWaterColorWJ takes player whichPlayer, integer red, integer green, integer blue, integer alpha returns nothing
        if (GetLocalPlayer() == whichPlayer) then
            call SetWaterBaseColor( red, green, blue, alpha )
        endif
    endfunction

    function SetTerrainFogWJ takes player whichPlayer, integer style, real zstart, real zend, real density, real red, real green, real blue returns nothing
        if (GetLocalPlayer() == whichPlayer) then
            call SetTerrainFogEx( style, zstart, zend, density, red, green, blue )
        endif
    endfunction

    //! runtextmacro Scope("AddOrderAbility")
        function GetAbilityOrder takes integer whichAbility, integer index returns integer
            return GetIntegerFromTableById(whichAbility, AddOrderAbility_SCOPE_ID, index)
        endfunction

        function CountOrderAbilities takes integer whichOrder returns integer
            return CountIntegersInTableById(whichOrder, AddOrderAbility_SCOPE_ID)
        endfunction

        function GetOrderAbility takes integer whichOrder, integer index returns integer
            return GetIntegerFromTableById(whichOrder, AddOrderAbility_SCOPE_ID, index)
        endfunction

        function AddOrderAbility takes integer whichOrder, integer whichAbility returns nothing
            call AddIntegerToTableById( whichAbility, AddOrderAbility_SCOPE_ID, whichOrder )
            call AddIntegerToTableById( whichOrder, AddOrderAbility_SCOPE_ID, whichAbility )
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Research")
        globals
            key RESEARCH_TYPE_KEY
        endglobals

        struct ResearchType
            integer array goldCost[12]
            integer id
        endstruct

        function GetResearchTypeGoldCost takes ResearchType whichResearchType, integer level returns integer
            return whichResearchType.goldCost[level]
        endfunction

        function SetResearchTypeGoldCost takes ResearchType whichResearchType, integer level, integer goldCost returns nothing
            set whichResearchType.goldCost[level] = goldCost
        endfunction

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        function CountResearchTypeIdUnitTypes takes integer whichResearchTypeId returns integer
            return CountIntegersInTableById(whichResearchTypeId, Research_SCOPE_ID)
        endfunction

        function GetResearchTypeIdUnitType takes integer whichResearchTypeId, integer index returns UnitType
            return GetIntegerFromTableById(whichResearchTypeId, Research_SCOPE_ID, index)
        endfunction

        function IsUnitTypeUsingResearchTypeId takes UnitType whichUnitType, integer whichResearchTypeId returns boolean
            return GetSavedBoolean(I2S(whichUnitType.id), SCOPE_PREFIX + I2S(whichResearchTypeId))
        endfunction

        function AddUnitTypeResearchTypeId takes UnitType whichUnitType, integer whichResearchTypeId returns nothing
            call AddIntegerToTableById( whichResearchTypeId, Research_SCOPE_ID, whichUnitType )
            call SaveBooleanWJ( I2S(whichUnitType.id), SCOPE_PREFIX + I2S(whichResearchTypeId), true )
        endfunction

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        function GetResearchType takes integer whichResearchTypeId returns ResearchType
            return GetAttachedIntegerById( whichResearchTypeId, RESEARCH_TYPE_KEY )
        endfunction

        function IsResearchType takes integer whichResearchTypeId returns boolean
            return (GetResearchType(whichResearchTypeId) != NULL)
        endfunction

        function InitResearchType takes integer whichResearchTypeId returns ResearchType
            local ResearchType d = ResearchType.create()
            set d.id = whichResearchTypeId
            call AttachIntegerById( whichResearchTypeId, RESEARCH_TYPE_KEY, d )
            //call SetPlayerTechResearched( NEUTRAL_PASSIVE_PLAYER, whichResearchTypeId, 1 )
            return d
        endfunction
    //! runtextmacro Endscope()

    function PingMasterWizard takes integer whichTeam returns nothing
        local Unit wizard = MASTER_WIZARDS[whichTeam]
        local unit wizardSelf = wizard.self
        call PingMinimapEx( GetUnitX( wizardSelf ), GetUnitY( wizardSelf ), 5, 0, 0, 255, false )
        set wizardSelf = null
    endfunction

    //! runtextmacro Scope("SelectionGroup")
        globals
            private group SelectionGroup_ENUM_GROUP
            private group array SelectionGroup_SHIP
        endglobals

        function CreateSelectionGroup takes player whichPlayer returns group
            local group newGroup = CreateGroupWJ()
            local group sourceGroup = SelectionGroup_SHIP[GetPlayerId(whichPlayer)]
            local unit enumUnit = FirstOfGroup( sourceGroup )
            if ( enumUnit != null ) then
                loop
                    call GroupRemoveUnit( sourceGroup, enumUnit )
                    call GroupAddUnit( SelectionGroup_ENUM_GROUP, enumUnit )
                    call GroupAddUnit( newGroup, enumUnit )
                    set enumUnit = FirstOfGroup( sourceGroup )
                    exitwhen ( enumUnit == null )
                endloop
                set enumUnit = FirstOfGroup( SelectionGroup_ENUM_GROUP )
                loop
                    call GroupRemoveUnit( SelectionGroup_ENUM_GROUP, enumUnit )
                    call GroupAddUnit( sourceGroup, enumUnit )
                    set enumUnit = FirstOfGroup( SelectionGroup_ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
            set sourceGroup = null
            set TEMP_GROUP = newGroup
            set newGroup = null
            return TEMP_GROUP
        endfunction

        public function SelectionGroup_Deselect takes player whichPlayer, unit whichUnit returns nothing
            call GroupRemoveUnit(SelectionGroup_SHIP[GetPlayerId(whichPlayer)], whichUnit)
        endfunction

        public function SelectionGroup_Select takes player whichPlayer, unit whichUnit returns nothing
            call GroupAddUnit(SelectionGroup_SHIP[GetPlayerId(whichPlayer)], whichUnit)
        endfunction

        public function SelectionGroup_Init takes nothing returns nothing
            local integer iteration = MAX_PLAYER_INDEX
            set SelectionGroup_ENUM_GROUP = CreateGroupWJ()
            loop
                set SelectionGroup_SHIP[iteration] = CreateGroupWJ()
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
        endfunction
    //! runtextmacro Endscope()

    function AddUnitTeamSight takes Unit whichUnit returns nothing
        local real sightRange = GetUnitSightRange( whichUnit )
        local unit whichUnitSelf = whichUnit.self
        local integer whichUnitTeam = GetPlayerTeam( whichUnit.owner )
        local integer iteration = CountTeamPlayersAlive(whichUnitTeam)
        local real x = GetUnitX( whichUnitSelf )
        local real y = GetUnitY( whichUnitSelf )
        set whichUnitSelf = null
        loop
            exitwhen ( iteration < 0 )
            call FogModifierStart(CreateFogModifierCircleWJ( GetTeamPlayersAlive(whichUnitTeam, iteration), FOG_OF_WAR_VISIBLE, x, y, sightRange, false, false ))
            set iteration = iteration - 1
        endloop
    endfunction

    function AddUnitAllSight takes Unit whichUnit returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        local real sightRange = GetUnitSightRange( whichUnit )
        local player specificPlayer
        local unit whichUnitSelf = whichUnit.self
        local real x = GetUnitX( whichUnitSelf )
        local real y = GetUnitY( whichUnitSelf )
        set whichUnitSelf = null
        loop
            set specificPlayer = PlayerWJ(iteration)
            if (IsPlayerDead(specificPlayer) == false) then
                call FogModifierStart(CreateFogModifierCircleWJ( specificPlayer, FOG_OF_WAR_VISIBLE, x, y, sightRange, false, false ))
            endif
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set specificPlayer = null
    endfunction

    function GetTimeString takes integer count returns string
        local integer devidedCount
        local integer iteration
        local string result
        if ( count >= 86400 ) then
            return "--- Water's Footman Wars ---"
        endif
        set iteration = 1
        set result = ""
        loop
            exitwhen ( iteration > 3 )
            if ( iteration != 1 ) then
                set result = ":" + result
            endif
            set devidedCount = ( count - ( count / PowI( 60, iteration ) ) * PowI( 60, iteration ) ) / PowI( 60, iteration - 1 )
            if ( devidedCount < 10 ) then
                set result = "0" + I2S( devidedCount ) + result
            else
                set result = I2S( devidedCount ) + result
            endif
            set iteration = iteration + 1
        endloop
        return result
    endfunction

    function GetPlayerGoldCost takes integer goldCost, player whichPlayer returns integer
        if (whichPlayer != null) then
            if ( CashDiscount_ON[GetPlayerTeam( whichPlayer )] ) then
                return R2I( goldCost * CashDiscount_GOLD_COST_FACTOR )
            endif
        endif
        return goldCost
    endfunction

    function GetObjectGoldCost takes player sourceOwner, integer someObjectId returns integer
        local ItemType someItemType = GetItemTypeWJ(someObjectId)
        local UnitType someUnitType
        local ResearchType someResearchType
        if (someItemType != NULL) then
            return GetItemTypeGoldCost(someItemType)
        endif
        set someUnitType = GetUnitType(someObjectId)
        if (someUnitType != NULL) then
            return GetUnitTypeGoldCost(someUnitType)
        endif
        set someResearchType = GetResearchType(someObjectId)
        if (someResearchType != NULL) then
            return GetResearchTypeGoldCost(someResearchType, GetPlayerTechCount(sourceOwner, someObjectId, true) + 1)
        endif
        return 0
    endfunction

    function StringIf takes string s, boolean b returns string
        if (b) then
            return s
        endif
        return null
    endfunction

    function StringIfElse takes string s, string s2, boolean b returns string
        if (b) then
            return s
        endif
        return s2
    endfunction

    //! textmacro StringSetIf takes variable, setValue, flag
        if ($flag$) then
            set $variable$ = $setValue$
        endif
    //! endtextmacro

    //! runtextmacro Scope("AbilityRequiredResearch")
        function CountRequiredResearchAbilities takes integer whichResearchTypeId returns integer
            return CountIntegersInTableById( whichResearchTypeId, AbilityRequiredResearch_SCOPE_ID )
        endfunction

        function GetRequiredResearchAbility takes integer whichResearchTypeId, integer index returns integer
            return GetIntegerFromTableById( whichResearchTypeId, AbilityRequiredResearch_SCOPE_ID, index )
        endfunction

        function GetAbilityRequiredResearch takes integer whichAbility returns integer
            return GetAttachedIntegerById( whichAbility, AbilityRequiredResearch_SCOPE_ID )
        endfunction

        function SetAbilityRequiredResearch takes integer whichAbility, integer whichResearchTypeId returns nothing
            call AttachIntegerById( whichAbility, AbilityRequiredResearch_SCOPE_ID, whichResearchTypeId )
            call AddIntegerToTableById( whichResearchTypeId, AbilityRequiredResearch_SCOPE_ID, whichAbility )
        endfunction
    //! runtextmacro Endscope()

    function IsPointInPlayRegion takes real targetX, real targetY returns boolean
        if (GetTerrainCliffLevel( targetX, targetY ) != STANDARD_CLIFF_LEVEL) then
            if (IsPointInRect(targetX, targetY, CENTER_RECT) == false) then
                return false
            endif
        endif
        return true
    endfunction

    public function Init takes nothing returns nothing
        call Altar_Altar_Init()
        call SelectionGroup_SelectionGroup_Init()
        call Terrain_Terrain_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Header\Miscellaneous.j

//file: D:\Warcraft III\Mapping\WFW\Data\Header\Player.j
//TESH.scrollpos=199
//TESH.alwaysfold=0
//! runtextmacro Scope("Player")
    globals
        constant integer MAX_PLAYER_INDEX = 11
        constant integer MAX_PLAYERS_AMOUNT = 12
        constant integer MAX_PLAYERS_PER_TEAM = 3
        constant integer MAX_NEUTRAL_PLAYER_INDEX = MAX_PLAYER_INDEX + 4
        constant integer MAX_NEUTRAL_PLAYERS_AMOUNT = MAX_PLAYERS_AMOUNT + 4
        constant player NEUTRAL_AGGRESSIVE_PLAYER = Player(PLAYER_NEUTRAL_AGGRESSIVE)
        constant player NEUTRAL_PASSIVE_PLAYER = Player(PLAYER_NEUTRAL_PASSIVE)
        constant playercolor NEUTRAL_PASSIVE_PLAYER_COLOR = ConvertPlayerColor(GetPlayerId(NEUTRAL_PASSIVE_PLAYER))
        player TEMP_PLAYER
        player TEMP_PLAYER2

        private boolean array IS_PLAYER_DEAD
        private boolean array IS_PLAYER_STARTED
        private string array PLAYER_COLOR_IMAGE
        private string array PLAYER_COLOR_STRING
        private integer array PLAYER_COLOR_RED
        private integer array PLAYER_COLOR_GREEN
        private integer array PLAYER_COLOR_BLUE
        private integer array PLAYER_HERO_COUNT
        private Race array PLAYER_RACE
        private Unit array PLAYER_RESEARCH_CENTER
        private Unit array PLAYER_TOWN_HALL
    endglobals

    //! textmacro CreateSimplePlayerState takes structMember, name, type
        function GetPlayer$name$ takes player whichPlayer returns $type$
            return PLAYER_$structMember$[GetPlayerId(whichPlayer)]
        endfunction

        function SetPlayer$name$ takes player whichPlayer, $type$ value returns nothing
            set PLAYER_$structMember$[GetPlayerId(whichPlayer)] = value
        endfunction
    //! endtextmacro

    //! textmacro CreateSimpleFlagPlayerState takes structMember, name
        function IsPlayer$name$ takes player whichPlayer returns boolean
            return IS_PLAYER_$structMember$[GetPlayerId(whichPlayer)]
        endfunction

        function SetPlayer$name$ takes player whichPlayer, boolean flag returns nothing
            set IS_PLAYER_$structMember$[GetPlayerId(whichPlayer)] = flag
        endfunction
    //! endtextmacro

    function PlayerWJ takes integer index returns player
        if ( ( index < 0 ) or ( index > 15 ) ) then
            call WriteBug( "Fatal: PlayerWJ" )
            return null
        endif
        return Player( index )
    endfunction

    //! runtextmacro Scope("AbilityEnabling")
        function IsPlayerAbilityEnabled takes player whichPlayer, integer abilcode returns boolean
            return ( GetSavedBoolean( I2S(abilcode), I2S(AbilityEnabling_SCOPE_ID + GetPlayerId(whichPlayer)) ) == false )
        endfunction

        function EnablePlayerAbility takes player whichPlayer, integer abilcode, boolean flag returns nothing
            call SaveBooleanWJ( I2S(abilcode), I2S(AbilityEnabling_SCOPE_ID + GetPlayerId(whichPlayer)), flag == false )
            call SetPlayerAbilityAvailable( whichPlayer, abilcode, flag )
        endfunction
    //! runtextmacro Endscope()

    function AddPlayerState takes player whichPlayer, playerstate whichPlayerState, integer value returns nothing
        call SetPlayerState( whichPlayer, whichPlayerState, GetPlayerState( whichPlayer, whichPlayerState ) + value )
    endfunction

    //! runtextmacro Scope("Alliance")
        globals
            private integer ALLIANCES_COUNT = -1
        endglobals

        private struct Alliance_Data
            player array elements[MAX_PLAYERS_AMOUNT]
            integer count
        endstruct

        function CountAlliances takes nothing returns integer
            return ALLIANCES_COUNT
        endfunction

        function GetPlayerAllianceWJ takes player whichPlayer returns integer
            return GetAttachedInteger( whichPlayer, Alliance_SCOPE_ID )
        endfunction

        function CountAlliancePlayers takes integer whichAlliance returns integer
            local Alliance_Data d = GetSavedInteger(SCOPE_PREFIX, I2S(whichAlliance))
            return d.count
        endfunction

        function GetAlliancePlayer takes integer whichAlliance, integer index returns player
            local Alliance_Data d = GetSavedInteger(SCOPE_PREFIX, I2S(whichAlliance))
            return d.elements[index]
        endfunction

        function AddPlayerToAlliance takes player whichPlayer, integer whichAlliance returns nothing
            local integer count
            local Alliance_Data d = GetSavedInteger(SCOPE_PREFIX, I2S(whichAlliance))
            local boolean isWhichPlayerPlaying
            local integer iteration
            local player otherPlayer
            if ( d == NULL ) then
                set count = 0
                set d = Alliance_Data.create()
                set d = whichAlliance + 1
                set ALLIANCES_COUNT = ALLIANCES_COUNT + 1
                call SaveIntegerWJ(SCOPE_PREFIX, I2S(whichAlliance), d)
                call AttachInteger(whichPlayer, Alliance_SCOPE_ID, whichAlliance)
            else
                set d = Alliance_Data(whichAlliance + 1)
                set count = d.count
                set isWhichPlayerPlaying = ( GetPlayerSlotState( whichPlayer ) == PLAYER_SLOT_STATE_PLAYING )
                set iteration = count
                set count = count + 1
                loop
                    exitwhen ( iteration < 0 )
                    set otherPlayer = d.elements[iteration]
                    call SetPlayerAlliance( otherPlayer, whichPlayer, ALLIANCE_HELP_REQUEST, true )
                    call SetPlayerAlliance( otherPlayer, whichPlayer, ALLIANCE_HELP_RESPONSE, true )
                    call SetPlayerAlliance( otherPlayer, whichPlayer, ALLIANCE_PASSIVE, true )
                    call SetPlayerAlliance( otherPlayer, whichPlayer, ALLIANCE_SHARED_SPELLS, true )
                    if ( GetPlayerSlotState( otherPlayer ) == PLAYER_SLOT_STATE_PLAYING ) then
                        call SetPlayerAlliance( otherPlayer, whichPlayer, ALLIANCE_SHARED_VISION, true )
                    endif
                    call SetPlayerAlliance( otherPlayer, whichPlayer, ALLIANCE_SHARED_XP, true )
                    call SetPlayerAlliance( whichPlayer, otherPlayer, ALLIANCE_HELP_REQUEST, true )
                    call SetPlayerAlliance( whichPlayer, otherPlayer, ALLIANCE_HELP_RESPONSE, true )
                    call SetPlayerAlliance( whichPlayer, otherPlayer, ALLIANCE_PASSIVE, true )
                    call SetPlayerAlliance( whichPlayer, otherPlayer, ALLIANCE_SHARED_SPELLS, true )
                    if ( isWhichPlayerPlaying ) then
                        call SetPlayerAlliance( whichPlayer, otherPlayer, ALLIANCE_SHARED_VISION, true )
                    endif
                    call SetPlayerAlliance( whichPlayer, otherPlayer, ALLIANCE_SHARED_XP, true )
                    set iteration = iteration - 1
                endloop
            endif
            set d.elements[count] = whichPlayer
            set d.count = count
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Team")
        globals
            private player array Team_PLAYERS
            private integer array Team_PLAYERS_COUNT
        endglobals

        function CountTeamPlayers takes integer whichTeam returns integer
            return Team_PLAYERS_COUNT[whichTeam]
        endfunction

        function GetTeamPlayers takes integer whichTeam, integer index returns player
            return Team_PLAYERS[whichTeam * MAX_PLAYERS_AMOUNT + index]
        endfunction

        function AddTeamPlayers takes integer whichTeam, player whichPlayer returns nothing
            local integer count = CountTeamPlayers(whichTeam) + 1
            set Team_PLAYERS_COUNT[whichTeam] = count
            set Team_PLAYERS[whichTeam * MAX_PLAYERS_AMOUNT + count] = whichPlayer
        endfunction

        //! runtextmacro Scope("Alive")
            globals
                private player array Alive_PLAYERS_ALIVE
                private integer array Alive_PLAYERS_ALIVE_COUNT
            endglobals

            function CountTeamPlayersAlive takes integer whichTeam returns integer
                return Alive_PLAYERS_ALIVE_COUNT[whichTeam]
            endfunction

            function GetTeamPlayersAlive takes integer whichTeam, integer index returns player
                return Alive_PLAYERS_ALIVE[whichTeam * MAX_PLAYERS_AMOUNT + index]
            endfunction

            function RemoveTeamPlayersAlive takes integer whichTeam, player whichPlayer returns nothing
                local integer count = CountTeamPlayersAlive(whichTeam)
                local integer iteration = count
                loop
                    exitwhen (GetTeamPlayersAlive(whichTeam, iteration) == whichPlayer)
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                endloop
                set Alive_PLAYERS_ALIVE[whichTeam * MAX_PLAYERS_AMOUNT + iteration] = Alive_PLAYERS_ALIVE[whichTeam * MAX_PLAYERS_AMOUNT + count]
                set Alive_PLAYERS_ALIVE_COUNT[whichTeam] = count - 1
            endfunction

            function AddTeamPlayersAlive takes integer whichTeam, player whichPlayer returns nothing
                local integer count = CountTeamPlayersAlive(whichTeam) + 1
                set Alive_PLAYERS_ALIVE_COUNT[whichTeam] = count
                set Alive_PLAYERS_ALIVE[whichTeam * MAX_PLAYERS_AMOUNT + count] = whichPlayer
            endfunction

            public function Alive_Init takes nothing returns nothing
                local integer iteration = GetTeams() - 1
                loop
                    set iteration = iteration - 1
                    set Alive_PLAYERS_ALIVE_COUNT[iteration] = -1
                    exitwhen (iteration < 0)
                endloop
            endfunction
        //! runtextmacro Endscope()

        public function Team_Init takes nothing returns nothing
            local integer iteration = GetTeams() - 1
            loop
                set iteration = iteration - 1
                set Team_PLAYERS_COUNT[iteration] = -1
                exitwhen (iteration < 0)
            endloop
            call Alive_Alive_Init()
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro CreateSimpleFlagPlayerState("DEAD", "Dead")
    //! runtextmacro CreateSimpleFlagPlayerState("STARTED", "Started")

    //! runtextmacro CreateSimplePlayerState("RACE", "RaceWJ", "Race")

    //! runtextmacro CreateSimplePlayerState("HERO_COUNT", "HeroCount", "integer")
    //! runtextmacro CreateSimplePlayerState("RESEARCH_CENTER", "ResearchCenter", "Unit")
    //! runtextmacro CreateSimplePlayerState("TOWN_HALL", "TownHall", "Unit")

    //! runtextmacro CreateSimplePlayerState("COLOR_IMAGE", "ColorImage", "string")

    //! runtextmacro CreateSimplePlayerState("COLOR_STRING", "ColorString", "string")

    //! runtextmacro CreateSimplePlayerState("COLOR_RED", "ColorRed", "integer")

    //! runtextmacro CreateSimplePlayerState("COLOR_GREEN", "ColorGreen", "integer")

    //! runtextmacro CreateSimplePlayerState("COLOR_BLUE", "ColorBlue", "integer")

    scope Force
        globals
            force TEMP_FORCE
        endglobals

        function CreateForceWJ takes nothing returns force
            local force newForce = CreateForce()
            call AddObject( newForce, "Force" )
        ///    call AddSavedIntegerToTable( "Objects", "Forces", newForceId )
            set TEMP_FORCE = newForce
            set newForce = null
            return TEMP_FORCE
        endfunction

        function DestroyForceWJ takes force whichForce returns nothing
            call RemoveObject( whichForce, "Force" )
        ///    call RemoveSavedIntegerFromTable( "Objects", "Forces", whichForceId )
            call DestroyForce( whichForce )
        endfunction
    endscope

    public function Init takes nothing returns nothing
        call Team_Team_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Header\Player.j

//file: D:\Warcraft III\Mapping\WFW\Data\Header\Race.j
//TESH.scrollpos=8
//TESH.alwaysfold=0
//! runtextmacro Scope("Race")
    globals
        constant integer MAX_TOWN_HALLS_PER_RACE = 4
    endglobals

    struct Race
        UnitType researchCenter
        UnitType array townHalls[MAX_TOWN_HALLS_PER_RACE]
        integer townHallsCount
    endstruct

    globals
        Race array RACES
        integer RACES_COUNT = -1
    endglobals

    //! textmacro CreateSimpleRaceState takes structMember, name, type
        function GetRace$name$ takes Race whichRace returns $type$
            return whichRace.$structMember$
        endfunction

        function SetRace$name$ takes Race whichRace, $type$ amount returns nothing
            set whichRace.$structMember$ = amount
        endfunction
    //! endtextmacro

    //! runtextmacro CreateSimpleRaceState("researchCenter", "ResearchCenter", "integer")

    //! runtextmacro Scope("TownHall")
        function CountRaceTownHalls takes Race whichRace returns integer
            return whichRace.townHallsCount
        endfunction

        function GetRaceTownHall takes Race whichRace, integer index returns UnitType
            return whichRace.townHalls[index]
        endfunction

        function SetRaceTownHall takes Race whichRace, integer index, UnitType townHall returns nothing
            set whichRace.townHalls[index] = townHall
            set whichRace.townHallsCount = whichRace.townHallsCount + 1
        endfunction
    //! runtextmacro Endscope()

    function CreateRace takes nothing returns Race
        local Race d = Race.create()
        set RACES_COUNT = RACES_COUNT + 1
        //set d = RACES_COUNT + 1
        set d.townHallsCount = -1
        set RACES[RACES_COUNT] = d
        return d
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Header\Race.j

//file: D:\Warcraft III\Mapping\WFW\Data\Header\Unit.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Unit")
    globals
        Unit CASTER
        Unit FILTER_UNIT
        unit FILTER_UNIT_SELF
        private constant integer Stun_AMOUNT = 6
        Unit TARGET_UNIT
        Unit TEMP_UNIT
        unit TEMP_UNIT_SELF
        UnitType TEMP_UNIT_TYPE
        Unit TRIGGER_UNIT = NULL
        unit TRIGGER_UNIT_SELF
        UnitType TRIGGER_UNIT_TYPE
    endglobals

    struct UnitType
        integer array abilities[13]
        integer abilitiesCount = -1
        real agility = 0
        real agilityPerLevel = 0
        real armor = 0
        real array armorForPlayer[MAX_PLAYERS_AMOUNT]
        real array armorBySpellForPlayer[MAX_PLAYERS_AMOUNT]
        integer armorType = 0
        real array attackRateForPlayer[MAX_PLAYERS_AMOUNT]
        integer automaticAbility = 0
        string blood = null
        string bloodExplosion = null
        boolean canNotBeRevived = false
        boolean canNotBeInited = false
        real array criticalStrikeForPlayer[MAX_PLAYERS_AMOUNT]
        boolean decay = false
        real decayTime = 0
        real damage = 0
        integer damageDices = 0
        integer damageDicesSides = 0
        real array damageForPlayer[MAX_PLAYERS_AMOUNT]
        integer damageType = 0
        integer drop = 0
        integer ep = 0
        integer goldCost = 0
        integer array heroAbilities[4]
        integer heroAbilitiesCount = -1
        integer id
        string imagePath
        real impactZ = 0
        real intelligence = 0
        real intelligencePerLevel = 0
        boolean isAltar = false
        boolean isCaster = false
        boolean isMelee = false
        boolean isShared = false
        boolean isSpawn = false
        boolean isTownHall = false
        boolean isWard = false
        integer level = 0
        real lifeRegeneration = 0
        real array lifeRegenerationForPlayer[MAX_PLAYERS_AMOUNT]
        real mana = 0
        real manaRegeneration = 0
        real array manaRegenerationForPlayer[MAX_PLAYERS_AMOUNT]
        real maxLife = 0
        real array maxLifeForPlayer[MAX_PLAYERS_AMOUNT]
        real maxMana = 0
        real array maxManaForPlayer[MAX_PLAYERS_AMOUNT]
        real missileArc = 0
        integer missileDummyUnitId = 0
        real missileSpeed = 0
        real outpactZ = 0
        SoundType array pissedSounds[12]
        integer pissedSoundsCount = -1
        integer primaryAttribute = 0
        Race race = NULL
        real scale = 0
        real sightRange = 0
        integer shopMaxCharges = 0
        real shopRefreshInterval = 0
        real shopRefreshIntervalStart = 0
        integer spawnBonus = 0
        integer spawnStage = 0
        real spawnTime = 0
        real array spawnTimeForPlayer[MAX_PLAYERS_AMOUNT]
        integer spawnTypeId = 0
        boolean specialAttack = false
        real speed = 0
        real array speedForPlayer[MAX_PLAYERS_AMOUNT]
        boolean array splash[MAX_NEUTRAL_PLAYERS_AMOUNT]
        boolean splashAffectionAir = false
        boolean splashAffectionAlly = false
        boolean splashAffectionEnemy = false
        boolean splashAffectionGround = false
        real splashAreaRange = 0
        real splashDamageFactor = 0
        real splashWindowAngle = 0
        real strength = 0
        real strengthPerLevel = 0
        integer supplyProduced = 0
        integer supplyUsed = 0
        boolean upgradesInstantly = false
        real vertexColorRed = 0
        real vertexColorGreen = 0
        real vertexColorBlue = 0
        real vertexColorAlpha = 0

        static method create_Executed takes nothing returns nothing
            local integer iteration = MAX_PLAYER_INDEX
            local UnitType new = TEMP_UNIT_TYPE
            loop
                set new.armorForPlayer[iteration] = 0
                set new.armorBySpellForPlayer[iteration] = 0
                set new.attackRateForPlayer[iteration] = 0
                set new.criticalStrikeForPlayer[iteration] = 0
                set new.damageForPlayer[iteration] = 0
                set new.lifeRegenerationForPlayer[iteration] = 0
                set new.manaRegenerationForPlayer[iteration] = 0
                set new.maxLifeForPlayer[iteration] = 0
                set new.maxManaForPlayer[iteration] = 0
                set new.spawnTimeForPlayer[iteration] = 0
                set new.speedForPlayer[iteration] = 0
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
        endmethod

        static method create takes nothing returns UnitType
            set TEMP_UNIT_TYPE = UnitType.allocate()
            call UnitType.create_Executed.execute()
            return TEMP_UNIT_TYPE
        endmethod
    endstruct

    function GetUnitType takes integer whichUnitTypeId returns UnitType
        return GetAttachedIntegerById(whichUnitTypeId, UNIT_TYPE_KEY)
    endfunction

    //! textmacro CreateSimpleUnitTypeState takes structMember, name, type
        function GetUnitType$name$ takes UnitType whichUnitType returns $type$
            return whichUnitType.$structMember$
        endfunction

        function SetUnitType$name$ takes UnitType whichUnitType, $type$ amount returns nothing
            set whichUnitType.$structMember$ = amount
        endfunction
    //! endtextmacro

    //! textmacro CreateSimpleUnitTypeStateForPlayer takes structMember, name, type
        function GetUnitType$name$ForPlayer takes UnitType whichUnitType, player whichPlayer returns $type$
            return whichUnitType.$structMember$ForPlayer[GetPlayerId(whichPlayer)]
        endfunction

        function SetUnitType$name$ForPlayer takes UnitType whichUnitType, player whichPlayer, $type$ amount returns nothing
            set whichUnitType.$structMember$ForPlayer[GetPlayerId(whichPlayer)] = amount
        endfunction

        function AddUnitType$name$ForPlayer takes UnitType whichUnitType, player whichPlayer, $type$ amount returns nothing
            call SetUnitType$name$ForPlayer(whichUnitType, whichPlayer, GetUnitType$name$ForPlayer(whichUnitType, whichPlayer) + amount)
        endfunction
    //! endtextmacro

    //! textmacro CreateSimpleFlagUnitTypeState takes structMember, name
        function IsUnitType$name$ takes UnitType whichUnitType returns boolean
            return whichUnitType.$structMember$
        endfunction

        function SetUnitType$name$ takes UnitType whichUnitType returns nothing
            set whichUnitType.$structMember$ = true
        endfunction
    //! endtextmacro

    //! runtextmacro CreateSimpleFlagUnitTypeState("canNotBeRevived", "CanNotBeRevived")
    //! runtextmacro CreateSimpleFlagUnitTypeState("canNotBeInited", "CanNotBeInited")
    //! runtextmacro CreateSimpleFlagUnitTypeState("decay", "Decay")
    //! runtextmacro CreateSimpleFlagUnitTypeState("specialAttack", "SpecialAttack")

    //! runtextmacro Scope("Splash")
        function IsUnitTypeSplashForPlayer takes UnitType whichUnitType, player whichPlayer returns boolean
            return whichUnitType.splash[GetPlayerId(whichPlayer)]
        endfunction

        function SetUnitTypeSplashForPlayer takes UnitType whichUnitType, player whichPlayer returns nothing
            set whichUnitType.splash[GetPlayerId(whichPlayer)] = true
        endfunction

        function SetUnitTypeSplash takes UnitType whichUnitType returns nothing
            local integer iteration = MAX_NEUTRAL_PLAYER_INDEX
            loop
                call SetUnitTypeSplashForPlayer(whichUnitType, PlayerWJ(iteration))
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro CreateSimpleUnitTypeState("goldCost", "GoldCost", "integer")
    //! runtextmacro CreateSimpleUnitTypeState("imagePath", "Image", "string")
    //! runtextmacro CreateSimpleUnitTypeState("primaryAttribute", "PrimaryAttribute", "integer")
    //! runtextmacro CreateSimpleUnitTypeState("race", "Race", "Race")
    //! runtextmacro CreateSimpleUnitTypeState("mana", "StartMana", "real")

    //! runtextmacro CreateSimpleUnitTypeState("missileArc", "MissileArc", "real")
    //! runtextmacro CreateSimpleUnitTypeState("missileDummyUnitId", "MissileDummyUnitId", "integer")
    //! runtextmacro CreateSimpleUnitTypeState("missileSpeed", "MissileSpeed", "real")

    //! runtextmacro CreateSimpleFlagUnitTypeState("isAltar", "Altar")
    //! runtextmacro CreateSimpleFlagUnitTypeState("isCaster", "Caster")
    //! runtextmacro CreateSimpleFlagUnitTypeState("isMelee", "Melee")
    //! runtextmacro CreateSimpleFlagUnitTypeState("isShared", "Shared")
    //! runtextmacro CreateSimpleFlagUnitTypeState("isSpawn", "Spawn")
    //! runtextmacro CreateSimpleFlagUnitTypeState("isTownHall", "TownHall")
    //! runtextmacro CreateSimpleFlagUnitTypeState("isWard", "Ward")

    //! runtextmacro CreateSimpleFlagUnitTypeState("splashAffectionAir", "SplashAffectionAir")
    //! runtextmacro CreateSimpleFlagUnitTypeState("splashAffectionAlly", "SplashAffectionAlly")
    //! runtextmacro CreateSimpleFlagUnitTypeState("splashAffectionEnemy", "SplashAffectionEnemy")
    //! runtextmacro CreateSimpleFlagUnitTypeState("splashAffectionGround", "SplashAffectionGround")
    //! runtextmacro CreateSimpleUnitTypeState("splashAreaRange", "SplashAreaRange", "real")
    //! runtextmacro CreateSimpleUnitTypeState("splashDamageFactor", "SplashDamageFactor", "real")
    //! runtextmacro CreateSimpleUnitTypeState("splashWindowAngle", "SplashWindowAngle", "real")

    //! runtextmacro CreateSimpleFlagUnitTypeState("upgradesInstantly", "UpgradesInstantly")

    struct Unit
        real agility = 0
        real agilityBonus = 0
        integer anyDamageEvents = 0
        real armor = 0
        real armorBonus = 0
        real armorBreakRelativeBonus = 0
        real armorBySpellBonus = 0
        real armorRelativeBonus = 0
        real attackRate = 0
        integer attackSilence = 0
        integer automaticAbility = 0
        real criticalStrike = 0
        real criticalStrikeDefense = 0
        integer criticalStrikeImmunity = 0
        integer currentUpgradeGoldCost = 0
        string blood = null
        string bloodExplosion = null
        integer canNotBeRevived = 0
        real damage = 0
        real damageBonus = 0
        real damageBySpellBonus = 0
        real damageRelativeBonus = 0
        boolean dead = false
        integer decay = 0
        real decayTime = 0
        integer drop = 0
        integer dropBonus = 0
        integer dropByKillBonus = 0
        real dropByKillRelativeBonus = 0
        real evasion = 0
        integer explode = 0
        integer frostSlow = 0
        effect frostSlowEffect = null
        integer ghost = 0
        integer goldSpentInUpgrades = 0
        real healBySpell = 0
        integer id
        real impactZ = 0
        real intelligence = 0
        real intelligenceBonus = 0
        integer invisibility = 0
        integer invulnerability = 0
        integer invulnerabilityEffectAmount = 0
        effect invulnerabilityEffect = null
        integer level = 0
        real lifeRegeneration = 0
        real lifeRegenerationBonus = 0
        integer magicImmunity = 0
        real manaRegeneration = 0
        real manaRegenerationBonus = 0
        real maxLife = 0
        real maxMana = 0
        real miss = 0
        real outpactZ = 0
        widget orderTarget = null
        real orderX = 0
        real orderY = 0
        player owner
        integer pathing = 1
        integer pause = 0
        real rallyX = 0
        real rallyY = 0
        integer remainingReferences = 0
        integer revaluation = 0
        real scale = 0
        real array scaleForPlayer[MAX_PLAYERS_AMOUNT]
        unit self
        real sightRange = 0
        integer silence = 0
        real speed = 0
        real speedBonus = 0
        real strength = 0
        real strengthBonus = 0
        integer array stun[Stun_AMOUNT]
        integer stunEntanglingRoots = 0
        real stunDurationRelativeBonus = 0
        effect array stunEffect[Stun_AMOUNT]
        integer stunEnsnare = 0
        integer stunThunderbolt = 0
        integer supplyProduced = 0
        integer supplyUsed = 0
        UnitType type
        real vertexColorRed = 0
        real array vertexColorRedForPlayer[MAX_PLAYERS_AMOUNT]
        real vertexColorGreen = 0
        real array vertexColorGreenForPlayer[MAX_PLAYERS_AMOUNT]
        real vertexColorBlue = 0
        real array vertexColorBlueForPlayer[MAX_PLAYERS_AMOUNT]
        real vertexColorAlpha = 0
        real array vertexColorAlphaForPlayer[MAX_PLAYERS_AMOUNT]
        boolean waitsForRemoval = false

        static method create_Executed takes nothing returns nothing
            local integer iteration = MAX_PLAYER_INDEX
            local Unit new = TEMP_UNIT
            loop
                set new.scaleForPlayer[iteration] = 0
                set new.vertexColorRedForPlayer[iteration] = 0
                set new.vertexColorGreenForPlayer[iteration] = 0
                set new.vertexColorBlueForPlayer[iteration] = 0
                set new.vertexColorAlphaForPlayer[iteration] = 0
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
        endmethod

        static method create takes nothing returns Unit
            set TEMP_UNIT = Unit.allocate()
            call Unit.create_Executed.execute()
            return TEMP_UNIT
        endmethod
    endstruct

    function GetUnit takes unit whichUnit returns Unit
        return GetAttachedInteger(whichUnit, UNIT_KEY)
    endfunction

    //! textmacro CreateSimpleUnitState takes structMember, name, type
        function GetUnit$name$ takes Unit whichUnit returns $type$
            return whichUnit.$structMember$
        endfunction

        function SetUnit$name$ takes Unit whichUnit, $type$ amount returns nothing
            set whichUnit.$structMember$ = amount
        endfunction

        function AddUnit$name$ takes Unit whichUnit, $type$ amount returns nothing
            call SetUnit$name$( whichUnit, GetUnit$name$(whichUnit) + amount)
        endfunction
    //! endtextmacro

    //! textmacro CreateSimpleAddUnitState takes structMember, name, type
        function GetUnit$name$ takes Unit whichUnit returns $type$
            return whichUnit.$structMember$
        endfunction

        function RemoveUnit$name$ takes Unit whichUnit returns nothing
            set whichUnit.$structMember$ = GetUnit$name$(whichUnit) - 1
        endfunction

        function SetUnit$name$ takes Unit whichUnit, $type$ amount returns nothing
            set whichUnit.$structMember$ = amount
        endfunction

        function AddUnit$name$ takes Unit whichUnit returns nothing
            call SetUnit$name$( whichUnit, GetUnit$name$(whichUnit) + 1)
        endfunction
    //! endtextmacro

    //! textmacro CreateSimpleFlagUnitState takes structMember, name
        function IsUnit$name$ takes Unit whichUnit returns boolean
            return whichUnit.$structMember$
        endfunction

        function SetUnit$name$ takes Unit whichUnit, boolean flag returns nothing
            set whichUnit.$structMember$ = flag
        endfunction
    //! endtextmacro

    //! textmacro CreateSimpleFlagCountUnitState takes structMember, name
        function GetUnit$name$ takes Unit whichUnit returns integer
            return whichUnit.$structMember$
        endfunction

        function RemoveUnit$name$ takes Unit whichUnit returns nothing
            set whichUnit.$structMember$ = GetUnit$name$(whichUnit) - 1
        endfunction

        function SetUnit$name$ takes Unit whichUnit, integer amount returns nothing
            set whichUnit.$structMember$ = amount
        endfunction

        function AddUnit$name$ takes Unit whichUnit returns nothing
            set whichUnit.$structMember$ = GetUnit$name$(whichUnit) + 1
        endfunction

        function AddUnit$name$ByAmount takes Unit whichUnit, integer amount returns nothing
            set whichUnit.$structMember$ = GetUnit$name$(whichUnit) + amount
        endfunction
    //! endtextmacro

    //! runtextmacro CreateSimpleFlagCountUnitState("anyDamageEvents", "AnyDamageEvents")
    //! runtextmacro CreateSimpleFlagCountUnitState("canNotBeRevived", "CanNotBeRevived")
    //! runtextmacro CreateSimpleFlagUnitState("dead", "Dead")
    //! runtextmacro CreateSimpleFlagCountUnitState("decay", "Decay")
    //! runtextmacro CreateSimpleUnitState("goldSpentInUpgrades", "GoldSpentInUpgrades", "integer")

    scope AutomaticAbility
        function GetUnitAutomaticAbility takes Unit whichUnit returns integer
            return whichUnit.automaticAbility
        endfunction

        function SetUnitAutomaticAbility takes Unit whichUnit, integer whichAbility returns nothing
            set whichUnit.automaticAbility = whichAbility
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("automaticAbility", "AutomaticAbility", "integer")
    endscope

    function IsUnitWard takes Unit whichUnit returns boolean
        return IsUnitTypeWard( GetUnitType(GetUnitTypeId(whichUnit.self)) )
    endfunction

    //! runtextmacro Scope("OutpactZ")
        //! runtextmacro CreateSimpleUnitState("outpactZ", "OutpactZ", "real")

        //! runtextmacro CreateSimpleUnitTypeState("outpactZ", "OutpactZ", "real")
    //! runtextmacro Endscope()

    //! runtextmacro Scope("ImpactZ")
        //! runtextmacro CreateSimpleUnitState("impactZ", "ImpactZ", "real")

        function GetUnitTypeImpactZ takes UnitType whichUnitType returns real
            return whichUnitType.impactZ
        endfunction

        function SetUnitTypeImpactZ takes UnitType whichUnitType, real amount returns nothing
            set whichUnitType.impactZ = amount
            call SetUnitTypeOutpactZ(whichUnitType, amount)
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Decay")

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //! runtextmacro CreateSimpleUnitState("decayTime", "DecayTime", "real")

        //! runtextmacro CreateSimpleUnitTypeState("decayTime", "DecayTime", "real")
    //! runtextmacro Endscope()

    //! runtextmacro Scope("UpdateUnitDisplay")
        globals
            private constant integer DUMMY_SPELL_ID = 'A012'
        endglobals

        function UpdateUnitDisplay takes unit whichUnit returns nothing
            call UnitAddAbility( whichUnit, DUMMY_SPELL_ID )
            call UnitRemoveAbility( whichUnit, DUMMY_SPELL_ID )
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("EP")
        function GetUnitEP takes unit whichUnit returns integer
            return GetHeroXP( whichUnit )
        endfunction

        function SetUnitEP takes unit whichUnit, real amount returns nothing
            call SetHeroXP( whichUnit, R2I( amount ), false )
            call UpdateUnitDisplay(whichUnit)
        endfunction

        function AddUnitEP takes unit whichUnit, real amount returns nothing
            call SetUnitEP( whichUnit, GetUnitEP( whichUnit ) + amount )
        endfunction

        function SetUnitSkillPointsWJ takes unit whichUnit, integer amount returns nothing
            call UnitModifySkillPoints( whichUnit, amount - GetHeroSkillPoints( whichUnit ) )
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("ep", "EP", "integer")
    //! runtextmacro Endscope()

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Supply")
        function GetUnitSupplyProduced takes Unit whichUnit returns integer
            return whichUnit.supplyProduced
        endfunction

        function SetUnitSupplyProduced takes Unit whichUnit, player whichUnitOwner, integer amount returns nothing
            local integer oldAmount = GetUnitSupplyProduced( whichUnit )
            set whichUnit.supplyProduced = amount
            call AddPlayerState( whichUnitOwner, PLAYER_STATE_RESOURCE_FOOD_CAP, amount - oldAmount )
        endfunction

        function AddUnitSupplyProduced takes Unit whichUnit, player whichUnitOwner, integer amount returns nothing
            call SetUnitSupplyProduced( whichUnit, whichUnitOwner, GetUnitSupplyProduced( whichUnit ) + amount )
        endfunction

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitTypeState("supplyProduced", "SupplyProduced", "integer")

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        function GetUnitSupplyUsed takes Unit whichUnit returns integer
            return whichUnit.supplyUsed
        endfunction

        function SetUnitSupplyUsed takes Unit whichUnit, player whichUnitOwner, integer amount returns nothing
            local integer oldAmount = GetUnitSupplyUsed( whichUnit )
            set whichUnit.supplyUsed = amount
            call AddPlayerState( whichUnitOwner, PLAYER_STATE_RESOURCE_FOOD_USED, amount - oldAmount )
        endfunction

        function AddUnitSupplyUsed takes Unit whichUnit, player whichUnitOwner, integer amount returns nothing
            call SetUnitSupplyUsed( whichUnit, whichUnitOwner, GetUnitSupplyUsed( whichUnit ) + amount )
        endfunction

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitTypeState("supplyUsed", "SupplyUsed", "integer")
    //! runtextmacro Endscope()

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function GetUnitFacingWJ takes unit whichUnit returns real
        return GetUnitFacing( whichUnit ) * DEG_TO_RAD
    endfunction

    function GetUnitLevelWJ takes UnitType whichUnitType returns integer
        return whichUnitType.level
    endfunction

    function GetUnitCurrentTarget takes Unit whichUnit returns widget
        return whichUnit.orderTarget
    endfunction

    function GetUnitCurrentX takes Unit whichUnit returns real
        return whichUnit.orderX
    endfunction

    function GetUnitCurrentY takes Unit whichUnit returns real
        return whichUnit.orderX
    endfunction

    function SetUnitFacingWJ takes unit whichUnit, real angle returns nothing
        call SetUnitFacing( whichUnit, angle * RAD_TO_DEG )
    endfunction

    function AddUnitState takes unit whichUnit, unitstate whichUnitState, real value returns nothing
        call SetUnitState( whichUnit, whichUnitState, GetUnitState( whichUnit, whichUnitState ) + value )
    endfunction

    function DispelUnit takes Unit whichUnit, boolean negativeBuffs, boolean positiveBuffs, boolean showGraphics returns nothing
        set UnitIsDispelled_NEGATIVE_BUFFS = negativeBuffs
        set UnitIsDispelled_POSITIVE_BUFFS = positiveBuffs
        set UnitIsDispelled_SHOW_GRAPHICS = showGraphics
        set TRIGGER_UNIT = whichUnit
        call RunTrigger( UnitIsDispelled_DUMMY_TRIGGER )
    endfunction

    function IsUnitChanneling takes Unit whichUnit returns boolean
        return false
    endfunction

    function UnitHasItemOfType takes Unit whichUnit, integer whichItemTypeId returns boolean
        local integer inventorySize
        local unit whichUnitSelf = whichUnit.self
        local integer iteration = UnitInventorySize( whichUnitSelf ) - 1
        loop
            exitwhen ( iteration < 0 )
            if ( GetItemTypeId( UnitItemInSlot( whichUnitSelf, iteration ) ) == whichItemTypeId ) then
                return true
            endif
            set iteration = iteration - 1
        endloop
        set whichUnitSelf = null
        return false
    endfunction

    function InitAbility takes integer abilcode returns nothing
        //call UnitAddAbility( WORLD_CASTER, abilcode )
        call UnitRemoveAbility( WORLD_CASTER, abilcode )
    endfunction

    function UnitApplyTimedLifeWJ takes unit whichUnit, real time returns nothing
        call UnitApplyTimedLife( whichUnit, 'BTLF', time )
    endfunction

    function SetUnitOwnerWJ takes Unit whichUnit, player whichPlayer, boolean changeColor returns nothing
        local unit whichUnitSelf = whichUnit.self
        if ( changeColor ) then
            call SetUnitColor( whichUnitSelf, GetPlayerColor( whichPlayer ) )
        endif
        call SetUnitOwner( whichUnitSelf, whichPlayer, false )
        set whichUnitSelf = null
    endfunction

    //! runtextmacro Scope("Position")
        globals
            private item DUMMY_ITEM
        endglobals

        function SetUnitXWJ takes unit whichUnit, real x returns nothing
            if ( x < PLAY_RECT_MIN_X ) then
        debug call WriteBug( "Unterschreitung MapX: " + GetUnitName( whichUnit ) + "; " + R2S( x ) )
                set x = PLAY_RECT_MIN_X
            elseif ( x > PLAY_RECT_MAX_X ) then
        debug call WriteBug( "Ueberschreitung MapX: " + GetUnitName( whichUnit ) + "; " + R2S( x ) )
                set x = PLAY_RECT_MAX_X
            endif
            call SetUnitX( whichUnit, x )
        endfunction

        function SetUnitYWJ takes unit whichUnit, real y returns nothing
            if ( y < PLAY_RECT_MIN_Y ) then
        debug call WriteBug( "Unterschreitung MapY: " + GetUnitName( whichUnit ) + "; " + R2S( y ) )
                set y = PLAY_RECT_MIN_Y
            elseif ( y > PLAY_RECT_MAX_Y ) then
        debug call WriteBug( "Ueberschreitung MapY: " + GetUnitName( whichUnit ) + "; " + R2S( y ) )
                set y = PLAY_RECT_MAX_Y
            endif
            call SetUnitY( whichUnit, y )
        endfunction

        //! runtextmacro Scope("SetUnitZ")
            globals
                private constant integer SetUnitZ_DUMMY_SPELL_ID = 'Amrf'
            endglobals

            function GetUnitZ takes unit whichUnit, real x, real y returns real
                return GetFloorHeight( x, y ) + GetUnitFlyHeight( whichUnit )
            endfunction

            function SetUnitZ takes unit whichUnit, real x, real y, real z returns nothing
                call SetUnitFlyHeight( whichUnit, z - GetFloorHeight( x, y ), 0 )
            endfunction

            function InitUnitZ takes unit whichUnit returns nothing
                call UnitAddAbility(whichUnit, SetUnitZ_DUMMY_SPELL_ID)
                call UnitRemoveAbility(whichUnit, SetUnitZ_DUMMY_SPELL_ID)
            endfunction
        //! runtextmacro Endscope()

        function SetUnitXIfNotBlocked takes unit whichUnit, real oldX, real oldY, real x returns boolean
            call SetItemPosition( DUMMY_ITEM, x, oldY )
            if ( ( Absolute( GetItemX( DUMMY_ITEM ) - x ) < 1 ) and ( Absolute( GetItemY( DUMMY_ITEM ) - oldY ) < 1 ) ) then
                call SetUnitX( whichUnit, x )
                return false
            endif
            return true
        endfunction

        function SetUnitYIfNotBlocked takes unit whichUnit, real oldX, real oldY, real y returns boolean
            call SetItemPosition( DUMMY_ITEM, oldX, y )
            if ( ( Absolute( GetItemX( DUMMY_ITEM ) - oldX ) < 1 ) and ( Absolute( GetItemY( DUMMY_ITEM ) - y ) < 1 ) ) then
                call SetUnitY( whichUnit, y )
                return false
            endif
            return true
        endfunction

        function SetUnitXYIfNotBlocked takes unit whichUnit, real oldX, real oldY, real x, real y returns boolean
            if ( SetUnitXIfNotBlocked( whichUnit, oldX, oldY, x ) ) then
                if ( SetUnitYIfNotBlocked( whichUnit, x, oldY, y ) ) then
                    return true
                endif
            else
                call SetUnitYIfNotBlocked( whichUnit, oldX, oldY, y )
            endif
            return false
        endfunction

        public function Position_Init takes nothing returns nothing
            set DUMMY_ITEM = CreateHiddenItem('I014')
        endfunction
    //! runtextmacro Endscope()

    function CheckMoveEvents takes Unit whichUnit, real x, real y, real z returns nothing
        set TRIGGER_UNIT = whichUnit
        set UnitIsMoveChecked_X = x
        set UnitIsMoveChecked_Y = y
        set UnitIsMoveChecked_Z = z
        call RunTrigger(UnitIsMoveChecked_DUMMY_TRIGGER)
    endfunction

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Armor
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Armor")
        //! runtextmacro Scope("Base")
            //! runtextmacro CreateSimpleUnitState("armor", "Armor", "real")
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Bonus")
            globals
                private constant integer Bonus_DECREASING_ABILITIES_MAX = 6
                private integer array Bonus_DECREASING_ABILITIES
                private constant integer Bonus_INCREASING_ABILITIES_MAX = 6
                private integer array Bonus_INCREASING_ABILITIES
            endglobals

            function GetUnitArmorBonus takes Unit whichUnit returns real
                return whichUnit.armorBonus
            endfunction

            function SetUnitArmorBonus takes Unit whichUnit, real amount returns nothing
                local integer packet
                local integer packetLevel
                local real previousAmount = GetUnitArmorBonus(whichUnit)
                local unit whichUnitSelf = whichUnit.self
                set whichUnit.armorBonus = amount
                if (amount * previousAmount <= 0) then
                    if (previousAmount < 0) then
                        set packetLevel = Bonus_DECREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    else
                        set packetLevel = Bonus_INCREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    endif
                    if (amount < 0) then
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set amount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set amount = amount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set amount = amount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                else
                    set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                    set packet = R2I(Pow(2, packetLevel))
                    if (amount < 0) then
                        set amount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set amount = amount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                    set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                    set packet = R2I(Pow(2, packetLevel))
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set amount = amount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                endif
                set whichUnitSelf = null
            endfunction

            function AddUnitArmorBonus takes Unit whichUnit, real amount returns nothing
                call SetUnitArmorBonus( whichUnit, GetUnitArmorBonus( whichUnit ) + amount )
            endfunction

            public function Bonus_Init takes nothing returns nothing
                set Bonus_DECREASING_ABILITIES[0] = 'A00U'
                set Bonus_DECREASING_ABILITIES[1] = 'A06E'
                set Bonus_DECREASING_ABILITIES[2] = 'A06F'
                set Bonus_DECREASING_ABILITIES[3] = 'A06G'
                set Bonus_DECREASING_ABILITIES[4] = 'A06H'
                set Bonus_DECREASING_ABILITIES[5] = 'A06I'
                set Bonus_DECREASING_ABILITIES[6] = 'A06J'

                set Bonus_INCREASING_ABILITIES[0] = 'A00T'
                set Bonus_INCREASING_ABILITIES[1] = 'A068'
                set Bonus_INCREASING_ABILITIES[2] = 'A069'
                set Bonus_INCREASING_ABILITIES[3] = 'A06A'
                set Bonus_INCREASING_ABILITIES[4] = 'A06B'
                set Bonus_INCREASING_ABILITIES[5] = 'A06C'
                set Bonus_INCREASING_ABILITIES[6] = 'A06D'
            endfunction
        //! runtextmacro Endscope()

        function GetUnitArmorTotal takes Unit whichUnit returns real
            return (GetUnitArmor(whichUnit) + GetUnitArmorBonus(whichUnit))
        endfunction

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitTypeState("armor", "Armor", "real")

        //! runtextmacro CreateSimpleUnitTypeStateForPlayer("armor", "Armor", "real")

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitState("armorRelativeBonus", "ArmorRelativeBonus", "real")

        //! runtextmacro CreateSimpleUnitState("armorBreakRelativeBonus", "ArmorBreakRelativeBonus", "real")

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitState("armorBySpellBonus", "ArmorBySpellBonus", "real")

        //! runtextmacro CreateSimpleUnitTypeStateForPlayer("armorBySpell", "ArmorBySpell", "real")

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitTypeState("armorType", "ArmorType", "integer")

        public function Armor_Init takes nothing returns nothing
            call Bonus_Bonus_Init()
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Attack
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Attack")
        //! runtextmacro Scope("AttackMultiplier")
            globals
                constant integer ARMOR_TYPE_LIGHT = 0
                constant integer ARMOR_TYPE_MEDIUM = 1
                constant integer ARMOR_TYPE_LARGE = 2
                constant integer ARMOR_TYPE_FORT = 3
                constant integer ARMOR_TYPE_HERO = 4
                constant integer ARMOR_TYPE_UNARMORED = 5
                constant integer ARMOR_TYPE_DIVINE = 6

                private constant integer ARMOR_TYPES_AMOUNT = 7
                private real array ATTACK_MULTIPLIERS

                constant integer DMG_TYPE_NORMAL = 0
                constant integer DMG_TYPE_PIERCE = 1
                constant integer DMG_TYPE_SIEGE = 2
                constant integer DMG_TYPE_MAGIC = 3
                constant integer DMG_TYPE_CHAOS = 4
                constant integer DMG_TYPE_HERO = 5
                constant integer DMG_TYPE_SPELLS = 6
            endglobals

            function GetAttackMultiplier takes integer whichDamageType, integer whichArmorType returns real
                return ATTACK_MULTIPLIERS[whichDamageType * ARMOR_TYPES_AMOUNT + whichArmorType]
            endfunction

            private function InitAttackMultiplier takes integer whichDamageType, integer whichArmorType, real amount returns nothing
                set ATTACK_MULTIPLIERS[whichDamageType * ARMOR_TYPES_AMOUNT + whichArmorType] = amount
            endfunction

            public function AttackMultiplier_Init takes nothing returns nothing
                call InitAttackMultiplier(DMG_TYPE_NORMAL, ARMOR_TYPE_LIGHT, 1)
                call InitAttackMultiplier(DMG_TYPE_NORMAL, ARMOR_TYPE_MEDIUM, 1.35)
                call InitAttackMultiplier(DMG_TYPE_NORMAL, ARMOR_TYPE_LARGE, 1)
                call InitAttackMultiplier(DMG_TYPE_NORMAL, ARMOR_TYPE_FORT, 0.7)
                call InitAttackMultiplier(DMG_TYPE_NORMAL, ARMOR_TYPE_HERO, 1)
                call InitAttackMultiplier(DMG_TYPE_NORMAL, ARMOR_TYPE_UNARMORED, 1)
                call InitAttackMultiplier(DMG_TYPE_NORMAL, ARMOR_TYPE_DIVINE, 1)

                call InitAttackMultiplier(DMG_TYPE_PIERCE, ARMOR_TYPE_LIGHT, 1.5)
                call InitAttackMultiplier(DMG_TYPE_PIERCE, ARMOR_TYPE_MEDIUM, 0.7)
                call InitAttackMultiplier(DMG_TYPE_PIERCE, ARMOR_TYPE_LARGE, 1)
                call InitAttackMultiplier(DMG_TYPE_PIERCE, ARMOR_TYPE_FORT, 0.35)
                call InitAttackMultiplier(DMG_TYPE_PIERCE, ARMOR_TYPE_HERO, 0.5)
                call InitAttackMultiplier(DMG_TYPE_PIERCE, ARMOR_TYPE_UNARMORED, 1.35)
                call InitAttackMultiplier(DMG_TYPE_PIERCE, ARMOR_TYPE_DIVINE, 1)

                call InitAttackMultiplier(DMG_TYPE_SIEGE, ARMOR_TYPE_LIGHT, 1)
                call InitAttackMultiplier(DMG_TYPE_SIEGE, ARMOR_TYPE_MEDIUM, 0.65)
                call InitAttackMultiplier(DMG_TYPE_SIEGE, ARMOR_TYPE_LARGE, 1)
                call InitAttackMultiplier(DMG_TYPE_SIEGE, ARMOR_TYPE_FORT, 1.5)
                call InitAttackMultiplier(DMG_TYPE_SIEGE, ARMOR_TYPE_HERO, 0.35)
                call InitAttackMultiplier(DMG_TYPE_SIEGE, ARMOR_TYPE_UNARMORED, 1)
                call InitAttackMultiplier(DMG_TYPE_SIEGE, ARMOR_TYPE_DIVINE, 1)

                call InitAttackMultiplier(DMG_TYPE_MAGIC, ARMOR_TYPE_LIGHT, 1.25)
                call InitAttackMultiplier(DMG_TYPE_MAGIC, ARMOR_TYPE_MEDIUM, 0.75)
                call InitAttackMultiplier(DMG_TYPE_MAGIC, ARMOR_TYPE_LARGE, 1.5)
                call InitAttackMultiplier(DMG_TYPE_MAGIC, ARMOR_TYPE_FORT, 0.35)
                call InitAttackMultiplier(DMG_TYPE_MAGIC, ARMOR_TYPE_HERO, 0.5)
                call InitAttackMultiplier(DMG_TYPE_MAGIC, ARMOR_TYPE_UNARMORED, 1)
                call InitAttackMultiplier(DMG_TYPE_MAGIC, ARMOR_TYPE_DIVINE, 1)

                call InitAttackMultiplier(DMG_TYPE_CHAOS, ARMOR_TYPE_LIGHT, 1)
                call InitAttackMultiplier(DMG_TYPE_CHAOS, ARMOR_TYPE_MEDIUM, 1)
                call InitAttackMultiplier(DMG_TYPE_CHAOS, ARMOR_TYPE_LARGE, 1)
                call InitAttackMultiplier(DMG_TYPE_CHAOS, ARMOR_TYPE_FORT, 1)
                call InitAttackMultiplier(DMG_TYPE_CHAOS, ARMOR_TYPE_HERO, 1)
                call InitAttackMultiplier(DMG_TYPE_CHAOS, ARMOR_TYPE_UNARMORED, 1)
                call InitAttackMultiplier(DMG_TYPE_CHAOS, ARMOR_TYPE_DIVINE, 1)

                call InitAttackMultiplier(DMG_TYPE_HERO, ARMOR_TYPE_LIGHT, 1)
                call InitAttackMultiplier(DMG_TYPE_HERO, ARMOR_TYPE_MEDIUM, 1)
                call InitAttackMultiplier(DMG_TYPE_HERO, ARMOR_TYPE_LARGE, 1)
                call InitAttackMultiplier(DMG_TYPE_HERO, ARMOR_TYPE_FORT, 1)
                call InitAttackMultiplier(DMG_TYPE_HERO, ARMOR_TYPE_HERO, 1)
                call InitAttackMultiplier(DMG_TYPE_HERO, ARMOR_TYPE_UNARMORED, 1)
                call InitAttackMultiplier(DMG_TYPE_HERO, ARMOR_TYPE_DIVINE, 1)

                call InitAttackMultiplier(DMG_TYPE_SPELLS, ARMOR_TYPE_LIGHT, 1)
                call InitAttackMultiplier(DMG_TYPE_SPELLS, ARMOR_TYPE_MEDIUM, 1)
                call InitAttackMultiplier(DMG_TYPE_SPELLS, ARMOR_TYPE_LARGE, 1)
                call InitAttackMultiplier(DMG_TYPE_SPELLS, ARMOR_TYPE_FORT, 0.5)
                call InitAttackMultiplier(DMG_TYPE_SPELLS, ARMOR_TYPE_HERO, 1)
                call InitAttackMultiplier(DMG_TYPE_SPELLS, ARMOR_TYPE_UNARMORED, 1)
                call InitAttackMultiplier(DMG_TYPE_SPELLS, ARMOR_TYPE_DIVINE, 1)
            endfunction
        //! runtextmacro Endscope()

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro Scope("Silence")
            globals
                private constant integer Silence_DUMMY_SPELL_ID = 'Abun'
                private constant integer Silence_ICON_DUMMY_SPELL_ID = 'A08P'
            endglobals

            function GetUnitAttackSilence takes Unit whichUnit returns integer
                return whichUnit.attackSilence
            endfunction

            function RemoveUnitAttackSilence takes Unit whichUnit returns nothing
                local integer amount = GetUnitAttackSilence( whichUnit ) - 1
                local unit whichUnitSelf
                set whichUnit.attackSilence = amount
                if ( amount == 0 ) then
                    set whichUnitSelf = whichUnit.self
                    call UnitRemoveAbility( whichUnitSelf, Silence_DUMMY_SPELL_ID )
                    call UnitRemoveAbility( whichUnitSelf, Silence_ICON_DUMMY_SPELL_ID )
                    set whichUnitSelf = null
                endif
            endfunction

            function AddUnitAttackSilence takes Unit whichUnit returns nothing
                local integer amount = GetUnitAttackSilence( whichUnit ) + 1
                local unit whichUnitSelf
                set whichUnit.attackSilence = amount
                if ( amount == 1 ) then
                    set whichUnitSelf = whichUnit.self
                    call UnitAddAbility( whichUnitSelf, Silence_DUMMY_SPELL_ID )
                    call UnitAddAbility( whichUnitSelf, Silence_ICON_DUMMY_SPELL_ID )
                    set whichUnitSelf = null
                endif
            endfunction

            public function Silence_Init takes nothing returns nothing
                call InitAbility(Silence_DUMMY_SPELL_ID)
            endfunction
        //! runtextmacro Endscope()

        public function Attack_Init takes nothing returns nothing
            call AttackMultiplier_AttackMultiplier_Init()
            call Silence_Silence_Init()
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Blood
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Blood")
        //! runtextmacro CreateSimpleUnitState("blood", "Blood", "string")

        //! runtextmacro CreateSimpleUnitTypeState("blood", "Blood", "string")

        //! runtextmacro CreateSimpleUnitState("bloodExplosion", "BloodExplosion", "string")

        //! runtextmacro CreateSimpleUnitTypeState("bloodExplosion", "BloodExplosion", "string")
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pause
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Pause")
        function RemoveUnitPause takes Unit whichUnit returns nothing
            local integer amount = whichUnit.pause - 1
            set whichUnit.pause = amount
            if (amount == 0) then
                call PauseUnit( whichUnit.self, false )
            endif
        endfunction

        function AddUnitPause takes Unit whichUnit returns nothing
            local integer amount = whichUnit.pause + 1
            set whichUnit.pause = amount
            if (amount == 1) then
                call PauseUnit( whichUnit.self, true )
            endif
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Critical Strike
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("CriticalStrike")
        globals
            constant real CRITICAL_STRIKE_DAMAGE_FACTOR = 2.
        endglobals

        //! runtextmacro CreateSimpleUnitState("criticalStrike", "CriticalStrike", "real")

        //! runtextmacro CreateSimpleUnitTypeStateForPlayer("criticalStrike", "CriticalStrike", "real")

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitState("criticalStrikeDefense", "CriticalStrikeDefense", "real")

        /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        function GetUnitCriticalStrikeImmunity takes Unit whichUnit returns integer
            return whichUnit.criticalStrikeImmunity
        endfunction

        function RemoveUnitCriticalStrikeImmunity takes Unit whichUnit returns nothing
            set whichUnit.criticalStrikeImmunity = GetUnitCriticalStrikeImmunity(whichUnit) - 1
        endfunction

        function AddUnitCriticalStrikeImmunity takes Unit whichUnit returns nothing
            set whichUnit.criticalStrikeImmunity = GetUnitCriticalStrikeImmunity(whichUnit) + 1
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Drop
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Drop")
        globals
            private constant real Drop_HERO_LEVEL_FACTOR = 23.
        endglobals

        //! runtextmacro Scope("Bonus")
            //! runtextmacro CreateSimpleUnitState("dropBonus", "DropBonus", "integer")

            ///////////////////////////////////////////////////////////////////////////////////////////////////////////

            //! runtextmacro CreateSimpleUnitState("dropByKillBonus", "DropByKillBonus", "integer")

            //! runtextmacro CreateSimpleUnitState("dropByKillRelativeBonus", "DropByKillRelativeBonus", "real")
        //! runtextmacro Endscope()

        //! runtextmacro CreateSimpleUnitTypeState("drop", "Drop", "integer")

        function GetUnitDrop takes UnitType whichUnitType returns integer
            return GetUnitTypeDrop(whichUnitType)
        endfunction

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        function GetAttackDrop takes UnitType attacker, Unit victim, UnitType victimType returns integer
            return R2I( ( GetUnitTypeDrop( victimType ) + GetHeroLevel( victim.self ) * Drop_HERO_LEVEL_FACTOR ) * ( 1 + GetUnitDropByKillRelativeBonus( attacker ) ) + GetUnitDropByKillBonus( attacker ) + GetUnitDropBonus( victim ) )
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function ClearUnitRequestQueue takes Unit whichUnit returns nothing
        local integer iteration = 1
        local unit whichUnitSelf = whichUnit.self
        loop
            exitwhen ( iteration > 8 )
            set UnitGetsOrder_IGNORE_NEXT = true
            call IssueImmediateOrderById( whichUnitSelf, CANCEL_ORDER_ID )
            set iteration = iteration + 1
        endloop
        set UnitGetsOrder_IGNORE_NEXT = false
        set whichUnitSelf = null
    endfunction

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////    Invulnerability
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Invulnerability")
        globals
            private constant string Invulnerability_TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\DivineShield\\DivineShieldTarget.mdl"
            private constant string Invulnerability_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        function GetUnitInvulnerability takes Unit whichUnit returns integer
            return whichUnit.invulnerability
        endfunction

        function RemoveUnitInvulnerability takes Unit whichUnit returns nothing
            local integer amount = GetUnitInvulnerability(whichUnit) - 1
            set whichUnit.invulnerability = amount
            if (amount == 0) then
                call SetUnitInvulnerable(whichUnit.self, false)
            endif
        endfunction

        function AddUnitInvulnerability takes Unit whichUnit returns nothing
            local integer amount = GetUnitInvulnerability(whichUnit) + 1
            set whichUnit.invulnerability = amount
            if (amount == 1) then
                call SetUnitInvulnerable(whichUnit.self, true)
            endif
        endfunction

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        function GetUnitInvulnerabilityEffectAmount takes Unit whichUnit returns integer
            return whichUnit.invulnerabilityEffectAmount
        endfunction

        function RemoveUnitInvulnerabilityWithEffect takes Unit whichUnit returns nothing
            local integer amount = GetUnitInvulnerabilityEffectAmount(whichUnit) - 1
            set whichUnit.invulnerabilityEffectAmount = amount
            if (amount == 0) then
                call DestroyEffectWJ(whichUnit.invulnerabilityEffect)
            endif
            call RemoveUnitInvulnerability(whichUnit)
        endfunction

        function AddUnitInvulnerabilityWithEffect takes Unit whichUnit returns nothing
            local integer amount = GetUnitInvulnerabilityEffectAmount(whichUnit) + 1
            set whichUnit.invulnerabilityEffectAmount = amount
            if (amount == 1) then
                set whichUnit.invulnerabilityEffect = AddSpecialEffectTargetWJ( Invulnerability_TARGET_EFFECT_PATH, whichUnit.self, Invulnerability_TARGET_EFFECT_ATTACHMENT_POINT )
            endif
            call AddUnitInvulnerability(whichUnit)
        endfunction

        //! runtextmacro Scope("Timed")
            private struct Timed_Data
                timer durationTimer
                Unit target
            endstruct

            private function Timed_Ending takes Timed_Data d, timer durationTimer, Unit target returns nothing
                call FlushAttachedInteger( durationTimer, Timed_SCOPE_ID )
                call DestroyTimerWJ( durationTimer )
                call FlushAttachedIntegerById( target.id, Timed_SCOPE_ID )
                call RemoveUnitInvulnerabilityWithEffect( target )
            endfunction

            private function Timed_EndingByTimer takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(durationTimer, Timed_SCOPE_ID)
                call Timed_Ending(d, durationTimer, d.target)
                set durationTimer = null
            endfunction

            function SetUnitInvulnerabilityTimed takes Unit target, real duration returns nothing
                local timer durationTimer
                local integer targetId = target.id
                local Timed_Data d = GetAttachedIntegerById( targetId, Timed_SCOPE_ID )
                if ( d == NULL ) then
                    set d = Timed_Data.create()
                    set durationTimer = CreateTimerWJ()
                    set d.durationTimer = durationTimer
                    set d.target = target
                    call AttachInteger( durationTimer, Timed_SCOPE_ID, d )
                    call AttachIntegerById( targetId, Timed_SCOPE_ID, d )
                    call AddUnitInvulnerabilityWithEffect( target )
                else
                    set durationTimer = d.durationTimer
                endif
                if ( duration > TimerGetRemaining( durationTimer ) ) then
                    call TimerStart( durationTimer, duration, false, function Timed_EndingByTimer )
                endif
                set durationTimer = null
            endfunction
        //! runtextmacro Endscope()

        public function Invulnerability_Init takes nothing returns nothing
            call InitEffectType(Invulnerability_TARGET_EFFECT_PATH)
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function UnitDamageUnitEx takes Unit whichUnit, Unit whichTarget, real amount, weapontype whichWeaponType returns nothing
        local boolean causesDeath
        local integer DamageTrigger
        local player whichTargetOwner
        local unit whichTargetSelf = whichTarget.self
        local unit whichUnitSelf = whichUnit.self
        if ( GetUnitInvulnerability( whichTarget ) <= 0 ) then
            call DisableTrigger( UnitTakesDamage_DUMMY_TRIGGER )
            if (GetUnitAnyDamageEvents(whichTarget) > 0) then
                set DAMAGE_AMOUNT = amount
                set DAMAGE_SOURCE = whichUnit
                set TRIGGER_UNIT = whichTarget
                call RunTrigger(UnitTakesAnyDamage_DUMMY_TRIGGER)
                set amount = DAMAGE_AMOUNT
            endif
            set causesDeath = ( ( amount >= GetUnitState( whichTargetSelf, UNIT_STATE_LIFE ) - LIMIT_OF_DEATH ) and ( whichUnit != null ) )
            if ( causesDeath ) then
                set whichTargetOwner = whichTarget.owner
                if ( IsUnitEnemy( whichUnitSelf, whichTargetOwner ) ) then
                    if ( GetAttackDrop( whichUnit, whichTarget, whichTarget.type ) != GetUnitDrop( whichTarget ) ) then
                        call SetPlayerState( whichTargetOwner, PLAYER_STATE_GIVES_BOUNTY, 0 )
                    endif
                    set TRIGGER_UNIT = whichUnit
                endif
                set whichTargetOwner = null
                if ( IsUnitType( whichTargetSelf, UNIT_TYPE_STRUCTURE ) ) then
                    call ClearUnitRequestQueue( whichTarget )
                endif
            endif
            call UnitDamageTarget( whichUnitSelf, whichTargetSelf, amount, false, false, null, null, whichWeaponType )
            call EnableTrigger( UnitTakesDamage_DUMMY_TRIGGER )
            if ( causesDeath ) then
                set TRIGGER_UNIT = whichUnit
            endif
        endif
        set whichTargetSelf = null
        set whichUnitSelf = null
    endfunction

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Damage
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Damage")
        //! runtextmacro Scope("Base")
            globals
                private constant integer Base_DECREASING_ITEMS_MAX = 6
                private item array Base_DECREASING_ITEMS
                private constant integer Base_INCREASING_ITEMS_MAX = 6
                private item array Base_INCREASING_ITEMS
            endglobals

            function GetUnitDamage takes Unit whichUnit returns real
                return whichUnit.damage
            endfunction

            function SetUnitDamage takes Unit whichUnit, real amount returns nothing
                local integer packet
                local integer packetLevel
                local real previousAmount = GetUnitDamage(whichUnit)
                local unit whichUnitSelf = whichUnit.self
                local boolean hasInventory = (UnitInventorySize(whichUnitSelf) > 0)
                set whichUnit.damage = amount
                set amount = R2I(amount) - R2I(previousAmount)
                if (hasInventory == false) then
                    call UnitAddAbility(whichUnitSelf, HERO_INVENTORY_SPELL_ID)
                endif
                if (amount < 0) then
                    set amount = -amount
                    set packet = 64
                    set packetLevel = Base_DECREASING_ITEMS_MAX
                    loop
                        exitwhen (amount < 1)
                        loop
                            exitwhen (amount < packet)
                            call UnitAddItem(whichUnitSelf, Base_DECREASING_ITEMS[packetLevel])
                            call SetWidgetLife(Base_DECREASING_ITEMS[packetLevel], 1)
                            set amount = amount - packet
                        endloop
                        set packet = packet / 2
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packet = 64
                    set packetLevel = Base_INCREASING_ITEMS_MAX
                    loop
                        exitwhen (amount < 1)
                        loop
                            exitwhen (amount < packet)
                            call UnitAddItem(whichUnitSelf, Base_INCREASING_ITEMS[packetLevel])
                            call SetWidgetLife(Base_INCREASING_ITEMS[packetLevel], 1)
                            set amount = amount - packet
                        endloop
                        set packet = packet / 2
                        set packetLevel = packetLevel - 1
                    endloop
                endif
                if (hasInventory == false) then
                    call UnitRemoveAbility(whichUnitSelf, HERO_INVENTORY_SPELL_ID)
                endif
                set whichUnitSelf = null
            endfunction

            function AddUnitDamage takes Unit whichUnit, real amount returns nothing
                call SetUnitDamage( whichUnit, GetUnitDamage( whichUnit ) + amount )
            endfunction

            public function Base_Init takes nothing returns nothing
                local integer array itemTypes
                local integer iteration = 0

                set itemTypes[0] = 'I00N'
                set itemTypes[1] = 'I00O'
                set itemTypes[2] = 'I00P'
                set itemTypes[3] = 'I00Q'
                set itemTypes[4] = 'I00R'
                set itemTypes[5] = 'I00S'
                set itemTypes[6] = 'I00T'
                loop
                    exitwhen (iteration > Base_DECREASING_ITEMS_MAX)
                    set Base_DECREASING_ITEMS[iteration] = CreateHiddenItem(itemTypes[iteration])
                    set iteration = iteration + 1
                endloop

                set itemTypes[0] = 'I00G'
                set itemTypes[1] = 'I00H'
                set itemTypes[2] = 'I00I'
                set itemTypes[3] = 'I00J'
                set itemTypes[4] = 'I00K'
                set itemTypes[5] = 'I00L'
                set itemTypes[6] = 'I00M'
                set iteration = 0
                loop
                    exitwhen (iteration > Base_INCREASING_ITEMS_MAX)
                    set Base_INCREASING_ITEMS[iteration] = CreateHiddenItem(itemTypes[iteration])
                    set iteration = iteration + 1
                endloop
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Bonus")
            globals
                private constant integer Bonus_DECREASING_ABILITIES_MAX = 6
                private integer array Bonus_DECREASING_ABILITIES
                private constant integer Bonus_INCREASING_ABILITIES_MAX = 6
                private integer array Bonus_INCREASING_ABILITIES
            endglobals

            function GetUnitDamageBonus takes Unit whichUnit returns real
                return whichUnit.damageBonus
            endfunction

            function SetUnitDamageBonus takes Unit whichUnit, real amount returns nothing
                local integer packet
                local integer packetLevel
                local real previousAmount = GetUnitDamageBonus(whichUnit)
                local unit whichUnitSelf = whichUnit.self
                set whichUnit.damageBonus = amount
                if (amount * previousAmount <= 0) then
                    if (previousAmount < 0) then
                        set packetLevel = Bonus_DECREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    else
                        set packetLevel = Bonus_INCREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    endif
                    if (amount < 0) then
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set amount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set amount = amount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set amount = amount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                else
                    set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                    set packet = R2I(Pow(2, packetLevel))
                    if (amount < 0) then
                        set amount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set amount = amount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                    set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                    set packet = R2I(Pow(2, packetLevel))
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set amount = amount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                endif
            endfunction

            function AddUnitDamageBonus takes Unit whichUnit, real amount returns nothing
                call SetUnitDamageBonus( whichUnit, GetUnitDamageBonus( whichUnit ) + amount )
            endfunction

            public function Bonus_Init takes nothing returns nothing
                set Bonus_DECREASING_ABILITIES[0] = 'A00O'
                set Bonus_DECREASING_ABILITIES[1] = 'A04K'
                set Bonus_DECREASING_ABILITIES[2] = 'A04L'
                set Bonus_DECREASING_ABILITIES[3] = 'A04M'
                set Bonus_DECREASING_ABILITIES[4] = 'A04N'
                set Bonus_DECREASING_ABILITIES[5] = 'A04O'
                set Bonus_DECREASING_ABILITIES[6] = 'A04P'

                set Bonus_INCREASING_ABILITIES[0] = 'A00K'
                set Bonus_INCREASING_ABILITIES[1] = 'A04Q'
                set Bonus_INCREASING_ABILITIES[2] = 'A04R'
                set Bonus_INCREASING_ABILITIES[3] = 'A04S'
                set Bonus_INCREASING_ABILITIES[4] = 'A04T'
                set Bonus_INCREASING_ABILITIES[5] = 'A04U'
                set Bonus_INCREASING_ABILITIES[6] = 'A04V'
            endfunction
        //! runtextmacro Endscope()

        function GetUnitDamageTotal takes Unit whichUnit returns real
            return (GetUnitDamage(whichUnit) + GetUnitDamageBonus(whichUnit))
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("damage", "Damage", "real")

        //! runtextmacro CreateSimpleUnitTypeStateForPlayer("damage", "Damage", "real")

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitTypeState("damageDices", "DamageDices", "integer")

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitTypeState("damageDicesSides", "DamageDicesSides", "integer")

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitState("damageRelativeBonus", "DamageRelativeBonus", "real")

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitState("damageBySpellBonus", "DamageBySpellBonus", "real")

        function UnitDamageUnitBySpell takes Unit whichUnit, Unit whichTarget, real amount returns nothing
            call UnitDamageUnitEx( whichUnit, whichTarget, amount * ( 1 + GetUnitDamageBySpellBonus( whichUnit ) - GetUnitArmorBySpellBonus( whichTarget ) ), null )
        endfunction

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //! runtextmacro CreateSimpleUnitTypeState("damageType", "DamageType", "integer")

        public function Damage_Init takes nothing returns nothing
            call Base_Base_Init()
            call Bonus_Bonus_Init()
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Heal
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro CreateSimpleUnitState("healBySpell", "HealBySpell", "real")

    function HealUnitBySpell takes Unit whichUnit, real amount returns nothing
        set amount = amount * ( 1 + GetUnitHealBySpell( whichUnit ) )
        call AddUnitState( whichUnit.self, UNIT_STATE_LIFE, amount )
    endfunction

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Locust
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function AddUnitLocust takes unit whichUnit returns nothing
        call UnitAddAbility( whichUnit, LOCUST_SPELL_ID )
    endfunction

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Moveability
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    function RemoveUnitMoveability takes unit whichUnit returns nothing
        call UnitRemoveAbility( whichUnit, MOVE_SPELL_ID )
    endfunction

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Max Life
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("MaxLife")
        globals
            private constant integer MaxLife_DECREASING_PACKET_LEVEL_MAX = 12
            private constant integer MaxLife_DECREASING_SPELL_ID = 'A01N'
            private constant integer MaxLife_INCREASING_PACKET_LEVEL_MAX = 12
            private constant integer MaxLife_INCREASING_SPELL_ID = 'A01M'
        endglobals

        function GetUnitMaxLife takes Unit whichUnit returns real
            return whichUnit.maxLife
        endfunction

        function SetUnitMaxLife takes Unit whichUnit, real amount returns nothing
            local integer packet
            local integer packetLevel
            local real previousAmount = GetUnitMaxLife(whichUnit)
            local unit whichUnitSelf = whichUnit.self
            set whichUnit.maxLife = amount
            set amount = R2I(amount) - R2I(previousAmount)
            if (amount < 0) then
                set amount = -amount
                set packet = 1024
                set packetLevel = MaxLife_DECREASING_PACKET_LEVEL_MAX
                loop
                    exitwhen (amount < 1)
                    loop
                        exitwhen (amount < packet)
                        call UnitAddAbility(whichUnitSelf, MaxLife_DECREASING_SPELL_ID)
                        call SetUnitAbilityLevel(whichUnitSelf, MaxLife_DECREASING_SPELL_ID, packetLevel)
                        call UnitRemoveAbility(whichUnitSelf, MaxLife_DECREASING_SPELL_ID)
                        set amount = amount - packet
                    endloop
                    set packet = packet / 2
                    set packetLevel = packetLevel - 1
                endloop
            else
                set packet = 1024
                set packetLevel = MaxLife_INCREASING_PACKET_LEVEL_MAX
                loop
                    exitwhen (amount < 1)
                    loop
                        exitwhen (amount < packet)
                        call UnitAddAbility(whichUnitSelf, MaxLife_INCREASING_SPELL_ID)
                        call SetUnitAbilityLevel(whichUnitSelf, MaxLife_INCREASING_SPELL_ID, packetLevel)
                        call UnitRemoveAbility(whichUnitSelf, MaxLife_INCREASING_SPELL_ID)
                        set amount = amount - packet
                    endloop
                    set packet = packet / 2
                    set packetLevel = packetLevel - 1
                endloop
            endif
            set whichUnitSelf = null
        endfunction

        function AddUnitMaxLife takes Unit whichUnit, real amount returns nothing
            call SetUnitMaxLife(whichUnit, GetUnitMaxLife(whichUnit) + amount)
        endfunction

        public function MaxLife_Init takes nothing returns nothing
            call InitAbility( MaxLife_DECREASING_SPELL_ID )
            call InitAbility( MaxLife_INCREASING_SPELL_ID )
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("maxLife", "MaxLife", "real")

        //! runtextmacro CreateSimpleUnitTypeStateForPlayer("maxLife", "MaxLife", "real")
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Max Mana
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("MaxMana")
        globals
            private constant integer MaxMana_DECREASING_PACKET_LEVEL_MAX = 12
            private constant integer MaxMana_DECREASING_SPELL_ID = 'A02P'
            private constant integer MaxMana_INCREASING_PACKET_LEVEL_MAX = 12
            private constant integer MaxMana_INCREASING_SPELL_ID = 'A02O'
        endglobals

        function GetUnitMaxMana takes Unit whichUnit returns real
            return whichUnit.maxMana
        endfunction

        function SetUnitMaxMana takes Unit whichUnit, real amount returns nothing
            local integer packet
            local integer packetLevel
            local real previousAmount = GetUnitMaxMana(whichUnit)
            local unit whichUnitSelf = whichUnit.self
            set whichUnit.maxMana = amount
            set amount = R2I(amount) - R2I(previousAmount)
            if (amount < 0) then
                set amount = -amount
                set packet = 1024
                set packetLevel = MaxMana_DECREASING_PACKET_LEVEL_MAX
                loop
                    exitwhen (amount < 1)
                    loop
                        exitwhen (amount < packet)
                        call UnitAddAbility(whichUnitSelf, MaxMana_DECREASING_SPELL_ID)
                        call SetUnitAbilityLevel(whichUnitSelf, MaxMana_DECREASING_SPELL_ID, packetLevel)
                        call UnitRemoveAbility(whichUnitSelf, MaxMana_DECREASING_SPELL_ID)
                        set amount = amount - packet
                    endloop
                    set packet = packet / 2
                    set packetLevel = packetLevel - 1
                endloop
            else
                set packet = 1024
                set packetLevel = MaxMana_INCREASING_PACKET_LEVEL_MAX
                loop
                    exitwhen (amount < 1)
                    loop
                        exitwhen (amount < packet)
                        call UnitAddAbility(whichUnitSelf, MaxMana_INCREASING_SPELL_ID)
                        call SetUnitAbilityLevel(whichUnitSelf, MaxMana_INCREASING_SPELL_ID, packetLevel)
                        call UnitRemoveAbility(whichUnitSelf, MaxMana_INCREASING_SPELL_ID)
                        set amount = amount - packet
                    endloop
                    set packet = packet / 2
                    set packetLevel = packetLevel - 1
                endloop
            endif
            set whichUnitSelf = null
        endfunction

        function AddUnitMaxMana takes Unit whichUnit, real amount returns nothing
            call SetUnitMaxMana(whichUnit, GetUnitMaxMana(whichUnit) + amount)
        endfunction

        public function MaxMana_Init takes nothing returns nothing
            call InitAbility( MaxMana_DECREASING_SPELL_ID )
            call InitAbility( MaxMana_INCREASING_SPELL_ID )
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("maxMana", "MaxMana", "real")

        //! runtextmacro CreateSimpleUnitTypeStateForPlayer("maxMana", "MaxMana", "real")
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Regeneration")
        globals
            constant real REGENERATION_INTERVAL = 1.
        endglobals

        //! runtextmacro Scope("LifeRegeneration")
            //! runtextmacro CreateSimpleUnitState("lifeRegeneration", "LifeRegeneration", "real")

            //! runtextmacro CreateSimpleUnitState("lifeRegenerationBonus", "LifeRegenerationBonus", "real")

            //! runtextmacro CreateSimpleUnitTypeState("lifeRegeneration", "LifeRegeneration", "real")

            //! runtextmacro CreateSimpleUnitTypeStateForPlayer("lifeRegeneration", "LifeRegeneration", "real")
        //! runtextmacro Endscope()

        //! runtextmacro Scope("ManaRegeneration")
            //! runtextmacro CreateSimpleUnitState("manaRegeneration", "ManaRegeneration", "real")

            //! runtextmacro CreateSimpleUnitState("manaRegenerationBonus", "ManaRegenerationBonus", "real")

            //! runtextmacro CreateSimpleUnitTypeState("manaRegeneration", "ManaRegeneration", "real")

            //! runtextmacro CreateSimpleUnitTypeStateForPlayer("manaRegeneration", "ManaRegeneration", "real")
        //! runtextmacro Endscope()
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Hero Attributes
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    globals
        constant real DAMAGE_BONUS_PER_PRIMARY_ATTRIBUTE_POINT = 1.
    endglobals

    //! runtextmacro Scope("Agility")
        globals
            private constant real Agility_ARMOR_BONUS_PER_AGILITY_POINT = 0.2
        endglobals

        //! runtextmacro Scope("Base")
            function GetHeroAgility takes Unit whichUnit returns real
                return whichUnit.agility
            endfunction

            function SetHeroAgility takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                local real previousAmount = GetHeroAgility(whichUnit)
                local integer primaryAttribute = whichUnitType.primaryAttribute
                set whichUnit.agility = amount
                call SetHeroAgi(whichUnit.self, R2I(amount), true)
                set amount = amount - previousAmount
                call AddUnitArmor( whichUnit, amount * Agility_ARMOR_BONUS_PER_AGILITY_POINT )
                if ( primaryAttribute == 2 ) then
                    call AddUnitDamage( whichUnit, amount * DAMAGE_BONUS_PER_PRIMARY_ATTRIBUTE_POINT )
                endif
            endfunction

            function AddHeroAgility takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                call SetHeroAgility(whichUnit, whichUnitType, GetHeroAgility(whichUnit) + amount)
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Bonus")
            globals
                private constant integer Bonus_DECREASING_ABILITIES_MAX = 6
                private integer array Bonus_DECREASING_ABILITIES
                private constant integer Bonus_INCREASING_ABILITIES_MAX = 6
                private integer array Bonus_INCREASING_ABILITIES
            endglobals

            function GetHeroAgilityBonus takes Unit whichUnit returns real
                return whichUnit.agilityBonus
            endfunction

            function SetHeroAgilityBonus takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                local integer packet
                local integer packetLevel
                local real previousAmount = GetHeroAgilityBonus(whichUnit)
                local integer primaryAttribute = whichUnitType.primaryAttribute
                local real remainingAmount
                local unit whichUnitSelf = whichUnit.self
                set whichUnit.agilityBonus = amount
                if (amount * previousAmount <= 0) then
                    if (previousAmount < 0) then
                        set packetLevel = Bonus_DECREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    else
                        set packetLevel = Bonus_INCREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    endif
                    if (amount < 0) then
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= remainingAmount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                else
                    if (amount < 0) then
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= remainingAmount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= remainingAmount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                endif
                set amount = amount - previousAmount
                call AddUnitArmorBonus( whichUnit, amount * Agility_ARMOR_BONUS_PER_AGILITY_POINT )
                if ( primaryAttribute == 2 ) then
                    call AddUnitDamageBonus( whichUnit, amount * DAMAGE_BONUS_PER_PRIMARY_ATTRIBUTE_POINT )
                endif
                set whichUnitSelf = null
            endfunction

            function AddHeroAgilityBonus takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                call SetHeroAgilityBonus( whichUnit, whichUnitType, GetHeroAgilityBonus( whichUnit ) + amount )
            endfunction

            public function Bonus_Init takes nothing returns nothing
                set Bonus_DECREASING_ABILITIES[0] = 'A019'
                set Bonus_DECREASING_ABILITIES[1] = 'A05E'
                set Bonus_DECREASING_ABILITIES[2] = 'A05F'
                set Bonus_DECREASING_ABILITIES[3] = 'A05G'
                set Bonus_DECREASING_ABILITIES[4] = 'A05H'
                set Bonus_DECREASING_ABILITIES[5] = 'A05I'
                set Bonus_DECREASING_ABILITIES[6] = 'A05J'

                set Bonus_INCREASING_ABILITIES[0] = 'A018'
                set Bonus_INCREASING_ABILITIES[1] = 'A058'
                set Bonus_INCREASING_ABILITIES[2] = 'A059'
                set Bonus_INCREASING_ABILITIES[3] = 'A05A'
                set Bonus_INCREASING_ABILITIES[4] = 'A05B'
                set Bonus_INCREASING_ABILITIES[5] = 'A05C'
                set Bonus_INCREASING_ABILITIES[6] = 'A05D'
            endfunction
        //! runtextmacro Endscope()

        function GetHeroAgilityTotal takes Unit whichUnit returns real
            return (GetHeroAgility(whichUnit) + GetHeroAgilityBonus(whichUnit))
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("agility", "Agility", "real")
        //! runtextmacro CreateSimpleUnitTypeState("agilityPerLevel", "AgilityPerLevel", "real")

        public function Agility_Init takes nothing returns nothing
            call Bonus_Bonus_Init()
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Intelligence")
        globals
            private constant real Intelligence_MAX_MANA_BONUS_PER_INTELLIGENCE_POINT = 15.
            private constant real Intelligence_MANA_REGENERATION_BONUS_PER_INTELLIGENCE_POINT = 0.025 * REGENERATION_INTERVAL
        endglobals

        //! runtextmacro Scope("Base")
            function GetHeroIntelligence takes Unit whichUnit returns real
                return whichUnit.intelligence
            endfunction

            function SetHeroIntelligence takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                local real previousAmount = GetHeroIntelligence(whichUnit)
                local integer primaryAttribute = whichUnitType.primaryAttribute
                set whichUnit.intelligence = amount
                call SetHeroInt(whichUnit.self, R2I(amount), true)
                set amount = amount - previousAmount
                call AddUnitMaxMana( whichUnit, amount * Intelligence_MAX_MANA_BONUS_PER_INTELLIGENCE_POINT )
                call AddUnitManaRegeneration( whichUnit, amount * Intelligence_MANA_REGENERATION_BONUS_PER_INTELLIGENCE_POINT )
                if ( primaryAttribute == 3 ) then
                    call AddUnitDamage( whichUnit, amount * DAMAGE_BONUS_PER_PRIMARY_ATTRIBUTE_POINT )
                endif
            endfunction

            function AddHeroIntelligence takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                call SetHeroIntelligence(whichUnit, whichUnitType, GetHeroIntelligence(whichUnit) + amount)
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Bonus")
            globals
                private constant integer Bonus_DECREASING_ABILITIES_MAX = 6
                private integer array Bonus_DECREASING_ABILITIES
                private constant integer Bonus_INCREASING_ABILITIES_MAX = 6
                private integer array Bonus_INCREASING_ABILITIES
            endglobals

            function GetHeroIntelligenceBonus takes Unit whichUnit returns real
                return whichUnit.intelligenceBonus
            endfunction

            function SetHeroIntelligenceBonus takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                local integer packet
                local integer packetLevel
                local real previousAmount = GetHeroIntelligenceBonus(whichUnit)
                local integer primaryAttribute = whichUnitType.primaryAttribute
                local real remainingAmount
                local unit whichUnitSelf = whichUnit.self
                set whichUnit.intelligenceBonus = amount
                if (amount * previousAmount <= 0) then
                    if (previousAmount < 0) then
                        set packetLevel = Bonus_DECREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    else
                        set packetLevel = Bonus_INCREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    endif
                    if (amount < 0) then
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= remainingAmount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                else
                    if (amount < 0) then
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= remainingAmount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= remainingAmount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                endif
                set amount = amount - previousAmount
                call AddUnitMaxMana( whichUnit, amount * Intelligence_MAX_MANA_BONUS_PER_INTELLIGENCE_POINT )
                call AddUnitManaRegenerationBonus( whichUnit, amount * Intelligence_MANA_REGENERATION_BONUS_PER_INTELLIGENCE_POINT )
                if ( primaryAttribute == 3 ) then
                    call AddUnitDamageBonus( whichUnit, amount * DAMAGE_BONUS_PER_PRIMARY_ATTRIBUTE_POINT )
                endif
                set whichUnitSelf = null
            endfunction

            function AddHeroIntelligenceBonus takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                call SetHeroIntelligenceBonus( whichUnit, whichUnitType, GetHeroIntelligenceBonus( whichUnit ) + amount )
            endfunction

            public function Bonus_Init takes nothing returns nothing
                set Bonus_DECREASING_ABILITIES[0] = 'A01G'
                set Bonus_DECREASING_ABILITIES[1] = 'A05Q'
                set Bonus_DECREASING_ABILITIES[2] = 'A05R'
                set Bonus_DECREASING_ABILITIES[3] = 'A05S'
                set Bonus_DECREASING_ABILITIES[4] = 'A05T'
                set Bonus_DECREASING_ABILITIES[5] = 'A05U'
                set Bonus_DECREASING_ABILITIES[6] = 'A05V'

                set Bonus_INCREASING_ABILITIES[0] = 'A01E'
                set Bonus_INCREASING_ABILITIES[1] = 'A05K'
                set Bonus_INCREASING_ABILITIES[2] = 'A05L'
                set Bonus_INCREASING_ABILITIES[3] = 'A05M'
                set Bonus_INCREASING_ABILITIES[4] = 'A05N'
                set Bonus_INCREASING_ABILITIES[5] = 'A05O'
                set Bonus_INCREASING_ABILITIES[6] = 'A05P'
            endfunction
        //! runtextmacro Endscope()

        function GetHeroIntelligenceTotal takes Unit whichUnit returns real
            return (GetHeroIntelligence(whichUnit) + GetHeroIntelligenceBonus(whichUnit))
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("intelligence", "Intelligence", "real")
        //! runtextmacro CreateSimpleUnitTypeState("intelligencePerLevel", "IntelligencePerLevel", "real")

        public function Intelligence_Init takes nothing returns nothing
            call Bonus_Bonus_Init()
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Strength")
        globals
            private constant real Strength_MAX_LIFE_BONUS_PER_STRENGTH_POINT = 25.
            private constant real Strength_LIFE_REGENERATION_BONUS_PER_STRENGTH_POINT = 0.025 * REGENERATION_INTERVAL
        endglobals

        //! runtextmacro Scope("Base")
            function GetHeroStrength takes Unit whichUnit returns real
                return whichUnit.strength
            endfunction

            function SetHeroStrength takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                local real previousAmount = GetHeroStrength(whichUnit)
                local integer primaryAttribute = whichUnitType.primaryAttribute
                set whichUnit.strength = amount
                call SetHeroStr(whichUnit.self, R2I(amount), true)
                set amount = amount - previousAmount
                call AddUnitMaxLife( whichUnit, amount * Strength_MAX_LIFE_BONUS_PER_STRENGTH_POINT )
                call AddUnitLifeRegeneration( whichUnit, amount * Strength_LIFE_REGENERATION_BONUS_PER_STRENGTH_POINT )
                if ( primaryAttribute == 1 ) then
                    call AddUnitDamage( whichUnit, amount * DAMAGE_BONUS_PER_PRIMARY_ATTRIBUTE_POINT )
                endif
            endfunction

            function AddHeroStrength takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                call SetHeroStrength(whichUnit, whichUnitType, GetHeroStrength(whichUnit) + amount)
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Bonus")
            globals
                private constant integer Bonus_DECREASING_ABILITIES_MAX = 6
                private integer array Bonus_DECREASING_ABILITIES
                private constant integer Bonus_INCREASING_ABILITIES_MAX = 6
                private integer array Bonus_INCREASING_ABILITIES
            endglobals

            function GetHeroStrengthBonus takes Unit whichUnit returns real
                return whichUnit.strengthBonus
            endfunction

            function SetHeroStrengthBonus takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                local integer packet
                local integer packetLevel
                local real previousAmount = GetHeroStrengthBonus(whichUnit)
                local integer primaryAttribute = whichUnitType.primaryAttribute
                local real remainingAmount
                local unit whichUnitSelf = whichUnit.self
                set whichUnit.strengthBonus = amount
                if (amount * previousAmount <= 0) then
                    if (previousAmount < 0) then
                        set packetLevel = Bonus_DECREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    else
                        set packetLevel = Bonus_INCREASING_ABILITIES_MAX
                        loop
                            call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            set packetLevel = packetLevel - 1
                            exitwhen (packetLevel < 0)
                        endloop
                    endif
                    if (amount < 0) then
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= amount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= remainingAmount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                else
                    if (amount < 0) then
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_DECREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = -amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= remainingAmount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_DECREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    else
                        set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), Bonus_INCREASING_ABILITIES_MAX))
                        set packet = R2I(Pow(2, packetLevel))
                        set remainingAmount = amount
                        loop
                            exitwhen (packetLevel < 0)
                            if (packet <= remainingAmount) then
                                call UnitAddAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                                set remainingAmount = remainingAmount - packet
                            else
                                call UnitRemoveAbility(whichUnitSelf, Bonus_INCREASING_ABILITIES[packetLevel])
                            endif
                            set packet = packet / 2
                            set packetLevel = packetLevel - 1
                        endloop
                    endif
                endif
                set amount = amount - previousAmount
                call AddUnitMaxLife( whichUnit, amount * Strength_MAX_LIFE_BONUS_PER_STRENGTH_POINT )
                call AddUnitLifeRegenerationBonus( whichUnit, amount * Strength_LIFE_REGENERATION_BONUS_PER_STRENGTH_POINT )
                if ( primaryAttribute == 1 ) then
                    call AddUnitDamageBonus( whichUnit, amount * DAMAGE_BONUS_PER_PRIMARY_ATTRIBUTE_POINT )
                endif
                set whichUnitSelf = null
            endfunction

            function AddHeroStrengthBonus takes Unit whichUnit, UnitType whichUnitType, real amount returns nothing
                call SetHeroStrengthBonus( whichUnit, whichUnitType, GetHeroStrengthBonus( whichUnit ) + amount )
            endfunction

            public function Bonus_Init takes nothing returns nothing
                set Bonus_DECREASING_ABILITIES[0] = 'A017'
                set Bonus_DECREASING_ABILITIES[1] = 'A062'
                set Bonus_DECREASING_ABILITIES[2] = 'A063'
                set Bonus_DECREASING_ABILITIES[3] = 'A064'
                set Bonus_DECREASING_ABILITIES[4] = 'A065'
                set Bonus_DECREASING_ABILITIES[5] = 'A066'
                set Bonus_DECREASING_ABILITIES[6] = 'A067'

                set Bonus_INCREASING_ABILITIES[0] = 'A016'
                set Bonus_INCREASING_ABILITIES[1] = 'A05W'
                set Bonus_INCREASING_ABILITIES[2] = 'A05X'
                set Bonus_INCREASING_ABILITIES[3] = 'A05Y'
                set Bonus_INCREASING_ABILITIES[4] = 'A05Z'
                set Bonus_INCREASING_ABILITIES[5] = 'A060'
                set Bonus_INCREASING_ABILITIES[6] = 'A061'
            endfunction
        //! runtextmacro Endscope()

        function GetHeroStrengthTotal takes Unit whichUnit returns real
            return (GetHeroStrength(whichUnit) + GetHeroStrengthBonus(whichUnit))
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("strength", "Strength", "real")
        //! runtextmacro CreateSimpleUnitTypeState("strengthPerLevel", "StrengthPerLevel", "real")

        public function Strength_Init takes nothing returns nothing
            call Bonus_Bonus_Init()
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Evasion
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Evasion")
        globals
            private constant integer Evasion_SPELL_ID = 'A00L'
        endglobals

        function GetUnitEvasionChance takes Unit whichUnit returns real
            return whichUnit.evasion
        endfunction

        function SetUnitEvasionChance takes Unit whichUnit, real chance returns nothing
            set whichUnit.evasion = chance
            call SetUnitAbilityLevel( whichUnit.self, Evasion_SPELL_ID, 1 + R2I( chance * 100 ) )
        endfunction

        function AddUnitEvasionChance takes Unit whichUnit, real chance returns nothing
            call SetUnitEvasionChance( whichUnit, GetUnitEvasionChance( whichUnit ) + chance )
        endfunction

        public function Evasion_Init takes nothing returns nothing
            call InitAbility(Evasion_SPELL_ID)
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Miss
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Miss")
        globals
            private constant integer Miss_BUFF_ID = 'B00Q'
            private constant integer Miss_ORDER_ID = 852190//OrderId("curse")
            private constant integer Miss_SPELL_ID = 'A04I'
        endglobals

        function GetUnitMissChance takes Unit whichUnit returns real
            return whichUnit.miss
        endfunction

        function SetUnitMissChance takes Unit whichUnit, real chance returns nothing
            local unit whichUnitSelf = whichUnit.self
            set whichUnit.miss = chance
            call UnitRemoveAbility( whichUnitSelf, Miss_BUFF_ID )
            if ( chance > 0 ) then
                call SetUnitAbilityLevel( WORLD_CASTER, Miss_SPELL_ID, R2I( chance * 100 ) )
                call IssueTargetOrderById( WORLD_CASTER, Miss_ORDER_ID, whichUnitSelf )
            endif
            set whichUnitSelf = null
        endfunction

        function AddUnitMissChance takes Unit whichUnit, real chance returns nothing
            call SetUnitMissChance( whichUnit, GetUnitMissChance( whichUnit ) + chance )
        endfunction

        public function Miss_Init takes nothing returns nothing
            call InitAbility( Miss_SPELL_ID )
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Pathing
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Pathing")
        function GetUnitPathing takes Unit whichUnit returns integer
            return whichUnit.pathing
        endfunction

        function RemoveUnitPathing takes Unit whichUnit returns nothing
            local integer amount = GetUnitPathing( whichUnit ) - 1
            set whichUnit.pathing = amount
            if ( amount == 0 ) then
                call SetUnitPathing( whichUnit.self, false )
            endif
        endfunction

        function AddUnitPathing takes Unit whichUnit returns nothing
            local integer amount = GetUnitPathing( whichUnit ) + 1
            set whichUnit.pathing = amount
            if ( amount == 1 ) then
                call SetUnitPathing( whichUnit.self, true )
            endif
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Scaling
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Scale")
        function GetUnitScale takes Unit whichUnit returns real
            return whichUnit.scale
        endfunction

        function SetUnitScaleWJ takes unit whichUnit, real scale returns nothing
            call SetUnitScale( whichUnit, scale, scale, scale )
        endfunction

        function SetUnitScaleEx takes Unit whichUnit, real scale returns nothing
            set whichUnit.scale = scale
            call SetUnitScaleWJ( whichUnit.self, scale )
        endfunction

        function AddUnitScale takes Unit whichUnit, real scale returns nothing
            call SetUnitScaleEx( whichUnit, GetUnitScale( whichUnit ) + scale )
        endfunction

        //! runtextmacro Scope("Timed")
            globals
                private constant real Timed_UPDATE_TIME = 0.035
            endglobals

            private struct Timed_Data
                real bonusScalePerInterval
                timer durationTimer
                timer updateTimer
                Unit whichUnit
            endstruct

            private function Timed_Ending takes Timed_Data d, timer durationTimer, Unit whichUnit returns nothing
                local timer updateTimer = d.updateTimer
                local integer whichUnitId = whichUnit.id
                call d.destroy()
                call FlushAttachedInteger( durationTimer, Timed_SCOPE_ID )
                call DestroyTimerWJ(durationTimer)
                call FlushAttachedInteger( updateTimer, Timed_SCOPE_ID )
                call DestroyTimerWJ( updateTimer )
                set updateTimer = null
                call RemoveIntegerFromTableById( whichUnitId, Timed_SCOPE_ID, d )
                if (CountIntegersInTableById(whichUnitId, Timed_SCOPE_ID) == TABLE_EMPTY) then
                    //! runtextmacro RemoveEventById( "whichUnitId", "Timed_EVENT_DECAY" )
                endif
            endfunction

            public function Timed_Decay takes Unit whichUnit returns nothing
                local Timed_Data d
                local integer whichUnitId = whichUnit.id
                local integer iteration = CountIntegersInTableById(whichUnitId, Timed_SCOPE_ID) - 1
                if (iteration > TABLE_EMPTY) then
                    loop
                        set d = GetIntegerFromTableById(whichUnitId, Timed_SCOPE_ID, iteration)
                        call Timed_Ending(d, d.durationTimer, whichUnit)
                        set iteration = iteration - 1
                        exitwhen (iteration < TABLE_STARTED)
                    endloop
                endif
            endfunction

            private function Timed_Decay_Event takes nothing returns nothing
                call Timed_Decay(TRIGGER_UNIT)
            endfunction

            private function Timed_EndingByTimer takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(durationTimer, Timed_SCOPE_ID)
                call Timed_Ending( d, durationTimer, d.whichUnit )
                set durationTimer = null
            endfunction

            private function Timed_Update takes nothing returns nothing
                local timer updateTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(updateTimer, Timed_SCOPE_ID)
                local Unit whichUnit = d.whichUnit
                set updateTimer = null
                call AddUnitScale( whichUnit, d.bonusScalePerInterval )
            endfunction

            function AddUnitScaleTimed takes Unit whichUnit, real scale, real duration returns nothing
                local Timed_Data d = Timed_Data.create()
                local timer durationTimer = CreateTimerWJ()
                local timer updateTimer = CreateTimerWJ()
                local integer whichUnitId = whichUnit.id
                set d.bonusScalePerInterval = scale * Timed_UPDATE_TIME / duration
                set d.updateTimer = updateTimer
                set d.whichUnit = whichUnit
                call AttachInteger( durationTimer, Timed_SCOPE_ID, d )
                call AttachInteger( updateTimer, Timed_SCOPE_ID, d )
                call AddIntegerToTableById( whichUnitId, Timed_SCOPE_ID, d )
                if (CountIntegersInTableById(whichUnitId, Timed_SCOPE_ID) == TABLE_STARTED) then
                    //! runtextmacro AddEventById( "whichUnitId", "Timed_EVENT_DECAY" )
                endif
                call TimerStart( updateTimer, Timed_UPDATE_TIME, true, function Timed_Update )
                set updateTimer = null
                call TimerStart( durationTimer, duration, false, function Timed_EndingByTimer )
                set durationTimer = null
            endfunction

            public function Timed_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Timed_EVENT_DECAY", "UnitFinishesDecaying_EVENT_KEY", "0", "function Timed_Decay_Event" )
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro CreateSimpleUnitTypeState("scale", "Scale", "real")

        public function Scale_Init takes nothing returns nothing
            call Timed_Timed_Init()
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("DummyScale")
        private struct DummyScale_Data
            real scale
        endstruct

        function DestroyDummyScale takes unit dummyUnit returns nothing
            local DummyScale_Data d = GetAttachedInteger(dummyUnit, DummyScale_SCOPE_ID)
            call d.destroy()
            call FlushAttachedInteger(dummyUnit, DummyScale_SCOPE_ID)
        endfunction

        private function DummyScale_GetScale takes DummyScale_Data d returns real
            return d.scale
        endfunction

        private function DummyScale_Set takes unit dummyUnit, DummyScale_Data d, real scale returns nothing
            set d.scale = scale
            call SetUnitScale( dummyUnit, scale, scale, scale )
        endfunction

        private function DummyScale_Add takes unit dummyUnit, DummyScale_Data d, real scale returns nothing
            call DummyScale_Set( dummyUnit, d, DummyScale_GetScale( d ) + scale )
        endfunction

        //! runtextmacro Scope("Timed")
            globals
                private constant real Timed_UPDATE_TIME = 0.035
            endglobals

            private struct Timed_Data
                real bonusScalePerInterval
                timer durationTimer
                timer updateTimer
                unit whichUnit
            endstruct

            private function Timed_GetUnitData takes unit whichUnit returns Timed_Data
                return GetAttachedInteger(whichUnit, Timed_SCOPE_ID)
            endfunction

            private function Timed_Ending takes Timed_Data d, timer durationTimer, unit whichUnit returns nothing
                local timer updateTimer = d.updateTimer
                call d.destroy()
                call DestroyTimerWJ( durationTimer )
                call DestroyTimerWJ( updateTimer )
                set updateTimer = null
                call RemoveIntegerFromTable( whichUnit, Timed_SCOPE_ID, d )
            endfunction

            private function Timed_EndingByTimer takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(durationTimer, Timed_SCOPE_ID)
                call Timed_Ending( d, durationTimer, d.whichUnit )
                set durationTimer = null
            endfunction

            private function Timed_Update takes nothing returns nothing
                local timer updateTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(updateTimer, Timed_SCOPE_ID)
                local unit whichUnit = d.whichUnit
                call DummyScale_Add( whichUnit, Timed_GetUnitData(whichUnit), d.bonusScalePerInterval )
                set whichUnit = null
            endfunction

            function AddDummyScaleTimed takes unit whichUnit, real scale, real duration returns nothing
                local Timed_Data d
                local timer durationTimer
                local timer updateTimer
                if ( duration != 0 ) then
                    set d = Timed_Data.create()
                    set durationTimer = CreateTimerWJ()
                    set updateTimer = CreateTimerWJ()
                    set d.bonusScalePerInterval = scale / (R2I(duration / Timed_UPDATE_TIME))
                    set d.durationTimer = durationTimer
                    set d.updateTimer = updateTimer
                    set d.whichUnit = whichUnit
                    call AttachInteger( durationTimer, Timed_SCOPE_ID, d )
                    call AttachInteger( updateTimer, Timed_SCOPE_ID, d )
                    call AddIntegerToTable( whichUnit, Timed_SCOPE_ID, d )
                    call TimerStart( updateTimer, Timed_UPDATE_TIME, true, function Timed_Update )
                    set updateTimer = null
                    call TimerStart( durationTimer, duration, false, function Timed_EndingByTimer )
                    set durationTimer = null
                else
                    call DummyScale_Add(whichUnit, Timed_GetUnitData(whichUnit), scale)
                endif
            endfunction
        //! runtextmacro Endscope()

        function InitDummyScale takes unit dummyUnit, real scale returns nothing
            local DummyScale_Data d = DummyScale_Data.create()
            set d.scale = scale
            call AttachInteger(dummyUnit, DummyScale_SCOPE_ID, d)
            call SetUnitScale(dummyUnit, scale, scale, scale)
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Silence
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Silence")
        globals
            private constant integer Silence_DUMMY_BUFF_ID = 'B00G'
            private constant integer Silence_DUMMY_ORDER_ID = 852668//OrderId("soulburn")
            private constant integer Silence_DUMMY_SPELL_ID = 'B00G'
        endglobals

        function GetUnitSilence takes Unit whichUnit returns integer
            return whichUnit.silence
        endfunction

        function RemoveUnitSilence takes Unit whichUnit returns nothing
            local integer amount = GetUnitSilence( whichUnit ) - 1
            set whichUnit.silence = amount
            if ( amount == 0 ) then
                call UnitRemoveAbility( whichUnit.self, Silence_DUMMY_BUFF_ID )
            endif
        endfunction

        function AddUnitSilence takes Unit whichUnit returns nothing
            local integer amount = GetUnitSilence( whichUnit ) + 1
            set whichUnit.silence = amount
            if ( amount == 1 ) then
                call IssueTargetOrderById( WORLD_CASTER, Silence_DUMMY_ORDER_ID, whichUnit.self )
            endif
        endfunction

        public function Silence_Init takes nothing returns nothing
            call UnitAddAbility(WORLD_CASTER, Silence_DUMMY_SPELL_ID)
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Attack Rate
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("AttackRate")
        globals
            private constant integer AttackRate_DECREASING_ABILITIES_MAX = 6
            private integer array AttackRate_DECREASING_ABILITIES
            private constant integer AttackRate_INCREASING_ABILITIES_MAX = 6
            private integer array AttackRate_INCREASING_ABILITIES
        endglobals

        function GetUnitAttackRate takes Unit whichUnit returns real
            return whichUnit.attackRate
        endfunction

        function SetUnitAttackRate takes Unit whichUnit, real amount returns nothing
            local integer packet
            local integer packetLevel
            local real previousAmount = GetUnitAttackRate(whichUnit)
            local unit whichUnitSelf = whichUnit.self
            set whichUnit.attackRate = amount
            set amount = amount * 100
            if (amount * previousAmount <= 0) then
                if (previousAmount < 0) then
                    set packetLevel = AttackRate_DECREASING_ABILITIES_MAX
                    loop
                        call UnitRemoveAbility(whichUnitSelf, AttackRate_DECREASING_ABILITIES[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < 0)
                    endloop
                else
                    set packetLevel = AttackRate_INCREASING_ABILITIES_MAX
                    loop
                        call UnitRemoveAbility(whichUnitSelf, AttackRate_INCREASING_ABILITIES[packetLevel])
                        set packetLevel = packetLevel - 1
                        exitwhen (packetLevel < 0)
                    endloop
                endif
                if (amount < 0) then
                    set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), AttackRate_DECREASING_ABILITIES_MAX))
                    set packet = R2I(Pow(2, packetLevel))
                    set amount = -amount
                    loop
                        exitwhen (packetLevel < 0)
                        if (packet <= amount) then
                            call UnitAddAbility(whichUnitSelf, AttackRate_DECREASING_ABILITIES[packetLevel])
                            set amount = amount - packet
                        endif
                        set packet = packet / 2
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), AttackRate_INCREASING_ABILITIES_MAX))
                    set packet = R2I(Pow(2, packetLevel))
                    loop
                        exitwhen (packetLevel < 0)
                        if (packet <= amount) then
                            call UnitAddAbility(whichUnitSelf, AttackRate_INCREASING_ABILITIES[packetLevel])
                            set amount = amount - packet
                        endif
                        set packet = packet / 2
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            else
                set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), AttackRate_DECREASING_ABILITIES_MAX))
                set packet = R2I(Pow(2, packetLevel))
                if (amount < 0) then
                    set amount = -amount
                    loop
                        exitwhen (packetLevel < 0)
                        if (packet <= amount) then
                            call UnitAddAbility(whichUnitSelf, AttackRate_DECREASING_ABILITIES[packetLevel])
                            set amount = amount - packet
                        else
                            call UnitRemoveAbility(whichUnitSelf, AttackRate_DECREASING_ABILITIES[packetLevel])
                        endif
                        set packet = packet / 2
                        set packetLevel = packetLevel - 1
                    endloop
                else
                    set packetLevel = R2I(Min(Log(Max(Absolute(previousAmount), Absolute(amount)), 2), AttackRate_INCREASING_ABILITIES_MAX))
                    set packet = R2I(Pow(2, packetLevel))
                    loop
                        exitwhen (packetLevel < 0)
                        if (packet <= amount) then
                            call UnitAddAbility(whichUnitSelf, AttackRate_INCREASING_ABILITIES[packetLevel])
                            set amount = amount - packet
                        else
                            call UnitRemoveAbility(whichUnitSelf, AttackRate_INCREASING_ABILITIES[packetLevel])
                        endif
                        set packet = packet / 2
                        set packetLevel = packetLevel - 1
                    endloop
                endif
            endif
            set whichUnitSelf = null
        endfunction

        function AddUnitAttackRate takes Unit whichUnit, real amount returns nothing
            call SetUnitAttackRate( whichUnit, GetUnitAttackRate( whichUnit ) + amount )
        endfunction

        //! runtextmacro CreateSimpleUnitTypeStateForPlayer("attackRate", "AttackRate", "real")

        public function AttackRate_Init takes nothing returns nothing
            set AttackRate_DECREASING_ABILITIES[0] = 'A02L'
            set AttackRate_DECREASING_ABILITIES[1] = 'A052'
            set AttackRate_DECREASING_ABILITIES[2] = 'A053'
            set AttackRate_DECREASING_ABILITIES[3] = 'A054'
            set AttackRate_DECREASING_ABILITIES[4] = 'A055'
            set AttackRate_DECREASING_ABILITIES[5] = 'A056'
            set AttackRate_DECREASING_ABILITIES[6] = 'A057'

            set AttackRate_INCREASING_ABILITIES[0] = 'A02K'
            set AttackRate_INCREASING_ABILITIES[1] = 'A04W'
            set AttackRate_INCREASING_ABILITIES[2] = 'A04X'
            set AttackRate_INCREASING_ABILITIES[3] = 'A04Y'
            set AttackRate_INCREASING_ABILITIES[4] = 'A04Z'
            set AttackRate_INCREASING_ABILITIES[5] = 'A050'
            set AttackRate_INCREASING_ABILITIES[6] = 'A051'
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Sight Range
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("SightRange")
        globals
            private constant integer SightRange_DECREASING_PACKET_LEVEL_MAX = 12
            private constant integer SightRange_DECREASING_SPELL_ID = 'A03D'
            private constant integer SightRange_INCREASING_PACKET_LEVEL_MAX = 12
            private constant integer SightRange_INCREASING_SPELL_ID = 'A03C'
        endglobals

        function GetUnitSightRange takes Unit whichUnit returns real
            return whichUnit.sightRange
        endfunction

        function SetUnitSightRange takes Unit whichUnit, real amount returns nothing
            local integer packet
            local integer packetLevel
            local real previousAmount = GetUnitSightRange(whichUnit)
            local unit whichUnitSelf = whichUnit.self
            set whichUnit.sightRange = amount
            set amount = R2I(amount) - R2I(previousAmount)
            if (amount < 0) then
                set amount = -amount
                set packet = 1024
                set packetLevel = SightRange_DECREASING_PACKET_LEVEL_MAX
                loop
                    exitwhen (amount < 1)
                    loop
                        exitwhen (amount < packet)
                        call UnitAddAbility(whichUnitSelf, SightRange_DECREASING_SPELL_ID)
                        call SetUnitAbilityLevel(whichUnitSelf, SightRange_DECREASING_SPELL_ID, packetLevel)
                        call UnitRemoveAbility(whichUnitSelf, SightRange_DECREASING_SPELL_ID)
                        set amount = amount - packet
                    endloop
                    set packet = packet / 2
                    set packetLevel = packetLevel - 1
                endloop
            else
                set packet = 1024
                set packetLevel = SightRange_INCREASING_PACKET_LEVEL_MAX
                loop
                    exitwhen (amount < 1)
                    loop
                        exitwhen (amount < packet)
                        call UnitAddAbility(whichUnitSelf, SightRange_INCREASING_SPELL_ID)
                        call SetUnitAbilityLevel(whichUnitSelf, SightRange_INCREASING_SPELL_ID, packetLevel)
                        call UnitRemoveAbility(whichUnitSelf, SightRange_INCREASING_SPELL_ID)
                        set amount = amount - packet
                    endloop
                    set packet = packet / 2
                    set packetLevel = packetLevel - 1
                endloop
            endif
            set whichUnitSelf = null
        endfunction

        function AddUnitSightRange takes Unit whichUnit, real amount returns nothing
            call SetUnitSightRange(whichUnit, GetUnitSightRange(whichUnit) + amount)
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("sightRange", "SightRange", "real")

        public function SightRange_Init takes nothing returns nothing
            call InitAbility(SightRange_DECREASING_SPELL_ID)
            call InitAbility(SightRange_INCREASING_SPELL_ID)
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Speed
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Speed")
        globals
            public constant real Speed_LOWER_CAP = 125.
            public constant real Speed_UPPER_CAP = 522.
        endglobals

        function GetUnitSpeed takes Unit whichUnit returns real
            return whichUnit.speed
        endfunction

        function GetUnitSpeedBonus takes Unit whichUnit returns real
            return whichUnit.speedBonus
        endfunction

        //! runtextmacro Scope("Base")
            function SetUnitSpeed takes Unit whichUnit, real amount returns nothing
                local real bonusSpeed = GetUnitSpeedBonus( whichUnit )
                set whichUnit.speed = amount
                set amount = bonusSpeed + amount
                set amount = Max( Speed_LOWER_CAP, amount )
                set amount = Min( amount, Speed_UPPER_CAP )
                call SetUnitMoveSpeed( whichUnit.self, amount - Sign( bonusSpeed ) )
            endfunction

            function AddUnitSpeed takes Unit whichUnit, real amount returns nothing
                call SetUnitSpeed( whichUnit, GetUnitSpeed( whichUnit ) + amount )
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Bonus")
            globals
                private constant integer Bonus_DUMMY_SPELL_ID = 'A010'
            endglobals

            function SetUnitSpeedBonus takes Unit whichUnit, real amount returns nothing
                local integer abilityLevel
                local unit whichUnitSelf = whichUnit.self
                set whichUnit.speedBonus = amount
                if ( amount > 0 ) then
                    set abilityLevel = 3
                else
                    set abilityLevel = 1 + B2I( amount < 0 )
                endif
                set amount = GetUnitSpeed( whichUnit ) + amount
                set amount = Max( Speed_LOWER_CAP, amount )
                set amount = Min( amount, Speed_UPPER_CAP )
                call SetUnitMoveSpeed( whichUnitSelf, amount - Sign( GetUnitSpeedBonus( whichUnit ) ) )
                call SetUnitAbilityLevel( whichUnitSelf, Bonus_DUMMY_SPELL_ID, abilityLevel )
                call UpdateUnitDisplay( whichUnitSelf )
                set whichUnitSelf = null
            endfunction

            function AddUnitSpeedBonus takes Unit whichUnit, real amount returns nothing
                call SetUnitSpeedBonus( whichUnit, GetUnitSpeedBonus( whichUnit ) + amount )
            endfunction

            public function Bonus_Init takes nothing returns nothing
                call InitAbility( Bonus_DUMMY_SPELL_ID )
            endfunction
        //! runtextmacro Endscope()

        function GetUnitSpeedTotal takes Unit whichUnit returns real
            return (GetUnitSpeed(whichUnit) + GetUnitSpeedBonus(whichUnit))
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("speed", "Speed", "real")

        //! runtextmacro CreateSimpleUnitTypeStateForPlayer("speed", "Speed", "real")

        public function Speed_Init takes nothing returns nothing
            call Bonus_Bonus_Init()
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Stun
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Stun")
        globals
            private string array Stun_TARGET_EFFECTS_PATH
            private string array Stun_TARGET_EFFECTS_ATTACHMENT_POINT
        endglobals

        //! runtextmacro CreateSimpleUnitState("stunDurationRelativeBonus", "StunDurationRelativeBonus", "real")

        //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

        function GetUnitStun takes Unit whichUnit, integer number returns integer
            return whichUnit.stun[number]
        endfunction

        //! runtextmacro Scope("Ensnare")
            globals
                private constant integer Ensnare_AIR_BUFF_ID = 'B009'
                private constant integer Ensnare_GROUND_BUFF_ID = 'B00U'
                private constant integer Ensnare_DUMMY_ORDER_ID = 852106//OrderId( "ensnare" )
                private constant integer Ensnare_DUMMY_SPELL_ID = 'A07U'
            endglobals

            public function Ensnare_Remove takes Unit whichUnit returns nothing
                local integer amount = whichUnit.stunEnsnare - 1
                set whichUnit.stunEnsnare = amount
                if (amount == 0) then
                    call UnitRemoveAbility( whichUnit.self, Ensnare_AIR_BUFF_ID )
                    call UnitRemoveAbility( whichUnit.self, Ensnare_GROUND_BUFF_ID )
                endif
            endfunction

            //! runtextmacro Scope("Cancel")
                globals
                    public constant integer Cancel_ORDER_ID = 851973
                endglobals

                private struct Cancel_Data
                    timer delayTimer
                    Unit whichUnit
                endstruct

                private function Cancel_Ending takes Cancel_Data d, timer delayTimer, Unit whichUnit returns nothing
                    local integer whichUnitId = whichUnit.id
                    call d.destroy()
                    call FlushAttachedInteger(delayTimer, Cancel_SCOPE_ID)
                    call DestroyTimerWJ(delayTimer)
                    call FlushAttachedIntegerById(whichUnitId, Cancel_SCOPE_ID)
                    //! runtextmacro RemoveEventById( "whichUnitId", "Cancel_EVENT_DEATH" )
                    call UnitRemoveAbility( whichUnit.self, Ensnare_AIR_BUFF_ID )
                    call UnitRemoveAbility( whichUnit.self, Ensnare_GROUND_BUFF_ID )
                endfunction

                public function Cancel_Death takes Unit whichUnit returns nothing
                    local Cancel_Data d = GetAttachedIntegerById(whichUnit.id, Cancel_SCOPE_ID)
                    if (d != NULL) then
                        call Cancel_Ending(d, d.delayTimer, whichUnit)
                    endif
                endfunction

                private function Cancel_Death_Event takes nothing returns nothing
                    call Cancel_Death(DYING_UNIT)
                endfunction

                private function Cancel_EndingByTimer takes nothing returns nothing
                    local timer delayTimer = GetExpiredTimer()
                    local Cancel_Data d = GetAttachedInteger(delayTimer, Cancel_SCOPE_ID)
                    call Cancel_Ending(d, delayTimer, d.whichUnit)
                    set delayTimer = null
                endfunction

                public function Cancel_OrderExecute takes Unit whichUnit returns nothing
                    local Cancel_Data d
                    local timer delayTimer
                    local integer whichUnitId
                    if (whichUnit.stunThunderbolt == 0) then
                        set whichUnitId = whichUnit.id
                        if (GetAttachedIntegerById(whichUnitId, Cancel_SCOPE_ID) == NULL) then
                            set d = Cancel_Data.create()
                            set delayTimer = CreateTimerWJ()
                            set d.delayTimer = delayTimer
                            set d.whichUnit = whichUnit
                            call AttachInteger(delayTimer, Cancel_SCOPE_ID, d)
                            call AttachIntegerById(whichUnitId, Cancel_SCOPE_ID, d)
                            //! runtextmacro AddEventById( "whichUnitId", "Cancel_EVENT_DEATH" )
                            call TimerStart(delayTimer, 0, false, function Cancel_EndingByTimer)
                            set delayTimer = null
                        endif
                    endif
                endfunction

                private function Cancel_OrderExecute_Event takes nothing returns nothing
                    call Cancel_OrderExecute(ORDERED_UNIT)
                endfunction

                public function Cancel_Init takes nothing returns nothing
                    //! runtextmacro CreateEvent( "Cancel_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Cancel_Death_Event" )
                    //! runtextmacro AddNewEventById( "Cancel_EVENT_ORDER_EXECUTE", "Cancel_ORDER_ID", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function Cancel_OrderExecute_Event" )
                endfunction
            //! runtextmacro Endscope()

            public function Ensnare_Add takes Unit whichUnit returns nothing
                local integer amount = whichUnit.stunEnsnare + 1
                local unit whichUnitSelf
                set whichUnit.stunEnsnare = amount
                if (amount == 1) then
                    set whichUnitSelf = whichUnit.self
                    call SetUnitX( WORLD_CASTER, GetUnitX( whichUnitSelf ) )
                    call SetUnitY( WORLD_CASTER, GetUnitY( whichUnitSelf ) )
                    call IssueTargetOrderById( WORLD_CASTER, Ensnare_DUMMY_ORDER_ID, whichUnitSelf )
                    set whichUnitSelf = null
                endif
            endfunction

            public function Ensnare_Init takes nothing returns nothing
                //call InitAbility(Ensnare_DUMMY_SPELL_ID)
                call Cancel_Cancel_Init()
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("EntanglingRoots")
            globals
                private constant integer EntanglingRoots_DUMMY_BUFF_ID = 'B00S'
                private constant integer EntanglingRoots_DUMMY_ORDER_ID = 852171//OrderId( "entanglingroots" )
                private constant integer EntanglingRoots_DUMMY_SPELL_ID = 'A072'
            endglobals

            public function EntanglingRoots_Remove takes Unit whichUnit returns nothing
                local integer amount = whichUnit.stunEntanglingRoots - 1
                set whichUnit.stunEntanglingRoots = amount
                if (amount == 0) then
                    call UnitRemoveAbility( whichUnit.self, EntanglingRoots_DUMMY_BUFF_ID )
                endif
            endfunction

            public function EntanglingRoots_Add takes Unit whichUnit returns nothing
                local integer amount = whichUnit.stunEntanglingRoots + 1
                local unit whichUnitSelf
                set whichUnit.stunEntanglingRoots = amount
                if (amount == 1) then
                    set whichUnitSelf = whichUnit.self
                    call SetUnitX( WORLD_CASTER, GetUnitX( whichUnitSelf ) )
                    call SetUnitY( WORLD_CASTER, GetUnitY( whichUnitSelf ) )
                    call IssueTargetOrderById( WORLD_CASTER, EntanglingRoots_DUMMY_ORDER_ID, whichUnitSelf )
                    set whichUnitSelf = null
                endif
            endfunction

            public function EntanglingRoots_Init takes nothing returns nothing
                //call InitAbility(EntanglingRoots_DUMMY_SPELL_ID)
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Thunderbolt")
            globals
                private constant integer Thunderbolt_DUMMY_BUFF_ID = 'B00T'
                private constant integer Thunderbolt_DUMMY_ORDER_ID = 852095//OrderId( "thunderbolt" )
                private constant integer Thunderbolt_DUMMY_SPELL_ID = 'A073'
            endglobals

            public function Thunderbolt_Remove takes Unit whichUnit returns nothing
                local integer amount = whichUnit.stunThunderbolt - 1
                set whichUnit.stunThunderbolt = amount
                if (amount == 0) then
                    call UnitRemoveAbility( whichUnit.self, Thunderbolt_DUMMY_BUFF_ID )
                endif
            endfunction

            //! runtextmacro Scope("Cancel")
                globals
                    public constant integer Cancel_ORDER_ID = 851973
                endglobals

                private struct Cancel_Data
                    timer delayTimer
                    Unit whichUnit
                endstruct

                private function Cancel_Ending takes Cancel_Data d, timer delayTimer, Unit whichUnit returns nothing
                    local integer whichUnitId = whichUnit.id
                    call d.destroy()
                    call FlushAttachedInteger(delayTimer, Cancel_SCOPE_ID)
                    call DestroyTimerWJ(delayTimer)
                    call FlushAttachedIntegerById(whichUnitId, Cancel_SCOPE_ID)
                    //! runtextmacro RemoveEventById( "whichUnitId", "Cancel_EVENT_DEATH" )
                    call UnitRemoveAbility( whichUnit.self, Thunderbolt_DUMMY_BUFF_ID )
                endfunction

                public function Cancel_Death takes Unit whichUnit returns nothing
                    local Cancel_Data d = GetAttachedIntegerById(whichUnit.id, Cancel_SCOPE_ID)
                    if (d != NULL) then
                        call Cancel_Ending(d, d.delayTimer, whichUnit)
                    endif
                endfunction

                private function Cancel_Death_Event takes nothing returns nothing
                    call Cancel_Death(DYING_UNIT)
                endfunction

                private function Cancel_EndingByTimer takes nothing returns nothing
                    local timer delayTimer = GetExpiredTimer()
                    local Cancel_Data d = GetAttachedInteger(delayTimer, Cancel_SCOPE_ID)
                    call Cancel_Ending(d, delayTimer, d.whichUnit)
                    set delayTimer = null
                endfunction

                public function Cancel_OrderExecute takes Unit whichUnit returns nothing
                    local Cancel_Data d
                    local timer delayTimer
                    local integer whichUnitId
                    if (whichUnit.stunThunderbolt == 0) then
                        set whichUnitId = whichUnit.id
                        if (GetAttachedIntegerById(whichUnitId, Cancel_SCOPE_ID) == NULL) then
                            set d = Cancel_Data.create()
                            set delayTimer = CreateTimerWJ()
                            set d.delayTimer = delayTimer
                            set d.whichUnit = whichUnit
                            call AttachInteger(delayTimer, Cancel_SCOPE_ID, d)
                            call AttachIntegerById(whichUnitId, Cancel_SCOPE_ID, d)
                            //! runtextmacro AddEventById( "whichUnitId", "Cancel_EVENT_DEATH" )
                            call TimerStart(delayTimer, 0, false, function Cancel_EndingByTimer)
                            set delayTimer = null
                        endif
                    endif
                endfunction

                private function Cancel_OrderExecute_Event takes nothing returns nothing
                    call Cancel_OrderExecute(ORDERED_UNIT)
                endfunction

                public function Cancel_Init takes nothing returns nothing
                    //! runtextmacro CreateEvent( "Cancel_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Cancel_Death_Event" )
                    //! runtextmacro AddNewEventById( "Cancel_EVENT_ORDER_EXECUTE", "Cancel_ORDER_ID", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function Cancel_OrderExecute_Event" )
                endfunction
            //! runtextmacro Endscope()

            public function Thunderbolt_Add takes Unit whichUnit returns nothing
                local integer amount = whichUnit.stunThunderbolt + 1
                local unit whichUnitSelf
                set whichUnit.stunThunderbolt = amount
                if (amount == 1) then
                    set whichUnitSelf = whichUnit.self
                    call SetUnitX( WORLD_CASTER, GetUnitX( whichUnitSelf ) )
                    call SetUnitY( WORLD_CASTER, GetUnitY( whichUnitSelf ) )
                    call IssueTargetOrderById( WORLD_CASTER, Thunderbolt_DUMMY_ORDER_ID, whichUnitSelf )
                    set whichUnitSelf = null
                endif
            endfunction

            public function Thunderbolt_Init takes nothing returns nothing
                //call InitAbility(Thunderbolt_DUMMY_SPELL_ID)
                call Cancel_Cancel_Init()
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Type0")
            public function Type0_Ending takes Unit whichUnit returns nothing
                //! runtextmacro RemoveEventById( "whichUnit.id", "Type0_EVENT_DEATH" )
                call EntanglingRoots_EntanglingRoots_Remove(whichUnit)
            endfunction

            public function Type0_Death takes Unit whichUnit returns nothing
                if (GetUnitStun(whichUnit, 0) > 0) then
                    call Type0_Ending(whichUnit)
                endif
            endfunction

            private function Type0_Death_Event takes nothing returns nothing
                call Type0_Death(DYING_UNIT)
            endfunction

            public function Type0_Start takes Unit whichUnit returns nothing
                //! runtextmacro AddEventById( "whichUnit.id", "Type0_EVENT_DEATH" )
                call EntanglingRoots_EntanglingRoots_Add(whichUnit)
            endfunction

            public function Type0_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Type0_EVENT_DEATH", "UnitDies_EVENT_KEY", "1", "function Type0_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Type1")
            public function Type1_Ending takes Unit whichUnit returns nothing
                //! runtextmacro RemoveEventById( "whichUnit.id", "Type1_EVENT_DEATH" )
                call Thunderbolt_Thunderbolt_Remove(whichUnit)
            endfunction

            public function Type1_Death takes Unit whichUnit returns nothing
                if (GetUnitStun(whichUnit, 1) > 0) then
                    call Type1_Ending(whichUnit)
                endif
            endfunction

            private function Type1_Death_Event takes nothing returns nothing
                call Type1_Death(DYING_UNIT)
            endfunction

            public function Type1_Start takes Unit whichUnit returns nothing
                //! runtextmacro AddEventById( "whichUnit.id", "Type1_EVENT_DEATH" )
                call Thunderbolt_Thunderbolt_Add(whichUnit)
            endfunction

            public function Type1_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Type1_EVENT_DEATH", "UnitDies_EVENT_KEY", "1", "function Type1_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Type2")
            public function Type2_Ending takes Unit whichUnit returns nothing
                //! runtextmacro RemoveEventById( "whichUnit.id", "Type2_EVENT_DEATH" )
                call Thunderbolt_Thunderbolt_Remove(whichUnit)
            endfunction

            public function Type2_Death takes Unit whichUnit returns nothing
                if (GetUnitStun(whichUnit, 2) > 0) then
                    call Type2_Ending(whichUnit)
                endif
            endfunction

            private function Type2_Death_Event takes nothing returns nothing
                call Type2_Death(DYING_UNIT)
            endfunction

            public function Type2_Start takes Unit whichUnit returns nothing
                //! runtextmacro AddEventById( "whichUnit.id", "Type2_EVENT_DEATH" )
                call Thunderbolt_Thunderbolt_Add(whichUnit)
            endfunction

            public function Type2_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Type2_EVENT_DEATH", "UnitDies_EVENT_KEY", "1", "function Type2_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Type3")
            public function Type3_Ending takes Unit whichUnit returns nothing
                //! runtextmacro RemoveEventById( "whichUnit.id", "Type3_EVENT_DEATH" )
                call Ensnare_Ensnare_Remove(whichUnit)
            endfunction

            public function Type3_Death takes Unit whichUnit returns nothing
                if (GetUnitStun(whichUnit, 3) > 0) then
                    call Type3_Ending(whichUnit)
                endif
            endfunction

            private function Type3_Death_Event takes nothing returns nothing
                call Type3_Death(DYING_UNIT)
            endfunction

            public function Type3_Start takes Unit whichUnit returns nothing
                //! runtextmacro AddEventById( "whichUnit.id", "Type3_EVENT_DEATH" )
                call Ensnare_Ensnare_Add(whichUnit)
            endfunction

            public function Type3_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Type3_EVENT_DEATH", "UnitDies_EVENT_KEY", "1", "function Type3_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Type4")
            public function Type4_Ending takes Unit whichUnit returns nothing
                //! runtextmacro RemoveEventById( "whichUnit.id", "Type4_EVENT_DEATH" )
                call EntanglingRoots_EntanglingRoots_Remove(whichUnit)
            endfunction

            public function Type4_Death takes Unit whichUnit returns nothing
                if (GetUnitStun(whichUnit, 4) > 0) then
                    call Type4_Ending(whichUnit)
                endif
            endfunction

            private function Type4_Death_Event takes nothing returns nothing
                call Type4_Death(DYING_UNIT)
            endfunction

            public function Type4_Start takes Unit whichUnit returns nothing
                //! runtextmacro AddEventById( "whichUnit.id", "Type4_EVENT_DEATH" )
                call EntanglingRoots_EntanglingRoots_Add(whichUnit)
            endfunction

            public function Type4_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Type4_EVENT_DEATH", "UnitDies_EVENT_KEY", "1", "function Type4_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Type5")
            public function Type5_Ending takes Unit whichUnit returns nothing
                //! runtextmacro RemoveEventById( "whichUnit.id", "Type5_EVENT_DEATH" )
                call Thunderbolt_Thunderbolt_Remove(whichUnit)
            endfunction

            public function Type5_Death takes Unit whichUnit returns nothing
                if (GetUnitStun(whichUnit, 5) > 0) then
                    call Type5_Ending(whichUnit)
                endif
            endfunction

            private function Type5_Death_Event takes nothing returns nothing
                call Type5_Death(DYING_UNIT)
            endfunction

            public function Type5_Start takes Unit whichUnit returns nothing
                //! runtextmacro AddEventById( "whichUnit.id", "Type5_EVENT_DEATH" )
                call Thunderbolt_Thunderbolt_Add(whichUnit)
            endfunction

            public function Type5_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Type5_EVENT_DEATH", "UnitDies_EVENT_KEY", "1", "function Type5_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        function RemoveUnitStun takes Unit whichUnit, integer number returns nothing
            local integer amount = whichUnit.stun[number] - 1
            set whichUnit.stun[number] = amount
            if (amount == 0) then
                call DestroyEffectWJ(whichUnit.stunEffect[number])
                if ( number == 0 ) then
                    call Type0_Type0_Ending(whichUnit)
                elseif ( number == 1 ) then
                    call Type1_Type1_Ending(whichUnit)
                elseif ( number == 2 ) then
                    call Type2_Type2_Ending(whichUnit)
                elseif ( number == 3 ) then
                    call Type3_Type3_Ending(whichUnit)
                elseif ( number == 4 ) then
                    call Type4_Type4_Ending(whichUnit)
                elseif ( number == 5 ) then
                    call Type5_Type5_Ending(whichUnit)
                endif
            endif
        endfunction

        function AddUnitStun takes Unit whichUnit, integer number returns nothing
            local integer amount = whichUnit.stun[number] + 1
            set whichUnit.stun[number] = amount
            if (amount == 1) then
                set whichUnit.stunEffect[number] = AddSpecialEffectTargetWJ( Stun_TARGET_EFFECTS_PATH[number], whichUnit.self, Stun_TARGET_EFFECTS_ATTACHMENT_POINT[number] )
                if ( number == 0 ) then
                    call Type0_Type0_Start(whichUnit)
                elseif ( number == 1 ) then
                    call Type1_Type1_Start(whichUnit)
                elseif ( number == 2 ) then
                    call Type2_Type2_Start(whichUnit)
                elseif ( number == 3 ) then
                    call Type3_Type3_Start(whichUnit)
                elseif ( number == 4 ) then
                    call Type4_Type4_Start(whichUnit)
                elseif ( number == 5 ) then
                    call Type5_Type5_Start(whichUnit)
                endif
            endif
        endfunction

        //! runtextmacro Scope("Timed")
            globals
                private integer array Timed_SCOPES_ID
            endglobals

            private struct Timed_Data
                Unit target
            endstruct

            //! runtextmacro Scope("Number")
                public struct Number_Data
                    timer durationTimer
                    integer number
                    Unit target
                endstruct

                public function Number_Ending takes Number_Data d, timer durationTimer, Unit target returns nothing
                    local integer number = d.number
                    call d.destroy()
                    call FlushAttachedInteger( durationTimer, Number_SCOPE_ID )
                    call DestroyTimerWJ( durationTimer )
                    call FlushAttachedIntegerById( target.id, Number_SCOPE_ID )
                    call RemoveUnitStun(target, number)
                endfunction

                public function Number_EndingByDeath takes Unit target returns nothing
                    local Number_Data d = GetAttachedIntegerById(target.id, Number_SCOPE_ID)
                    if (d != NULL) then
                        call Number_Ending(d, d.durationTimer, target)
                    endif
                endfunction

                private function Number_EndingByTimer takes nothing returns nothing
                    local timer durationTimer = GetExpiredTimer()
                    local Number_Data d = GetAttachedInteger(durationTimer, Number_SCOPE_ID)
                    call Number_Ending(d, durationTimer, d.target)
                    set durationTimer = null
                endfunction

                public function Number_Start takes Unit target, integer number, real duration returns nothing
                    local timer durationTimer
                    local integer targetId = target.id
                    local Number_Data d = GetAttachedIntegerById(targetId, Number_SCOPE_ID)
                    if (d == NULL) then
                        set durationTimer = CreateTimerWJ()
                        set d = Number_Data.create()
                        set d.durationTimer = durationTimer
                        set d.number = number
                        set d.target = target
                        call AttachInteger(durationTimer, Number_SCOPE_ID, d)
                        call AttachIntegerById(targetId, Number_SCOPE_ID, d)
                        call AddUnitStun( target, number )
                        call TimerStart( durationTimer, duration, false, function Number_EndingByTimer )
                    else
                        set durationTimer = d.durationTimer
                        if ( duration > TimerGetRemaining( durationTimer ) ) then
                            call TimerStart( durationTimer, duration, false, function Number_EndingByTimer )
                        endif
                    endif
                    set durationTimer = null
                endfunction
            //! runtextmacro Endscope()

            public function Timed_Death takes Unit target returns nothing
                local integer targetId = target.id
                local Timed_Data d = GetAttachedIntegerById(targetId, Timed_SCOPE_ID)
                if (d != NULL) then
                    call d.destroy()
                    call FlushAttachedIntegerById( targetId, Timed_SCOPE_ID )
                    //! runtextmacro RemoveEventById( "targetId", "Timed_EVENT_DEATH" )
                    call Number_Number_EndingByDeath(target)
                endif
            endfunction

            private function Timed_Death_Event takes nothing returns nothing
                call Timed_Death(DYING_UNIT)
            endfunction

            function SetUnitStunTimed takes Unit target, integer number, real duration returns nothing
                local Timed_Data d
                local integer targetId
                set duration = duration * ( 1 + GetUnitStunDurationRelativeBonus( target ) )
                if (duration > 0) then
                    set targetId = target.id
                    set d = GetAttachedIntegerById(targetId, Timed_SCOPE_ID)
                    if ( d == NULL ) then
                        set d = Timed_Data.create()
                        set d.target = target
                        call AttachIntegerById( targetId, Timed_SCOPE_ID, d )
                        //! runtextmacro AddEventById( "targetId", "Timed_EVENT_DEATH" )
                    endif
                    call Number_Number_Start(target, number, duration)
                endif
            endfunction

            public function Timed_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Timed_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Timed_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        public function Stun_Init takes nothing returns nothing
            local integer iteration = Stun_AMOUNT - 1
            set Stun_TARGET_EFFECTS_PATH[0] = ""
            set Stun_TARGET_EFFECTS_ATTACHMENT_POINT[0] = ""
            set Stun_TARGET_EFFECTS_PATH[1] = "Abilities\\Spells\\Human\\Thunderclap\\ThunderclapTarget.mdl"
            set Stun_TARGET_EFFECTS_ATTACHMENT_POINT[1] = "overhead"
            set Stun_TARGET_EFFECTS_PATH[2] = "Abilities\\Spells\\Undead\\FreezingBreath\\FreezingBreathTargetArt.mdl"
            set Stun_TARGET_EFFECTS_ATTACHMENT_POINT[2] = "origin"
            set Stun_TARGET_EFFECTS_PATH[3] = ""
            set Stun_TARGET_EFFECTS_ATTACHMENT_POINT[3] = ""
            set Stun_TARGET_EFFECTS_PATH[4] = "Abilities\\Spells\\Human\\slow\\slowtarget.mdl"
            set Stun_TARGET_EFFECTS_ATTACHMENT_POINT[4] = "origin"
            set Stun_TARGET_EFFECTS_PATH[5] = ""
            set Stun_TARGET_EFFECTS_ATTACHMENT_POINT[5] = ""
            loop
                call InitEffectType( Stun_TARGET_EFFECTS_PATH[iteration] )
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call Ensnare_Ensnare_Init()
            call EntanglingRoots_EntanglingRoots_Init()
            call Thunderbolt_Thunderbolt_Init()
            call Type0_Type0_Init()
            call Type1_Type1_Init()
            call Type2_Type2_Init()
            call Type3_Type3_Init()
            call Type4_Type4_Init()
            call Type5_Type5_Init()
            call Timed_Timed_Init()
        endfunction
    //! runtextmacro Endscope()

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Vertex Color
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("VertexColor")
        function GetUnitVertexColorRed takes Unit whichUnit returns real
            return whichUnit.vertexColorRed
        endfunction

        function GetUnitVertexColorRedForPlayer takes Unit whichUnit, player whichPlayer returns real
            return whichUnit.vertexColorRedForPlayer[GetPlayerId(whichPlayer)]
        endfunction

        function GetUnitVertexColorGreen takes Unit whichUnit returns real
            return whichUnit.vertexColorGreen
        endfunction

        function GetUnitVertexColorGreenForPlayer takes Unit whichUnit, player whichPlayer returns real
            return whichUnit.vertexColorGreenForPlayer[GetPlayerId(whichPlayer)]
        endfunction

        function GetUnitVertexColorBlue takes Unit whichUnit returns real
            return whichUnit.vertexColorBlue
        endfunction

        function GetUnitVertexColorBlueForPlayer takes Unit whichUnit, player whichPlayer returns real
            return whichUnit.vertexColorBlueForPlayer[GetPlayerId(whichPlayer)]
        endfunction

        function GetUnitVertexColorAlpha takes Unit whichUnit returns real
            return whichUnit.vertexColorAlpha
        endfunction

        function GetUnitVertexColorAlphaForPlayer takes Unit whichUnit, player whichPlayer returns real
            return whichUnit.vertexColorAlphaForPlayer[GetPlayerId(whichPlayer)]
        endfunction

        function SetUnitVertexColorWJ takes Unit whichUnit, real red, real green, real blue, real alpha, player whichPlayer returns nothing
            if ( whichPlayer == null ) then
                set red = red + GetUnitVertexColorRedForPlayer(whichUnit, whichPlayer)
                set red = Max( 0, red )
                set red = Min( red, 255 )
                set green = green + GetUnitVertexColorGreenForPlayer(whichUnit, whichPlayer)
                set green = Max( 0, green )
                set green = Min( green, 255 )
                set blue = blue + GetUnitVertexColorBlueForPlayer(whichUnit, whichPlayer)
                set blue = Max( 0, blue )
                set blue = Min( blue, 255 )
                set alpha = alpha + GetUnitVertexColorAlphaForPlayer(whichUnit, whichPlayer)
                set alpha = Max( 0, alpha )
                set alpha = Min( alpha, 255 )
                call SetUnitVertexColor( whichUnit.self, R2I( red ), R2I( green ), R2I( blue ), R2I( alpha ) )
            elseif ( GetLocalPlayer() == whichPlayer ) then
                set red = red + GetUnitVertexColorRed(whichUnit)
                set red = Max( 0, red )
                set red = Min( red, 255 )
                set green = green + GetUnitVertexColorGreen(whichUnit)
                set green = Max( 0, green )
                set green = Min( green, 255 )
                set blue = blue + GetUnitVertexColorBlue(whichUnit)
                set blue = Max( 0, blue )
                set blue = Min( blue, 255 )
                set alpha = alpha + GetUnitVertexColorAlpha(whichUnit)
                set alpha = Max( 0, alpha )
                set alpha = Min( alpha, 255 )
                call SetUnitVertexColor( whichUnit.self, R2I( red ), R2I( green ), R2I( blue ), R2I( alpha ) )
            endif
        endfunction

        function SetUnitVertexColorEx takes Unit whichUnit, real red, real green, real blue, real alpha, player whichPlayer returns nothing
            local integer whichPlayerId
            if ( whichPlayer == null ) then
                set whichUnit.vertexColorRed = red
                set whichUnit.vertexColorGreen = green
                set whichUnit.vertexColorBlue = blue
                set whichUnit.vertexColorAlpha = alpha
            else
                set whichPlayerId = GetPlayerId(whichPlayer)
                set whichUnit.vertexColorRedForPlayer[whichPlayerId] = red
                set whichUnit.vertexColorGreenForPlayer[whichPlayerId] = green
                set whichUnit.vertexColorBlueForPlayer[whichPlayerId] = blue
                set whichUnit.vertexColorAlphaForPlayer[whichPlayerId] = alpha
            endif
            call SetUnitVertexColorWJ( whichUnit, red, green, blue, alpha, whichPlayer )
        endfunction

        function AddUnitVertexColor takes Unit whichUnit, real red, real green, real blue, real alpha, player whichPlayer returns nothing
            if (whichPlayer == null) then
                call SetUnitVertexColorEx( whichUnit, GetUnitVertexColorRed( whichUnit ) + red, GetUnitVertexColorGreen( whichUnit ) + green, GetUnitVertexColorBlue( whichUnit ) + blue, GetUnitVertexColorAlpha(whichUnit) + alpha, whichPlayer )
            else
                call SetUnitVertexColorEx( whichUnit, GetUnitVertexColorRedForPlayer(whichUnit, whichPlayer) + red, GetUnitVertexColorGreenForPlayer(whichUnit, whichPlayer) + green, GetUnitVertexColorBlueForPlayer(whichUnit, whichPlayer) + blue, GetUnitVertexColorAlphaForPlayer(whichUnit, whichPlayer) + alpha, whichPlayer )
            endif
        endfunction

        //! runtextmacro Scope("Timed")
            globals
                private constant real Timed_UPDATE_TIME = 0.035
            endglobals

            private struct Timed_Data
                real bonusRedPerInterval
                real bonusGreenPerInterval
                real bonusBluePerInterval
                real bonusAlphaPerInterval
                timer durationTimer
                timer updateTimer
                player whichPlayer
                Unit whichUnit
            endstruct

            private function Timed_Ending takes Timed_Data d, timer durationTimer, Unit whichUnit returns nothing
                local timer updateTimer = d.updateTimer
                local integer whichUnitId = whichUnit.id
                call d.destroy()
                call DestroyTimerWJ( durationTimer )
                call DestroyTimerWJ( updateTimer )
                set updateTimer = null
                call RemoveIntegerFromTableById( whichUnitId, Timed_SCOPE_ID, d )
                if (CountIntegersInTableById(whichUnitId, Timed_SCOPE_ID) == TABLE_EMPTY) then
                    //! runtextmacro RemoveEventById( "whichUnitId", "Timed_EVENT_DECAY" )
                endif
            endfunction

            public function Timed_Decay takes Unit whichUnit returns nothing
                local Timed_Data d
                local integer whichUnitId = whichUnit.id
                local integer iteration = CountIntegersInTableById(whichUnitId, Timed_SCOPE_ID)
                if (iteration > TABLE_EMPTY) then
                    loop
                        set d = GetIntegerFromTableById(whichUnitId, Timed_SCOPE_ID, iteration)
                        call Timed_Ending(d, d.durationTimer, whichUnit)
                        set iteration = iteration - 1
                        exitwhen (iteration < TABLE_STARTED)
                    endloop
                endif
            endfunction

            private function Timed_Decay_Event takes nothing returns nothing
                call Timed_Decay(TRIGGER_UNIT)
            endfunction

            private function Timed_EndingByTimer takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(durationTimer, Timed_SCOPE_ID)
                call Timed_Ending( d, durationTimer, d.whichUnit )
                set durationTimer = null
            endfunction

            private function Timed_Update takes nothing returns nothing
                local timer updateTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(updateTimer, Timed_SCOPE_ID)
                local Unit whichUnit = d.whichUnit
                call AddUnitVertexColor( whichUnit, d.bonusRedPerInterval, d.bonusGreenPerInterval, d.bonusBluePerInterval, d.bonusAlphaPerInterval, d.whichPlayer )
            endfunction

            function AddUnitVertexColorTimed takes Unit whichUnit, real red, real green, real blue, real alpha, player whichPlayer, real duration returns nothing
                local Timed_Data d
                local timer durationTimer
                local timer updateTimer
                local integer wavesAmount
                local integer whichUnitId
                if ( duration != 0 ) then
                    set d = Timed_Data.create()
                    set durationTimer = CreateTimerWJ()
                    set updateTimer = CreateTimerWJ()
                    set wavesAmount = R2I(duration / Timed_UPDATE_TIME)
                    set whichUnitId = whichUnit.id
                    set d.bonusRedPerInterval = red / wavesAmount
                    set d.bonusGreenPerInterval = green / wavesAmount
                    set d.bonusBluePerInterval = blue / wavesAmount
                    set d.bonusAlphaPerInterval = alpha / wavesAmount
                    set d.durationTimer = durationTimer
                    set d.updateTimer = updateTimer
                    set d.whichPlayer = whichPlayer
                    set d.whichUnit = whichUnit
                    call AttachInteger( durationTimer, Timed_SCOPE_ID, d )
                    call AttachInteger( updateTimer, Timed_SCOPE_ID, d )
                    call AddIntegerToTableById( whichUnitId, Timed_SCOPE_ID, d )
                    if (CountIntegersInTableById(whichUnitId, Timed_SCOPE_ID) == TABLE_STARTED) then
                        //! runtextmacro AddEventById( "whichUnitId", "Timed_EVENT_DECAY" )
                    endif
                    call TimerStart( updateTimer, Timed_UPDATE_TIME, true, function Timed_Update )
                    set updateTimer = null
                    call TimerStart( durationTimer, duration, false, function Timed_EndingByTimer )
                    set durationTimer = null
                else
                    call AddUnitVertexColor(whichUnit, red, green, blue, alpha, whichPlayer)
                endif
            endfunction

            public function Timed_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Timed_EVENT_DECAY", "UnitFinishesDecaying_EVENT_KEY", "0", "function Timed_Decay_Event" )
            endfunction
        //! runtextmacro Endscope()

        function GetUnitTypeVertexColorRed takes UnitType whichUnitType returns real
            return whichUnitType.vertexColorRed
        endfunction

        function GetUnitTypeVertexColorGreen takes UnitType whichUnitType returns real
            return whichUnitType.vertexColorGreen
        endfunction

        function GetUnitTypeVertexColorBlue takes UnitType whichUnitType returns real
            return whichUnitType.vertexColorBlue
        endfunction

        function GetUnitTypeVertexColorAlpha takes UnitType whichUnitType returns real
            return whichUnitType.vertexColorAlpha
        endfunction

        function SetUnitTypeVertexColor takes UnitType whichUnitType, real red, real green, real blue, real alpha returns nothing
            set whichUnitType.vertexColorRed = red
            set whichUnitType.vertexColorGreen = green
            set whichUnitType.vertexColorBlue = blue
            set whichUnitType.vertexColorAlpha = alpha
        endfunction

        public function VertexColor_Init takes nothing returns nothing
            call Timed_Timed_Init()
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("DummyVertexColor")
        private struct DummyVertexColor_Data
            real red
            real green
            real blue
            real alpha
        endstruct

        function DestroyDummyVertexColor takes unit dummyUnit returns nothing
            local DummyVertexColor_Data d = GetAttachedInteger(dummyUnit, DummyVertexColor_SCOPE_ID)
            call d.destroy()
            call FlushAttachedInteger(dummyUnit, DummyVertexColor_SCOPE_ID)
        endfunction

        private function DummyVertexColor_GetRed takes DummyVertexColor_Data d returns real
            return d.red
        endfunction

        private function DummyVertexColor_GetGreen takes DummyVertexColor_Data d returns real
            return d.green
        endfunction

        private function DummyVertexColor_GetBlue takes DummyVertexColor_Data d returns real
            return d.blue
        endfunction

        private function DummyVertexColor_GetAlpha takes DummyVertexColor_Data d returns real
            return d.alpha
        endfunction

        private function DummyVertexColor_Set takes unit dummyUnit, DummyVertexColor_Data d, real red, real green, real blue, real alpha returns nothing
            set d.red = red
            set d.green = green
            set d.blue = blue
            set d.alpha = alpha
            set red = Max( 0, red )
            set red = Min( red, 255 )
            set green = Max( 0, green )
            set green = Min( green, 255 )
            set blue = Max( 0, blue )
            set blue = Min( blue, 255 )
            set alpha = Max( 0, alpha )
            set alpha = Min( alpha, 255 )
            call SetUnitVertexColor( dummyUnit, R2I( red ), R2I( green ), R2I( blue ), R2I( alpha ) )
        endfunction

        private function DummyVertexColor_Add takes unit dummyUnit, DummyVertexColor_Data d, real red, real green, real blue, real alpha returns nothing
            call DummyVertexColor_Set( dummyUnit, d, DummyVertexColor_GetRed( d ) + red, DummyVertexColor_GetGreen( d ) + green, DummyVertexColor_GetBlue( d ) + blue, DummyVertexColor_GetAlpha( d ) + alpha )
        endfunction

        //! runtextmacro Scope("Timed")
            globals
                private constant real Timed_UPDATE_TIME = 0.035
            endglobals

            private struct Timed_Data
                real bonusRedPerInterval
                real bonusGreenPerInterval
                real bonusBluePerInterval
                real bonusAlphaPerInterval
                timer durationTimer
                timer updateTimer
                unit whichUnit
            endstruct

            private function Timed_GetUnitData takes unit whichUnit returns Timed_Data
                return GetAttachedInteger(whichUnit, Timed_SCOPE_ID)
            endfunction

            private function Timed_Ending takes Timed_Data d, timer durationTimer, unit whichUnit returns nothing
                local timer updateTimer = d.updateTimer
                call d.destroy()
                call DestroyTimerWJ( durationTimer )
                call DestroyTimerWJ( updateTimer )
                set updateTimer = null
                call RemoveIntegerFromTable( whichUnit, Timed_SCOPE_ID, d )
            endfunction

            private function Timed_EndingByTimer takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(durationTimer, Timed_SCOPE_ID)
                call Timed_Ending( d, durationTimer, d.whichUnit )
                set durationTimer = null
            endfunction

            private function Timed_Update takes nothing returns nothing
                local timer updateTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(updateTimer, Timed_SCOPE_ID)
                local unit whichUnit = d.whichUnit
                call DummyVertexColor_Add( whichUnit, Timed_GetUnitData(whichUnit), d.bonusRedPerInterval, d.bonusGreenPerInterval, d.bonusBluePerInterval, d.bonusAlphaPerInterval )
                set whichUnit = null
            endfunction

            function AddDummyVertexColorTimed takes unit whichUnit, real red, real green, real blue, real alpha, real duration returns nothing
                local Timed_Data d
                local timer durationTimer
                local timer updateTimer
                local integer wavesAmount
                if ( duration != 0 ) then
                    set d = Timed_Data.create()
                    set durationTimer = CreateTimerWJ()
                    set updateTimer = CreateTimerWJ()
                    set wavesAmount = R2I(duration / Timed_UPDATE_TIME)
                    set d.bonusRedPerInterval = red / wavesAmount
                    set d.bonusGreenPerInterval = green / wavesAmount
                    set d.bonusBluePerInterval = blue / wavesAmount
                    set d.bonusAlphaPerInterval = alpha / wavesAmount
                    set d.durationTimer = durationTimer
                    set d.updateTimer = updateTimer
                    set d.whichUnit = whichUnit
                    call AttachInteger( durationTimer, Timed_SCOPE_ID, d )
                    call AttachInteger( updateTimer, Timed_SCOPE_ID, d )
                    call AddIntegerToTable( whichUnit, Timed_SCOPE_ID, d )
                    call TimerStart( updateTimer, Timed_UPDATE_TIME, true, function Timed_Update )
                    set updateTimer = null
                    call TimerStart( durationTimer, duration, false, function Timed_EndingByTimer )
                    set durationTimer = null
                else
                    call DummyVertexColor_Add(whichUnit, Timed_GetUnitData(whichUnit), red, green, blue, alpha)
                endif
            endfunction
        //! runtextmacro Endscope()

        function InitDummyVertexColor takes unit dummyUnit, real red, real green, real blue, real alpha returns nothing
            local DummyVertexColor_Data d = DummyVertexColor_Data.create()
            set d.red = red
            set d.green = green
            set d.blue = blue
            set d.alpha = alpha
            call AttachInteger(dummyUnit, DummyVertexColor_SCOPE_ID, d)
            call SetUnitVertexColor(dummyUnit, R2I(red), R2I(green), R2I(blue), R2I(alpha))
        endfunction
    //! runtextmacro Endscope()

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("FrostSlow")
        globals
            private constant real FrostSlow_BONUS_RED = -150.
            private constant real FrostSlow_BONUS_GREEN = -150.
            private constant real FrostSlow_BONUS_BLUE = 0.
            private constant real FrostSlow_FADE_TIME = 0.5
            private constant string FrostSlow_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl"
            private constant string FrostSlow_TARGET_EFFECT_ATTACHMENT_POINT = "chest"
        endglobals

        function GetUnitFrostSlow takes Unit whichUnit returns integer
            return whichUnit.frostSlow
        endfunction

        function RemoveUnitFrostSlow takes Unit whichUnit returns nothing
            local integer amount = GetUnitFrostSlow(whichUnit) - 1
            set whichUnit.frostSlow = amount
            if (amount == 0) then
                call DestroyEffectWJ(whichUnit.frostSlowEffect)
                call AddUnitVertexColorTimed( whichUnit, -FrostSlow_BONUS_RED, -FrostSlow_BONUS_GREEN, -FrostSlow_BONUS_BLUE, 0, null, FrostSlow_FADE_TIME )
            endif
        endfunction

        function AddUnitFrostSlow takes Unit whichUnit returns nothing
            local integer amount = GetUnitFrostSlow(whichUnit) + 1
            set whichUnit.frostSlow = amount
            if (amount == 1) then
                set whichUnit.frostSlowEffect = AddSpecialEffectTargetWJ( FrostSlow_TARGET_EFFECT_PATH, whichUnit.self, FrostSlow_TARGET_EFFECT_ATTACHMENT_POINT )
                call AddUnitVertexColorTimed( whichUnit, FrostSlow_BONUS_RED, FrostSlow_BONUS_GREEN, FrostSlow_BONUS_BLUE, 0, null, FrostSlow_FADE_TIME )
            endif
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // Ghost
    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Ghost")
        function GetUnitGhost takes Unit whichUnit returns integer
            return whichUnit.ghost
        endfunction

        function RemoveUnitGhost takes Unit whichUnit returns nothing
            local integer amount = GetUnitGhost( whichUnit ) - 1
            set whichUnit.ghost = amount
            if ( amount == 0 ) then
                call UnitRemoveAbility( whichUnit.self, GHOST_SPELL_ID )
            endif
        endfunction

        function AddUnitGhost takes Unit whichUnit returns nothing
            local integer amount = GetUnitGhost( whichUnit ) + 1
            set whichUnit.ghost = amount
            if ( amount == 1 ) then
                call UnitAddAbility( whichUnit.self, GHOST_SPELL_ID )
            endif
        endfunction
    //! runtextmacro Endscope()

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////    Invisibility
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Invisibility")
        function GetUnitInvisibility takes Unit whichUnit returns integer
            return whichUnit.invisibility
        endfunction

        function RemoveUnitInvisibility takes Unit whichUnit returns nothing
            local integer amount = GetUnitInvisibility(whichUnit) - 1
            set whichUnit.invisibility = amount
            if (amount == 0) then
                call RemoveUnitGhost(whichUnit)
                call UnitRemoveAbility(whichUnit.self, INVISIBILITY_SPELL_ID)
                call AddUnitVertexColor(whichUnit, 0, 0, 0, 0, null)
            endif
        endfunction

        function AddUnitInvisibility takes Unit whichUnit returns nothing
            local integer amount = GetUnitInvisibility(whichUnit) + 1
            set whichUnit.invisibility = amount
            if (amount == 1) then
                call AddUnitGhost(whichUnit)
                call UnitAddAbility(whichUnit.self, INVISIBILITY_SPELL_ID)
            endif
        endfunction
    //! runtextmacro Endscope()

    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    ////    Magic Immunity
    /////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("MagicImmunity")
        globals
            private constant integer MagicImmunity_DUMMY_SPELL_BOOK_SPELL_ID = 'A07N'
            private constant integer MagicImmunity_DUMMY_SPELL_ID = 'A02M'
            private constant integer MagicImmunity_ICON_DUMMY_SPELL_ID = 'A02N'
        endglobals

        function GetUnitMagicImmunity takes Unit whichUnit returns integer
            return whichUnit.magicImmunity
        endfunction

        function RemoveUnitMagicImmunity takes Unit whichUnit returns nothing
            local integer amount = whichUnit.magicImmunity - 1
            set whichUnit.magicImmunity = amount
            if (amount == 0) then
                call UnitRemoveAbility(whichUnit.self, MagicImmunity_DUMMY_SPELL_BOOK_SPELL_ID)
            endif
        endfunction

        function AddUnitMagicImmunity takes Unit whichUnit returns nothing
            local integer amount = whichUnit.magicImmunity + 1
            set whichUnit.magicImmunity = amount
            if (amount == 1) then
                call DispelUnit(whichUnit, true, false, false)
                call UnitAddAbility(whichUnit.self, MagicImmunity_DUMMY_SPELL_BOOK_SPELL_ID)
            endif
        endfunction

        public function MagicImmunity_Init takes nothing returns nothing
            local integer iteration = MAX_PLAYER_INDEX
            loop
                call SetPlayerAbilityAvailable(PlayerWJ(iteration), MagicImmunity_DUMMY_SPELL_BOOK_SPELL_ID, false)
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    //! runtextmacro Scope("Order")
        function GetAbilityOrderId takes integer abilityId, integer orderId returns integer
            if (abilityId == 0) then
                return 0
            endif
            if (orderId == 0) then
                return 0
            endif
            return MaxI( INTEGER_MIN, -('0000' + (abilityId - 'A000') * (orderId - 851000)) )
        endfunction

        function IssueImmediateOrderByIdEx takes Unit whichUnit, integer whichOrder returns boolean
            local boolean result
            call DisableTrigger( UnitGetsOrder_DUMMY_TRIGGER )
            set result = IssueImmediateOrderById( whichUnit.self, whichOrder )
            call EnableTrigger( UnitGetsOrder_DUMMY_TRIGGER )
            return result
        endfunction

        //! runtextmacro Scope("ImmediateTimed")
            private struct ImmediateTimed_Data
                timer delayTimer
                Unit target
                integer whichOrder
                Unit whichUnit
            endstruct

            private function ImmediateTimed_Ending takes ImmediateTimed_Data d, timer delayTimer, Unit whichUnit returns nothing
                local integer whichUnitId = whichUnit.id
                call d.destroy()
                call FlushAttachedInteger( delayTimer, ImmediateTimed_SCOPE_ID )
                call DestroyTimerWJ( delayTimer )
                call FlushAttachedIntegerById( whichUnitId, ImmediateTimed_SCOPE_ID )
                //! runtextmacro RemoveEventById( "whichUnitId", "ImmediateTimed_EVENT_DEATH" )
                //! runtextmacro RemoveEventById( "whichUnitId", "ImmediateTimed_EVENT_ORDER" )
            endfunction

            public function ImmediateTimed_Death takes Unit whichUnit returns nothing
                local ImmediateTimed_Data d = GetAttachedIntegerById( whichUnit.id, ImmediateTimed_SCOPE_ID )
                if ( d != NULL ) then
                    call ImmediateTimed_Ending( d, d.delayTimer, whichUnit )
                endif
            endfunction

            private function ImmediateTimed_Death_Event takes nothing returns nothing
                call ImmediateTimed_Death(DYING_UNIT)
            endfunction

            public function ImmediateTimed_OrderExecute takes Unit whichUnit returns nothing
                local ImmediateTimed_Data d = GetAttachedIntegerById( whichUnit.id, ImmediateTimed_SCOPE_ID )
                if ( d != NULL ) then
                    call ImmediateTimed_Ending( d, d.delayTimer, whichUnit )
                endif
            endfunction

            private function ImmediateTimed_OrderExecute_Event takes nothing returns nothing
                call ImmediateTimed_OrderExecute(ORDERED_UNIT)
            endfunction

            private function ImmediateTimed_EndingByTimer takes nothing returns nothing
                local timer delayTimer = GetExpiredTimer()
                local ImmediateTimed_Data d = GetAttachedInteger(delayTimer, ImmediateTimed_SCOPE_ID)
                local integer whichOrder = d.whichOrder
                local Unit whichUnit = d.whichUnit
                call ImmediateTimed_Ending( d, delayTimer, whichUnit )
                set delayTimer = null
                call IssueImmediateOrderById( whichUnit.self, whichOrder )
            endfunction

            function IssueImmediateOrderByIdTimed takes Unit whichUnit, integer whichOrder, real time returns nothing
                local ImmediateTimed_Data d = ImmediateTimed_Data.create()
                local timer delayTimer = CreateTimerWJ()
                local integer whichUnitId = whichUnit.id
                set d.delayTimer = delayTimer
                set d.whichOrder = whichOrder
                set d.whichUnit = whichUnit
                call AttachInteger( delayTimer, ImmediateTimed_SCOPE_ID, d )
                call AttachIntegerById( whichUnitId, ImmediateTimed_SCOPE_ID, d )
                //! runtextmacro AddEventById( "whichUnitId", "ImmediateTimed_EVENT_DEATH" )
                //! runtextmacro AddEventById( "whichUnitId", "ImmediateTimed_EVENT_ORDER" )
                call TimerStart( delayTimer, time, false, function ImmediateTimed_EndingByTimer )
                set delayTimer = null
            endfunction

            public function ImmediateTimed_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "ImmediateTimed_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function ImmediateTimed_Death_Event" )
                //! runtextmacro CreateEvent( "ImmediateTimed_EVENT_ORDER_EXECUTE", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function ImmediateTimed_OrderExecute_Event" )
            endfunction
        //! runtextmacro Endscope()

        function IssuePointOrderByIdEx takes Unit whichUnit, integer whichOrder, real x, real y returns boolean
            local boolean result
            call DisableTrigger( UnitGetsOrder_DUMMY_TRIGGER )
            set result = IssuePointOrderById( whichUnit.self, whichOrder, x, y )
            call EnableTrigger( UnitGetsOrder_DUMMY_TRIGGER )
            return result
        endfunction

        function IssueTargetOrderByIdEx takes Unit whichUnit, integer whichOrder, widget whichTarget returns boolean
            local boolean result
            call DisableTrigger( UnitGetsOrder_DUMMY_TRIGGER )
            set result = IssueTargetOrderById( whichUnit.self, whichOrder, whichTarget )
            call EnableTrigger( UnitGetsOrder_DUMMY_TRIGGER )
            return result
        endfunction

        //! runtextmacro Scope("TargetTimed")
            private struct TargetTimed_Data
                timer delayTimer
                Unit target
                integer whichOrder
                Unit whichUnit
            endstruct

            private function TargetTimed_Ending takes TargetTimed_Data d, timer delayTimer, Unit whichUnit returns nothing
                local integer whichUnitId = whichUnit.id
                call d.destroy()
                call FlushAttachedInteger( delayTimer, TargetTimed_SCOPE_ID )
                call DestroyTimerWJ( delayTimer )
                call FlushAttachedIntegerById( whichUnitId, TargetTimed_SCOPE_ID )
                //! runtextmacro RemoveEventById( "whichUnitId", "TargetTimed_EVENT_DEATH" )
                //! runtextmacro RemoveEventById( "whichUnitId", "TargetTimed_EVENT_ORDER" )
            endfunction

            public function TargetTimed_Death takes Unit whichUnit returns nothing
                local TargetTimed_Data d = GetAttachedIntegerById( whichUnit.id, TargetTimed_SCOPE_ID )
                if ( d != NULL ) then
                    call TargetTimed_Ending( d, d.delayTimer, whichUnit )
                endif
            endfunction

            private function TargetTimed_Death_Event takes nothing returns nothing
                call TargetTimed_Death(DYING_UNIT)
            endfunction

            public function TargetTimed_OrderExecute takes Unit whichUnit returns nothing
                local TargetTimed_Data d = GetAttachedIntegerById( whichUnit.id, TargetTimed_SCOPE_ID )
                if ( d != NULL ) then
                    call TargetTimed_Ending( d, d.delayTimer, whichUnit )
                endif
            endfunction

            private function TargetTimed_OrderExecute_Event takes nothing returns nothing
                call TargetTimed_OrderExecute(ORDERED_UNIT)
            endfunction

            private function TargetTimed_EndingByTimer takes nothing returns nothing
                local timer delayTimer = GetExpiredTimer()
                local TargetTimed_Data d = GetAttachedInteger(delayTimer, TargetTimed_SCOPE_ID)
                local Unit target = d.target
                local integer whichOrder = d.whichOrder
                local Unit whichUnit = d.whichUnit
                call TargetTimed_Ending( d, delayTimer, whichUnit )
                set delayTimer = null
                call IssueTargetOrderById( whichUnit.self, whichOrder, target.self )
            endfunction

            function IssueTargetOrderByIdTimed takes Unit whichUnit, integer whichOrder, Unit target, real time returns nothing
                local TargetTimed_Data d = TargetTimed_Data.create()
                local timer delayTimer = CreateTimerWJ()
                local integer whichUnitId = whichUnit.id
                set d.delayTimer = delayTimer
                set d.target = target
                set d.whichOrder = whichOrder
                set d.whichUnit = whichUnit
                call AttachInteger( delayTimer, TargetTimed_SCOPE_ID, d )
                call AttachIntegerById( whichUnitId, TargetTimed_SCOPE_ID, d )
                //! runtextmacro AddEventById( "whichUnitId", "TargetTimed_EVENT_DEATH" )
                //! runtextmacro AddEventById( "whichUnitId", "TargetTimed_EVENT_ORDER" )
                call TimerStart( delayTimer, time, false, function TargetTimed_EndingByTimer )
                set delayTimer = null
            endfunction

            public function TargetTimed_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "TargetTimed_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function TargetTimed_Death_Event" )
                //! runtextmacro CreateEvent( "TargetTimed_EVENT_ORDER_EXECUTE", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function TargetTimed_OrderExecute_Event" )
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("Stop")
            function StopUnit takes Unit whichUnit returns nothing
                local real whichUnitAngle
                local unit whichUnitSelf = whichUnit.self
                if ( IsUnitType( whichUnitSelf, UNIT_TYPE_STRUCTURE ) ) then
                    call ClearUnitRequestQueue( whichUnit )
                    call IssueImmediateOrderById( whichUnitSelf, STOP_EX_ORDER_ID )
                else
                    set whichUnitAngle = GetUnitFacingWJ( whichUnitSelf )
                    set UnitGetsOrder_IGNORE_NEXT = true
                    if (IssuePointOrderById( whichUnitSelf, MOVE_ORDER_ID, GetUnitX( whichUnitSelf ) + 1 * Cos( whichUnitAngle ), GetUnitY( whichUnitSelf ) + 1 * Sin( whichUnitAngle ) ) == false) then
                        set UnitGetsOrder_IGNORE_NEXT = false
                    endif
                endif
                set whichUnitSelf = null
            endfunction
        //! runtextmacro Endscope()

        public function Order_Init takes nothing returns nothing
            call ImmediateTimed_ImmediateTimed_Init()
            call TargetTimed_TargetTimed_Init()
        endfunction
    //! runtextmacro Endscope()

    //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

    globals
        key UNIT_KEY
    endglobals

    function InitUnit takes unit whichUnit returns unit
        call AddObject( whichUnit, "Unit" )
    ///    call AddSavedIntegerToTable( "Objects", "Units", whichUnitId )
        return whichUnit
    endfunction

    function InitUnitEx takes unit whichUnit returns Unit
        call InitUnit(whichUnit)
        set TRIGGER_UNIT_SELF = whichUnit
        call RunTrigger(UnitAppears_DUMMY_TRIGGER)
        return GetUnit(whichUnit)
    endfunction

    function CreateUnitWJ takes player whichPlayer, integer whichTypeId, real x, real y, real angle returns unit
        return InitUnit( CreateUnit( whichPlayer, whichTypeId, x, y, angle * RAD_TO_DEG ) )
    endfunction

    function CreateUnitEx takes player whichPlayer, integer whichTypeId, real x, real y, real angle returns Unit
        local Unit newUnit
        local unit newUnitSelf = CreateUnitWJ( whichPlayer, whichTypeId, x, y, angle )
        call InitUnitEx( newUnitSelf )
        set newUnit = GetUnit(newUnitSelf)
        set newUnitSelf = null
        return newUnit
    endfunction

    function GetConstructingStructureEx takes nothing returns Unit
        return InitUnitEx( GetConstructingStructure() )
    endfunction

    function GetSoldUnitEx takes nothing returns Unit
        return InitUnitEx( GetSoldUnit() )
    endfunction

    function GetTrainedUnitEx takes nothing returns Unit
        return InitUnitEx( GetTrainedUnit() )
    endfunction

    function RemoveUnitWJ takes unit whichUnit returns nothing
        call RemoveObject( whichUnit, "Unit" )
    ///    call RemoveSavedIntegerFromTable( "Objects", "Units", whichUnitId )
        call RemoveUnit( whichUnit )
        set whichUnit = null
    endfunction

    globals
        key UNIT_TYPE_KEY
    endglobals

    function IsUnitTypeWJ takes integer whichUnitTypeId returns boolean
        return (GetUnitType(whichUnitTypeId) != NULL)
    endfunction

    function InitUnitType takes integer whichUnitTypeId returns nothing
        call RemoveUnitWJ( CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, whichUnitTypeId, 0, 0, 0 ) )
    endfunction

    function InitUnitTypeEx takes integer whichUnitTypeId returns UnitType
        local UnitType d = UnitType.create()
        set d.id = whichUnitTypeId
        call AttachIntegerById( whichUnitTypeId, UNIT_TYPE_KEY, d )
        call InitUnitType(whichUnitTypeId)
        return d
    endfunction

    //! runtextmacro Scope("RemainingReferences")
        function GetUnitRemainingReferences takes Unit whichUnit returns integer
            return whichUnit.remainingReferences
        endfunction

        function RemoveUnitRemainingReference takes Unit whichUnit returns nothing
            local integer amount = GetUnitRemainingReferences( whichUnit ) - 1
            local unit whichUnitSelf
            if ( ( amount == 0 ) and ( whichUnit.waitsForRemoval ) ) then
                set whichUnitSelf = whichUnit.self
                call whichUnit.destroy()
        //        call ShowUnitWJ( whichUnit, true )
                call RemoveUnitWJ( whichUnitSelf )
                set whichUnitSelf = null
            else
                set whichUnit.remainingReferences = amount
            endif
        endfunction

        function AddUnitRemainingReference takes Unit whichUnit returns nothing
            set whichUnit.remainingReferences = GetUnitRemainingReferences(whichUnit) + 1
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("RemoveUnit")
        function RemoveUnitEx takes Unit decayingUnit returns nothing
            set TRIGGER_UNIT = decayingUnit
            call RunTrigger(UnitFinishesDecaying_DUMMY_TRIGGER)
        endfunction

        //! runtextmacro Scope("Timed")
            private struct Timed_Data
                unit target
            endstruct

            private function Timed_Ending takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local Timed_Data d = GetAttachedInteger(durationTimer, Timed_SCOPE_ID)
                local unit target = d.target
                call FlushAttachedInteger( durationTimer, Timed_SCOPE_ID )
                call DestroyTimerWJ( durationTimer )
                set durationTimer = null
                call RemoveUnitWJ( target )
                set target = null
            endfunction

            function RemoveUnitTimed takes unit target, real time returns nothing
                local Timed_Data d = Timed_Data.create()
                local timer durationTimer = CreateTimerWJ()
                set d.target = target
                call AttachInteger( durationTimer, Timed_SCOPE_ID, d )
                call TimerStart( durationTimer, time, false, function Timed_Ending )
                set durationTimer = null
            endfunction
        //! runtextmacro Endscope()

        //! runtextmacro Scope("TimedEx")
            private struct TimedEx_Data
                timer durationTimer
                Unit target
            endstruct

            private function TimedEx_Ending takes TimedEx_Data d, timer durationTimer, Unit target returns nothing
                local integer targetId = target.id
                call d.destroy()
                call FlushAttachedInteger( durationTimer, TimedEx_SCOPE_ID )
                call DestroyTimerWJ( durationTimer )
                call FlushAttachedIntegerById(targetId, TimedEx_SCOPE_ID)
                //! runtextmacro RemoveEventById( "targetId", "TimedEx_EVENT_DECAY" )
            endfunction

            public function TimedEx_Decay takes Unit target returns nothing
                local TimedEx_Data d = GetAttachedIntegerById(target.id, TimedEx_SCOPE_ID)
                if (d != NULL) then
                    call TimedEx_Ending(d, d.durationTimer, target)
                endif
            endfunction

            private function TimedEx_Decay_Event takes nothing returns nothing
                call TimedEx_Decay(TRIGGER_UNIT)
            endfunction

            private function TimedEx_EndingByTimer takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local TimedEx_Data d = GetAttachedInteger(durationTimer, TimedEx_SCOPE_ID)
                local Unit target = d.target
                call TimedEx_Ending(d, durationTimer, target)
                set durationTimer = null
                call RemoveUnitEx( target )
            endfunction

            function RemoveUnitTimedEx takes Unit target, real time returns nothing
                local TimedEx_Data d = TimedEx_Data.create()
                local timer durationTimer = CreateTimerWJ()
                local integer targetId = target.id
                set d.durationTimer = durationTimer
                set d.target = target
                call AttachInteger( durationTimer, TimedEx_SCOPE_ID, d )
                call AttachIntegerById(targetId, TimedEx_SCOPE_ID, d)
                //! runtextmacro AddEventById( "targetId", "TimedEx_EVENT_DECAY" )
                call TimerStart( durationTimer, time, false, function TimedEx_EndingByTimer )
                set durationTimer = null
            endfunction

            public function TimedEx_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "TimedEx_EVENT_DECAY", "UnitFinishesDecaying_EVENT_KEY", "0", "function TimedEx_Decay_Event" )
            endfunction
        //! runtextmacro Endscope()

        public function RemoveUnit_Init takes nothing returns nothing
            call TimedEx_TimedEx_Init()
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Upgrade")
        private struct Upgrade_Data
        endstruct

        function GetUnitCurrentUpgradeGoldCost takes Unit whichUnit returns integer
            return whichUnit.currentUpgradeGoldCost
        endfunction

        private function Upgrade_Ending takes Upgrade_Data d, Unit whichUnit returns nothing
            local integer whichUnitId = whichUnit.id
            call d.destroy()
            call FlushAttachedIntegerById(whichUnitId, Upgrade_SCOPE_ID)
            //! runtextmacro RemoveEventById( "whichUnitId", "Upgrade_EVENT_DEATH" )
        endfunction

        function Upgrade_Remove takes Unit whichUnit returns nothing
            call Upgrade_Ending(GetAttachedIntegerById(whichUnit.id, Upgrade_SCOPE_ID), whichUnit)
        endfunction

        function Upgrade_Death takes Unit whichUnit returns nothing
            local Upgrade_Data d = GetAttachedIntegerById(whichUnit.id, Upgrade_SCOPE_ID)
            if ( d != NULL ) then
                call Upgrade_Ending(d, whichUnit)
            endif
        endfunction

        private function Upgrade_Death_Event takes nothing returns nothing
            call Upgrade_Death( DYING_UNIT )
        endfunction

        function Upgrade_Start takes Unit whichUnit, integer goldCost returns nothing
            local Upgrade_Data d = Upgrade_Data.create()
            local integer whichUnitId = whichUnit.id
            set whichUnit.currentUpgradeGoldCost = goldCost
            call AttachIntegerById(whichUnitId, Upgrade_SCOPE_ID, d)
            //! runtextmacro AddEventById( "whichUnitId", "Upgrade_EVENT_DEATH" )
        endfunction

        public function Upgrade_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Upgrade_EVENT_DEATH", "UnitDies_EVENT_KEY", "1", "function Upgrade_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Shop")
        function AddUnitSoldItemTypeId takes unit sellingUnit, integer soldItemTypeId, integer amount returns nothing
            if ( amount > 1 ) then
                call AddItemToStock( sellingUnit, soldItemTypeId, amount, amount )
            endif
            call AddItemToStock( sellingUnit, soldItemTypeId, amount, amount )
        endfunction

        function AddUnitSoldItemTypeIdEx takes unit sellingUnit, integer soldItemTypeId, integer amount, integer maxAmount returns nothing
            if ( amount > 1 ) then
                call AddItemToStock( sellingUnit, soldItemTypeId, amount, maxAmount )
            endif
            call AddItemToStock( sellingUnit, soldItemTypeId, amount, maxAmount )
        endfunction

        function RemoveUnitSoldUnitTypeId takes unit sellingUnit, integer soldUnitTypeId returns nothing
            call RemoveUnitFromStock( sellingUnit, soldUnitTypeId )
        endfunction

        function AddUnitSoldUnitTypeId takes unit sellingUnit, integer soldUnitTypeId, integer amount returns nothing
            if ( amount > 1 ) then
                call AddUnitToStock( sellingUnit, soldUnitTypeId, amount, amount )
            endif
            call AddUnitToStock( sellingUnit, soldUnitTypeId, amount, amount )
        endfunction

        //! runtextmacro CreateSimpleUnitTypeState("shopMaxCharges", "ShopMaxCharges", "integer")
        //! runtextmacro CreateSimpleUnitTypeState("shopRefreshInterval", "ShopRefreshInterval", "real")
        //! runtextmacro CreateSimpleUnitTypeState("shopRefreshIntervalStart", "ShopRefreshIntervalStart", "real")
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Explode")
        function GetUnitExplode takes Unit whichUnit returns integer
            return whichUnit.explode
        endfunction

        function RemoveUnitExplode takes Unit whichUnit returns nothing
            set whichUnit.explode = whichUnit.explode - 1
        endfunction

        function AddUnitExplode takes Unit whichUnit returns nothing
            set whichUnit.explode = whichUnit.explode + 1
            call AddUnitCanNotBeRevived(whichUnit)
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Abilities")
        function CountUnitTypeAbilities takes UnitType whichUnitType returns integer
            return whichUnitType.abilitiesCount
        endfunction

        function GetUnitTypeAbility takes UnitType whichUnitType, integer index returns integer
            return whichUnitType.abilities[index]
        endfunction

        function AddUnitTypeAbility takes UnitType whichUnitType, integer abilcode returns nothing
            local integer count = CountUnitTypeAbilities(whichUnitType) + 1
            set whichUnitType.abilities[count] = abilcode
            set whichUnitType.abilitiesCount = count
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("HeroAbilities")
        function CountUnitHeroAbilities takes UnitType whichUnitType returns integer
            return whichUnitType.heroAbilitiesCount
        endfunction

        function GetUnitHeroAbility takes UnitType whichUnitType, integer index returns integer
            return whichUnitType.heroAbilities[index]
        endfunction

        function AddUnitHeroAbility takes UnitType whichUnitType, integer abilcode returns nothing
            local integer count = CountUnitHeroAbilities(whichUnitType) + 1
            set whichUnitType.heroAbilities[count] = abilcode
            set whichUnitType.heroAbilitiesCount = count
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Illusion")
        globals
            private constant integer Illusion_ILLUSION_HERO_INVENTORY_SPELL_ID = 'A07G'
            private constant string Illusion_SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageDeathCaster.mdl"
        endglobals

        private struct Illusion_Data
            force displayShip
        endstruct

        function UpdateIllusionDisplay takes Unit whichUnit returns nothing
            local Illusion_Data d = GetAttachedIntegerById(whichUnit.id, Illusion_SCOPE_ID)
            local force displayShip = d.displayShip
            local integer iteration = MAX_PLAYER_INDEX
            local player specificPlayer
            loop
                set specificPlayer = PlayerWJ( iteration )
                if ( IsPlayerInForce(specificPlayer, displayShip) ) then
                    if ( IsUnitAlly( whichUnit.self, specificPlayer ) == false ) then
                        call ForceRemovePlayer(displayShip, specificPlayer)
                        call AddUnitVertexColor( whichUnit, 223, -163, 0, 0, specificPlayer )
                    endif
                else
                    if ( IsUnitAlly( whichUnit.self, specificPlayer ) ) then
                        call ForceAddPlayer(displayShip, specificPlayer)
                        call AddUnitVertexColor( whichUnit, -223, 163, 0, 0, specificPlayer )
                    endif
                endif
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            set displayShip = null
            set specificPlayer = null
        endfunction

        function IsUnitIllusionWJ takes Unit whichUnit returns boolean
            return (GetAttachedIntegerById( whichUnit.id, Illusion_SCOPE_ID ) != NULL)
        endfunction

        public function Illusion_Decay takes Unit whichUnit returns nothing
            local Illusion_Data d
            local force displayShip
            local integer whichUnitId
            if (IsUnitIllusionWJ(whichUnit)) then
                set whichUnitId = whichUnit.id
                set d = GetAttachedIntegerById(whichUnitId, Illusion_SCOPE_ID)
                set displayShip = d.displayShip
                call d.destroy()
                call DestroyForceWJ(displayShip)
                set displayShip = null
                call FlushAttachedIntegerById(whichUnitId, Illusion_SCOPE_ID)
                //! runtextmacro RemoveEventById( "whichUnitId", "Illusion_EVENT_DECAY" )
            endif
        endfunction

        private function Illusion_Decay_Event takes nothing returns nothing
            call Illusion_Decay(TRIGGER_UNIT)
        endfunction

        function CreateIllusion takes Unit fromWhichUnit, player forWhichPlayer returns Unit
            local Illusion_Data d = Illusion_Data.create()
            local unit fromWhichUnitSelf = fromWhichUnit.self
            local integer fromWhichUnitTypeId = fromWhichUnit.type.id
            local UnitType fromWhichUnitType = GetUnitType(fromWhichUnitTypeId)
            local real fromWhichUnitX = GetUnitX( fromWhichUnitSelf )
            local real fromWhichUnitY = GetUnitY( fromWhichUnitSelf )
            local integer iteration
            local real fromWhichUnitAngle = GetUnitFacingWJ( fromWhichUnitSelf )
            local Unit newUnit
            local integer newUnitId
            local unit newUnitSelf
            local item specificItem
            set UnitAppears_NEXT_IS_ILLUSION = true
            set newUnit = CreateUnitEx( forWhichPlayer, fromWhichUnitTypeId, fromWhichUnitX, fromWhichUnitY, fromWhichUnitAngle )
            set newUnitId = newUnit.id
            set newUnitSelf = newUnit.self
            set d.displayShip = CreateForceWJ()
            call AttachIntegerById(newUnitId, Illusion_SCOPE_ID, d)
            //! runtextmacro AddEventById( "newUnitId", "Illusion_EVENT_DECAY" )
            if ( IsUnitType( fromWhichUnitSelf, UNIT_TYPE_HERO ) ) then
                set iteration = CountUnitTypeAbilities(fromWhichUnitType)
                loop
                    exitwhen ( iteration < 0 )
                    call UnitRemoveAbility( newUnitSelf, GetUnitTypeAbility(fromWhichUnitType, iteration) )
                    set iteration = iteration - 1
                endloop
                set iteration = CountUnitHeroAbilities(fromWhichUnitType)
                loop
                    exitwhen ( iteration < 0 )
                    call UnitRemoveAbility( newUnitSelf, GetUnitHeroAbility(fromWhichUnitType, iteration) )
                    set iteration = iteration - 1
                endloop
                call SetUnitEP( newUnitSelf, GetUnitEP( fromWhichUnitSelf ) )
                call UnitModifySkillPoints( newUnitSelf, -GetHeroSkillPoints(newUnitSelf) )
            endif
            //call UnitRemoveAbility( newUnit, 'AHbu' )
            set iteration = 0
            if ( GetUnitAbilityLevel( newUnitSelf, HERO_INVENTORY_SPELL_ID ) > 0 ) then
                call UnitRemoveAbility(newUnitSelf, HERO_INVENTORY_SPELL_ID)
                call UnitAddAbility( newUnitSelf, Illusion_ILLUSION_HERO_INVENTORY_SPELL_ID )
                loop
                    exitwhen ( iteration >= UnitInventorySize( newUnitSelf ) )
                    set specificItem = UnitItemInSlot( fromWhichUnitSelf, iteration )
                    if ( specificItem != null ) then
                        set specificItem = CreateItemWJ( GetItemTypeId( specificItem ), 0, 0 )
                        call UnitAddItem( newUnitSelf, specificItem )
                        call UnitDropItemSlot( newUnitSelf, specificItem, iteration )
                    endif
                    set iteration = iteration + 1
                endloop
                set specificItem = null
            endif
            call AddUnitDecay(newUnit)
            call SetUnitDecayTime(newUnit, 0)
            call SetUnitBlood( newUnit, "" )
            call SetUnitBloodExplosion( newUnit, Illusion_SPECIAL_EFFECT_PATH )
            call SetUnitDamageRelativeBonus( newUnit, -1 )
            call AddUnitExplode( newUnit )
            call SetUnitState( newUnitSelf, UNIT_STATE_LIFE, GetUnitState( fromWhichUnitSelf, UNIT_STATE_LIFE ) )
            call SetUnitState( newUnitSelf, UNIT_STATE_MANA, GetUnitState( fromWhichUnitSelf, UNIT_STATE_MANA ) )
            call UnitAddType( newUnitSelf, UNIT_TYPE_SUMMONED )
            set fromWhichUnitSelf = null
            set newUnitSelf = null
            call SetUnitStunDurationRelativeBonus( newUnit, -1 )
            call SetUnitSupplyProduced( newUnit, forWhichPlayer, 0 )
            call SetUnitSupplyUsed( newUnit, forWhichPlayer, 0 )
            call UpdateIllusionDisplay( newUnit )
            return newUnit
        endfunction

        public function Illusion_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Illusion_EVENT_DECAY", "UnitFinishesDecaying_EVENT_KEY", "0", "function Illusion_Decay_Event" )
            call InitEffectType(Illusion_SPECIAL_EFFECT_PATH)
        endfunction
    //! runtextmacro Endscope()

    function SetUnitOwnerEx takes Unit whichUnit, player whichPlayer, boolean changeColor returns nothing
        local player whichUnitOwner = whichUnit.owner
        local integer whichUnitSupplyProduced = GetUnitSupplyProduced( whichUnit )
        local integer whichUnitSupplyUsed = GetUnitSupplyUsed( whichUnit )
        call SetUnitSupplyProduced( whichUnit, whichUnitOwner, 0 )
        call SetUnitSupplyUsed( whichUnit, whichUnitOwner, 0 )
        call SetUnitOwnerWJ( whichUnit, whichPlayer, changeColor )
        call SetUnitSupplyProduced( whichUnit, whichUnitOwner, whichUnitSupplyProduced )
        call SetUnitSupplyUsed( whichUnit, whichUnitOwner, whichUnitSupplyUsed )
        if ( IsUnitIllusionWJ( whichUnit ) ) then
            call UpdateIllusionDisplay( whichUnit )
        endif
    endfunction

    //! runtextmacro Scope("UnitSound")
        function CountUnitTypePissedSounds takes UnitType whichUnitType returns integer
            return whichUnitType.pissedSoundsCount
        endfunction

        function GetUnitTypePissedSound takes UnitType whichUnitType, integer index returns SoundType
            return whichUnitType.pissedSounds[index]
        endfunction

        function AddUnitTypePissedSound takes UnitType whichUnitType, SoundType whichSoundType returns nothing
            local integer count = CountUnitTypePissedSounds(whichUnitType) + 1
            set whichUnitType.pissedSounds[count] = whichSoundType
            set whichUnitType.pissedSoundsCount = count
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Revaluation")
        globals
            private real array Revaluation_BONUS_RELATIVE_DAMAGE
            private real array Revaluation_BONUS_RELATIVE_LIFE
            private real array Revaluation_BONUS_RELATIVE_LIFE_REGENERATION
            private real array Revaluation_BONUS_RELATIVE_MANA
            private real array Revaluation_BONUS_RELATIVE_MANA_REGENERATION
            private real array Revaluation_BONUS_RELATIVE_VERTEX_COLOR_RED
            private real array Revaluation_BONUS_RELATIVE_VERTEX_COLOR_GREEN
            private real array Revaluation_BONUS_RELATIVE_VERTEX_COLOR_BLUE
            private real array Revaluation_BONUS_SCALE
            private unittype array Revaluation_BONUS_UNIT_TYPE
            constant integer REVALUATION_LEVELS_AMOUNT = 2
            private constant string Revaluation_SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Demon\\ReviveDemon\\ReviveDemon.mdl"//"Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl"//"Abilities\\Spells\\Other\\Levelup\\Levelupcaster.mdl"
        endglobals

        function GetUnitRevaluation takes Unit whichUnit returns integer
            return whichUnit.revaluation
        endfunction

        function SetUnitRevaluation takes Unit whichUnit, integer level returns nothing
            local real bonusRelativeDamage
            local real bonusRelativeLife
            local real bonusRelativeMana
            local real bonusRelativeLifeRegeneration
            local real bonusRelativeManaRegeneration
            local real bonusRelativeVertexColorRed
            local real bonusRelativeVertexColorGreen
            local real bonusRelativeVertexColorBlue
            local real bonusScale
            local integer oldLevel = whichUnit.revaluation
            local integer iteration
            local integer min
            local unit whichUnitSelf
            local UnitType whichUnitType
            if (level != oldLevel) then
                set bonusRelativeDamage = 0
                set bonusRelativeLife = 0
                set bonusRelativeMana = 0
                set bonusRelativeLifeRegeneration = 0
                set bonusRelativeManaRegeneration = 0
                set bonusRelativeVertexColorRed = 0
                set bonusRelativeVertexColorGreen = 0
                set bonusRelativeVertexColorBlue = 0
                set bonusScale = 0
                set iteration = MaxI(level, oldLevel)
                set min = MinI(level, oldLevel)
                set whichUnitSelf = whichUnit.self
                set whichUnitType = whichUnit.type
                loop
                    set bonusRelativeDamage = bonusRelativeDamage + Revaluation_BONUS_RELATIVE_DAMAGE[iteration]
                    set bonusRelativeLife = bonusRelativeLife + Revaluation_BONUS_RELATIVE_LIFE[iteration]
                    set bonusRelativeMana = bonusRelativeMana + Revaluation_BONUS_RELATIVE_MANA[iteration]
                    set bonusRelativeLifeRegeneration = bonusRelativeLifeRegeneration + Revaluation_BONUS_RELATIVE_LIFE_REGENERATION[iteration]
                    set bonusRelativeManaRegeneration = bonusRelativeManaRegeneration + Revaluation_BONUS_RELATIVE_MANA_REGENERATION[iteration]
                    set bonusRelativeVertexColorRed = bonusRelativeVertexColorRed + Revaluation_BONUS_RELATIVE_VERTEX_COLOR_RED[iteration]
                    set bonusRelativeVertexColorGreen = bonusRelativeVertexColorGreen + Revaluation_BONUS_RELATIVE_VERTEX_COLOR_GREEN[iteration]
                    set bonusRelativeVertexColorBlue = bonusRelativeVertexColorBlue + Revaluation_BONUS_RELATIVE_VERTEX_COLOR_BLUE[iteration]
                    set bonusScale = bonusScale + Revaluation_BONUS_SCALE[iteration]
                    set iteration = iteration - 1
                    exitwhen (iteration == min)
                endloop
                if (oldLevel > 0) then
                    call UnitRemoveType(whichUnitSelf, Revaluation_BONUS_UNIT_TYPE[oldLevel])
                endif
                if (level < oldLevel) then
                    set bonusRelativeDamage = -bonusRelativeDamage
                    set bonusRelativeLife = -bonusRelativeLife
                    set bonusRelativeMana = -bonusRelativeMana
                    set bonusRelativeLifeRegeneration = -bonusRelativeLifeRegeneration
                    set bonusRelativeManaRegeneration = -bonusRelativeManaRegeneration
                    set bonusRelativeVertexColorRed = -bonusRelativeVertexColorRed
                    set bonusRelativeVertexColorGreen = -bonusRelativeVertexColorGreen
                    set bonusRelativeVertexColorBlue = -bonusRelativeVertexColorBlue
                    set bonusScale = -bonusScale
                else
                    call DestroyEffectWJ( AddSpecialEffectWJ( Revaluation_SPECIAL_EFFECT_PATH, GetUnitX( whichUnitSelf ), GetUnitY( whichUnitSelf ) ) )
                    if (level > 0) then
                        call UnitAddType( whichUnitSelf, Revaluation_BONUS_UNIT_TYPE[level] )
                    endif
                endif
                set whichUnitSelf = null
                set whichUnit.revaluation = level
                call AddUnitDamage( whichUnit, bonusRelativeDamage * GetUnitTypeDamage( whichUnitType ) )
                call AddUnitMaxLife( whichUnit, bonusRelativeLife * GetUnitTypeMaxLife( whichUnitType ) )
                call AddUnitMaxMana( whichUnit, bonusRelativeMana * GetUnitTypeMaxMana( whichUnitType ) )
                call AddUnitLifeRegeneration( whichUnit, bonusRelativeLifeRegeneration * GetUnitTypeLifeRegeneration( whichUnitType ) )
                call AddUnitManaRegeneration( whichUnit, bonusRelativeManaRegeneration * GetUnitTypeManaRegeneration( whichUnitType ) )
                call AddUnitScaleTimed( whichUnit, bonusScale * GetUnitTypeScale(whichUnitType), 1 )
                call AddUnitVertexColorTimed( whichUnit, bonusRelativeVertexColorRed * GetUnitTypeVertexColorRed(whichUnitType), bonusRelativeVertexColorGreen * GetUnitTypeVertexColorGreen(whichUnitType), bonusRelativeVertexColorBlue * GetUnitTypeVertexColorBlue(whichUnitType), 0, null, 1 )
            endif
            set TRIGGER_UNIT = whichUnit
            set UnitIsRevaluated_LEVEL = level
            set UnitIsRevaluated_OLD_LEVEL = oldLevel
            call RunTrigger(UnitIsRevaluated_DUMMY_TRIGGER)
        endfunction

        public function Revaluation_Init takes nothing returns nothing
            set Revaluation_BONUS_RELATIVE_DAMAGE[1] = 0.5
            set Revaluation_BONUS_RELATIVE_DAMAGE[2] = 0.75
            set Revaluation_BONUS_RELATIVE_LIFE[1] = 0.5
            set Revaluation_BONUS_RELATIVE_LIFE[2] = 0.75
            set Revaluation_BONUS_RELATIVE_LIFE_REGENERATION[1] = 0.5
            set Revaluation_BONUS_RELATIVE_LIFE_REGENERATION[2] = 0.75
            set Revaluation_BONUS_RELATIVE_MANA[1] = 0.5
            set Revaluation_BONUS_RELATIVE_MANA[2] = 0.75
            set Revaluation_BONUS_RELATIVE_MANA_REGENERATION[1] = 0.5
            set Revaluation_BONUS_RELATIVE_MANA_REGENERATION[2] = 0.75
            set Revaluation_BONUS_RELATIVE_VERTEX_COLOR_RED[1] = -0.5
            set Revaluation_BONUS_RELATIVE_VERTEX_COLOR_RED[2] = 0.5
            set Revaluation_BONUS_RELATIVE_VERTEX_COLOR_GREEN[1] = -0.5
            set Revaluation_BONUS_RELATIVE_VERTEX_COLOR_GREEN[2] = 0.3
            set Revaluation_BONUS_RELATIVE_VERTEX_COLOR_BLUE[1] = -0.5
            set Revaluation_BONUS_RELATIVE_VERTEX_COLOR_BLUE[2] = -0.5
            set Revaluation_BONUS_SCALE[1] = 0.1
            set Revaluation_BONUS_SCALE[2] = 0.1
            set Revaluation_BONUS_UNIT_TYPE[1] = UNIT_TYPE_GIANT
            set Revaluation_BONUS_UNIT_TYPE[2] = UNIT_TYPE_TAUREN
            call InitEffectType( Revaluation_SPECIAL_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    function UnitChangeForm takes Unit whichUnit, UnitType toWhichUnitType returns nothing
        set TRIGGER_UNIT = whichUnit
        set TRIGGER_UNIT_TYPE = toWhichUnitType
        call RunTrigger( UnitChangesForm_DUMMY_TRIGGER )
    endfunction

    public function Init takes nothing returns nothing
        call Armor_Armor_Init()
        call Attack_Attack_Init()
        call AttackRate_AttackRate_Init()
        call Damage_Damage_Init()
        call Evasion_Evasion_Init()
        call MaxLife_MaxLife_Init()
        call MaxMana_MaxMana_Init()
        call SightRange_SightRange_Init()
        call Scale_Scale_Init()
        call Speed_Speed_Init()
        call VertexColor_VertexColor_Init()

        call Agility_Agility_Init()
        call Intelligence_Intelligence_Init()
        call Strength_Strength_Init()

        call Invulnerability_Invulnerability_Init()
        call MagicImmunity_MagicImmunity_Init()
        call Silence_Silence_Init()

        call Illusion_Illusion_Init()
        call Position_Position_Init()
        call Stun_Stun_Init()

        call Order_Order_Init()
        call RemoveUnit_RemoveUnit_Init()
        call Revaluation_Revaluation_Init()
        call Upgrade_Upgrade_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Header\Unit.j

//file: D:\Warcraft III\Mapping\WFW\Data\Header\WeatherEffect.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("WeatherEffect")
    globals
        public weathereffect array ALL
        public integer COUNT = -1
        public boolean array IS_DISPLAYED
        public boolean array PLAYER_HIDES
        weathereffect TEMP_WEATHER_EFFECT
    endglobals

    function GetWeatherEffectIndex takes weathereffect whichWeatherEffect returns integer
        return (GetHandleId(whichWeatherEffect) * ( -1 ) - 101)
    endfunction

    function AddWeatherEffectWJ takes rect whichRect, integer whichWeatherType returns weathereffect
        local weathereffect newWeatherEffect = AddWeatherEffect( whichRect, whichWeatherType )
        local integer index = GetWeatherEffectIndex(newWeatherEffect)
        set COUNT = COUNT + 1
        set ALL[COUNT] = newWeatherEffect
        set IS_DISPLAYED[index] = false
        call AddObject( newWeatherEffect, "WeatherEffect" )
        ///call AddSavedIntegerToTable( "Objects", "WeatherEffects", newWeatherEffectId )
        set TEMP_WEATHER_EFFECT = newWeatherEffect
        set newWeatherEffect = null
        return TEMP_WEATHER_EFFECT
    endfunction

    function EnableWeatherEffectWJ takes weathereffect whichWeatherEffect, player whichPlayer, boolean flag returns nothing
        if ( whichPlayer == null ) then
            set IS_DISPLAYED[GetWeatherEffectIndex(whichWeatherEffect)] = flag
            set whichPlayer = GetLocalPlayer()
        endif
        if ( GetLocalPlayer() == whichPlayer ) then
            if ( flag ) then
                if ( PLAYER_HIDES[GetPlayerId(whichPlayer)] == false ) then
                    call EnableWeatherEffect( whichWeatherEffect, flag )
                endif
            else
                call EnableWeatherEffect( whichWeatherEffect, flag )
            endif
        endif
    endfunction

    function RemoveWeatherEffectWJ takes weathereffect whichWeatherEffect returns nothing
        local integer iteration = COUNT
        loop
            exitwhen (ALL[iteration] == whichWeatherEffect)
            set iteration = iteration - 1
        endloop
        set ALL[iteration] = ALL[COUNT]
        set COUNT = COUNT - 1
        call RemoveObject( whichWeatherEffect, "WeatherEffect" )
        ///call RemoveSavedIntegerFromTable( "Objects", "WeatherEffects", newWeatherEffectId )
        if ( whichWeatherEffect == null ) then
            call WriteBug( "Fatal: RemoveWeatherEffectWJ" )
        else
            call RemoveWeatherEffect( whichWeatherEffect )
            set whichWeatherEffect = null
        endif
    endfunction

    //! runtextmacro Scope("EnableTimed")
        private struct EnableTimed_Data
            boolean flag
            weathereffect target
            player whichPlayer
        endstruct

        private function EnableTimed_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local EnableTimed_Data d = GetAttachedInteger( durationTimer, EnableTimed_SCOPE_ID )
            local boolean flag = d.flag
            local weathereffect target = d.target
            local player whichPlayer = d.whichPlayer
            call d.destroy()
            call FlushAttachedInteger( durationTimer, EnableTimed_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            call EnableWeatherEffectWJ( target, whichPlayer, flag )
            set target = null
            set whichPlayer = null
        endfunction

        function EnableWeatherEffectTimed takes weathereffect target, player whichPlayer, boolean flag, real time returns nothing
            local EnableTimed_Data d = EnableTimed_Data.create()
            local timer durationTimer = CreateTimerWJ()
            set d.flag = flag
            set d.target = target
            set d.whichPlayer = whichPlayer
            call AttachInteger( durationTimer, EnableTimed_SCOPE_ID, d )
            call TimerStart( durationTimer, time, false, function EnableTimed_Ending )
            set durationTimer = null
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("RemoveTimed")
        private struct RemoveTimed_Data
            weathereffect target
        endstruct

        private function RemoveTimed_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local RemoveTimed_Data d = GetAttachedInteger( durationTimer, RemoveTimed_SCOPE_ID )
            local weathereffect target = d.target
            call d.destroy()
            call FlushAttachedInteger( durationTimer, RemoveTimed_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            call RemoveWeatherEffectWJ( target )
            set target = null
        endfunction

        function RemoveWeatherEffectTimed takes weathereffect target, real time returns nothing
            local RemoveTimed_Data d = RemoveTimed_Data.create()
            local timer durationTimer = CreateTimerWJ()
            set d.target = target
            call AttachInteger( durationTimer, RemoveTimed_SCOPE_ID, d )
            call TimerStart( durationTimer, time, false, function RemoveTimed_Ending )
            set durationTimer = null
        endfunction
    //! runtextmacro Endscope()
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Header\WeatherEffect.j

//file: D:\Warcraft III\Mapping\WFW\Data\Header\Constants.page\Constants.j
scope Constants
    globals
        constant real CENTER_X = 0.
        constant real CENTER_Y = 0.
        constant real HINT_TEXT_DURATION = 12.
        constant real LIMIT_OF_DEATH = 0.405
        constant real LIMIT_OF_IMMORTALS = 1.
        constant integer NULL = 0
        constant integer STANDARD_CLIFF_LEVEL = 2
    endglobals
endscope

scope ErrorStrings
    globals
        public constant string ABILITY_DEACTIVATED = "Ability deactivated"
        public constant string ALREADY_BOMB = "Is already a bomb"
        public constant string ALREADY_FULL_LIFE = "Has already full life"
        public constant string ALREADY_FULL_MANA = "Has already full mana"
        public constant string CAN_NOT_HAVE_SOCKET = "Cannot be socled"
        public constant string EARLY_PROMOTION = "No targets were found that could be revaluated"
        public constant string HAS_ALREADY_SOCKET = "Is already socled"
        public constant string INVALID_TARGET = "Invalid target"
        public constant string NEEDS_MANA_POOL = "Requires manapool"
        public constant string NEEDS_RACE = "Choose your race first"
        public constant string NO_CORPSES_FOUND = "No usable corpses were found"
        public constant string NOT_ALLY = "Not on allies"
        public constant string NOT_ENEMY_MECHANICAL = "No mechanical targets that are hostile"
        public constant string NOT_HERO = "Not on heroes"
        public constant string NOT_ILLUSION = "Not on illusions"
        public constant string NOT_MECHANICAL = "No mechanical targets allowed"
        public constant string NOT_NEUTRAL = "Not on neutrals"
        public constant string NOT_SELF = "Not self"
        public constant string NOT_STRUCTURE = "Not on buildings"
        public constant string NOT_WARD = "Not on wards"
        public constant string ONLY_ALLY = "Must be casted on an allied unit"
        public constant string ONLY_GROUND = "Only ground entities"
        public constant string ONLY_ORGANIC = "Only organic entities"
        public constant string ONLY_SPAWNS = "Only castable on spawn units"
        public constant string ONLY_SPAWNS_OR_RESERVE = "Only castable on spawn units or Reserves"
        public constant string ONLY_TOWN_HALL = "Must be casted on a town hall"
        public constant string ONLY_YOUR_TOWN_HALL = "Only usable on your own town hall"
        public constant string SHOP_BELONGS_TO_ENEMY = "This shop belongs to your enemy"
        public constant string TARGET_IS_INVULNERABLE = "Target is invulnerable"
        public constant string TARGET_IS_MAGIC_IMMUNE = "Target is immune to magical spells"
        public constant string TARGET_TOO_CLOSE = "Target too close"
        public constant string TOO_LESS_GOLD = "Not enough gold"
        public constant string TOO_LESS_LIFE = "Not enough life"
        public constant string TOO_LESS_LUMBER = "Not enough lumber"
        public constant string TOO_LESS_MANA = "Not enough mana"
        public constant string TOO_LESS_SUPPLY = "Needs more supply"
        public constant string TOO_MIGHTY = "Too mighty"
        public constant string WHAT_ABOUT_RACE_FIRST = "This makes no sense"
    endglobals
endscope

scope ColorStrings
    globals
        public constant integer BODY_LENGTH = 8
        public constant string FOOTY_DARK = "|cff0077ff"
        public constant string FOOTY_LIGHT = "|cff00bbff"
        public constant string GOLD = "|cffffcc00"
        public constant string GREEN = "|cff00ff00"
        public constant string RED = "|cffff0000"
        public constant string RESET = "|r"
        public constant integer RESET_LENGTH = 2
        public constant string SET_DARK = "|cffba4200"
        public constant string SET_LIGHT = "|cffdc640f"
        public constant string START = "|c"
        public constant integer START_LENGTH = 2
        public constant string YELLOW = "|cffffff00"
    endglobals
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Header\Constants.page\Constants.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Abilities.j
//TESH.scrollpos=115
//TESH.alwaysfold=0
scope Abilities
    globals
        constant integer ABILITY_STORAGE_SPELL_ID = 'A02A'
        constant integer ABILITY_STORAGE2_SPELL_ID = 'A02Q'
        constant integer ATTACK_GROUND_ORDER_ID = 851984//OrderId( "attackground" )
        constant integer ATTACK_ONCE_ORDER_ID = 851985//OrderId( "attackonce" )
        constant integer ATTACK_ORDER_ID = 851983//OrderId( "attack" )
        constant integer BUY_SHOP_ITEM_SPELL_ID = 'A002'
        constant integer CANCEL_ORDER_ID = 851976
        constant integer DELIVER_LUMBER_SPELL_ID = 'A07F'
        constant integer GHOST_SPELL_ID = 'Agho'
        constant integer HARVESTING_AUTO_ORDER_ID = 852022//OrderId( "autoharvestlumber" )
        constant integer HARVESTING_SPELL_ID = 'A07B'
        constant integer HERO_INVENTORY_SPELL_ID = 'AInv'
        constant integer HOLD_POSITION_ORDER_ID = 851993//OrderId( "holdposition" )
        constant integer INSTANT_CAST_BUFF_ID = 'B00V'
        constant integer INVISIBILITY_SPELL_ID = 'Apiv'
        constant integer LOCUST_SPELL_ID = 'Aloc'
        constant integer MATSUGAN_SPELL_ID = 'A07Z'
        constant integer MOVE_ORDER_ID = 851986//OrderId( "move" )
        constant integer MOVE_SPELL_ID = 'Amov'
        constant integer PATROL_ORDER_ID = 851990//OrderId( "patrol" )
        constant integer REPAIR_SPELL_ID = 'Ahrp'
        constant integer SELL_ITEMS_SPELL_ID = 'Asid'
        constant integer SELL_UNITS_SPELL_ID = 'Asud'
        constant integer SET_RALLY_ORDER_ID = 851980//OrderId( "setrally" )
        constant integer SHARED_CONTROL_SPELL_ID = 'A02V'
        constant integer SMART_ORDER_ID = 851971//OrderId( "smart" )
        constant integer SPLASH_SPELL_ID = 'A03X'
        constant integer STOP_EX_ORDER_ID = 852486//OrderId("banish")
        constant integer STOP_EX_SPELL_ID = 'A03Q'
        constant integer STOP_ORDER_ID = 851972//OrderId( "stop" )
    endglobals

    private function Init3 takes nothing returns nothing
        call Payday_Init()
        call PoisonFountain_Init()
        call PreviousHero_Init()
        call Pulverize_Init()
        call RaiseDead_Init()
        call RapidFire_Init()
        call RefillMana_Init()
        call Reincarnation_Init()
        call ReleaseUnitShredder_Init()
        call Resurrection_Init()
        call RequestReinforcements_Init()
        call Riposte_Init()
        call Rust_Init()
        call Sales_Init()
        call SelfHeal_Init()
        call ShadowMeld_Init()
        call ShockWave_Init()
        call SilverSpores_Init()
        call Slam_Init()
        call SlowPoison_Init()
        call SoulVessel_Init()
        call SpellDisconnection_Init()
        call Stability_Init()
        call StrongArm_Init()
        call SuddenFrost_Init()
        call Suicide_Init()
        call SummonFaust_Init()
        call SummonInfernal_Init()
        call SummonPeq_Init()
        call SummonPeqqiBeast_Init()
        call SwitchShops_Init()
        call ThermalFissure_Init()
        call ToadReflection_Init()
        //call TonelessMist_Init()
        call UnholyArmor_Init()
        call UtilizationOfRests_Init()
        call VioletDefense_Init()
        call VividStrikes_Init()
        call WhipLash_Init()
        call Whirlwind_Init()
        call WonderSeeds_Init()
    endfunction

    private function Init2 takes nothing returns nothing
        call FleshBomb_Init()
        call FreeRoad_Init()
        call Frenzy_Init()
        call FrostBolt_Init()
        call FrostNova_Init()
        call FuneralFeast_Init()
        call Fury_Init()
        call GhostTakeOver_Init()
        call GhoulFrenzy_Init()
        call HammerThrow_Init()
        call Harmagedon_Init()
        call Harmagedon2_Init()
        call Heal_Init()
        call HindranceOfLearning_Init()
        call Hurricane_Init()
        call IceBall_Init()
        call Immolation_Init()
        call Inspiration_Init()
        call Invulnerability_Init()
        call Kataikaze_Init()
        call KidneyShot_Init()
        call KittyJump_Init()
        call LastGrave_Init()
        call LayEgg_Init()
        call Libertine_Init()
        call LifeDrain_Init()
        call LifeRegenerationAura_Init()
        call LifeRegenerationAuraNeutral_Init()
        call LightningAttack_Init()
        call LightOfPurge_Init()
        call LinearBoomerang_Init()
        call LittleThunderstorm_Init()
        call MagicalLariat_Init()
        call MagicalSuperiority_Init()
        call ManaRegenerationAura_Init()
        call ManaRegenerationAuraNeutral_Init()
        call ManaTheft_Init()
        call Meditation_Init()
        call Metamorphosis_Init()
        call MightAura_Init()
        call MindBreaker_Init()
        call MysticalAttack_Init()
        call NaturalEmbrace_Init()
        call Net_Init()
        call Neutralization_Init()
        call NextHero_Init()
    endfunction

    public function Init takes nothing returns nothing
        call TriggerRegisterUnitEvent( gg_trg_worldcastertest, WORLD_CASTER, EVENT_UNIT_DEATH )
        call SetUnitInvulnerable(WORLD_CASTER, true)
        call InitAbility( ABILITY_STORAGE_SPELL_ID )
        call InitAbility( ABILITY_STORAGE2_SPELL_ID )
        call InitAbility(STOP_EX_SPELL_ID)

        call AcidStrike_Init()
        call AdvancedTraining_Init()
        call AdvertisingGift_Init()
        call Air_Init()
        call AirPassage_Init()
        call ArtilleryAttack_Init()
        call AttackDerivation_Init()
        call AxeMaster_Init()
        call Barrage_Init()
        call Bash_Init()
        //call BattleGolem_Init()
        call Berserk_Init()
        call BloodyClaws_Init()
        call BondOfSouls_Init()
        call BubbleArmor_Init()
        call Burrow_Init()
        call Cannibalism_Init()
        call CashDiscount_Init()
        call ChainLightning_Init()
        call ChillyPresence_Init()
        call ChooseHero_Init()
        call ChooseRandomHero_Init()
        call ChooseRandomHeroFromSelection_Init()
        call CourageAndHonor_Init()
        call CripplingWave_Init()
        call CriticalStrike_Init()
        call CrowdPuller_Init()
        call CurseOfTheBloodline_Init()
        call DarkCloud_Init()
        call Defend_Init()
        call Disarm_Init()
        call DiversionaryTactics_Init()
        call DiversionShot_Init()
        call DivineArmor_Init()
        call DivineShield_Init()
        call Downgrade_Init()
        call DreadCall_Init()
        call EarlyPromotion_Init()
        call EasyPrey_Init()
        call EmployHenchman_Init()
        call Enchant_Init()
        call EnergyGap_Init()
        call EsteemInCoins_Init()
        call Evasion_Init()
        call Feedback_Init()
        call FeelingOfSecurity_Init()
        call Fertilizer_Init()
        call FieryBoots_Init()
        call Fireball_Init()
        call FireBurst_Init()
        call ExecuteCode( function Init2 )
        call ExecuteCode( function Init3 )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Abilities.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Constructions.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope Constructions
    public function Init takes nothing returns nothing
        call Brick_Init()
        call Grass_Init()
        call Marble_Init()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Constructions.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Destructables.j
//TESH.scrollpos=18
//TESH.alwaysfold=0
scope Destructables
    public function Init takes nothing returns nothing
        local DestructableType d

        globals
            constant integer BLOCKER_DESTRUCTABLE_ID = 'B002'
        endglobals

        // Blocker
        set d = InitDestructableTypeEx(BLOCKER_DESTRUCTABLE_ID)
        set d.scale = 1
        set d.variationsCount = 0

        globals
            constant integer FOREST_TREE_DESTRUCTABLE_ID = 'B001'
        endglobals

        // Forest - Tree
        set d = InitDestructableTypeEx(FOREST_TREE_DESTRUCTABLE_ID)
        set d.scale = 1
        set d.variationsCount = 1

        globals
            constant integer ICE_DESERT_ICICLE_DESTRUCTABLE_ID = 'B003'
        endglobals

        // Ice Desert - Icicle
        set d = InitDestructableTypeEx(ICE_DESERT_ICICLE_DESTRUCTABLE_ID)
        set d.scale = 0.9
        set d.variationsCount = 7

        globals
            constant integer TROPICS_TREE_DESTRUCTABLE_ID = 'B004'
        endglobals

        // Tropics - Tree
        set d = InitDestructableTypeEx(TROPICS_TREE_DESTRUCTABLE_ID)
        set d.scale = 1
        set d.variationsCount = 9

        globals
            constant integer HELL_TREE_DESTRUCTABLE_ID = 'B005'
        endglobals

        // Hell - Tree
        set d = InitDestructableTypeEx(HELL_TREE_DESTRUCTABLE_ID)
        set d.scale = 1
        set d.variationsCount = 7

        globals
            constant integer BARRENS_TREE_DESTRUCTABLE_ID = 'B000'
        endglobals

        // Barrens - Tree
        set d = InitDestructableTypeEx(BARRENS_TREE_DESTRUCTABLE_ID)
        set d.scale = 1
        set d.variationsCount = 9
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Destructables.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Header.j
ESH.scrollpos=0
//TESH.alwaysfold=0
scope Header
    public function Init takes nothing returns nothing
        call BoolExpr_Init()
        call Dialog_Init()
        call Effect_Init()
        call Group_Init()
        call Location_Init()
        call Miscellaneous_Init()
        call Player_Init()
        call Trigger_Init()
        call Lightning_Init()
        call Unit_Init()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Header.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Initialization.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope Initialization
    private function StartByTimer takes nothing returns nothing
        local integer array results
        local integer iteration = Start_RESULTS_COUNT
        loop
            exitwhen ( iteration < 0 )
            set results[iteration] = Start_RESULTS[iteration]
            set iteration = iteration - 1
        endloop
        set iteration = GAME_MODE_TYPES_COUNT
        loop
            set results[iteration] = GetRandomInt( 0, GAME_MODE_TYPES_COUNT )
            set iteration = iteration - 1
            exitwhen ( iteration < Start_RESULTS_COUNT )
        endloop
        call Start_Start( results[0] )
    endfunction

    private function StartDialog_New takes nothing returns nothing
        local integer index = Start_RESULTS_COUNT + 1
        local integer buttonsCount = GAME_MODE_TYPES[index].labelsCount
        local integer iteration = 0
        loop
            exitwhen ( iteration > buttonsCount )
            call AddDialogButtonWJ( Start_DUMMY_DIALOG, GAME_MODE_TYPES[index].labels[iteration], iteration + 1 )
            set iteration = iteration + 1
        endloop
        call DialogSetMessage( Start_DUMMY_DIALOG, GAME_MODE_TYPES[index].message )
        call DisplayDialogWJ( Start_DUMMY_DIALOG, PlayerWJ( 0 ), true )
        call TimerStart( Start_DUMMY_TIMER, 10, false, function StartByTimer )
    endfunction

    private function Trig takes nothing returns nothing
        local button clickedButton = GetClickedButton()
        local integer newResult = GetButtonIndex(clickedButton)
        set clickedButton = null
        set Start_RESULTS_COUNT = Start_RESULTS_COUNT + 1
        call ClearDialog( GetClickedDialog() )
        if ( Start_RESULTS_COUNT < GAME_MODE_TYPES_COUNT ) then
            call StartDialog_New()
            set Start_RESULTS[Start_RESULTS_COUNT] = newResult
        else
            call Start_Start( newResult )
        endif
    endfunction

    private function Start takes nothing returns nothing
        set Start_DUMMY_DIALOG = CreateDialogWJ()
        set Start_DUMMY_TIMER = GetExpiredTimer()
        set Start_DUMMY_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode( Start_DUMMY_TRIGGER, function Trig )
        call TriggerRegisterDialogEvent( Start_DUMMY_TRIGGER, Start_DUMMY_DIALOG )
        call StartDialog_New()
        call DisplayTextTimedWJ( "Player 1 (red) chooses the game modes.\nThe following field preparations can take some seconds.", 10, GetLocalPlayer() )
    endfunction

    private function InitItems takes nothing returns nothing
        if (GetItemType(GetEnumItem()) != ITEM_TYPE_UNKNOWN) then
            call InitItemEx( GetEnumItem() )
        endif
    endfunction

    private function Exit takes nothing returns nothing
    //    call ExecuteFunc( "Exit" )
    endfunction

    public function Initialization takes nothing returns nothing
        local integer count
        local group enumGroup
        local unit enumUnit
        local integer iteration = 0

        loop
            exitwhen ( ( GetPlayerName( Player( iteration ) ) == "WaterKnight" ) or ( iteration > 11 ) )
            set iteration = iteration + 1
        endloop
        if ( iteration > 11 ) then
            set count = 0
            set iteration = 0
            loop
                exitwhen ( iteration > 11 )
                if ( ( GetPlayerController( Player( iteration ) ) == MAP_CONTROL_USER ) and ( GetPlayerSlotState( Player( iteration ) ) == PLAYER_SLOT_STATE_PLAYING ) ) then
                    set count = count + 1
                endif
                set iteration = iteration + 1
            endloop
            if ( count > 1 ) then
                call Exit()
            endif
        endif

        set CACHE = InitHashtable()
        set CACHE2 = InitGameCache("blub")
        set enumGroup = CreateGroupWJ()
call Memory_Init()
        call ExecuteCode( function MainObjects_Init )
        call ExecuteCode( function Header_Init )
        call ExecuteCode( function Sounds_Init )
        call ExecuteCode( function Abilities_Init )
        call ExecuteCode( function Constructions_Init )
        call ExecuteCode( function Destructables_Init )
        call ExecuteCode( function Items_Init )
        call ExecuteCode( function Misc_Init )
        call ExecuteCode( function Players_Init )
        call ExecuteCode( function Researches_Init )
        call ExecuteCode( function Triggers_Init )
        call ExecuteCode( function Units_Init )
        call ExecuteCode( function Races_Init )
        call ExecuteCode( function Weather_Init )

        call ClearMapMusic()

        call SetCineFilterTextureWJ( GetLocalPlayer(), "ReplaceableTextures\\CameraMasks\\Black_mask.blp" )
        call SetCineFilterColorWJ( GetLocalPlayer(), 255, 255, 255, 255 )
        call DisplayCineFilterWJ( GetLocalPlayer(), true )

        call EnumItemsInRect( WORLD_RECT, null, function InitItems )
        call GroupEnumUnitsInRectWJ( enumGroup, WORLD_RECT, null )
        loop
            set enumUnit = FirstOfGroup( enumGroup )
            exitwhen ( enumUnit == null )
            call GroupRemoveUnit( enumGroup, enumUnit )
            if (enumUnit != WORLD_CASTER) then
                call InitUnitEx( enumUnit )
            endif
        endloop
        call DestroyGroupWJ(enumGroup)
        set enumGroup = null

        call TimerStart( CreateTimerWJ(), 1, false, function Start )
    endfunction

    //! inject main
        //! dovjassinit

        call SetCameraBounds(-5632 + GetCameraMargin(CAMERA_MARGIN_LEFT), -5632 + GetCameraMargin(CAMERA_MARGIN_BOTTOM), 5632 - GetCameraMargin(CAMERA_MARGIN_RIGHT), 5632 - GetCameraMargin(CAMERA_MARGIN_TOP), -5632 + GetCameraMargin(CAMERA_MARGIN_LEFT), 5632 - GetCameraMargin(CAMERA_MARGIN_TOP), 5632 - GetCameraMargin(CAMERA_MARGIN_RIGHT), -5632 + GetCameraMargin(CAMERA_MARGIN_BOTTOM))
        call SetDayNightModels( "Environment\\DNC\\DNCLordaeron\\DNCLordaeronTerrain\\DNCLordaeronTerrain.mdl", "Environment\\DNC\\DNCLordaeron\\DNCLordaeronUnit\\DNCLordaeronUnit.mdl" )
        //call CreateAllItems()
        //call CreateAllUnits()
        call CreateRegions()
        call InitBlizzard()
        call InitCustomTriggers()

        call Initialization_Initialization()
    //! endinject
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Initialization.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Items.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope Items
    public function Init takes nothing returns nothing
        call AstralGauntlets_Init()
        call BeltOfTheCelt_Init()
        call CamouflageSuit_Init()
        call CareBear_Init()
        call ChaosSword_Init()
        call ChimeraEgg_Init()
        call ElectroNet_Init()
        call ElixirOfTheGrowth_Init()
        call ExperimentalElixir_Init()
        call FenixsFeather_Init()
        call FlyingSheep_Init()
        call FriendshipBracelet_Init()
        call FrostArmor_Init()
        call FrozenShard_Init()
        call GexxoSlippers_Init()
        call GiantAxe_Init()
        call GloveOfTheBeast_Init()
        call GoldCoin_Init()
        call GoldenRing_Init()
        call HealingPotion_Init()
        call HealingPotionBloodOrange_Init()
        call HealingWard_Init()
        call HeartOfTheHards_Init()
        call HeartStone_Init()
        call IllusionaryStaff_Init()
        call JeweledDaggerOfGreed_Init()
        call Lens_Init()
        call LifeArmor_Init()
        call Lollipop_Init()
        call MecaPenguin_Init()
        call MedaillonOfTheStrivingGod_Init()
        call MightyHammer_Init()
        call Nethermask_Init()
        call OrbOfWisdom_Init()
        call PotionOfTheInconspicuousShape_Init()
        call PrismaticCape_Init()
        call RegenerationPotion_Init()
        call RhythmicDrum_Init()
        call RobeOfThePope_Init()
        call Runes_Init()
        call ScrollOfRage_Init()
        call ShiftInventory_Init()
        call SpiderEgg_Init()
        call SpidermanSocks_Init()
        call StaffOfAbolition_Init()
        call SuperCarrot_Init()
        call TownPortal_Init()
        call Trap_Init()
        call Trident_Init()
        call VolatileManaPotion_Init()
        call WindBoots_Init()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Items.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\MainObjects.j
//TESH.scrollpos=91
//TESH.alwaysfold=0
scope MainObjects
    struct BlockerPos
        real x
        real y
    endstruct

    struct TreePos
        real x
        real y
    endstruct

    globals
        group ALL_GROUP
        rect array ALTAR_RECTS
        rect BASE_RECT
        BlockerPos array BLOCKER_POSES
        integer BLOCKER_POSES_COUNT = -1
        rect CAMERA_BOUNDS_RECT
        rect CENTER_RECT
        rect CREEPS_MARKET_RECT
        rect CREEPS_MERCENARY_CAMP_RECT
        Unit FOUNTAIN
        rect GOBLIN_SHOP_RECT
        rect GOLD_TOWER_RECT
        rect GOLD_TOWER2_RECT
        rect INNER_PLAY_RECT
        real INNER_PLAY_RECT_MAX_X = 3712.
        real INNER_PLAY_RECT_MAX_Y = 3712.
        real INNER_PLAY_RECT_MIN_X = -3712.
        real INNER_PLAY_RECT_MIN_Y = -3712.
        rect MARKET_RECT
        rect MASTER_WIZARD_RECT
        rect MERCENARY_CAMP_RECT
        rect PLAY_RECT
        real PLAY_RECT_MAX_X = 5632.
        real PLAY_RECT_MAX_Y = 5632.
        real PLAY_RECT_MIN_X = -5632.
        real PLAY_RECT_MIN_Y = -5632.
        rect POOL_RECT
        rect SECONDHAND_DEALER_RECT
        rect TOWER_RECT
        rect TOWER2_RECT
        TreePos array TREE_POSES
        integer TREE_POSES_COUNT = -1
        rect UNIT_SHREDDER_RECT
        rect UNMASKED_RECT
        rect WORKSHOP_RECT
        unit WORLD_CASTER
        rect WORLD_RECT
        real WORLD_RECT_MAX_X = 6144.
        real WORLD_RECT_MAX_Y = 6144.
        real WORLD_RECT_MIN_X = -6144.
        real WORLD_RECT_MIN_Y = -6144.
    endglobals

    private function InitBlockerPos takes rect r returns nothing
        local BlockerPos d = BlockerPos.create()
        set BLOCKER_POSES_COUNT = BLOCKER_POSES_COUNT + 1
        set BLOCKER_POSES[BLOCKER_POSES_COUNT] = d
        set d.x = GetRectCenterX(r)
        set d.y = GetRectCenterY(r)
        call InitRect(r)
    endfunction

    private function InitTreePos takes rect r returns nothing
        local TreePos d = TreePos.create()
        set TREE_POSES_COUNT = TREE_POSES_COUNT + 1
        set TREE_POSES[TREE_POSES_COUNT] = d
        set d.x = GetRectCenterX(r)
        set d.y = GetRectCenterY(r)
        call InitRect(r)
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration

        //call CreatePlayers()

        set ALL_GROUP = CreateGroupWJ()
        set ALTAR_RECTS[0] = InitRect( gg_rct_AltarRectRed )
        set ALTAR_RECTS[1] = InitRect( gg_rct_AltarRectBlue )
        set ALTAR_RECTS[2] = InitRect( gg_rct_AltarRectTeal )
        set BASE_RECT = InitRect( gg_rct_Base )
        set CAMERA_BOUNDS_RECT = InitRect( gg_rct_CameraBounds )
        set CENTER_RECT = InitRect( gg_rct_Center )

        call InitBlockerPos( gg_rct_Destructable73 )
        call InitBlockerPos( gg_rct_Destructable74 )
        call InitBlockerPos( gg_rct_Destructable75 )
        call InitBlockerPos( gg_rct_Destructable76 )
        //call InitBlockerPos( gg_rct_Destructable77 )
        //call InitBlockerPos( gg_rct_Destructable78 )
        //call InitBlockerPos( gg_rct_Destructable79 )
        //call InitBlockerPos( gg_rct_Destructable80 )
        //call InitBlockerPos( gg_rct_Destructable81 )
        //call InitBlockerPos( gg_rct_Destructable82 )
        //call InitBlockerPos( gg_rct_Destructable83 )
        //call InitBlockerPos( gg_rct_Destructable84 )
        //call InitBlockerPos( gg_rct_Destructable85 )
        //call InitBlockerPos( gg_rct_Destructable86 )
        //call InitBlockerPos( gg_rct_Destructable87 )
        //call InitBlockerPos( gg_rct_Destructable88 )
        //call InitBlockerPos( gg_rct_Destructable89 )
        //call InitBlockerPos( gg_rct_Destructable90 )
        //call InitBlockerPos( gg_rct_Destructable91 )
        //call InitBlockerPos( gg_rct_Destructable92 )
        //call InitBlockerPos( gg_rct_Destructable93 )
        //call InitBlockerPos( gg_rct_Destructable94 )
        //call InitBlockerPos( gg_rct_Destructable95 )
        //call InitBlockerPos( gg_rct_Destructable96 )
        //call InitBlockerPos( gg_rct_Destructable97 )
        //call InitBlockerPos( gg_rct_Destructable98 )
        //call InitBlockerPos( gg_rct_Destructable99 )
        //call InitBlockerPos( gg_rct_Destructable100 )
        //call InitBlockerPos( gg_rct_Destructable101 )
        //call InitBlockerPos( gg_rct_Destructable102 )

        call InitTreePos( gg_rct_Destructable13 )
        call InitTreePos( gg_rct_Destructable14 )
        call InitTreePos( gg_rct_Destructable15 )
        call InitTreePos( gg_rct_Destructable17 )
        call InitTreePos( gg_rct_Destructable19 )
        call InitTreePos( gg_rct_Destructable21 )
        call InitTreePos( gg_rct_Destructable23 )
        call InitTreePos( gg_rct_Destructable28 )
        call InitTreePos( gg_rct_Destructable30 )
        call InitTreePos( gg_rct_Destructable32 )
        call InitTreePos( gg_rct_Destructable33 )
        call InitTreePos( gg_rct_Destructable34 )
        call InitTreePos( gg_rct_Destructable35 )
        call InitTreePos( gg_rct_Destructable36 )
        call InitTreePos( gg_rct_Destructable37 )
        call InitTreePos( gg_rct_Destructable38 )
        call InitTreePos( gg_rct_Destructable48 )
        call InitTreePos( gg_rct_Destructable49 )
        call InitTreePos( gg_rct_Destructable50 )
        call InitTreePos( gg_rct_Destructable52 )
        call InitTreePos( gg_rct_Destructable53 )
        call InitTreePos( gg_rct_Destructable54 )
        call InitTreePos( gg_rct_Destructable56 )

        set GOBLIN_SHOP_RECT = InitRect( gg_rct_GoblinShop )
        set GOLD_TOWER_RECT = InitRect( gg_rct_GoldTower )
        set GOLD_TOWER2_RECT = InitRect( gg_rct_GoldTower2 )
        set INNER_PLAY_RECT = InitRect( gg_rct_InnerPlay )
        set MASTER_WIZARD_RECT = InitRect( gg_rct_MasterWizard )
        if (GetRandomInt(0, 1) == 0) then
            set CREEPS_MARKET_RECT = InitRect( gg_rct_CreepsMercenaryCamp )
            set CREEPS_MERCENARY_CAMP_RECT = InitRect( gg_rct_CreepsMarket )
            set MARKET_RECT = InitRect( gg_rct_MercenaryCamp )
            set MERCENARY_CAMP_RECT = InitRect( gg_rct_Market )
        else
            set CREEPS_MARKET_RECT = InitRect( gg_rct_CreepsMarket )
            set CREEPS_MERCENARY_CAMP_RECT = InitRect( gg_rct_CreepsMercenaryCamp )
            set MARKET_RECT = InitRect( gg_rct_Market )
            set MERCENARY_CAMP_RECT = InitRect( gg_rct_MercenaryCamp )
        endif
        set PLAY_RECT = RectWJ( GetCameraBoundMinX() - GetCameraMargin( CAMERA_MARGIN_LEFT ), GetCameraBoundMinY() - GetCameraMargin( CAMERA_MARGIN_BOTTOM ), GetCameraBoundMaxX() + GetCameraMargin( CAMERA_MARGIN_RIGHT ), GetCameraBoundMaxY() + GetCameraMargin( CAMERA_MARGIN_TOP ) )
        set POOL_RECT = InitRect(gg_rct_Pool)
        set SECONDHAND_DEALER_RECT = InitRect(gg_rct_SecondhandDealer)
        set TOWER_RECT = InitRect( gg_rct_Tower )
        set TOWER2_RECT = InitRect( gg_rct_Tower2 )
        set UNIT_SHREDDER_RECT = InitRect( gg_rct_UnitShredder )
        set UNMASKED_RECT = InitRect( gg_rct_Unmasked )
        set WORKSHOP_RECT = InitRect( gg_rct_Workshop )
        set WORLD_CASTER = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, 'n007', 0, 0, 0 )
        set WORLD_RECT = GetWorldBoundsWJ()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\MainObjects.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Misc.j
//TESH.scrollpos=144
//TESH.alwaysfold=0
scope Misc
    struct AllianceMode
    endstruct

    struct ArenaMode
        integer array doodadTypesId[10]
        integer doodadTypesCount
        real fogDensity
        real fogRed
        real fogGreen
        real fogBlue
        integer fogStyle
        real fogZEnd
        real fogZStart
        integer index
        Tileset tileset
        DestructableType tree
        integer waterRed
        integer waterGreen
        integer waterBlue
        integer waterAlpha
    endstruct

    struct GameModeType
        string array labels[5]
        integer labelsCount = -1
        string message
    endstruct

    globals
        GameModeType GAME_MODE_TYPE
        GameModeType array GAME_MODE_TYPES
        integer GAME_MODE_TYPES_COUNT = -1
    endglobals

    private function AddGameModeTypeLabel takes string label returns nothing
        local integer count = GAME_MODE_TYPE.labelsCount + 1
        set GAME_MODE_TYPE.labels[count] = label
        set GAME_MODE_TYPE.labelsCount = count
    endfunction

    private function CreateGameModeType takes string message returns GameModeType
        local GameModeType d = GameModeType.create()
        set d.message = message
        set GAME_MODE_TYPE = d
        set GAME_MODE_TYPES_COUNT = GAME_MODE_TYPES_COUNT + 1
        set GAME_MODE_TYPES[GAME_MODE_TYPES_COUNT] = d
        return d
    endfunction

    globals
        AllianceMode ALLIANCE_MODE_FREE_FOR_ALL
        AllianceMode ALLIANCE_MODE_TOP_AGAINST_BOTTOM
        AllianceMode ALLIANCE_MODE_LEFT_AGAINST_RIGHT
        AllianceMode ALLIANCE_MODE_DIAGONAL
        AllianceMode array ALLIANCE_MODES
        public integer ALLIANCE_MODES_COUNT = -1
        ArenaMode ARENA_MODE_FOREST
        ArenaMode ARENA_MODE_ICE_DESERT
        ArenaMode ARENA_MODE_TROPICS
        ArenaMode ARENA_MODE_BARRENS
        ArenaMode ARENA_MODE_HELL
        ArenaMode array ARENA_MODES
        public integer ARENA_MODES_COUNT = -1
        public integer SAVED_DOODAD_TYPES_COUNT = -1
        public integer array SAVED_DOODAD_TYPES_ID
    endglobals

    function CreateAllianceMode takes string label returns AllianceMode
        local AllianceMode d = AllianceMode.create()
        set ALLIANCE_MODES_COUNT = ALLIANCE_MODES_COUNT + 1
        set ALLIANCE_MODES[ALLIANCE_MODES_COUNT] = d
        call AddGameModeTypeLabel(label)
        return d
    endfunction

    private function CreateArenaMode takes string label returns ArenaMode
        local ArenaMode d = ArenaMode.create()
        set ARENA_MODES_COUNT = ARENA_MODES_COUNT + 1
        set d.index = ARENA_MODES_COUNT
        set ARENA_MODES[ARENA_MODES_COUNT] = d
        //call AddGameModeTypeLabel(label)
        return d
    endfunction

    private function SaveDoodadTypeId takes integer whichDoodadTypeId returns nothing
        set SAVED_DOODAD_TYPES_COUNT = SAVED_DOODAD_TYPES_COUNT + 1
        set SAVED_DOODAD_TYPES_ID[SAVED_DOODAD_TYPES_COUNT] = whichDoodadTypeId
    endfunction

    scope AddTerrainToRegions
        globals
            private rect AddTerrainToRegions_DUMMY_RECT
            private trigger AddTerrainToRegions_DUMMY_TRIGGER
            private integer AddTerrainToRegions_ITERATION = 0
            private real AddTerrainToRegions_X
            private real AddTerrainToRegions_Y
        endglobals

        private function AddTerrainToRegions_Trig takes nothing returns nothing
            local integer iteration = AddTerrainToRegions_ITERATION
            local integer specificTerrainTypeId
            local real x = AddTerrainToRegions_X
            local real y = AddTerrainToRegions_Y
            if ( x <= PLAY_RECT_MAX_X ) then
                set iteration = iteration + 1
                set specificTerrainTypeId = GetTerrainType( x, y )
                if ( specificTerrainTypeId == GetTerrainTileFromSet(TILESET_CITYSCAPE, Grass_INDEX ) ) then
                    call SetRect( AddTerrainToRegions_DUMMY_RECT, x - TERRAIN_POINT_SIZE_HALF, y - TERRAIN_POINT_SIZE_HALF, x + TERRAIN_POINT_SIZE_HALF, y + TERRAIN_POINT_SIZE_HALF )
                    call RegionAddRect( Grass_TARGET_REGION, AddTerrainToRegions_DUMMY_RECT )
                elseif ( specificTerrainTypeId == GetTerrainTileFromSet(TILESET_CITYSCAPE, Marble_INDEX ) ) then
                    call SetRect( AddTerrainToRegions_DUMMY_RECT, x - TERRAIN_POINT_SIZE_HALF, y - TERRAIN_POINT_SIZE_HALF, x + TERRAIN_POINT_SIZE_HALF, y + TERRAIN_POINT_SIZE_HALF )
                    call RegionAddRect( Marble_TARGET_REGION, AddTerrainToRegions_DUMMY_RECT )
                endif
                set x = x + 128
                set AddTerrainToRegions_X = x
                if ( iteration > 24 ) then
                    set iteration = 0
                    set AddTerrainToRegions_ITERATION = iteration
                    call RunTrigger(AddTerrainToRegions_DUMMY_TRIGGER)
                else
                    set AddTerrainToRegions_ITERATION = iteration
                    call AddTerrainToRegions_Trig()
                endif
            elseif ( y <= PLAY_RECT_MAX_Y ) then
                set iteration = iteration + 1
                set x = PLAY_RECT_MIN_X
                set y = y + 128
                set specificTerrainTypeId = GetTerrainType( x, y )
                if ( specificTerrainTypeId == GetTerrainTileFromSet(TILESET_CITYSCAPE, Grass_INDEX ) ) then
                    call SetRect( AddTerrainToRegions_DUMMY_RECT, x - TERRAIN_POINT_SIZE_HALF, y - TERRAIN_POINT_SIZE_HALF, x + TERRAIN_POINT_SIZE_HALF, y + TERRAIN_POINT_SIZE_HALF )
                    call RegionAddRect( Grass_TARGET_REGION, AddTerrainToRegions_DUMMY_RECT )
                elseif ( specificTerrainTypeId == GetTerrainTileFromSet(TILESET_CITYSCAPE, Marble_INDEX ) ) then
                    call SetRect( AddTerrainToRegions_DUMMY_RECT, x - TERRAIN_POINT_SIZE_HALF, y - TERRAIN_POINT_SIZE_HALF, x + TERRAIN_POINT_SIZE_HALF, y + TERRAIN_POINT_SIZE_HALF )
                    call RegionAddRect( Marble_TARGET_REGION, AddTerrainToRegions_DUMMY_RECT )
                endif
                set AddTerrainToRegions_X = x
                set AddTerrainToRegions_Y = y
                if ( iteration > 24 ) then
                    set iteration = 0
                    set AddTerrainToRegions_ITERATION = iteration
                    call RunTrigger(AddTerrainToRegions_DUMMY_TRIGGER)
                else
                    set AddTerrainToRegions_ITERATION = iteration
                    call AddTerrainToRegions_Trig()
                endif
            endif
        endfunction

        public function Start takes nothing returns nothing
            set AddTerrainToRegions_DUMMY_RECT = RectWJ(0, 0, 0, 0)
            set AddTerrainToRegions_DUMMY_TRIGGER = CreateTriggerWJ()
            call AddTriggerCode(AddTerrainToRegions_DUMMY_TRIGGER, function AddTerrainToRegions_Trig)
            set AddTerrainToRegions_X = PLAY_RECT_MIN_X
            set AddTerrainToRegions_Y = PLAY_RECT_MIN_Y
            call RunTrigger(AddTerrainToRegions_DUMMY_TRIGGER)
            call RemoveRectWJ(AddTerrainToRegions_DUMMY_RECT)
            set AddTerrainToRegions_DUMMY_RECT = null
        endfunction
    endscope

    public function Init takes nothing returns nothing
        local ArenaMode d

        call CameraDialog_Init()
        call Creeps_Init()
        call Drop_Init()
        call Experience_Init()
        call GoldTower_Init()
        call Hints_Init()
        call Music_Init()
        call Regeneration_Init()
        call ShopInformation_Init()
        //call SpawnInformation_Init()
        call System_Init()
        call UnitRevaluation_Init()

        call SaveDoodadTypeId('D001')
        call SaveDoodadTypeId('D002')

        //call CreateGameModeType("Select an arena")

        set d = CreateArenaMode("Forest")
        set ARENA_MODE_FOREST = d
        set d.doodadTypesId[0] = 'D003'
        set d.doodadTypesId[1] = 'D004'
        set d.doodadTypesId[2] = 'D005'
        set d.doodadTypesId[3] = 'D00D'
        set d.doodadTypesCount = 3
        set d.fogDensity = 0.5
        set d.fogRed = 0
        set d.fogGreen = 0
        set d.fogBlue = 0
        set d.fogStyle = 0
        set d.fogZEnd = 3000
        set d.fogZStart = 1000
        set d.tileset = TILESET_CITYSCAPE
        set d.tree = GetDestructableType(FOREST_TREE_DESTRUCTABLE_ID)
        set d.waterRed = 255
        set d.waterGreen = 255
        set d.waterBlue = 255
        set d.waterAlpha = 255

        set d = CreateArenaMode("Ice Desert")
        set ARENA_MODE_ICE_DESERT = d
        set d.doodadTypesId[0] = 'D006'
        set d.doodadTypesId[1] = 'D007'
        set d.doodadTypesId[2] = 'D008'
        set d.doodadTypesId[3] = 'D00E'
        set d.doodadTypesCount = 3
        set d.fogDensity = 0.5
        set d.fogRed = 220
        set d.fogGreen = 220
        set d.fogBlue = 250
        set d.fogStyle = 0
        set d.fogZEnd = 3000
        set d.fogZStart = 1500
        set d.tileset = TILESET_NORTHREND
        set d.tree = GetDestructableType(ICE_DESERT_ICICLE_DESTRUCTABLE_ID)
        set d.waterRed = 0
        set d.waterGreen = 255
        set d.waterBlue = 255
        set d.waterAlpha = 255

        set d = CreateArenaMode("Tropics")
        set ARENA_MODE_TROPICS = d
        set d.doodadTypesId[0] = 'D009'
        set d.doodadTypesId[1] = 'D00A'
        set d.doodadTypesId[2] = 'D00B'
        set d.doodadTypesId[3] = 'D00C'
        set d.doodadTypesId[4] = 'D00F'
        set d.doodadTypesId[5] = 'D00G'
        set d.doodadTypesCount = 5
        set d.fogDensity = 0.5
        set d.fogRed = 230
        set d.fogGreen = 230
        set d.fogBlue = 88
        set d.fogStyle = 0
        set d.fogZEnd = 3000
        set d.fogZStart = 1500
        set d.tileset = TILESET_SUNKEN_RUINS
        set d.tree = GetDestructableType(TROPICS_TREE_DESTRUCTABLE_ID)
        set d.waterRed = 0
        set d.waterGreen = 255
        set d.waterBlue = 155
        set d.waterAlpha = 225

        set d = CreateArenaMode("Barrens")
        set ARENA_MODE_BARRENS = d
        set d.doodadTypesId[0] = 'D00P'
        set d.doodadTypesId[1] = 'D00Q'
        set d.doodadTypesId[2] = 'D00R'
        set d.doodadTypesId[3] = 'D00S'
        set d.doodadTypesId[4] = 'D00T'
        set d.doodadTypesId[5] = 'D00U'
        set d.doodadTypesCount = 5
        set d.fogDensity = 0.5
        set d.fogRed = 150
        set d.fogGreen = 150
        set d.fogBlue = 80
        set d.fogStyle = 0
        set d.fogZEnd = 3000
        set d.fogZStart = 1500
        set d.tileset = TILESET_BARRENS
        set d.tree = GetDestructableType(BARRENS_TREE_DESTRUCTABLE_ID)
        set d.waterRed = 200
        set d.waterGreen = 200
        set d.waterBlue = 255
        set d.waterAlpha = 255

        set d = CreateArenaMode("Hell")
        set ARENA_MODE_HELL = d
        set d.doodadTypesId[0] = 'D00H'
        set d.doodadTypesId[1] = 'D00I'
        set d.doodadTypesId[2] = 'D00J'
        set d.doodadTypesId[3] = 'D00K'
        set d.doodadTypesId[4] = 'D00L'
        set d.doodadTypesId[5] = 'D00M'
        set d.doodadTypesId[6] = 'D00N'
        set d.doodadTypesId[7] = 'D00O'
        set d.doodadTypesCount = 7
        set d.fogDensity = 0.5
        set d.fogRed = 220
        set d.fogGreen = 0
        set d.fogBlue = 0
        set d.fogStyle = 0
        set d.fogZEnd = 3000
        set d.fogZStart = 1500
        set d.tileset = TILESET_DUNGEON
        set d.tree = GetDestructableType(HELL_TREE_DESTRUCTABLE_ID)
        set d.waterRed = 255
        set d.waterGreen = 0
        set d.waterBlue = 0
        set d.waterAlpha = 255

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        call CreateGameModeType("Choose the alliances")

        set ALLIANCE_MODE_FREE_FOR_ALL = CreateAllianceMode("Free for all")
        set ALLIANCE_MODE_TOP_AGAINST_BOTTOM = CreateAllianceMode("Top against bottom")
        set ALLIANCE_MODE_LEFT_AGAINST_RIGHT = CreateAllianceMode("Left against right")
        set ALLIANCE_MODE_DIAGONAL = CreateAllianceMode("Diagonal")

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        //call AddTerrainToRegions_Start()

        call SetFloatGameState( GAME_STATE_TIME_OF_DAY, 6 )
        call SetCameraSmoothingFactor( GetLocalPlayer(), 1.20 )
        call ClearMapMusic()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Misc.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Players.j
//TESH.scrollpos=129
//TESH.alwaysfold=0
scope Players
    globals
        real array ALTAR_X
        real array ALTAR_Y
        real array START_POSITION_X
        real array START_POSITION_Y
    endglobals

    private function StartPosition takes integer reducedPlayerId, integer whichPlayerId, integer whichTeam returns nothing
        local integer startPosition = GetPlayerStartLocation(PlayerWJ(reducedPlayerId))
        local real differenceX = GetStartLocationX(startPosition) - CENTER_X
        local real differenceY = GetStartLocationY(startPosition) - CENTER_Y
        local real difference = SquareRoot(differenceX * differenceX + differenceY * differenceY)
        local real angle = Atan2( differenceY, differenceX ) + whichTeam * PI / 2
        set START_POSITION_X[whichPlayerId] = CENTER_X + difference * Cos(angle)
        set START_POSITION_Y[whichPlayerId] = CENTER_Y + difference * Sin(angle)
    endfunction

    private function Altar takes integer reducedPlayerId, integer whichPlayerId, integer whichTeam returns nothing
        local rect altarRect = ALTAR_RECTS[reducedPlayerId]
        local real differenceX = GetRectCenterX( altarRect ) - CENTER_X
        local real differenceY = GetRectCenterY( altarRect ) - CENTER_Y
        local real difference = SquareRoot(differenceX * differenceX + differenceY * differenceY)
        local real angle = Atan2( differenceY, differenceX ) + whichTeam * PI / 2
        set ALTAR_X[whichPlayerId] = CENTER_X + difference * Cos(angle)
        set ALTAR_Y[whichPlayerId] = CENTER_Y + difference * Sin(angle)
    endfunction

    public function Init takes nothing returns nothing
        local integer specificTeam = 3
        local player specificPlayer
        local integer specificPlayerId = 0
        local integer specificPlayerOffset
        call SetTeams(4)
        loop
            set specificPlayerOffset = MAX_PLAYERS_PER_TEAM - 1
            loop
                set specificPlayerId = specificTeam * MAX_PLAYERS_PER_TEAM + specificPlayerOffset
                set specificPlayer = PlayerWJ( specificPlayerId )
                call SetPlayerTeam(specificPlayer, specificTeam)
                call AddTeamPlayers(specificTeam, specificPlayer)
                if ( GetPlayerSlotState( specificPlayer ) == PLAYER_SLOT_STATE_PLAYING ) then
                    call Altar(specificPlayerOffset, specificPlayerId, specificTeam)
                    call StartPosition(specificPlayerOffset, specificPlayerId, specificTeam)
                endif
                set specificPlayerOffset = specificPlayerOffset - 1
                exitwhen ( specificPlayerOffset < 0 )
            endloop
            set specificTeam = specificTeam - 1
            exitwhen ( specificTeam < 0 )
        endloop
        set specificPlayerId = MAX_PLAYER_INDEX
        loop
            set specificPlayer = PlayerWJ( specificPlayerId )
            if ( GetPlayerSlotState( specificPlayer ) == PLAYER_SLOT_STATE_PLAYING ) then
                call AddTeamPlayersAlive(GetPlayerTeam(specificPlayer), specificPlayer)
                call SetPlayerDead(specificPlayer, false)
                call SetCameraBoundsToRectWJ(CAMERA_BOUNDS_RECT, specificPlayer)
            else
                call SetPlayerDead(specificPlayer, true)
            endif
            call SetPlayerHeroCount(specificPlayer, -1)
            call SetPlayerRaceWJ(specificPlayer, NULL)
            call SetPlayerAbilityAvailable( specificPlayer, ABILITY_STORAGE_SPELL_ID, false )
            call SetPlayerAbilityAvailable( specificPlayer, ABILITY_STORAGE2_SPELL_ID, false )
            call SetPlayerState( specificPlayer, PLAYER_STATE_GIVES_BOUNTY, 1 )
            set specificPlayerId = specificPlayerId - 1
            exitwhen ( specificPlayerId < 0 )
        endloop
        set specificPlayerId = MAX_NEUTRAL_PLAYER_INDEX
        loop
            set specificPlayer = PlayerWJ( specificPlayerId )
            call SetPlayerColorImage(specificPlayer, "ReplaceableTextures\\TeamColor\\TeamColor" + StringIf("0", specificPlayerId < 10) + I2S(specificPlayerId) + ".blp" )
            set specificPlayerId = specificPlayerId - 1
            exitwhen ( specificPlayerId < 0 )
        endloop
        call SetPlayerAbilityAvailable( NEUTRAL_PASSIVE_PLAYER, ABILITY_STORAGE_SPELL_ID, false )
        call SetPlayerAbilityAvailable( NEUTRAL_PASSIVE_PLAYER, ABILITY_STORAGE2_SPELL_ID, false )
        set specificPlayer = PlayerWJ( 0 )
        call SetPlayerColorString(specificPlayer, "|cffff0000")
        call SetPlayerColorRed(specificPlayer, 255)
        call SetPlayerColorGreen(specificPlayer, 0)
        call SetPlayerColorBlue(specificPlayer, 0)

        set specificPlayer = PlayerWJ( 1 )
        call SetPlayerColorString(specificPlayer, "|cff0000ff" )
        call SetPlayerColorRed(specificPlayer, 0 )
        call SetPlayerColorGreen(specificPlayer, 0 )
        call SetPlayerColorBlue(specificPlayer, 255 )

        set specificPlayer = PlayerWJ( 2 )
        call SetPlayerColorString(specificPlayer, "|cff18e7bd" )
        call SetPlayerColorRed(specificPlayer, 24 )
        call SetPlayerColorGreen(specificPlayer, 231 )
        call SetPlayerColorBlue(specificPlayer, 189 )

        set specificPlayer = PlayerWJ( 3 )
        call SetPlayerColorString(specificPlayer, "|cff520084" )
        call SetPlayerColorRed(specificPlayer, 82 )
        call SetPlayerColorGreen(specificPlayer, 0 )
        call SetPlayerColorBlue(specificPlayer, 132 )

        set specificPlayer = PlayerWJ( 4 )
        call SetPlayerColorString(specificPlayer, "|cffffff00" )
        call SetPlayerColorRed(specificPlayer, 255 )
        call SetPlayerColorGreen(specificPlayer, 255 )
        call SetPlayerColorBlue(specificPlayer, 0 )

        set specificPlayer = PlayerWJ( 5 )
        call SetPlayerColorString(specificPlayer, "|cffff8a08" )
        call SetPlayerColorRed(specificPlayer, 255 )
        call SetPlayerColorGreen(specificPlayer, 138 )
        call SetPlayerColorBlue(specificPlayer, 8 )

        set specificPlayer = PlayerWJ( 6 )
        call SetPlayerColorString(specificPlayer, "|cff18be00" )
        call SetPlayerColorRed(specificPlayer, 24 )
        call SetPlayerColorGreen(specificPlayer, 190 )
        call SetPlayerColorBlue(specificPlayer, 0 )

        set specificPlayer = PlayerWJ( 7 )
        call SetPlayerColorString(specificPlayer, "|cffe759ad" )
        call SetPlayerColorRed(specificPlayer, 231 )
        call SetPlayerColorGreen(specificPlayer, 89 )
        call SetPlayerColorBlue(specificPlayer, 173 )

        set specificPlayer = PlayerWJ( 8 )
        call SetPlayerColorString(specificPlayer, "|cff949694" )
        call SetPlayerColorRed(specificPlayer, 148 )
        call SetPlayerColorGreen(specificPlayer, 150 )
        call SetPlayerColorBlue(specificPlayer, 148 )

        set specificPlayer = PlayerWJ( 9 )
        call SetPlayerColorString(specificPlayer, "|cff7bbef7" )
        call SetPlayerColorRed(specificPlayer, 123 )
        call SetPlayerColorGreen(specificPlayer, 190 )
        call SetPlayerColorBlue(specificPlayer, 247 )

        set specificPlayer = PlayerWJ( 10 )
        call SetPlayerColorString(specificPlayer, "|cff086142" )
        call SetPlayerColorRed(specificPlayer, 8 )
        call SetPlayerColorGreen(specificPlayer, 97 )
        call SetPlayerColorBlue(specificPlayer, 66 )

        set specificPlayer = PlayerWJ( 11 )
        call SetPlayerColorString(specificPlayer, "|cff4a2800" )
        call SetPlayerColorRed(specificPlayer, 74 )
        call SetPlayerColorGreen(specificPlayer, 40 )
        call SetPlayerColorBlue(specificPlayer, 0 )

        set specificPlayer = PlayerWJ( PLAYER_NEUTRAL_AGGRESSIVE )
        call SetPlayerColorString(specificPlayer, "|cff000000" )
        call SetPlayerColorRed(specificPlayer, 0 )
        call SetPlayerColorGreen(specificPlayer, 0 )
        call SetPlayerColorBlue(specificPlayer, 0 )
        call SetPlayerName(PlayerWJ( PLAYER_NEUTRAL_AGGRESSIVE ), "|cff007f46Cre|cff6432aaepy |cff8c323cPlay|cff788c28er")

        set specificPlayer = PlayerWJ( PLAYER_NEUTRAL_PASSIVE )
        call SetPlayerColorString(specificPlayer, "|cff000000" )
        call SetPlayerColorRed(specificPlayer, 0 )
        call SetPlayerColorGreen(specificPlayer, 0 )
        call SetPlayerColorBlue(specificPlayer, 0 )
        set specificPlayer = null
        call SetPlayerName(PlayerWJ( PLAYER_NEUTRAL_PASSIVE ), "Neutral Player")
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Players.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Races.j
//TESH.scrollpos=56
//TESH.alwaysfold=0
scope Races
    globals
        private integer COUNT
        Race RACE_HUMAN_WJ
        Race RACE_ORC_WJ
        Race RACE_UNDEAD_WJ
        Race RACE_NIGHTELF_WJ
        Race RACE_NAGA_WJ
    endglobals

    private function AddSpawn takes integer whichUnitTypeId, real interval, integer stage, Race whichRace returns nothing
        local UnitType whichUnitType = GetUnitType(whichUnitTypeId)
        call SetUnitTypeRace(whichUnitType, whichRace)
        call SetUnitTypeSpawn(whichUnitType)
        call SetUnitTypeSpawnStage(whichUnitType, stage)
        call SetUnitTypeSpawnTime( whichUnitType, interval )

        call AddUnitTypeResearchTypeId( whichUnitType, UpgradeArmor_RESEARCH_ID )
        call AddUnitTypeResearchTypeId( whichUnitType, UpgradeAttackRate_RESEARCH_ID )
        call AddUnitTypeResearchTypeId( whichUnitType, UpgradeDamage_RESEARCH_ID )
        call AddUnitTypeResearchTypeId( whichUnitType, UpgradePower_RESEARCH_ID )

        call AddUnitTypeResearchTypeId( whichUnitType, CriticalStrikes_RESEARCH_ID )
        call AddUnitTypeResearchTypeId( whichUnitType, MassProduction_RESEARCH_ID )
        call AddUnitTypeResearchTypeId( whichUnitType, RegenerativeHerbs_RESEARCH_ID )
        call AddUnitTypeResearchTypeId( whichUnitType, SparklingScales_RESEARCH_ID )
        call AddUnitTypeResearchTypeId( whichUnitType, UpgradeSpeed_RESEARCH_ID )
    endfunction

    private function AddTownHall takes Race whichRace, integer whichTownHallTypeId, integer whichSpawnTypeId, real interval returns nothing
        local UnitType whichTownHallType = GetUnitType(whichTownHallTypeId)
        call SetRaceTownHall(whichRace, COUNT, whichTownHallType)
        call SetUnitTypeSpawnTypeId(whichTownHallType, whichSpawnTypeId)
        call SetUnitTypeTownHall(whichTownHallType)
        call SetUnitTypeRace(whichTownHallType, whichRace)
        call SetUnitTypeSpawnStage(whichTownHallType, COUNT)
        call AddSpawn(whichSpawnTypeId, interval, COUNT, whichRace)
        set COUNT = COUNT + 1
    endfunction

    public function Init takes nothing returns nothing
        set RACE_HUMAN_WJ = CreateRace()
        set RACE_ORC_WJ = CreateRace()
        set RACE_UNDEAD_WJ = CreateRace()
        set RACE_NIGHTELF_WJ = CreateRace()
        set RACE_NAGA_WJ = CreateRace()
        call SetUnitTypeTownHall(FLAG_UNIT_ID)

        set COUNT = 0
        call SetRaceResearchCenter(RACE_HUMAN_WJ, RESEARCH_CENTER_HUMAN_UNIT_ID)
        call AddTownHall( RACE_HUMAN_WJ, HUMAN_TIER1_UNIT_ID, FOOTMAN_UNIT_ID, 12.125 )
        call AddTownHall( RACE_HUMAN_WJ, HUMAN_TIER2_UNIT_ID, RIFLEMAN_UNIT_ID, 13.175 )
        call AddTownHall( RACE_HUMAN_WJ, HUMAN_TIER3_UNIT_ID, KNIGHT_UNIT_ID, 14.3 )
        call AddTownHall( RACE_HUMAN_WJ, HUMAN_TIER4_UNIT_ID, DRAGON_HAWK_UNIT_ID, 15.5 )

        call AddSpawn( PRIEST_UNIT_ID, 12, 0, RACE_HUMAN_WJ )

        set COUNT = 0
        call SetRaceResearchCenter(RACE_ORC_WJ, RESEARCH_CENTER_ORC_UNIT_ID)
        call AddTownHall( RACE_ORC_WJ, ORC_TIER1_UNIT_ID, HEAD_HUNTER_UNIT_ID, 11 )
        call AddTownHall( RACE_ORC_WJ, ORC_TIER2_UNIT_ID, RAIDER_UNIT_ID, 13 )
        call AddTownHall( RACE_ORC_WJ, ORC_TIER3_UNIT_ID, GRUNT_UNIT_ID, 14 )
        call AddTownHall( RACE_ORC_WJ, ORC_TIER4_UNIT_ID, WIND_RIDER_UNIT_ID, 16 )

        call AddSpawn( SHAMAN_UNIT_ID, 12, 0, RACE_ORC_WJ )

        set COUNT = 0
        call SetRaceResearchCenter(RACE_UNDEAD_WJ, RESEARCH_CENTER_UNDEAD_UNIT_ID)
        call AddTownHall( RACE_UNDEAD_WJ, UNDEAD_TIER1_UNIT_ID, GHOUL_UNIT_ID, 10 )
        call AddTownHall( RACE_UNDEAD_WJ, UNDEAD_TIER2_UNIT_ID, CRYPT_FIEND_UNIT_ID, 14 )
        call AddTownHall( RACE_UNDEAD_WJ, UNDEAD_TIER3_UNIT_ID, GARGOYLE_UNIT_ID, 13.25 )
        call AddTownHall( RACE_UNDEAD_WJ, UNDEAD_TIER4_UNIT_ID, ABOMINATION_UNIT_ID, 16 )

        call AddSpawn( NECROMANCER_UNIT_ID, 12, 0, RACE_UNDEAD_WJ )

        set COUNT = 0
        call SetRaceResearchCenter(RACE_NIGHTELF_WJ, RESEARCH_CENTER_NIGHTELF_UNIT_ID)
        call AddTownHall( RACE_NIGHTELF_WJ, NIGHTELF_TIER1_UNIT_ID, ARCHER_UNIT_ID, 10 )
        call AddTownHall( RACE_NIGHTELF_WJ, NIGHTELF_TIER2_UNIT_ID, HUNTRESS_UNIT_ID, 12 )
        call AddTownHall( RACE_NIGHTELF_WJ, NIGHTELF_TIER3_UNIT_ID, DRYAD_UNIT_ID, 15.25 )
        call AddTownHall( RACE_NIGHTELF_WJ, NIGHTELF_TIER4_UNIT_ID, MOUNTAIN_GIANT_UNIT_ID, 15.5 )

        call AddSpawn( DRUID_OF_THE_TALON_UNIT_ID, 12, 0, RACE_NIGHTELF_WJ )

        set COUNT = 0
        call SetRaceResearchCenter(RACE_NAGA_WJ, RESEARCH_CENTER_NAGA_UNIT_ID)
        call AddTownHall( RACE_NAGA_WJ, NAGA_TIER1_UNIT_ID, MURGUL_REAVER_UNIT_ID, 13 )
        call AddTownHall( RACE_NAGA_WJ, NAGA_TIER2_UNIT_ID, DRAGON_TURTLE_UNIT_ID, 14 )
        call AddTownHall( RACE_NAGA_WJ, NAGA_TIER3_UNIT_ID, MYRMIDON_UNIT_ID, 13.5 )
        call AddTownHall( RACE_NAGA_WJ, NAGA_TIER4_UNIT_ID, SNAP_DRAGON_UNIT_ID, 14.5 )

        call AddSpawn( SIREN_UNIT_ID, 12, 0, RACE_NAGA_WJ )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Races.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Researches.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope Researches
    public function Init takes nothing returns nothing
        call BigGun_Init()
        call CriticalStrikes_Init()
        call DoubleHead_Init()
        call GoodWinds_Init()
        call GreaterFireball_Init()
        call ImprovedFury_Init()
        call ImprovedInspiration_Init()
        call ImprovedRaiseDead_Init()
        call MassProduction_Init()
        call RegenerativeHerbs_Init()
        call SecondaryTalent_Init()
        call SelfHealResearch_Init()
        call SparklingScales_Init()
        call UpgradeArmor_Init()
        call UpgradeAttackRate_Init()
        call UpgradeDamage_Init()
        call UpgradePower_Init()
        call UpgradeSpeed_Init()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Researches.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Sounds.j
//TESH.scrollpos=450
//TESH.alwaysfold=0
scope Sounds
    public function Init takes nothing returns nothing
        local SoundType d

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //  Abilities
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
        
        globals
            integer ACID_STRIKE_SOUND_TYPE = 'S000'
        endglobals

        set d = InitSoundTypeEx(ACID_STRIKE_SOUND_TYPE, "Abilities\\Spells\\NightElf\\shadowstrike\\ShadowStrikeBirth1.wav")
        set ACID_STRIKE_SOUND_TYPE = d
        set d.duration = 2194
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BOND_OF_SOULS_SOUND_TYPE = 'S001'
        endglobals

        set d = InitSoundTypeEx(BOND_OF_SOULS_SOUND_TYPE, "Abilities\\Spells\\Human\\AerialShackles\\MagicLariatLoop1.wav")
        set BOND_OF_SOULS_SOUND_TYPE = d
        set d.duration = 3230
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer CASH_DISCOUNT_SOUND_TYPE = 'S002'
        endglobals

        set d = InitSoundTypeEx(CASH_DISCOUNT_SOUND_TYPE, "Sound\\Dialogue\\OrcCampaign\\Orc04\\O04Goblin19.mp3")
        set CASH_DISCOUNT_SOUND_TYPE = d
        set d.duration = 9822
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 0

        globals
            integer COOLDOWN_SOUND_TYPE = 'S003'
        endglobals

        set d = InitSoundTypeEx(COOLDOWN_SOUND_TYPE, "Abilities\\Spells\\Items\\SpellShieldAmulet\\SpellShieldImpact1.wav" )
        set COOLDOWN_SOUND_TYPE = d
        set d.duration = 476
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer DOWNGRADE_SOUND_TYPE = 'S004'
        endglobals

        set d = InitSoundTypeEx(DOWNGRADE_SOUND_TYPE, "Sound\\Buildings\\Shared\\BuildingPlacement.wav" )
        set DOWNGRADE_SOUND_TYPE = d
        set d.duration = 1283
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer ELIXIR_OF_THE_GROWTH_SOUND_TYPE = 'S005'
        endglobals

        set d = InitSoundTypeEx(ELIXIR_OF_THE_GROWTH_SOUND_TYPE, "Abilities\\Spells\\NightElf\\Rejuvenation\\RejuvenationTarget1.wav" )
        set ELIXIR_OF_THE_GROWTH_SOUND_TYPE = d
        set d.duration = 1335
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 0.8
        set d.volume = 127

        globals
            integer ENCHANT_SOUND_TYPE = 'S006'
        endglobals

        set d = InitSoundTypeEx(ENCHANT_SOUND_TYPE, "Abilities\\Spells\\Undead\\AntiMagicShell\\AntiMagicShellBirth1.wav" )
        set ENCHANT_SOUND_TYPE = d
        set d.duration = 1301
        set d.eax = "DefaultEAXON"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FAUST_LAUGH_SOUND_TYPE = 'S007'
        endglobals

        set d = InitSoundTypeEx(FAUST_LAUGH_SOUND_TYPE, "Sound\\Ambient\\DoodadEffects\\SargerasLaugh.wav" )
        set FAUST_LAUGH_SOUND_TYPE = d
        set d.duration = 3326
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FIERY_BOOTS_FIRE_SOUND_TYPE = 'S008'
        endglobals

        set d = InitSoundTypeEx(FIERY_BOOTS_FIRE_SOUND_TYPE, "Abilities\\Spells\\Orc\\LiquidFire\\TrollBatriderLiquidFire1.wav" )
        set FIERY_BOOTS_FIRE_SOUND_TYPE = d
        set d.duration = 1724
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 1
        set d.stop = true
        set d.volume = 70

        globals
            integer FIREBALL_IMPACT_SOUND_TYPE = 'Sfi0'
        endglobals

        set d = InitSoundTypeEx(FIREBALL_IMPACT_SOUND_TYPE, "Abilities\\Weapons\\FireBallMissile\\FireBallMissileDeath.wav" )
        set FIREBALL_IMPACT_SOUND_TYPE = d
        set d.duration = 1477
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 1
        set d.stop = true
        set d.volume = 127

        globals
            integer FIREBALL_LAUNCH_SOUND_TYPE = 'Sfl0'
        endglobals

        set d = InitSoundTypeEx(FIREBALL_LAUNCH_SOUND_TYPE, "Abilities\\Weapons\\FireBallMissile\\FireBallMissileLaunch1.wav" )
        set FIREBALL_LAUNCH_SOUND_TYPE = d
        set d.duration = 652
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 1
        set d.stop = true
        set d.volume = 127

        globals
            integer FIREBALL_LAUNCH2_SOUND_TYPE = 'Sfl1'
        endglobals

        set d = InitSoundTypeEx(FIREBALL_LAUNCH2_SOUND_TYPE, "Abilities\\Weapons\\FireBallMissile\\FireBallMissileLaunch2.wav" )
        set FIREBALL_LAUNCH2_SOUND_TYPE = d
        set d.duration = 605
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 1
        set d.stop = true
        set d.volume = 127

        globals
            integer FIREBALL_LAUNCH3_SOUND_TYPE = 'Sfl2'
        endglobals

        set d = InitSoundTypeEx(FIREBALL_LAUNCH3_SOUND_TYPE, "Abilities\\Weapons\\FireBallMissile\\FireBallMissileLaunch3.wav" )
        set FIREBALL_LAUNCH3_SOUND_TYPE = d
        set d.duration = 796
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 1
        set d.stop = true
        set d.volume = 127

        globals
            integer FLYING_SHEEP_SOUND_TYPE = 'S02U'
        endglobals

        set d = InitSoundTypeEx(FLYING_SHEEP_SOUND_TYPE, "Units\\Critters\\Sheep\\Sheep2.wav" )
        set FLYING_SHEEP_SOUND_TYPE = d
        set d.duration = 1300
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.stop = true
        set d.volume = 127

        globals
            integer FRENZY_SOUND_TYPE = 'S009'
        endglobals

        set d = InitSoundTypeEx(FRENZY_SOUND_TYPE, "Abilities\\Spells\\Orc\\Bloodlust\\BloodlustTarget.wav" )
        set FRENZY_SOUND_TYPE = d
        set d.duration = 2583
        set d.eax = "DefaultEAXON"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FURY_SOUND_TYPE = 'S00A'
        endglobals

        set d = InitSoundTypeEx(FURY_SOUND_TYPE, "Abilities\\Spells\\Orc\\Bloodlust\\BloodlustTarget.wav" )
        set FURY_SOUND_TYPE = d
        set d.duration = 2583
        set d.eax = "DefaultEAXON"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer HARMAGEDON_WARNING_SOUND_TYPE = 'S00B'
        endglobals

        set d = InitSoundTypeEx(HARMAGEDON_WARNING_SOUND_TYPE, "Sound\\Interface\\CreepAggroWhat1.wav" )
        set HARMAGEDON_WARNING_SOUND_TYPE = d
        set d.duration = 1236
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer HEALING_WARD_SOUND_TYPE = 'Shlw'
        endglobals

        set d = InitSoundTypeEx(HEALING_WARD_SOUND_TYPE, "Units\\Orc\\HealingWard\\PlaceAncestralGuardian.wav" )
        set HEALING_WARD_SOUND_TYPE = d
        set d.duration = 3063
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer HINDRANCE_OF_LEARNING_SOUND_TYPE = 'S00C'
        endglobals

        set d = InitSoundTypeEx(HINDRANCE_OF_LEARNING_SOUND_TYPE, "Units\\Creeps\\Ogre\\OgrePissed4.wav" )
        set HINDRANCE_OF_LEARNING_SOUND_TYPE = d
        set d.duration = 3534
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer KIDNEY_SHOT_SOUND_TYPE = 'S02F'
        endglobals

        set d = InitSoundTypeEx(KIDNEY_SHOT_SOUND_TYPE, "Sound\\Units\\Combat\\MetalHeavyBashMetal2.wav" )
        set KIDNEY_SHOT_SOUND_TYPE = d
        set d.duration = 1248
        set d.eax = "DefaultEAXON"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer KITTY_JUMP_SLICE_SOUND_TYPE = 'S00M'
        endglobals

        set d = InitSoundTypeEx(KITTY_JUMP_SLICE_SOUND_TYPE, "Sound\\Units\\Combat\\MetalHeavySliceFlesh1.wav" )
        set KITTY_JUMP_SLICE_SOUND_TYPE = d
        set d.duration = 1104
        set d.eax = "CombatSoundsEAX"
        set d.is3D = true
        set d.pitch = 0.75
        set d.volume = 90

        globals
            integer KITTY_JUMP_START_SOUND_TYPE = 'S00N'
        endglobals

        set d = InitSoundTypeEx(KITTY_JUMP_START_SOUND_TYPE, "Sound\\Units\\Footsteps\\step.wav" )
        set KITTY_JUMP_START_SOUND_TYPE = d
        set d.duration = 540
        set d.eax = "DefaultEAXON"
        set d.is3D = true
        set d.pitch = 0.6
        set d.volume = 100

        globals
            integer KITTY_JUMP_ENDING_SOUND_TYPE = 'S00O'
        endglobals

        set d = InitSoundTypeEx(KITTY_JUMP_ENDING_SOUND_TYPE, "Abilities\\Weapons\\FireBallMissile\\FireBallMissileLaunch1.wav" )
        set KITTY_JUMP_ENDING_SOUND_TYPE = d
        set d.duration = 652
        set d.eax = "MissilesEAX"
        set d.is3D = true
        set d.pitch = 0.8
        set d.volume = 100

        globals
            integer KITTY_JUMP_ENDING2_SOUND_TYPE = 'S00P'
        endglobals

        set d = InitSoundTypeEx(KITTY_JUMP_ENDING2_SOUND_TYPE, "Abilities\\Weapons\\LavaSpawnMissile\\LavaSpawnMissileDeath1.wav" )
        set KITTY_JUMP_ENDING2_SOUND_TYPE = d
        set d.duration = 438
        set d.eax = "CombatSoundsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer LIFE_DRAIN_LOOP_SOUND_TYPE = 'S00D'
        endglobals

        set d = InitSoundTypeEx(LIFE_DRAIN_LOOP_SOUND_TYPE, "Abilities\\Spells\\Other\\Drain\\LifeDrain.wav" )
        set LIFE_DRAIN_LOOP_SOUND_TYPE = d
        set d.duration = 2490
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer LIGHTNING_ATTACK_SOUND_TYPE = 'S00E'
        endglobals

        set d = InitSoundTypeEx(LIGHTNING_ATTACK_SOUND_TYPE, "Abilities\\Spells\\Orc\\LightningBolt\\LightningBolt.wav" )
        set LIGHTNING_ATTACK_SOUND_TYPE = d
        set d.duration = 2136
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer LIGHT_OF_PURGE_LOOP_SOUND_TYPE = 'S00F'
        endglobals

        set d = InitSoundTypeEx(LIGHT_OF_PURGE_LOOP_SOUND_TYPE, "Abilities\\Spells\\Other\\Drain\\SiphonManaLoop.wav" )
        set LIGHT_OF_PURGE_LOOP_SOUND_TYPE = d
        set d.duration = 1588
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MAGICAL_LARIAT_SOUND_TYPE = 'Smla'
        endglobals

        set d = InitSoundTypeEx(MAGICAL_LARIAT_SOUND_TYPE, "Abilities\\Spells\\Human\\AerialShackles\\MagicLariatLoop1.wav")
        set MAGICAL_LARIAT_SOUND_TYPE = d
        set d.duration = 3230
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer PEQ_WARCRY_SOUND_TYPE = 'S00G'
        endglobals

        set d = InitSoundTypeEx(PEQ_WARCRY_SOUND_TYPE, "Sound\\Dialogue\\HumanExpCamp\\Human06x\\BUTCHER.WAV" )
        set PEQ_WARCRY_SOUND_TYPE = d
        set d.duration = 3030
        set d.eax = "DefaultEAXON"
        set d.pitch = 1.1
        set d.volume = 127

        globals
            integer POISON_FOUNTAIN_LOOP_SOUND_TYPE = 'S00H'
        endglobals

        set d = InitSoundTypeEx(POISON_FOUNTAIN_LOOP_SOUND_TYPE, "Abilities\\Spells\\Undead\\DeathandDecay\\DeathAndDecayLoop1.wav" )
        set POISON_FOUNTAIN_LOOP_SOUND_TYPE = d
        set d.duration = 4004
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.looping = true
        set d.pitch = 2
        set d.volume = 127

        globals
            integer POTION_OF_THE_INCONSPICUOUS_SHAPE_SOUND_TYPE = 'S00I'
        endglobals

        set d = InitSoundTypeEx(POTION_OF_THE_INCONSPICUOUS_SHAPE_SOUND_TYPE, "Abilities\\Spells\\Human\\Banish\\BanishCaster.wav" )
        set POTION_OF_THE_INCONSPICUOUS_SHAPE_SOUND_TYPE = d
        set d.duration = 2415
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 2
        set d.volume = 127

        globals
            integer STABILITY_SOUND_TYPE = 'S00J'
        endglobals

        set d = InitSoundTypeEx(STABILITY_SOUND_TYPE, "Abilities\\Spells\\Human\\Invisibility\\InvisibilityTarget.wav" )
        set STABILITY_SOUND_TYPE = d
        set d.duration = 2043
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer SPELL_DISCONNECTION_IMPACT_SOUND_TYPE = 'S00K'
        endglobals

        set d = InitSoundTypeEx(SPELL_DISCONNECTION_IMPACT_SOUND_TYPE, "Abilities\\Weapons\\DemonHunterMissile\\DemonHunterMissileHit1.wav" )
        set SPELL_DISCONNECTION_IMPACT_SOUND_TYPE = d
        set d.duration = 775
        set d.eax = "MissilesEAX"
        set d.is3D = true
        set d.pitch = 0.8
        set d.volume = 115

        globals
            integer SPELL_DISCONNECTION_LAUNCH_SOUND_TYPE = 'S00L'
        endglobals

        set d = InitSoundTypeEx(SPELL_DISCONNECTION_LAUNCH_SOUND_TYPE, "Abilities\\Weapons\\DemonHunterMissile\\HeroDemonMissileLaunch2.wav" )
        set SPELL_DISCONNECTION_LAUNCH_SOUND_TYPE = d
        set d.duration = 1219
        set d.eax = "MissilesEAX"
        set d.is3D = true
        set d.pitch = 0.7
        set d.volume = 100

        globals
            integer TRIDENT_SOUND_TYPE = 'Str0'
        endglobals

        set d = InitSoundTypeEx(TRIDENT_SOUND_TYPE, "Abilities\\Weapons\\CannonTowerMissile\\CannonTowerMissileLaunch1.wav" )
        set TRIDENT_SOUND_TYPE = d
        set d.duration = 1088
        set d.eax = "DefaultEAXOn"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer TRIDENT_SOUND1_TYPE = 'Str1'
        endglobals

        set d = InitSoundTypeEx(TRIDENT_SOUND1_TYPE, "Abilities\\Weapons\\CannonTowerMissile\\CannonTowerMissileLaunch2.wav" )
        set TRIDENT_SOUND1_TYPE = d
        set d.duration = 1219
        set d.eax = "DefaultEAXOn"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer TRIDENT_SOUND2_TYPE = 'Str2'
        endglobals

        set d = InitSoundTypeEx(TRIDENT_SOUND2_TYPE, "Abilities\\Weapons\\CannonTowerMissile\\CannonTowerMissileLaunch3.wav" )
        set TRIDENT_SOUND2_TYPE = d
        set d.duration = 1088
        set d.eax = "DefaultEAXOn"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer WHIP_LASH_SOUND_TYPE = 'S00Q'
        endglobals

        set d = InitSoundTypeEx(WHIP_LASH_SOUND_TYPE, "WhipLash.wav" )
        set WHIP_LASH_SOUND_TYPE = d
        set d.duration = 800
        set d.eax = "DefaultEAXON"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer REQUEST_REINFORCEMENTS_LAUNCH_SOUND_TYPE = 'Srri'
        endglobals

        set d = InitSoundTypeEx(REQUEST_REINFORCEMENTS_LAUNCH_SOUND_TYPE, "Units\\Creeps\\GoblinZeppelin\\GoblinZeppelinYes2.wav" )
        set REQUEST_REINFORCEMENTS_LAUNCH_SOUND_TYPE = d
        set d.duration = 2519
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer RUST_SOUND_TYPE = 'S00S'
        endglobals

        set d = InitSoundTypeEx(RUST_SOUND_TYPE, "" )
        set RUST_SOUND_TYPE = d
        set d.duration = 996
        set d.eax = "MissilesEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //  Units
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        globals
            integer BERSERK_PISSED_SOUND_TYPE = 'S00T'
        endglobals

        set d = InitSoundTypeEx(BERSERK_PISSED_SOUND_TYPE, "Units\\Orc\\Hellscream\\GromPissed1.wav" )
        set BERSERK_PISSED_SOUND_TYPE = d
        set d.duration = 2043
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BERSERK_PISSED2_SOUND_TYPE = 'S00U'
        endglobals

        set d = InitSoundTypeEx(BERSERK_PISSED2_SOUND_TYPE, "Units\\Orc\\Hellscream\\GromPissed2.wav" )
        set BERSERK_PISSED2_SOUND_TYPE = d
        set d.duration = 1735
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BERSERK_PISSED3_SOUND_TYPE = 'S00V'
        endglobals

        set d = InitSoundTypeEx(BERSERK_PISSED3_SOUND_TYPE, "Units\\Orc\\Hellscream\\GromPissed3.wav" )
        set BERSERK_PISSED3_SOUND_TYPE = d
        set d.duration = 3136
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BOTANIST_PISSED_SOUND_TYPE = 'S00W'
        endglobals

        set d = InitSoundTypeEx(BOTANIST_PISSED_SOUND_TYPE, "Units\\NightElf\\HeroKeeperOfTheGrove\\KeeperOfTheGrovePissed1.wav" )
        set BOTANIST_PISSED_SOUND_TYPE = d
        set d.duration = 3813
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BOTANIST_PISSED2_SOUND_TYPE = 'S00X'
        endglobals

        set d = InitSoundTypeEx(BOTANIST_PISSED2_SOUND_TYPE, "Units\\NightElf\\HeroKeeperOfTheGrove\\KeeperOfTheGrovePissed2.wav" )
        set BOTANIST_PISSED2_SOUND_TYPE = d
        set d.duration = 2705
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BOTANIST_PISSED3_SOUND_TYPE = 'S00Y'
        endglobals

        set d = InitSoundTypeEx(BOTANIST_PISSED3_SOUND_TYPE, "Units\\NightElf\\HeroKeeperOfTheGrove\\KeeperOfTheGrovePissed3.wav" )
        set BOTANIST_PISSED3_SOUND_TYPE = d
        set d.duration = 2952
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BOTANIST_PISSED4_SOUND_TYPE = 'S00Z'
        endglobals

        set d = InitSoundTypeEx(BOTANIST_PISSED4_SOUND_TYPE, "Units\\NightElf\\HeroKeeperOfTheGrove\\KeeperOfTheGrovePissed4.wav" )
        set BOTANIST_PISSED4_SOUND_TYPE = d
        set d.duration = 2971
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BOTANIST_PISSED5_SOUND_TYPE = 'S010'
        endglobals

        set d = InitSoundTypeEx(BOTANIST_PISSED5_SOUND_TYPE, "Units\\NightElf\\HeroKeeperOfTheGrove\\KeeperOfTheGrovePissed5.wav" )
        set BOTANIST_PISSED5_SOUND_TYPE = d
        set d.duration = 2541
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BOTANIST_PISSED6_SOUND_TYPE = 'S011'
        endglobals

        set d = InitSoundTypeEx(BOTANIST_PISSED6_SOUND_TYPE, "Units\\NightElf\\HeroKeeperOfTheGrove\\KeeperOfTheGrovePissed6.wav" )
        set BOTANIST_PISSED6_SOUND_TYPE = d
        set d.duration = 2758
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FANATICAL_MECHANIC_PISSED_SOUND_TYPE = 'S012'
        endglobals

        set d = InitSoundTypeEx(FANATICAL_MECHANIC_PISSED_SOUND_TYPE, "Units\\Creeps\\HeroTinker\\HeroTinkerPissed1.wav" )
        set FANATICAL_MECHANIC_PISSED_SOUND_TYPE = d
        set d.duration = 2265
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FANATICAL_MECHANIC_PISSED2_SOUND_TYPE = 'S013'
        endglobals

        set d = InitSoundTypeEx(FANATICAL_MECHANIC_PISSED2_SOUND_TYPE, "Units\\Creeps\\HeroTinker\\HeroTinkerPissed2.wav" )
        set FANATICAL_MECHANIC_PISSED2_SOUND_TYPE = d
        set d.duration = 2242
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FANATICAL_MECHANIC_PISSED3_SOUND_TYPE = 'S014'
        endglobals

        set d = InitSoundTypeEx(FANATICAL_MECHANIC_PISSED3_SOUND_TYPE, "Units\\Creeps\\HeroTinker\\HeroTinkerPissed3.wav" )
        set FANATICAL_MECHANIC_PISSED3_SOUND_TYPE = d
        set d.duration = 5020
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FANATICAL_MECHANIC_PISSED4_SOUND_TYPE = 'S015'
        endglobals

        set d = InitSoundTypeEx(FANATICAL_MECHANIC_PISSED4_SOUND_TYPE, "Units\\Creeps\\HeroTinker\\HeroTinkerPissed4.wav" )
        set FANATICAL_MECHANIC_PISSED4_SOUND_TYPE = d
        set d.duration = 5690
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FANATICAL_MECHANIC_PISSED5_SOUND_TYPE = 'S016'
        endglobals

        set d = InitSoundTypeEx(FANATICAL_MECHANIC_PISSED5_SOUND_TYPE, "Units\\Creeps\\HeroTinker\\HeroTinkerPissed5.wav" )
        set FANATICAL_MECHANIC_PISSED5_SOUND_TYPE = d
        set d.duration = 4377
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FANATICAL_MECHANIC_PISSED6_SOUND_TYPE = 'S017'
        endglobals

        set d = InitSoundTypeEx(FANATICAL_MECHANIC_PISSED6_SOUND_TYPE, "Units\\Creeps\\HeroTinker\\HeroTinkerPissed6.wav" )
        set FANATICAL_MECHANIC_PISSED6_SOUND_TYPE = d
        set d.duration = 7657
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FANATICAL_MECHANIC_PISSED7_SOUND_TYPE = 'S018'
        endglobals

        set d = InitSoundTypeEx(FANATICAL_MECHANIC_PISSED7_SOUND_TYPE, "Units\\Creeps\\HeroTinker\\HeroTinkerPissed7.wav" )
        set FANATICAL_MECHANIC_PISSED7_SOUND_TYPE = d
        set d.duration = 2316
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer FANATICAL_MECHANIC_PISSED8_SOUND_TYPE = 'S019'
        endglobals

        set d = InitSoundTypeEx(FANATICAL_MECHANIC_PISSED8_SOUND_TYPE, "Units\\Creeps\\HeroTinker\\HeroTinkerPissed8.wav" )
        set FANATICAL_MECHANIC_PISSED8_SOUND_TYPE = d
        set d.duration = 3243
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer HEADHUNTRESS_PISSED_SOUND_TYPE = 'S01A'
        endglobals

        set d = InitSoundTypeEx(HEADHUNTRESS_PISSED_SOUND_TYPE, "Units\\NightElf\\Tyrande\\TyrandePissed1.wav" )
        set HEADHUNTRESS_PISSED_SOUND_TYPE = d
        set d.duration = 3686
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer HEADHUNTRESS_PISSED2_SOUND_TYPE = 'S01B'
        endglobals

        set d = InitSoundTypeEx(HEADHUNTRESS_PISSED2_SOUND_TYPE, "Units\\NightElf\\Tyrande\\TyrandePissed2.wav" )
        set HEADHUNTRESS_PISSED2_SOUND_TYPE = d
        set d.duration = 4359
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer HEADHUNTRESS_PISSED3_SOUND_TYPE = 'S01C'
        endglobals

        set d = InitSoundTypeEx(HEADHUNTRESS_PISSED3_SOUND_TYPE, "Units\\NightElf\\Tyrande\\TyrandePissed3.wav" )
        set HEADHUNTRESS_PISSED3_SOUND_TYPE = d
        set d.duration = 2640
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer HEADHUNTRESS_PISSED4_SOUND_TYPE = 'S01D'
        endglobals

        set d = InitSoundTypeEx(HEADHUNTRESS_PISSED4_SOUND_TYPE, "Units\\NightElf\\Tyrande\\TyrandePissed4.wav" )
        set HEADHUNTRESS_PISSED4_SOUND_TYPE = d
        set d.duration = 2099
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer HEADHUNTRESS_PISSED5_SOUND_TYPE = 'S01E'
        endglobals

        set d = InitSoundTypeEx(HEADHUNTRESS_PISSED5_SOUND_TYPE, "Units\\NightElf\\Tyrande\\TyrandePissed5.wav" )
        set HEADHUNTRESS_PISSED5_SOUND_TYPE = d
        set d.duration = 4672
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer LICH_PISSED_SOUND_TYPE = 'S01F'
        endglobals

        set d = InitSoundTypeEx(LICH_PISSED_SOUND_TYPE, "Units\\Undead\\KelThuzadLich\\KelThuzadPissed1.wav" )
        set LICH_PISSED_SOUND_TYPE = d
        set d.duration = 4127
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 63

        globals
            integer LICH_PISSED2_SOUND_TYPE = 'S01G'
        endglobals

        set d = InitSoundTypeEx(LICH_PISSED2_SOUND_TYPE, "Units\\Undead\\KelThuzadLich\\KelThuzadPissed2.wav" )
        set LICH_PISSED2_SOUND_TYPE = d
        set d.duration = 5712
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer LICH_PISSED3_SOUND_TYPE = 'S01H'
        endglobals

        set d = InitSoundTypeEx(LICH_PISSED3_SOUND_TYPE, "Units\\Undead\\KelThuzadLich\\KelThuzadPissed3.wav" )
        set LICH_PISSED3_SOUND_TYPE = d
        set d.duration = 2494
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer LICH_PISSED4_SOUND_TYPE = 'S01I'
        endglobals

        set d = InitSoundTypeEx(LICH_PISSED4_SOUND_TYPE, "Units\\Undead\\KelThuzadLich\\KelThuzadPissed4.wav" )
        set LICH_PISSED4_SOUND_TYPE = d
        set d.duration = 4809
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer LICH_PISSED5_SOUND_TYPE = 'S01J'
        endglobals

        set d = InitSoundTypeEx(LICH_PISSED5_SOUND_TYPE, "Units\\Undead\\KelThuzadLich\\KelThuzadPissed5.wav" )
        set LICH_PISSED5_SOUND_TYPE = d
        set d.duration = 6504
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MEDICINE_MAN_PISSED_SOUND_TYPE = 'S01K'
        endglobals

        set d = InitSoundTypeEx(MEDICINE_MAN_PISSED_SOUND_TYPE, "Units\\Orc\\Thrall\\ThrallPissed1.wav" )
        set MEDICINE_MAN_PISSED_SOUND_TYPE = d
        set d.duration = 1607
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MEDICINE_MAN_PISSED2_SOUND_TYPE = 'S01L'
        endglobals

        set d = InitSoundTypeEx(MEDICINE_MAN_PISSED2_SOUND_TYPE, "Units\\Orc\\Thrall\\ThrallPissed2.wav" )
        set MEDICINE_MAN_PISSED2_SOUND_TYPE = d
        set d.duration = 2786
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MEDICINE_MAN_PISSED3_SOUND_TYPE = 'S01M'
        endglobals

        set d = InitSoundTypeEx(MEDICINE_MAN_PISSED3_SOUND_TYPE, "Units\\Orc\\Thrall\\ThrallPissed3.wav" )
        set MEDICINE_MAN_PISSED3_SOUND_TYPE = d
        set d.duration = 1983
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MEDICINE_MAN_PISSED4_SOUND_TYPE = 'S01N'
        endglobals

        set d = InitSoundTypeEx(MEDICINE_MAN_PISSED4_SOUND_TYPE, "Units\\Orc\\Thrall\\ThrallPissed4.wav" )
        set MEDICINE_MAN_PISSED4_SOUND_TYPE = d
        set d.duration = 3493
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BLACK_KNIGHT_PISSED_SOUND_TYPE = 'S01O'
        endglobals

        set d = InitSoundTypeEx(BLACK_KNIGHT_PISSED_SOUND_TYPE, "Units\\Undead\\HeroDeathKnight\\DeathKnightPissed1.wav" )
        set BLACK_KNIGHT_PISSED_SOUND_TYPE = d
        set d.duration = 3089
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BLACK_KNIGHT_PISSED2_SOUND_TYPE = 'S01P'
        endglobals

        set d = InitSoundTypeEx(BLACK_KNIGHT_PISSED2_SOUND_TYPE, "Units\\Undead\\HeroDeathKnight\\DeathKnightPissed2.wav" )
        set BLACK_KNIGHT_PISSED2_SOUND_TYPE = d
        set d.duration = 2999
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BLACK_KNIGHT_PISSED3_SOUND_TYPE = 'S01Q'
        endglobals

        set d = InitSoundTypeEx(BLACK_KNIGHT_PISSED3_SOUND_TYPE, "Units\\Undead\\HeroDeathKnight\\DeathKnightPissed3.wav" )
        set BLACK_KNIGHT_PISSED3_SOUND_TYPE = d
        set d.duration = 3989
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BLACK_KNIGHT_PISSED4_SOUND_TYPE = 'S01R'
        endglobals

        set d = InitSoundTypeEx(BLACK_KNIGHT_PISSED4_SOUND_TYPE, "Units\\Undead\\HeroDeathKnight\\DeathKnightPissed4.wav" )
        set BLACK_KNIGHT_PISSED4_SOUND_TYPE = d
        set d.duration = 4350
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BLACK_KNIGHT_PISSED5_SOUND_TYPE = 'S01S'
        endglobals

        set d = InitSoundTypeEx(BLACK_KNIGHT_PISSED5_SOUND_TYPE, "Units\\Undead\\HeroDeathKnight\\DeathKnightPissed5.wav" )
        set BLACK_KNIGHT_PISSED5_SOUND_TYPE = d
        set d.duration = 2129
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer BLACK_KNIGHT_PISSED6_SOUND_TYPE = 'S01T'
        endglobals

        set d = InitSoundTypeEx(BLACK_KNIGHT_PISSED6_SOUND_TYPE, "Units\\Undead\\HeroDeathKnight\\DeathKnightPissed6.wav" )
        set BLACK_KNIGHT_PISSED6_SOUND_TYPE = d
        set d.duration = 4079
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer PALADIN_PISSED_SOUND_TYPE = 'S01U'
        endglobals

        set d = InitSoundTypeEx(PALADIN_PISSED_SOUND_TYPE, "Units\\Human\\Arthas\\ArthasPissed1.wav" )
        set PALADIN_PISSED_SOUND_TYPE = d
        set d.duration = 1698
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer PALADIN_PISSED2_SOUND_TYPE = 'S01V'
        endglobals

        set d = InitSoundTypeEx(PALADIN_PISSED2_SOUND_TYPE, "Units\\Human\\Arthas\\ArthasPissed2.wav" )
        set PALADIN_PISSED2_SOUND_TYPE = d
        set d.duration = 2609
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer PALADIN_PISSED3_SOUND_TYPE = 'S01W'
        endglobals

        set d = InitSoundTypeEx(PALADIN_PISSED3_SOUND_TYPE, "Units\\Human\\Arthas\\ArthasPissed3.wav" )
        set PALADIN_PISSED3_SOUND_TYPE = d
        set d.duration = 2043
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer PALADIN_PISSED4_SOUND_TYPE = 'S01X'
        endglobals

        set d = InitSoundTypeEx(PALADIN_PISSED4_SOUND_TYPE, "Units\\Human\\Arthas\\ArthasPissed4.wav" )
        set PALADIN_PISSED4_SOUND_TYPE = d
        set d.duration = 1994
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer PALADIN_PISSED5_SOUND_TYPE = 'S01Y'
        endglobals

        set d = InitSoundTypeEx(PALADIN_PISSED5_SOUND_TYPE, "Units\\Human\\Arthas\\ArthasPissed5.wav" )
        set PALADIN_PISSED5_SOUND_TYPE = d
        set d.duration = 1558
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer PALADIN_PISSED6_SOUND_TYPE = 'S01Z'
        endglobals

        set d = InitSoundTypeEx(PALADIN_PISSED6_SOUND_TYPE, "Units\\Human\\Arthas\\ArthasPissed6.wav" )
        set PALADIN_PISSED6_SOUND_TYPE = d
        set d.duration = 1082
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer PALADIN_PISSED7_SOUND_TYPE = 'S020'
        endglobals

        set d = InitSoundTypeEx(PALADIN_PISSED7_SOUND_TYPE, "Units\\Human\\Arthas\\ArthasPissed7.wav" )
        set PALADIN_PISSED7_SOUND_TYPE = d
        set d.duration = 2030
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer TRAVELLING_TRADER_PISSED_SOUND_TYPE = 'S021'
        endglobals

        set d = InitSoundTypeEx(TRAVELLING_TRADER_PISSED_SOUND_TYPE, "Units\\Creeps\\HEROGoblinALCHEMIST\\HeroAlchemistPissed1.wav" )
        set TRAVELLING_TRADER_PISSED_SOUND_TYPE = d
        set d.duration = 2642
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer TRAVELLING_TRADER_PISSED2_SOUND_TYPE = 'S022'
        endglobals

        set d = InitSoundTypeEx(TRAVELLING_TRADER_PISSED2_SOUND_TYPE, "Units\\Creeps\\HEROGoblinALCHEMIST\\HeroAlchemistPissed2.wav" )
        set TRAVELLING_TRADER_PISSED2_SOUND_TYPE = d
        set d.duration = 1736
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer TRAVELLING_TRADER_PISSED3_SOUND_TYPE = 'S023'
        endglobals

        set d = InitSoundTypeEx(TRAVELLING_TRADER_PISSED3_SOUND_TYPE, "Units\\Creeps\\HEROGoblinALCHEMIST\\HeroAlchemistPissed3.wav" )
        set TRAVELLING_TRADER_PISSED3_SOUND_TYPE = d
        set d.duration = 3541
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer TRAVELLING_TRADER_PISSED4_SOUND_TYPE = 'S024'
        endglobals

        set d = InitSoundTypeEx(TRAVELLING_TRADER_PISSED4_SOUND_TYPE, "Units\\Creeps\\HEROGoblinALCHEMIST\\HeroAlchemistPissed4.wav" )
        set TRAVELLING_TRADER_PISSED4_SOUND_TYPE = d
        set d.duration = 3608
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer TRAVELLING_TRADER_PISSED5_SOUND_TYPE = 'S025'
        endglobals

        set d = InitSoundTypeEx(TRAVELLING_TRADER_PISSED5_SOUND_TYPE, "Units\\Creeps\\HEROGoblinALCHEMIST\\HeroAlchemistPissed5.wav" )
        set TRAVELLING_TRADER_PISSED5_SOUND_TYPE = d
        set d.duration = 3700
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer TRAVELLING_TRADER_PISSED6_SOUND_TYPE = 'S026'
        endglobals

        set d = InitSoundTypeEx(TRAVELLING_TRADER_PISSED6_SOUND_TYPE, "Units\\Creeps\\HEROGoblinALCHEMIST\\HeroAlchemistPissed6.wav" )
        set TRAVELLING_TRADER_PISSED6_SOUND_TYPE = d
        set d.duration = 10879
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer WITCH_PISSED_SOUND_TYPE = 'S027'
        endglobals

        set d = InitSoundTypeEx(WITCH_PISSED_SOUND_TYPE, "Units\\Human\\Jaina\\JainaPissed1.wav" )
        set WITCH_PISSED_SOUND_TYPE = d
        set d.duration = 1377
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer WITCH_PISSED2_SOUND_TYPE = 'S028'
        endglobals

        set d = InitSoundTypeEx(WITCH_PISSED2_SOUND_TYPE, "Units\\Human\\Jaina\\JainaPissed2.wav" )
        set WITCH_PISSED2_SOUND_TYPE = d
        set d.duration = 1244
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer WITCH_PISSED3_SOUND_TYPE = 'S029'
        endglobals

        set d = InitSoundTypeEx(WITCH_PISSED3_SOUND_TYPE, "Units\\Human\\Jaina\\JainaPissed3.wav" )
        set WITCH_PISSED3_SOUND_TYPE = d
        set d.duration = 2365
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer WITCH_PISSED4_SOUND_TYPE = 'S02A'
        endglobals

        set d = InitSoundTypeEx(WITCH_PISSED4_SOUND_TYPE, "Units\\Human\\Jaina\\JainaPissed4.wav" )
        set WITCH_PISSED4_SOUND_TYPE = d
        set d.duration = 1950
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer WITCH_PISSED5_SOUND_TYPE = 'S02B'
        endglobals

        set d = InitSoundTypeEx(WITCH_PISSED5_SOUND_TYPE, "Units\\Human\\Jaina\\JainaPissed5.wav" )
        set WITCH_PISSED5_SOUND_TYPE = d
        set d.duration = 1623
        set d.eax = "HeroAcksEAX"
        set d.pitch = 1
        set d.volume = 127

        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////
        //  Misc
        ///////////////////////////////////////////////////////////////////////////////////////////////////////////////

        globals
            integer ERROR_SOUND_TYPE = 'S02C'
        endglobals

        set d = InitSoundTypeEx(ERROR_SOUND_TYPE, "Sound\\Interface\\Error.wav" )
        set ERROR_SOUND_TYPE = d
        set d.duration = 2043
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer LIGHTNING_IMPACT_SOUND_TYPE = 'S02D'
        endglobals

        set d = InitSoundTypeEx(LIGHTNING_IMPACT_SOUND_TYPE, "Abilities\\Spells\\Other\\StormEarthFire\\PandarenUltimate.wav" )
        set LIGHTNING_IMPACT_SOUND_TYPE = d
        set d.duration = 3251
        set d.eax = "DefaultEAXON"
        set d.is3D = true
        set d.pitch = 0.4
        set d.volume = 127

        globals
            integer HINT_SOUND_TYPE = 'S02E'
        endglobals

        set d = InitSoundTypeEx(HINT_SOUND_TYPE, "Sound\\Interface\\Hint.wav" )
        set HINT_SOUND_TYPE = d
        set d.duration = 2006
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MIST_SOUND_TYPE = 'S02G'
        endglobals

        set d = InitSoundTypeEx(MIST_SOUND_TYPE, "Sound\\Ambient\\Ashenvale\\FreakyForest1.wav" )
        set MIST_SOUND_TYPE = d
        set d.duration = 3135
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MIST2_SOUND_TYPE = 'S02H'
        endglobals

        set d = InitSoundTypeEx(MIST2_SOUND_TYPE, "Sound\\Ambient\\Ashenvale\\FreakyForest2.wav" )
        set MIST2_SOUND_TYPE = d
        set d.duration = 3901
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MIST3_SOUND_TYPE = 'S02I'
        endglobals

        set d = InitSoundTypeEx(MIST3_SOUND_TYPE, "Sound\\Ambient\\Ashenvale\\FreakyForest3.wav" )
        set MIST3_SOUND_TYPE = d
        set d.duration = 4830
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MIST4_SOUND_TYPE = 'S02J'
        endglobals

        set d = InitSoundTypeEx(MIST4_SOUND_TYPE, "Sound\\Ambient\\Ashenvale\\FreakyForest4.wav" )
        set MIST4_SOUND_TYPE = d
        set d.duration = 5248
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MIST5_SOUND_TYPE = 'S02K'
        endglobals

        set d = InitSoundTypeEx(MIST5_SOUND_TYPE, "Units\\NightElf\\Wisp\\WispPissed1.wav" )
        set MIST5_SOUND_TYPE = d
        set d.duration = 2798
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MIST6_SOUND_TYPE = 'S02L'
        endglobals

        set d = InitSoundTypeEx(MIST6_SOUND_TYPE, "Units\\NightElf\\Wisp\\WispPissed2.wav" )
        set MIST6_SOUND_TYPE = d
        set d.duration = 2786
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer MIST7_SOUND_TYPE = 'S02M'
        endglobals

        set d = InitSoundTypeEx(MIST7_SOUND_TYPE, "Units\\NightElf\\Wisp\\WispPissed3.wav" )
        set MIST7_SOUND_TYPE = d
        set d.duration = 2682
        set d.eax = "DefaultEAXON"
        set d.pitch = 1
        set d.volume = 127

        globals
            integer RAIN_SOUND_TYPE = 'S02N'
        endglobals

        set d = InitSoundTypeEx(RAIN_SOUND_TYPE, "Sound\\Ambient\\RainAmbience.wav" )
        set RAIN_SOUND_TYPE = d
        set d.duration = 4418
        set d.eax = "DefaultEAXON"
        set d.looping = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer RECEIVE_GOLD_SOUND_TYPE = 'S02O'
        endglobals

        set d = InitSoundTypeEx(RECEIVE_GOLD_SOUND_TYPE, "Abilities\\Spells\\Items\\ResourceItems\\ReceiveGold.wav" )
        set RECEIVE_GOLD_SOUND_TYPE = d
        set d.duration = 589
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer REFRESH_SOUND_TYPE = 'S02P'
        endglobals

        set d = InitSoundTypeEx(REFRESH_SOUND_TYPE, "Abilities\\Spells\\Items\\AIre\\RestorationPotion.wav" )
        set REFRESH_SOUND_TYPE = d
        set d.duration = 3158
        set d.eax = "DefaultEAXON"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer REFRESH_MANA_SOUND_TYPE = 'S02Q'
        endglobals

        set d = InitSoundTypeEx(REFRESH_MANA_SOUND_TYPE, "Abilities\\Spells\\Items\\AIma\\ManaPotion.wav" )
        set REFRESH_MANA_SOUND_TYPE = d
        set d.duration = 1555
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer SNOW_GHOST_MANA_DRAIN_SOUND_TYPE = 'S02R'
        endglobals

        set d = InitSoundTypeEx(SNOW_GHOST_MANA_DRAIN_SOUND_TYPE, "Abilities\\Spells\\NightElf\\ManaBurn\\ManaDrainTarget1.wav" )
        set SNOW_GHOST_MANA_DRAIN_SOUND_TYPE = d
        set d.duration = 1357
        set d.eax = "SpellsEAX"
        set d.is3D = true
        set d.pitch = 1
        set d.volume = 127

        globals
            integer WATER_SOUND_TYPE = 'S02S'
        endglobals

        set d = InitSoundTypeEx(WATER_SOUND_TYPE, "Sound\\Ambient\\DoodadEffects\\WaterLakeLoop1.wav" )
        set WATER_SOUND_TYPE = d
        set d.duration = 3297
        set d.eax = "DoodadsEAX"
        set d.is3D = true
        set d.pitch = 0.65
        set d.stop = true
        set d.volume = 127

        globals
            integer WATER2_SOUND_TYPE = 'S02T'
        endglobals

        set d = InitSoundTypeEx(WATER2_SOUND_TYPE, "Sound\\Ambient\\DoodadEffects\\WaterWavesLoop1.wav" )
        set WATER2_SOUND_TYPE = d
        set d.duration = 7445
        set d.eax = "DoodadsEAX"
        set d.is3D = true
        set d.pitch = 0.65
        set d.stop = true
        set d.volume = 110
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Sounds.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Start.j
//TESH.scrollpos=914
//TESH.alwaysfold=0
scope Start
    globals
        AllianceMode ALLIANCE_MODE
        ArenaMode ARENA_MODE
        public dialog DUMMY_DIALOG
        public timer DUMMY_TIMER
        public trigger DUMMY_TRIGGER
        Unit array GOBLIN_SHOPS
        public integer array RESULTS
        public integer RESULTS_COUNT = -1
        Unit array SHREDDERS
        real array SHREDDERS_X
        real array SHREDDERS_Y
        private constant integer START_GOLD = 500
        Tileset TILESET
        Unit array WORKSHOPS
    endglobals

    private function CommandList takes nothing returns nothing
        call DestroyTimerWJ( GetExpiredTimer() )
        call DisplayTextTimedWJ( "Command list:\n\n-c: show camera dialog (-c value)\n-cs x: set camera smoothing factor to x\n-m x: change background music to x\n-hints: toggle hints on/off\n-sfx: future special effects on/off\n-system: system messages on/off\n\nFor more information see \"Information (F9)\" under \"Commands\"", 30, GetLocalPlayer() )
    endfunction

    scope PlayerGifts
        private function PlayerGifts_BaseSight takes integer period, player whichPlayer returns nothing
            //! runtextmacro RotateRectAroundCenter("BASE_RECT", "PI / 2")
            call FogModifierStart(CreateFogModifierRectWJ( whichPlayer, FOG_OF_WAR_VISIBLE, dummyRect, false, false ))
            call RemoveRectWJ(dummyRect)
            set dummyRect = null
        endfunction

        private function PlayerGifts_PoolSight_Child takes integer period, player whichPlayer returns nothing
            //! runtextmacro RotateRectAroundCenter("POOL_RECT", "PI / 2")
            call FogModifierStart(CreateFogModifierRectWJ( whichPlayer, FOG_OF_WAR_VISIBLE, dummyRect, false, false ))
            call RemoveRectWJ(dummyRect)
            set dummyRect = null
        endfunction

        private function PlayerGifts_PoolSight takes player whichPlayer returns nothing
            local integer iteration = 3
            loop
                call PlayerGifts_PoolSight_Child(iteration, whichPlayer)
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
        endfunction

        private function PlayerGifts_Trig takes nothing returns nothing
            local real angle
            local integer brickTerrainTypeId = GetTerrainTileFromSet(TILESET, Brick_INDEX)
            local real centerTowerAngle
            local real centerTower2Angle
            local integer count
            local real differenceX
            local real differenceY
            local real difference1
            local real difference2
            local integer iteration
            local integer iteration2
            local real newX
            local real newY
            local player specificPlayer
            local integer specificPlayerId
            local integer specificPlayerTeam
            set iteration = MAX_PLAYER_INDEX
            if ( ALLIANCE_MODE == ALLIANCE_MODE_FREE_FOR_ALL ) then
                loop
                    set specificPlayer = PlayerWJ( iteration )
                    call AddPlayerToAlliance( specificPlayer, GetPlayerTeam( specificPlayer ) )
                    set iteration = iteration - 1
                    exitwhen ( iteration < 0 )
                endloop
            elseif ( ALLIANCE_MODE == ALLIANCE_MODE_TOP_AGAINST_BOTTOM ) then
                loop
                    set specificPlayer = PlayerWJ( iteration )
                    set specificPlayerTeam = GetPlayerTeam( specificPlayer )
                    if ( ( specificPlayerTeam == 0 ) or ( specificPlayerTeam == 3 ) ) then
                        call AddPlayerToAlliance( specificPlayer, 0 )
                    else
                        call AddPlayerToAlliance( specificPlayer, 1 )
                    endif
                    set iteration = iteration - 1
                    exitwhen ( iteration < 0 )
                endloop
            elseif ( ALLIANCE_MODE == ALLIANCE_MODE_LEFT_AGAINST_RIGHT ) then
                loop
                    set specificPlayer = PlayerWJ( iteration )
                    set specificPlayerTeam = GetPlayerTeam( specificPlayer )
                    if ( ( specificPlayerTeam == 0 ) or ( specificPlayerTeam == 1 ) ) then
                        call AddPlayerToAlliance( specificPlayer, 0 )
                    else
                        call AddPlayerToAlliance( specificPlayer, 1 )
                    endif
                    set iteration = iteration - 1
                    exitwhen ( iteration < 0 )
                endloop
            elseif ( ALLIANCE_MODE == ALLIANCE_MODE_DIAGONAL ) then
                loop
                    set specificPlayer = PlayerWJ( iteration )
                    set specificPlayerTeam = GetPlayerTeam( specificPlayer )
                    if ( ( specificPlayerTeam == 0 ) or ( specificPlayerTeam == 2 ) ) then
                        call AddPlayerToAlliance( specificPlayer, 0 )
                    else
                        call AddPlayerToAlliance( specificPlayer, 1 )
                    endif
                    set iteration = iteration - 1
                    exitwhen ( iteration < 0 )
                endloop
            endif
            set specificPlayer = null

            set differenceX = GetRectCenterX( TOWER_RECT ) - CENTER_X
            set differenceY = GetRectCenterY( TOWER_RECT ) - CENTER_Y
            set centerTowerAngle = Atan2( differenceY, differenceX )
            set difference1 = SquareRoot( differenceX * differenceX + differenceY * differenceY )
            set differenceX = GetRectCenterX( TOWER2_RECT ) - CENTER_X
            set differenceY = GetRectCenterY( TOWER2_RECT ) - CENTER_Y
            set centerTower2Angle = Atan2( differenceY, differenceX )
            set difference2 = SquareRoot( differenceX * differenceX + differenceY * differenceY )
            set iteration = GetTeams() - 1
            loop
                set count = 0
                set iteration2 = CountTeamPlayers(iteration)
                loop
                    exitwhen ( iteration2 < 0 )
                    set specificPlayer = GetTeamPlayers(iteration, iteration2)
                    if ( IsPlayerDead( specificPlayer ) == false ) then
                        set count = count + 1
                        set specificPlayerId = GetPlayerId(specificPlayer)
                        call SetPlayerTownHall( specificPlayer, CreateUnitEx( specificPlayer, FLAG_UNIT_ID, START_POSITION_X[specificPlayerId], START_POSITION_Y[specificPlayerId], STANDARD_ANGLE ) )
                        call FogModifierStart(CreateFogModifierRectWJ( specificPlayer, FOG_OF_WAR_VISIBLE, CENTER_RECT, false, false ))
                        call PlayerGifts_BaseSight(iteration, specificPlayer)
                    endif
                    set iteration2 = iteration2 - 1
                endloop
                if ( count > 0 ) then
                    set angle = centerTowerAngle + iteration * PI / 2
                    set newX = CENTER_X + difference1 * Cos( angle )
                    set newY = CENTER_Y + difference1 * Sin( angle )
                    set specificPlayer = GetTeamPlayers(iteration, MAX_PLAYERS_PER_TEAM - 1)
                    call SetTerrainTypeEx( newX, newY, brickTerrainTypeId )
                    call SetTerrainTypeEx( newX, newY, brickTerrainTypeId )
                    call SetTerrainTypeEx( newX, newY, brickTerrainTypeId )
                    call SetTerrainTypeEx( newX, newY, brickTerrainTypeId )
                    call CreateUnitEx( specificPlayer, MYSTICAL_TOWER_UNIT_ID, newX, newY, STANDARD_ANGLE )
                    set angle = centerTower2Angle + iteration * PI / 2
                    set newX = CENTER_X + difference2 * Cos( angle )
                    set newY = CENTER_Y + difference2 * Sin( angle )
                    call SetTerrainTypeEx( newX, newY, brickTerrainTypeId )
                    call SetTerrainTypeEx( newX, newY, brickTerrainTypeId )
                    call SetTerrainTypeEx( newX, newY, brickTerrainTypeId )
                    call SetTerrainTypeEx( newX, newY, brickTerrainTypeId )
                    call CreateUnitEx( GetTeamPlayers(iteration, 0), MYSTICAL_TOWER_UNIT_ID, newX, newY, STANDARD_ANGLE )
                endif
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop

            set iteration = MAX_PLAYER_INDEX
            loop
                set specificPlayer = PlayerWJ(iteration)
                if (IsPlayerDead(specificPlayer) == false) then
                    call SetPlayerState(specificPlayer, PLAYER_STATE_RESOURCE_GOLD, START_GOLD)
                    call PlayerGifts_PoolSight(specificPlayer)
                endif
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
        //    call GoldTower_Create()
        endfunction

        public function PlayerGifts_Start takes nothing returns nothing
            call ExecuteCode(function PlayerGifts_Trig)
        endfunction
    endscope

    scope PlaceDoodads
        globals
            private trigger PlaceDoodads_DUMMY_TRIGGER
            private integer PlaceDoodads_ITERATION = -1
            private real PlaceDoodads_X
            private real PlaceDoodads_Y
        endglobals

        private function PlaceDoodads_Hell takes nothing returns nothing
            local real angle
            local integer iteration = PlaceDoodads_ITERATION
            local real length
            local unit newUnit
            local integer random
            local integer specificTerrainTypeId = GetTerrainTileFromSet(TILESET, Grass_INDEX )
            local real x = PlaceDoodads_X
            local real y = PlaceDoodads_Y
            if ( x <= PLAY_RECT_MAX_X ) then
                set iteration = iteration + 1
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 7 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, CELL_SIZE )
                        if ( random == 10 ) then
                            set random = 'n025'
                        elseif ( random == 9 ) then
                            set random = 'n024'
                        else
                            set random = 'n013'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), 255 )
                    endif
                    set newUnit = null
                endif
                set x = x + 128
                set PlaceDoodads_X = x
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_Hell()
                endif
            elseif ( y <= PLAY_RECT_MAX_Y ) then
                set iteration = iteration + 1
                set x = PLAY_RECT_MIN_X
                set y = y + 128
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 7 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, CELL_SIZE )
                        if ( random == 10 ) then
                            set random = 'n025'
                        elseif ( random == 9 ) then
                            set random = 'n024'
                        else
                            set random = 'n013'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 0, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 0, 255 ), 255 )
                    endif
                    set newUnit = null
                endif
                set PlaceDoodads_X = x
                set PlaceDoodads_Y = y
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_Hell()
                endif
            endif
        endfunction

        private function PlaceDoodads_Barrens takes nothing returns nothing
            local real angle
            local integer iteration = PlaceDoodads_ITERATION
            local real length
            local unit newUnit
            local integer random
            local integer specificTerrainTypeId = GetTerrainTileFromSet(TILESET, Grass_INDEX )
            local real x = PlaceDoodads_X
            local real y = PlaceDoodads_Y
            if ( x <= PLAY_RECT_MAX_X ) then
                set iteration = iteration + 1
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 7 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, 32 )
                        if ( random == 10 ) then
                            set random = 'n025'
                        elseif ( random == 9 ) then
                            set random = 'n024'
                        else
                            set random = 'n013'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), 255 )
                    endif
                    set newUnit = null
                endif
                set x = x + 128
                set PlaceDoodads_X = x
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_Barrens()
                endif
            elseif ( y <= PLAY_RECT_MAX_Y ) then
                set iteration = iteration + 1
                set x = PLAY_RECT_MIN_X
                set y = y + 128
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 7 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, 32 )
                        if ( random == 10 ) then
                            set random = 'n025'
                        elseif ( random == 9 ) then
                            set random = 'n024'
                        else
                            set random = 'n013'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 0, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 0, 255 ), 255 )
                    endif
                    set newUnit = null
                endif
                set PlaceDoodads_X = x
                set PlaceDoodads_Y = y
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_Barrens()
                endif
            endif
        endfunction

        private function PlaceDoodads_Tropics takes nothing returns nothing
            local real angle
            local integer iteration = PlaceDoodads_ITERATION
            local real length
            local unit newUnit
            local integer random
            local integer specificTerrainTypeId = GetTerrainTileFromSet(TILESET, Grass_INDEX )
            local real x = PlaceDoodads_X
            local real y = PlaceDoodads_Y
            if ( x <= PLAY_RECT_MAX_X ) then
                set iteration = iteration + 1
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 6 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, 32 )
                        if ( random == 10 ) then
                            set random = 'n01C'
                        elseif ( random == 9 ) then
                            set random = 'n01D'
                        elseif ( random == 8 ) then
                            set random = 'n01E'
                        else
                            set random = 'n01F'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), 255 )
                    endif
                    set newUnit = null
                endif
                set x = x + 128
                set PlaceDoodads_X = x
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_Tropics()
                endif
            elseif ( y <= PLAY_RECT_MAX_Y ) then
                set iteration = iteration + 1
                set x = PLAY_RECT_MIN_X
                set y = y + 128
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 6 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, 32 )
                        if ( random == 10 ) then
                            set random = 'n01C'
                        elseif ( random == 9 ) then
                            set random = 'n01D'
                        elseif ( random == 8 ) then
                            set random = 'n01E'
                        else
                            set random = 'n01F'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 0, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 0, 255 ), 255 )
                    endif
                    set newUnit = null
                endif
                set PlaceDoodads_X = x
                set PlaceDoodads_Y = y
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_Tropics()
                endif
            endif
        endfunction

        private function PlaceDoodads_IceDesert takes nothing returns nothing
            local real angle
            local integer iteration = PlaceDoodads_ITERATION
            local real length
            local unit newUnit
            local integer random
            local integer specificTerrainTypeId = GetTerrainTileFromSet(TILESET, Grass_INDEX )
            local real x = PlaceDoodads_X
            local real y = PlaceDoodads_Y
            if ( x <= PLAY_RECT_MAX_X ) then
                set iteration = iteration + 1
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 7 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, 32 )
                        if ( random > 9 ) then
                            set random = 'n01H'
                        elseif ( random > 8 ) then
                            set random = 'n01I'
                        else
                            set random = 'n01J'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.3, 0.5 ), GetRandomReal( 0.3, 0.5 ), GetRandomReal( 0.3, 0.5 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), 255 )
                    endif
                    set newUnit = null
                endif
                set x = x + 128
                set PlaceDoodads_X = x
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_IceDesert()
                endif
            elseif ( y <= PLAY_RECT_MAX_Y ) then
                set iteration = iteration + 1
                set x = PLAY_RECT_MIN_X
                set y = y + 128
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 7 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, 32 )
                        if ( random > 9 ) then
                            set random = 'n01H'
                        elseif ( random > 8 ) then
                            set random = 'n01I'
                        else
                            set random = 'n01J'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.3, 0.5 ), GetRandomReal( 0.3, 0.5 ), GetRandomReal( 0.3, 0.5 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 0, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 0, 255 ), 255 )
                    endif
                    set newUnit = null
                endif
                set PlaceDoodads_X = x
                set PlaceDoodads_Y = y
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_IceDesert()
                endif
            endif
        endfunction

        private function PlaceDoodads_Forest takes nothing returns nothing
            local real angle
            local integer iteration = PlaceDoodads_ITERATION
            local real length
            local unit newUnit
            local integer random
            local integer specificTerrainTypeId = GetTerrainTileFromSet(TILESET, Grass_INDEX )
            local real x = PlaceDoodads_X
            local real y = PlaceDoodads_Y
            if ( x <= PLAY_RECT_MAX_X ) then
                set iteration = iteration + 1
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 7 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, 32 )
                        if ( random == 10 ) then
                            set random = 'n00B'
                        elseif ( random == 9 ) then
                            set random = 'n00C'
                        else
                            set random = 'n00D'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), 255 )
                    endif
                    set random = GetRandomInt( 1, 20 )
                    if ( random > 16 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, 32 )
                        if ( random == 17 ) then
                            set random = 'n00X'
                        elseif ( random == 18 ) then
                            set random = 'n00Y'
                        else
                            set random = 'n00W'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), 225 )
                    endif
                    set newUnit = null
                endif
                set x = x + 128
                set PlaceDoodads_X = x
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_Forest()
                endif
            elseif ( y <= PLAY_RECT_MAX_Y ) then
                set iteration = iteration + 1
                set x = PLAY_RECT_MIN_X
                set y = y + 128
                if ( ( GetTerrainType( x, y ) == specificTerrainTypeId ) and ( IsTerrainPathable( x, y, PATHING_TYPE_WALKABILITY ) == false ) and IsTerrainPathable( x, y, PATHING_TYPE_FLOATABILITY ) ) then
                    set random = GetRandomInt( 1, 10 )
                    if ( random > 7 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, CELL_SIZE )
                        if ( random == 10 ) then
                            set random = 'n00B'
                        elseif ( random == 9 ) then
                            set random = 'n00C'
                        else
                            set random = 'n00D'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 0, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 0, 255 ), 255 )
                    endif
                    set random = GetRandomInt( 1, 20 )
                    if ( random > 16 ) then
                        set angle = GetRandomReal( 0, 2 * PI )
                        set length = GetRandomReal( 0, CELL_SIZE )
                        if ( random == 17 ) then
                            set random = 'n00X'
                        elseif ( random == 18 ) then
                            set random = 'n00Y'
                        else
                            set random = 'n00W'
                        endif
                        set newUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, random, x + length * Cos( angle ), y + length * Sin( angle ), GetRandomReal( 0, 2 * PI ) )
                        call SetUnitScale( newUnit, GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ), GetRandomReal( 0.8, 1 ) )
                        call SetUnitVertexColor( newUnit, GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), GetRandomInt( 200, 255 ), 225 )
                    endif
                    set newUnit = null
                endif
                set PlaceDoodads_X = x
                set PlaceDoodads_Y = y
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceDoodads_ITERATION = iteration
                    call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
                else
                    set PlaceDoodads_ITERATION = iteration
                    call PlaceDoodads_Forest()
                endif
            endif
        endfunction

        public function PlaceDoodads_Start takes nothing returns nothing
            local integer iteration = ARENA_MODE.doodadTypesCount
            set PlaceDoodads_DUMMY_TRIGGER = CreateTriggerWJ()
            set PlaceDoodads_X = PLAY_RECT_MIN_X
            set PlaceDoodads_Y = PLAY_RECT_MIN_Y
            if ( ARENA_MODE == ARENA_MODE_FOREST ) then
                call AddTriggerCode(PlaceDoodads_DUMMY_TRIGGER, function PlaceDoodads_Forest)
            elseif ( ARENA_MODE == ARENA_MODE_ICE_DESERT ) then
                call AddTriggerCode(PlaceDoodads_DUMMY_TRIGGER, function PlaceDoodads_IceDesert)
            elseif ( ARENA_MODE == ARENA_MODE_TROPICS ) then
                call AddTriggerCode(PlaceDoodads_DUMMY_TRIGGER, function PlaceDoodads_Tropics)
            elseif ( ARENA_MODE == ARENA_MODE_BARRENS ) then
                //call AddTriggerCode(PlaceDoodads_DUMMY_TRIGGER, function PlaceDoodads_Barrens)
            elseif ( ARENA_MODE == ARENA_MODE_HELL ) then
                call AddTriggerCode(PlaceDoodads_DUMMY_TRIGGER, function PlaceDoodads_Hell)
            endif
            call RunTrigger(PlaceDoodads_DUMMY_TRIGGER)
            call SetDoodadAnimationRect( PLAY_RECT, -1, "hide", false )
            call SetDoodadAnimationRect( PLAY_RECT, -1, "soundoff", false )
            call SetTerrainFogEx( ARENA_MODE.fogStyle, ARENA_MODE.fogZStart, ARENA_MODE.fogZEnd, ARENA_MODE.fogDensity, ARENA_MODE.fogRed, ARENA_MODE.fogGreen, ARENA_MODE.fogBlue )
            call SetWaterBaseColor( ARENA_MODE.waterRed, ARENA_MODE.waterGreen, ARENA_MODE.waterBlue, ARENA_MODE.waterAlpha )
            loop
                exitwhen ( iteration < 0 )
                call SetDoodadAnimationRect( PLAY_RECT, ARENA_MODE.doodadTypesId[iteration], "show", false )
                set iteration = iteration - 1
            endloop
            set iteration = Misc_SAVED_DOODAD_TYPES_COUNT
            loop
                exitwhen ( iteration < 0 )
                call SetDoodadAnimationRect( PLAY_RECT, Misc_SAVED_DOODAD_TYPES_ID[iteration], "show", false )
                set iteration = iteration - 1
            endloop
        endfunction
    endscope

    scope PlaceDestructables
        private function Trig takes nothing returns nothing
            local BlockerPos d
            local TreePos e
            local integer iteration = BLOCKER_POSES_COUNT
            local integer iteration2
            local integer iteration3
            local DestructableType tree = ARENA_MODE.tree
            local real treeScale = tree.scale
            local integer treeId = tree.id
            local integer treeVariationsCount = tree.variationsCount
            local real x
            local real y
            loop
                set iteration2 = -1
                set d = BLOCKER_POSES[iteration]
                set x = CENTER_X - d.x
                set y = CENTER_Y - d.y
                loop
                    set iteration3 = iteration2
                    loop
                        call DestructableDies_RegisterDestructable(CreateDestructableWJ( BLOCKER_DESTRUCTABLE_ID, iteration2 * x, iteration3 * y, 0, 1, 0 ))
                        set iteration3 = -iteration3
                        exitwhen ( iteration3 == iteration2 )
                    endloop
                    set iteration2 = -iteration2
                    exitwhen ( iteration2 == -1 )
                endloop
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            set iteration = TREE_POSES_COUNT
            loop
                set iteration2 = -1
                set e = TREE_POSES[iteration]
                set x = CENTER_X - e.x
                set y = CENTER_Y - e.y
                loop
                    set iteration3 = iteration2
                    loop
                        call DestructableDies_RegisterDestructable(CreateDestructableWJ( treeId, iteration2 * x, iteration3 * y, GetRandomReal( 0, 2 * PI ), treeScale, GetRandomInt( 0, treeVariationsCount ) ))
                        set iteration3 = -iteration3
                        exitwhen ( iteration3 == iteration2 )
                    endloop
                    set iteration2 = -iteration2
                    exitwhen ( iteration2 == -1 )
                endloop
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
        endfunction

        public function PlaceDestructables_Start takes nothing returns nothing
            call ExecuteCode(function Trig)
        endfunction
    endscope

    scope PlaceNeutralBuildings
        private function PlaceNeutralBuildings_GoblinShop takes integer period returns nothing
            //! runtextmacro RotateAroundCenter("GOBLIN_SHOP_RECT", "PI / 2")
            local Unit newUnit
            set newUnit = CreateUnitEx( PlayerWJ( period * MAX_PLAYERS_PER_TEAM ), GOBLIN_SHOP_UNIT_ID, x, y, STANDARD_ANGLE )
            set GOBLIN_SHOPS[period] = newUnit
            call AddUnitTeamSight( newUnit )
        endfunction

        private function PlaceNeutralBuildings_Market takes integer period returns nothing
            //! runtextmacro RotateAroundCenter("MARKET_RECT", "PI / 2")
            local Unit newUnit
            call AddSpecialEffectTargetWJ( "Objects\\InventoryItems\\PotofGold\\PotofGold.mdl", CreateUnitEx( NEUTRAL_PASSIVE_PLAYER, MARKET_UNIT_ID, x, y, STANDARD_ANGLE ).self, "overhead" )
        endfunction

        private function PlaceNeutralBuildings_MercenaryCamp takes integer period returns nothing
            //! runtextmacro RotateAroundCenter("MERCENARY_CAMP_RECT", "PI / 2")
            local Unit newUnit
            call AddSpecialEffectTargetWJ( "Objects\\InventoryItems\\PotofGold\\PotofGold.mdl", CreateUnitEx( NEUTRAL_PASSIVE_PLAYER, MERCENARY_CAMP_UNIT_ID, x, y, STANDARD_ANGLE ).self, "overhead" )
        endfunction

        private function PlaceNeutralBuildings_MasterWizard takes integer period returns nothing
            //! runtextmacro RotateAroundCenter("MASTER_WIZARD_RECT", "PI / 2")
            local Unit newUnit
            call MasterWizard_Start( period, CreateUnitEx( PlayerWJ( period * MAX_PLAYERS_PER_TEAM ), MASTER_WIZARD_UNIT_ID, x, y, STANDARD_ANGLE ) )
        endfunction

        private function PlaceNeutralBuildings_SecondhandDealer takes integer period returns nothing
            //! runtextmacro RotateAroundCenter("SECONDHAND_DEALER_RECT", "PI / 2")
            local Unit newUnit
            call CreateUnitEx(NEUTRAL_PASSIVE_PLAYER, SECONDHAND_DEALER_UNIT_ID, x, y, STANDARD_ANGLE)
        endfunction

        private function PlaceNeutralBuildings_Shredder takes integer period returns nothing
            //! runtextmacro RotateAroundCenter("UNIT_SHREDDER_RECT", "PI / 2")
            local Unit newUnit
            set newUnit = CreateUnitEx( PlayerWJ( period * MAX_PLAYERS_PER_TEAM ), UNIT_SHREDDER_UNIT_ID, x, y, STANDARD_ANGLE )
            set SHREDDERS[period] = newUnit
            set SHREDDERS_X[period] = x
            set SHREDDERS_Y[period] = y
            call AddUnitTeamSight( newUnit )
        endfunction

        private function PlaceNeutralBuildings_Workshop takes integer period returns nothing
            //! runtextmacro RotateAroundCenter("WORKSHOP_RECT", "PI / 2")
            local Unit newUnit
            set newUnit = CreateUnitEx( PlayerWJ( period * MAX_PLAYERS_PER_TEAM ), WORKSHOP_UNIT_ID, x, y, STANDARD_ANGLE )
            set WORKSHOPS[period] = newUnit
            call AddUnitTeamSight( newUnit )
        endfunction

        private function PlaceNeutralBuildings_Trig takes nothing returns nothing
            local integer iteration = GetTeams() - 1
            set FOUNTAIN = CreateUnitEx( NEUTRAL_PASSIVE_PLAYER, FOUNTAIN_UNIT_ID, CENTER_X, CENTER_Y, STANDARD_ANGLE )
            loop
                call PlaceNeutralBuildings_GoblinShop(iteration)
                call PlaceNeutralBuildings_MasterWizard(iteration)
                if (ModulateReal(iteration, 2) == 0) then
                    call PlaceNeutralBuildings_Market(iteration)
                    call PlaceNeutralBuildings_MercenaryCamp(iteration)
                endif
                call PlaceNeutralBuildings_SecondhandDealer(iteration)
                call PlaceNeutralBuildings_Shredder(iteration)
                call PlaceNeutralBuildings_Workshop(iteration)
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
        endfunction

        public function PlaceNeutralBuildings_Start takes nothing returns nothing
            call ExecuteCode(function PlaceNeutralBuildings_Trig)
        endfunction
    endscope

    //! runtextmacro Scope("PlaceTerrain")
        globals
            private trigger PlaceTerrain_DUMMY_TRIGGER
            private integer PlaceTerrain_ITERATION = 0
            private real PlaceTerrain_X
            private real PlaceTerrain_Y
        endglobals

        private function PlaceTerrain_Trig takes nothing returns nothing
            local integer iteration = PlaceTerrain_ITERATION
            local real x = PlaceTerrain_X
            local real y = PlaceTerrain_Y
            if ( x <= PLAY_RECT_MAX_X ) then
                set iteration = iteration + 1
                call SetTerrainTypeWJ( x, y, GetAttachedIntegerById( GetTerrainType( x, y ), PlaceTerrain_SCOPE_ID ) )
                set x = x + 128
                set PlaceTerrain_X = x
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceTerrain_ITERATION = iteration
                    call RunTrigger(PlaceTerrain_DUMMY_TRIGGER)
                else
                    set PlaceTerrain_ITERATION = iteration
                    call PlaceTerrain_Trig()
                endif
            elseif ( y <= PLAY_RECT_MAX_Y ) then
                set iteration = iteration + 1
                set x = PLAY_RECT_MIN_X
                set y = y + 128
                call SetTerrainTypeWJ( x, y, GetAttachedIntegerById( GetTerrainType( x, y ), PlaceTerrain_SCOPE_ID ) )
                set PlaceTerrain_X = x
                set PlaceTerrain_Y = y
                if ( iteration > 24 ) then
                    set iteration = 0
                    set PlaceTerrain_ITERATION = iteration
                    call RunTrigger(PlaceTerrain_DUMMY_TRIGGER)
                else
                    set PlaceTerrain_ITERATION = iteration
                    call PlaceTerrain_Trig()
                endif
            endif
        endfunction

        public function PlaceTerrain_Start takes nothing returns nothing
            local integer oldTilesetTilesCount = CountTerrainTilesInSet( TILESET_CITYSCAPE )
            local integer iteration = oldTilesetTilesCount
            set PlaceTerrain_DUMMY_TRIGGER = CreateTrigger()
            set TILESET = ARENA_MODE.tileset
            loop
                exitwhen ( iteration < 0 )
                call AttachIntegerById( GetTerrainTileFromSet( TILESET_CITYSCAPE, iteration ), PlaceTerrain_SCOPE_ID, GetTerrainTileFromSet( TILESET, iteration ) )
                set iteration = iteration - 1
            endloop
            set PlaceTerrain_X = PLAY_RECT_MIN_X
            set PlaceTerrain_Y = PLAY_RECT_MIN_Y
            call AddTriggerCode(PlaceTerrain_DUMMY_TRIGGER, function PlaceTerrain_Trig)
            call RunTrigger(PlaceTerrain_DUMMY_TRIGGER)
            set iteration = oldTilesetTilesCount
            loop
                exitwhen ( iteration < 0 )
                call FlushAttachedIntegerById( GetTerrainTileFromSet( TILESET_CITYSCAPE, iteration ), PlaceTerrain_SCOPE_ID )
                set iteration = iteration - 1
            endloop
        endfunction
    //! runtextmacro Endscope()

    scope SetPathing
        globals
            private trigger SetPathing_DUMMY_TRIGGER
            private integer SetPathing_ITERATION = 0
            private real SetPathing_X
            private real SetPathing_Y
        endglobals

        private function SetPathing_Trig takes nothing returns nothing
            local integer brickTerrainTypeId = GetTerrainTileFromSet(TILESET, Brick_INDEX)
            local integer iteration = SetPathing_ITERATION
            local real x = SetPathing_X
            local real y = SetPathing_Y
            if ( x <= INNER_PLAY_RECT_MAX_X ) then
                set iteration = iteration + 1
                if ( GetTerrainType( x, y ) == brickTerrainTypeId ) then
                    call SetTerrainPointPathable( x, y, PATHING_TYPE_BUILDABILITY, true )
                else
        //            call SetTerrainPointPathable( x, y, PATHING_TYPE_BUILDABILITY, false )
                endif
                if ( GetTerrainCliffLevel( x, y ) == STANDARD_CLIFF_LEVEL ) then
                    //call SetTerrainPointPathable( x, y, PATHING_TYPE_FLYABILITY, true )
                else
                    if (IsPointInRect(x, y, CENTER_RECT) == false) then
                        //call SetTerrainPointPathable( x, y, PATHING_TYPE_FLOATABILITY, false )
                        call SetTerrainPointPathable( x, y, PATHING_TYPE_FLYABILITY, false )
                        //call SetTerrainPointPathable( x, y, PATHING_TYPE_WALKABILITY, false )
                    endif
                endif
                set x = x + 128
                set SetPathing_X = x
                if ( iteration > 24 ) then
                    set iteration = 0
                    set SetPathing_ITERATION = iteration
                    call RunTrigger( SetPathing_DUMMY_TRIGGER )
                else
                    set SetPathing_ITERATION = iteration
                    call SetPathing_Trig()
                endif
            elseif ( y <= INNER_PLAY_RECT_MAX_Y ) then
                set iteration = iteration + 1
                set x = INNER_PLAY_RECT_MIN_X
                set y = y + 128
                if ( GetTerrainType( x, y ) == brickTerrainTypeId ) then
                    call SetTerrainPointPathable( x, y, PATHING_TYPE_BUILDABILITY, true )
                else
        //            call SetTerrainPointPathable( x, y, PATHING_TYPE_BUILDABILITY, false )
                endif
                if ( GetTerrainCliffLevel( x, y ) == STANDARD_CLIFF_LEVEL ) then
                    //call SetTerrainPointPathable( x, y, PATHING_TYPE_FLYABILITY, true )
                else
                    if (IsPointInRect(x, y, CENTER_RECT) == false) then
                        //call SetTerrainPointPathable( x, y, PATHING_TYPE_FLOATABILITY, false )
                        call SetTerrainPointPathable( x, y, PATHING_TYPE_FLYABILITY, false )
                        //call SetTerrainPointPathable( x, y, PATHING_TYPE_WALKABILITY, false )
                    endif
                endif
                set SetPathing_X = x
                set SetPathing_Y = y
                if ( iteration > 24 ) then
                    set iteration = 0
                    set SetPathing_ITERATION = iteration
                    call RunTrigger( SetPathing_DUMMY_TRIGGER )
                else
                    set SetPathing_ITERATION = iteration
                    call SetPathing_Trig()
                endif
            endif
        endfunction

        public function SetPathing_Start takes nothing returns nothing
            set SetPathing_DUMMY_TRIGGER = CreateTriggerWJ()
            call AddTriggerCode(SetPathing_DUMMY_TRIGGER, function SetPathing_Trig)
            set SetPathing_X = INNER_PLAY_RECT_MIN_X
            set SetPathing_Y = INNER_PLAY_RECT_MIN_Y
            call RunTrigger(SetPathing_DUMMY_TRIGGER)
        endfunction
    endscope

    public function Start takes integer allianceModeIndex returns nothing
        local integer iteration
        call DestroyDialogWJ( DUMMY_DIALOG )
        call DestroyTimerWJ( DUMMY_TIMER )

        call ExecuteCode( function Sound_Start )

        call PlaySoundFromTypeAcrossRect( WATER_SOUND_TYPE, InitRect( gg_rct_WaterSound1 ), 0 )
        call PlaySoundFromTypeAcrossRect( WATER_SOUND_TYPE, InitRect( gg_rct_WaterSound2 ), 0 )
        call PlaySoundFromTypeAcrossRect( WATER_SOUND_TYPE, InitRect( gg_rct_WaterSound3 ), 0 )
        call PlaySoundFromTypeAcrossRect( WATER_SOUND_TYPE, InitRect( gg_rct_WaterSound4 ), 0 )
        call PlaySoundFromTypeAcrossRect( WATER2_SOUND_TYPE, gg_rct_WaterSound1, 0 )
        call PlaySoundFromTypeAcrossRect( WATER2_SOUND_TYPE, gg_rct_WaterSound2, 0 )
        call PlaySoundFromTypeAcrossRect( WATER2_SOUND_TYPE, gg_rct_WaterSound3, 0 )
        call PlaySoundFromTypeAcrossRect( WATER2_SOUND_TYPE, gg_rct_WaterSound4, 0 )
        call PlayMusic( "Sound\\Music\\mp3Music\\Doom.mp3" )

        set ALLIANCE_MODE = ALLIANCE_MODES[allianceModeIndex]
        set ARENA_MODE = ARENA_MODE_FOREST//ARENA_MODES[arenaModeIndex]

        //if ( ARENA_MODE == ARENA_MODE_FOREST ) then
            set TILESET = TILESET_CITYSCAPE
        //else
            call PlaceTerrain_PlaceTerrain_Start()
        //endif
        call PlaceNeutralBuildings_PlaceNeutralBuildings_Start()
        call PlaceDestructables_PlaceDestructables_Start()
        //call PlaceDoodads_PlaceDoodads_Start()
        call PlayerGifts_PlayerGifts_Start()
        call SetPathing_SetPathing_Start()

    //    call FogMaskEnable( false )
        set iteration = MAX_PLAYER_INDEX
        loop
            call SetFogStateRect( PlayerWJ( iteration ), FOG_OF_WAR_FOGGED, UNMASKED_RECT, true )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        call FogEnable( false )
        call FogEnable( true )
        call SetFloatGameState( GAME_STATE_TIME_OF_DAY, 12 )
        call SuspendTimeOfDay( true )

        call DisplayCineFilterWJ( GetLocalPlayer(), false )
        call BuildHouse_BuildHouse()
        //call StartWeather_Start()

        call CameraDialog_Start()
        call Creeps_Start()
        call ExtraGold_Start()
        call Infoboard_Start()
        call Infocard_Start()
        call Hints_Start()
        call Regeneration_Start()
        call TimeOfDay_Start()
        call TimerStart( CreateTimerWJ(), 20, false, function CommandList )
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Start.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Triggers.j
//TESH.scrollpos=21
//TESH.alwaysfold=0
scope Triggers
    public function Init takes nothing returns nothing
        call CoinIsPickedUp_Init()
        call Dawn_Init()
        call DestructableDies_Init()
        call Dusk_Init()
        call ItemDies_Init()
        call ItemFinishesDecaying_Init()
        call LightningDies_Init()
        call PlayerChangesLumberAmount_Init()
        call PlayerClicksDialog_Init()
        call PlayerDeselectsUnit_Init()
        call PlayerDies_Init()
        call PlayerLeaves_Init()
        call PlayerPressesEsc_Init()
        call PlayerSelectsUnit_Init()
        call PlayerSendsChatMessage_Init()
        call TerrainChanges_Init()
        call UnitAcquiresItem_Init()
        call UnitAcquiresTarget_Init()
        call UnitAppears_Init()
        call UnitBecomesRevivable_Init()
        call UnitBeginsCasting_Init()
        call UnitBeginsConstructing_Init()
        call UnitBeginsResearching_Init()
        call UnitBeginsUpgrading_Init()
        call UnitCancelsResearching_Init()
        call UnitCancelsUpgrading_Init()
        call UnitChangesForm_Init()
        call UnitChangesOwner_Init()
        call UnitChannels_Init()
        call UnitDecays_Init()
        call UnitDies_Init()
        call UnitDropsItem_Init()
        call UnitFinishesCasting_Init()
        call UnitFinishesConstructing_Init()
        call UnitFinishesDecaying_Init()
        call UnitFinishesResearching_Init()
        call UnitFinishesReviving_Init()
        call UnitFinishesTraining_Init()
        call UnitFinishesUpgrading_Init()
        call UnitGainsLevel_Init()
        call UnitGetsOrder_Init()
        call UnitIsActivated_Init()
        call UnitIsAttacked_Init()
        call UnitIsBeforeDying_Init()
        call UnitIsDispelled_Init()
        call UnitIsMoveChecked_Init()
        call UnitIsRevaluated_Init()
        call UnitLearnsSkill_Init()
        call UnitPawnsItem_Init()
        call UnitSellsItem_Init()
        call UnitSellsUnit_Init()
        call UnitStartsEffectOfAbility_Init()
        call UnitTakesAnyDamage_Init()
        call UnitTakesDamage_Init()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Triggers.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Units.j
//TESH.scrollpos=2699
//TESH.alwaysfold=0
scope Units
    scope Human
        public function Human_Init takes nothing returns nothing
            local UnitType d

            globals
                constant integer FARM_UNIT_ID = 'h00B'
            endglobals

            // Farm
            set d = InitUnitTypeEx( FARM_UNIT_ID )
            call AddUnitTypeAbility( d, GHOST_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife(d, 150000)
            call SetUnitTypeSightRange(d, 600)
            call SetUnitTypeScale(d, 1.4)
            call SetUnitTypeUpgradesInstantly( d )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 200)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer HUMAN_TIER1_UNIT_ID = 'h000'
            endglobals

            // Human - Tier 1
            set d = InitUnitTypeEx( HUMAN_TIER1_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 4000 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 12 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer FOOTMAN_UNIT_ID = 'h001'
            endglobals

            // Footman
            set d = InitUnitTypeEx( FOOTMAN_UNIT_ID )
            call AddUnitTypeAbility( d, Defend_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodFootman.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 10 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 2 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 25 )
            call SetUnitTypeEP( d, 27 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.5 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 410 )
            call SetUnitTypeScale( d, 1.05 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 230, 230, 230, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer WITCH_UNIT_ID = 'H003'
            endglobals

            // Witch
            set d = InitUnitTypeEx( WITCH_UNIT_ID )
            call AddUnitTypeAbility( d, Enchant_SPELL_ID )
            call AddUnitTypeAbility( d, MagicalSuperiority_SPELL_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            call AddUnitHeroAbility( d, ChillyPresence_SPELL_ID )
            call AddUnitHeroAbility( d, FireBurst_SPELL_ID )
            call AddUnitHeroAbility( d, Hurricane_SPELL_ID )
            call AddUnitHeroAbility( d, SummonInfernal_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNJaina.blp" )
            call SetUnitTypeImpactZ( d, 69 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, WITCH_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, WITCH_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, WITCH_PISSED3_SOUND_TYPE )
            call AddUnitTypePissedSound( d, WITCH_PISSED4_SOUND_TYPE )
            call AddUnitTypePissedSound( d, WITCH_PISSED5_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 15 )
            call SetUnitTypeAgilityPerLevel( d, 1.35 )
            call SetUnitTypeIntelligence( d, 20 )
            call SetUnitTypeIntelligencePerLevel( d, 3.45 )
            call SetUnitTypePrimaryAttribute( d, 3 )
            call SetUnitTypeStrength( d, 14 )
            call SetUnitTypeStrengthPerLevel( d, 1.05 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer PALADIN_UNIT_ID = 'H004'
            endglobals

            // Paladin
            set d = InitUnitTypeEx( PALADIN_UNIT_ID )
            call AddUnitTypeAbility( d, CourageAndHonor_SPELL_ID )
            call AddUnitTypeAbility( d, HammerThrow_SPELL_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            call AddUnitHeroAbility( d, EnergyGap_SPELL_ID )
            call AddUnitHeroAbility( d, LightOfPurge_SPELL_ID )
            call AddUnitHeroAbility( d, Resurrection_SPELL_ID )
            call AddUnitHeroAbility( d, Stability_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNArthas.blp" )
            call SetUnitTypeImpactZ( d, 69 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, PALADIN_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, PALADIN_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, PALADIN_PISSED3_SOUND_TYPE )
            call AddUnitTypePissedSound( d, PALADIN_PISSED4_SOUND_TYPE )
            call AddUnitTypePissedSound( d, PALADIN_PISSED5_SOUND_TYPE )
            call AddUnitTypePissedSound( d, PALADIN_PISSED6_SOUND_TYPE )
            call AddUnitTypePissedSound( d, PALADIN_PISSED7_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 13 )
            call SetUnitTypeAgilityPerLevel( d, 1.05 )
            call SetUnitTypeIntelligence( d, 16 )
            call SetUnitTypeIntelligencePerLevel( d, 2.25 )
            call SetUnitTypePrimaryAttribute( d, 1 )
            call SetUnitTypeStrength( d, 21 )
            call SetUnitTypeStrengthPerLevel( d, 3 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer HUMAN_TIER2_UNIT_ID = 'h005'
            endglobals

            // Human - Tier 2
            set d = InitUnitTypeEx( HUMAN_TIER2_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1250 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 5000 )
            call SetUnitTypeScale( d, 0.85 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 16 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RIFLEMAN_UNIT_ID = 'h006'
            endglobals

            // Rifleman
            set d = InitUnitTypeEx( RIFLEMAN_UNIT_ID )
            call AddUnitTypeAbility( d, BigGun_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodRifleman.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 12 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 25 )
            call SetUnitTypeEP( d, 29 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.5 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 432 )
            call SetUnitTypeScale( d, 1.05 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeSplashAffectionAir( d )
            call SetUnitTypeSplashAffectionEnemy( d )
            call SetUnitTypeSplashAffectionGround( d )
            call SetUnitTypeSplashDamageFactor( d, 0.6 )
            call SetUnitTypeSplashAreaRange( d, 215 )
            call SetUnitTypeSplashWindowAngle( d, 360 * RAD_TO_DEG )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, BigGun_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer HUMAN_TIER3_UNIT_ID = 'h007'
            endglobals

            // Human - Tier 3
            set d = InitUnitTypeEx( HUMAN_TIER3_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1750 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 6000 )
            call SetUnitTypeScale( d, 0.85 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 20 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer KNIGHT_UNIT_ID = 'h008'
            endglobals

            // Knight
            set d = InitUnitTypeEx( KNIGHT_UNIT_ID )
            call AddUnitTypeAbility( d, StrongArm_SPELL_ID )
            call SetUnitTypeArmor( d, 4 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodKnight.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 15 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 31 )
            call SetUnitTypeEP( d, 32 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.65 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 585 )
            call SetUnitTypeScale( d, 1.05 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 350 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, StrongArm_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer HUMAN_TIER4_UNIT_ID = 'h009'
            endglobals

            // Human - Tier 4
            set d = InitUnitTypeEx( HUMAN_TIER4_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 2250 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 7000 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 24 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer DRAGON_HAWK_UNIT_ID = 'h00Z'
            endglobals

            // Dragonhawk
            set d = InitUnitTypeEx( DRAGON_HAWK_UNIT_ID )
            call AddUnitTypeAbility( d, MagicalLariat_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LIGHT )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodMortarTeam.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 19 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 7 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 34 )
            call SetUnitTypeEP( d, 25 )
            call SetUnitTypeImpactZ( d, 20 )
            call SetUnitTypeLifeRegeneration( d, 1 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 470 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 700 )
            call SetUnitTypeSpeed( d, 310 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer PRIEST_UNIT_ID = 'h00A'
            endglobals

            // Priest
            set d = InitUnitTypeEx( PRIEST_UNIT_ID )
            call AddUnitTypeAbility( d, Inspiration_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_UNARMORED )
            call SetUnitTypeAutomaticAbility( d, Inspiration_SPELL_ID )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodPriest.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl" )
            call SetUnitTypeCaster( d )
            call SetUnitTypeDamage( d, 10 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 23 )
            call SetUnitTypeEP( d, 25 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.5 * REGENERATION_INTERVAL )
            call SetUnitTypeManaRegeneration( d, 0.8 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 270 )
            call SetUnitTypeMaxMana( d, 150 )
            call SetUnitTypeScale( d, 1.05 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeStartMana( d, 300 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer INFERNAL_UNIT_ID = 'n005'
            endglobals

            // Infernal
            set d = InitUnitTypeEx( INFERNAL_UNIT_ID )
            call AddUnitTypeAbility( d, Immolation_SPELL_ID )
            call SetUnitTypeArmor( d, 6 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 48 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 12 )
            call SetUnitTypeDamageType( d, DMG_TYPE_CHAOS )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 120 )
            call SetUnitTypeEP( d, 100 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 900 )
            call SetUnitTypeScale( d, 1.1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MONSTROUS_INFERNAL_UNIT_ID = 'n02A'
            endglobals

            // Monstrous Infernal
            set d = InitUnitTypeEx( MONSTROUS_INFERNAL_UNIT_ID )
            call AddUnitTypeAbility( d, Immolation_SPELL_ID )
            call SetUnitTypeArmor( d, 10 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 55 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 8 )
            call SetUnitTypeDamageType( d, DMG_TYPE_CHAOS )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 200 )
            call SetUnitTypeEP( d, 150 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1.5 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 1300 )
            call SetUnitTypeScale( d, 1.3 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 310 )
            call SetUnitTypeVertexColor(d, 255, 80, 80, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_HUMAN_UNIT_ID = 'h00O'
            endglobals

            // Research Center (Human, Page 1)
            set d = InitUnitTypeEx( RESEARCH_CENTER_HUMAN_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_HUMAN_PAGE_2_UNIT_ID = 'h011'
            endglobals

            // Research Center (Human, Page 2)
            set d = InitUnitTypeEx( RESEARCH_CENTER_HUMAN_PAGE_2_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
        endfunction
    endscope

    scope Orc
        public function Orc_Init takes nothing returns nothing
            local UnitType d

            globals
                constant integer TROLL_BURROW_UNIT_ID = 'o00A'
            endglobals

            // TrollBurrow
            set d = InitUnitTypeEx( TROLL_BURROW_UNIT_ID )
            call AddUnitTypeAbility( d, GHOST_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeUpgradesInstantly( d )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 200)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ORC_TIER1_UNIT_ID = 'o000'
            endglobals

            // Orc - Tier 1
            set d = InitUnitTypeEx( ORC_TIER1_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 4000 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 12 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer HEAD_HUNTER_UNIT_ID = 'o00J'
            endglobals

            // Head Hunter
            set d = InitUnitTypeEx( HEAD_HUNTER_UNIT_ID )
            call AddUnitTypeAbility( d, Berserk_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodHeadhunter.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 11 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 20 )
            call SetUnitTypeEP( d, 25 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.45 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 350 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ORC_TIER2_UNIT_ID = 'o002'
            endglobals

            // Orc - Tier 2
            set d = InitUnitTypeEx( ORC_TIER2_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1250 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 5000 )
            call SetUnitTypeScale( d, 0.8 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 16 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RAIDER_UNIT_ID = 'o003'
            endglobals

            // Raider
            set d = InitUnitTypeEx( RAIDER_UNIT_ID )
            call AddUnitTypeAbility( d, Evasion_RAIDER_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodWolfrider.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 10 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 2 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 27 )
            call SetUnitTypeEP( d, 30 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.95 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 468 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 360 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, Evasion_RAIDER_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ORC_TIER3_UNIT_ID = 'o004'
            endglobals

            // Orc - Tier 3
            set d = InitUnitTypeEx( ORC_TIER3_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1750 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 6000 )
            call SetUnitTypeScale( d, 0.8 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 20 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer GRUNT_UNIT_ID = 'o005'
            endglobals

            // Grunt
            set d = InitUnitTypeEx( GRUNT_UNIT_ID )
            call AddUnitTypeAbility( d, Disarm_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodGrunt.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 16 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 29 )
            call SetUnitTypeEP( d, 32 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1.1 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 585 )
            call SetUnitTypeScale( d, 1.1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, Disarm_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ORC_TIER4_UNIT_ID = 'o006'
            endglobals

            // Orc - Tier 4
            set d = InitUnitTypeEx( ORC_TIER4_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 2250 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 7000 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 24 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer WIND_RIDER_UNIT_ID = 'o007'
            endglobals

            // Windrider
            set d = InitUnitTypeEx( WIND_RIDER_UNIT_ID )
            call AddUnitTypeAbility( d, AirPassage_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LIGHT )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrdBloodWyvernRider.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 20 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 30 )
            call SetUnitTypeEP( d, 32 )
            call SetUnitTypeImpactZ( d, 20 )
            call SetUnitTypeLifeRegeneration( d, 0.75 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 528 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 700 )
            call SetUnitTypeSpeed( d, 320 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 2 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SHAMAN_UNIT_ID = 'o001'
            endglobals

            // Shaman
            set d = InitUnitTypeEx( SHAMAN_UNIT_ID )
            call AddUnitTypeAbility( d, Fireball_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_UNARMORED )
            call SetUnitTypeAutomaticAbility( d, Fireball_SPELL_ID )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodPeon.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeCaster( d )
            call SetUnitTypeDamage( d, 11 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 20 )
            call SetUnitTypeEP( d, 26 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.6 * REGENERATION_INTERVAL )
            call SetUnitTypeManaRegeneration( d, 0.75 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 245 )
            call SetUnitTypeMaxMana( d, 150 )
            call SetUnitTypeScale( d, 0.95 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeStartMana( d, 150 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer BERSERKER_UNIT_ID = 'O008'
            endglobals

            // Berserker
            set d = InitUnitTypeEx( BERSERKER_UNIT_ID )
            call AddUnitTypeAbility( d, Evasion_BERSERKER_SPELL_ID )
            call AddUnitTypeAbility( d, Meditation_SPELL_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodHellScream.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 12 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            call AddUnitHeroAbility( d, AxeMaster_SPELL_ID )
            call AddUnitHeroAbility( d, Frenzy_SPELL_ID )
            call AddUnitHeroAbility( d, MindBreaker_SPELL_ID )
            call AddUnitHeroAbility( d, Whirlwind_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNHellScream.blp" )
            call SetUnitTypeImpactZ( d, 69 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, BERSERK_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BERSERK_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BERSERK_PISSED3_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 320 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 23 )
            call SetUnitTypeAgilityPerLevel( d, 3.3 )
            call SetUnitTypeIntelligence( d, 14 )
            call SetUnitTypeIntelligencePerLevel( d, 1.05 )
            call SetUnitTypePrimaryAttribute( d, 2 )
            call SetUnitTypeStrength( d, 17 )
            call SetUnitTypeStrengthPerLevel( d, 2.4 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MEDICINE_MAN_UNIT_ID = 'O00B'
            endglobals

            // Medicine Man
            set d = InitUnitTypeEx( MEDICINE_MAN_UNIT_ID )
            call AddUnitTypeAbility( d, SoulVessel_SPELL_ID )
            call AddUnitTypeAbility( d, ThermalFissure_SPELL_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodHeroFarSeer.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            call AddUnitHeroAbility( d, BondOfSouls_SPELL_ID )
            call AddUnitHeroAbility( d, DarkCloud_SPELL_ID )
            call AddUnitHeroAbility( d, GhostTakeOver_SPELL_ID )
            call AddUnitHeroAbility( d, LittleThunderstorm_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNThrall.blp" )
            call SetUnitTypeImpactZ( d, 69 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, MEDICINE_MAN_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, MEDICINE_MAN_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, MEDICINE_MAN_PISSED3_SOUND_TYPE )
            call AddUnitTypePissedSound( d, MEDICINE_MAN_PISSED4_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 320 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 15 )
            call SetUnitTypeAgilityPerLevel( d, 1.65 )
            call SetUnitTypeIntelligence( d, 18 )
            call SetUnitTypeIntelligencePerLevel( d, 3 )
            call SetUnitTypePrimaryAttribute( d, 3 )
            call SetUnitTypeStrength( d, 16 )
            call SetUnitTypeStrengthPerLevel( d, 1.5 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_ORC_UNIT_ID = 'o00E'
            endglobals

            // Research Center (Orc, Page 1)
            set d = InitUnitTypeEx( RESEARCH_CENTER_ORC_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_ORC_PAGE_2_UNIT_ID = 'o00K'
            endglobals

            // Research Center (Orc, Page 2)
            set d = InitUnitTypeEx( RESEARCH_CENTER_ORC_PAGE_2_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
        endfunction
    endscope

    scope Undead
        public function Undead_Init takes nothing returns nothing
            local UnitType d

            globals
                constant integer ZIGGURAT_UNIT_ID = 'u008'
            endglobals

            // Ziggurat
            set d = InitUnitTypeEx( ZIGGURAT_UNIT_ID )
            call AddUnitTypeAbility( d, GHOST_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeUpgradesInstantly( d )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 200)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer UNDEAD_TIER1_UNIT_ID = 'u000'
            endglobals

            // Undead - Tier 1
            set d = InitUnitTypeEx( UNDEAD_TIER1_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UCancelDeath\\UCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 4000 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 12 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer GHOUL_UNIT_ID = 'u001'
            endglobals

            // Ghoul
            set d = InitUnitTypeEx( GHOUL_UNIT_ID )
            call AddUnitTypeAbility( d, GhoulFrenzy_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodGhoul.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 8 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 2 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 21 )
            call SetUnitTypeEP( d, 24 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1.2 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 345 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 330 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, GhoulFrenzy_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer UNDEAD_TIER2_UNIT_ID = 'u002'
            endglobals

            // Undead - Tier 2
            set d = InitUnitTypeEx( UNDEAD_TIER2_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UCancelDeath\\UCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1250 )
            call SetUnitTypeImpactZ( d, 260 )
            call SetUnitTypeMaxLife( d, 5000 )
            call SetUnitTypeScale( d, 0.8 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 16 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer CRYPT_FIEND_UNIT_ID = 'u003'
            endglobals

            // Crypt Fiend
            set d = InitUnitTypeEx( CRYPT_FIEND_UNIT_ID )
            call AddUnitTypeAbility( d, Burrow_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodCryptFiend.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 18 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_SIEGE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 26 )
            call SetUnitTypeEP( d, 30 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.9 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 366 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer CRYPT_FIEND_BURROWED_UNIT_ID = 'u00H'
            endglobals

            // Crypt Fiend (Burrowed)
            set d = InitUnitTypeEx( CRYPT_FIEND_BURROWED_UNIT_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodCryptFiend.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 18 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_SIEGE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 26 )
            call SetUnitTypeEP( d, 30 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.9 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 366 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer UNDEAD_TIER3_UNIT_ID = 'u004'
            endglobals

            // Undead - Tier 3
            set d = InitUnitTypeEx( UNDEAD_TIER3_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UCancelDeath\\UCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1750 )
            call SetUnitTypeImpactZ( d, 260 )
            call SetUnitTypeMaxLife( d, 6000 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 20 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer GARGOYLE_UNIT_ID = 'u00F'
            endglobals

            // Gargoyle
            set d = InitUnitTypeEx( GARGOYLE_UNIT_ID )
            call AddUnitTypeAbility( d, Kataikaze_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodGargoyle.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 16 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 26 )
            call SetUnitTypeEP( d, 26 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 3 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 425 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 700 )
            call SetUnitTypeSpeed( d, 340 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer UNDEAD_TIER4_UNIT_ID = 'u006'
            endglobals

            // Undead - Tier 4
            set d = InitUnitTypeEx( UNDEAD_TIER4_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UCancelDeath\\UCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 2250 )
            call SetUnitTypeImpactZ( d, 260 )
            call SetUnitTypeMaxLife( d, 7000 )
            call SetUnitTypeScale( d, 0.8 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 24 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ABOMINATION_UNIT_ID = 'u007'
            endglobals

            // Abomination
            set d = InitUnitTypeEx( ABOMINATION_UNIT_ID )
            call AddUnitTypeAbility( d, Cannibalism_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodAbomination.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 25 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 7 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 34 )
            call SetUnitTypeEP( d, 22 )
            call SetUnitTypeImpactZ( d, 70 )
            call SetUnitTypeLifeRegeneration( d, 1.4 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 650 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 280 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, Cannibalism_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer NECROMANCER_UNIT_ID = 'u005'
            endglobals

            // Necromancer
            set d = InitUnitTypeEx( NECROMANCER_UNIT_ID )
            call AddUnitTypeAbility( d, RaiseDead_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_UNARMORED )
            call SetUnitTypeAutomaticAbility( d, RaiseDead_SPELL_ID )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodNecromancer.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl" )
            call SetUnitTypeCaster( d )
            call SetUnitTypeDamage( d, 11 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 3 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 22 )
            call SetUnitTypeEP( d, 26 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.4 * REGENERATION_INTERVAL )
            call SetUnitTypeManaRegeneration( d, 0.8 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 270 )
            call SetUnitTypeMaxMana( d, 200 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeStartMana( d, 200 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SKELETON_WARRIOR_UNIT_ID = 'u00B'
            endglobals

            // Skeleton Warrior
            set d = InitUnitTypeEx( SKELETON_WARRIOR_UNIT_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 9 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 2 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 9 )
            call SetUnitTypeEP( d, 10 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 350 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer DARK_KNIGHT_UNIT_ID = 'U009'
            endglobals

            // Dark Knight
            set d = InitUnitTypeEx( DARK_KNIGHT_UNIT_ID )
            call AddUnitTypeAbility( d, UnholyArmor_SPELL_ID )
            call AddUnitTypeAbility( d, VividStrikes_SPELL_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_CHAOS )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            call AddUnitHeroAbility( d, AcidStrike_SPELL_ID )
            call AddUnitHeroAbility( d, FleshBomb_SPELL_ID )
            call AddUnitHeroAbility( d, Metamorphosis_SPELL_ID )
            call AddUnitHeroAbility( d, UtilizationOfRests_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNHeroDeathKnight.blp" )
            call SetUnitTypeImpactZ( d, 115 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, BLACK_KNIGHT_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BLACK_KNIGHT_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BLACK_KNIGHT_PISSED3_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BLACK_KNIGHT_PISSED4_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BLACK_KNIGHT_PISSED5_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BLACK_KNIGHT_PISSED6_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 320 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 12 )
            call SetUnitTypeAgilityPerLevel( d, 0.6 )
            call SetUnitTypeIntelligence( d, 17 )
            call SetUnitTypeIntelligencePerLevel( d, 2.4 )
            call SetUnitTypePrimaryAttribute( d, 1 )
            call SetUnitTypeStrength( d, 23 )
            call SetUnitTypeStrengthPerLevel( d, 3.3 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer LICH_UNIT_ID = 'U00A'
            endglobals

            // Lich
            set d = InitUnitTypeEx( LICH_UNIT_ID )
            call AddUnitTypeAbility( d, FuneralFeast_SPELL_ID )
            call AddUnitTypeAbility( d, SuddenFrost_SPELL_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            call AddUnitHeroAbility( d, IceBall_SPELL_ID )
            call AddUnitHeroAbility( d, LastGrave_SPELL_ID )
            call AddUnitHeroAbility( d, LifeDrain_SPELL_ID )
            call AddUnitHeroAbility( d, ManaTheft_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNHeroLich.blp" )
            call SetUnitTypeImpactZ( d, 69 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, LICH_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, LICH_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, LICH_PISSED3_SOUND_TYPE )
            call AddUnitTypePissedSound( d, LICH_PISSED4_SOUND_TYPE )
            call AddUnitTypePissedSound( d, LICH_PISSED5_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 17 )
            call SetUnitTypeAgilityPerLevel( d, 1.65 )
            call SetUnitTypeIntelligence( d, 20 )
            call SetUnitTypeIntelligencePerLevel( d, 3.45 )
            call SetUnitTypePrimaryAttribute( d, 3 )
            call SetUnitTypeStrength( d, 12 )
            call SetUnitTypeStrengthPerLevel( d, 0.75 )

            call AddUnitTypeResearchTypeId( d, SecondaryTalent_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ZOMBIE_LEVEL1_UNIT_ID = 'n008'
            endglobals

            // Zombie (Level 1)
            set d = InitUnitTypeEx( ZOMBIE_LEVEL1_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 19 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 8 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 22 )
            call SetUnitTypeEP( d, 20 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 240 )
            call SetUnitTypeScale( d, 1.3 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ZOMBIE_LEVEL2_UNIT_ID = 'n009'
            endglobals

            // Zombie (Level 2)
            set d = InitUnitTypeEx( ZOMBIE_LEVEL2_UNIT_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 24 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 3 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 24 )
            call SetUnitTypeEP( d, 21 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 330 )
            call SetUnitTypeScale( d, 1.35 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ZOMBIE_LEVEL3_UNIT_ID = 'n00A'
            endglobals

            // Zombie (Level 3)
            set d = InitUnitTypeEx( ZOMBIE_LEVEL3_UNIT_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 26 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 3 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 26 )
            call SetUnitTypeEP( d, 23 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 410 )
            call SetUnitTypeScale( d, 1.5 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ZOMBIE_LEVEL4_UNIT_ID = 'n02B'
            endglobals

            // Zombie (Level 4)
            set d = InitUnitTypeEx( ZOMBIE_LEVEL4_UNIT_ID )
            call AddUnitTypeAbility( d, Bash_Zombie_Zombie_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 29 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 3 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 28 )
            call SetUnitTypeEP( d, 26 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 480 )
            call SetUnitTypeScale( d, 1.6 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ZOMBIE_LEVEL5_UNIT_ID = 'n02C'
            endglobals

            // Zombie (Level 5)
            set d = InitUnitTypeEx( ZOMBIE_LEVEL5_UNIT_ID )
            call AddUnitTypeAbility( d, Bash_Zombie_Zombie_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 33 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 30 )
            call SetUnitTypeEP( d, 28 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 520 )
            call SetUnitTypeScale( d, 1.7 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_UNDEAD_UNIT_ID = 'u00E'
            endglobals

            // Research Center (Undead, Page 1)
            set d = InitUnitTypeEx( RESEARCH_CENTER_UNDEAD_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UCancelDeath\\UCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_UNDEAD_PAGE_2_UNIT_ID = 'u00G'
            endglobals

            // Research Center (Undead, Page 2)
            set d = InitUnitTypeEx( RESEARCH_CENTER_UNDEAD_PAGE_2_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UCancelDeath\\UCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
        endfunction
    endscope

    scope Nightelf
        public function Nightelf_Init takes nothing returns nothing
            local UnitType d

            globals
                constant integer MOON_WELL_UNIT_ID = 'e008'
            endglobals

            // Moon Well
            set d = InitUnitTypeEx( MOON_WELL_UNIT_ID )
            call AddUnitTypeAbility( d, GHOST_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeUpgradesInstantly( d )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 200)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer NIGHTELF_TIER1_UNIT_ID = 'e000'
            endglobals

            // Nightelf - Tier 1
            set d = InitUnitTypeEx( NIGHTELF_TIER1_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NECancelDeath\\NECancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 4000 )
            call SetUnitTypeScale( d, 0.8 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 12 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ARCHER_UNIT_ID = 'e001'
            endglobals

            // Archer
            set d = InitUnitTypeEx( ARCHER_UNIT_ID )
            call AddUnitTypeAbility( d, ShadowMeld_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodArcher.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NightElfSmallDeathExplode\\NightElfSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 13 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 3 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 21 )
            call SetUnitTypeEP( d, 26 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.7 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 280 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer NIGHTELF_TIER2_UNIT_ID = 'e002'
            endglobals

            // Nightelf - Tier 2
            set d = InitUnitTypeEx( NIGHTELF_TIER2_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NECancelDeath\\NECancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1250 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 5000 )
            call SetUnitTypeScale( d, 0.95 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 16 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer HUNTRESS_UNIT_ID = 'e003'
            endglobals

            // Huntress
            set d = InitUnitTypeEx( HUNTRESS_UNIT_ID )
            call AddUnitTypeAbility( d, AttackDerivation_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_UNARMORED )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodHuntress.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NightElfSmallDeathExplode\\NightElfSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 15 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 2 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 26 )
            call SetUnitTypeEP( d, 29 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.8 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 480 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 330 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, AttackDerivation_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer NIGHTELF_TIER3_UNIT_ID = 'e004'
            endglobals

            // Nightelf - Tier 3
            set d = InitUnitTypeEx( NIGHTELF_TIER3_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NECancelDeath\\NECancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1750 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 6000 )
            call SetUnitTypeScale( d, 0.95 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 20 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer DRYAD_UNIT_ID = 'e005'
            endglobals

            // Dryad
            set d = InitUnitTypeEx( DRYAD_UNIT_ID )
            call AddUnitTypeAbility( d, Neutralization_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_UNARMORED )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodDryad.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NightElfSmallDeathExplode\\NightElfSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 10 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 3 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 20 )
            call SetUnitTypeEP( d, 20 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.8 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 460 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpawnBonus( d, 1 )
            call SetUnitTypeSpeed( d, 350 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, Neutralization_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer NIGHTELF_TIER4_UNIT_ID = 'e006'
            endglobals

            // Nightelf - Tier 4
            set d = InitUnitTypeEx( NIGHTELF_TIER4_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NECancelDeath\\NECancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 2250 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 7000 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 24 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MOUNTAIN_GIANT_UNIT_ID = 'e007'
            endglobals

            // Mountain Giant
            set d = InitUnitTypeEx( MOUNTAIN_GIANT_UNIT_ID )
            call AddUnitTypeAbility( d, SelfHeal_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDamage( d, 20 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 7 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 35 )
            call SetUnitTypeEP( d, 36 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 845 )
            call SetUnitTypeScale( d, 0.7 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer DRUID_OF_THE_TALON_UNIT_ID = 'e00H'
            endglobals

            // Druid of the Talon
            set d = InitUnitTypeEx( DRUID_OF_THE_TALON_UNIT_ID )
            call AddUnitTypeAbility( d, VioletDefense_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_UNARMORED )
            call SetUnitTypeAutomaticAbility( d, VioletDefense_SPELL_ID )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodDruidoftheTalon.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NightElfLargeDeathExplode\\NightElfLargeDeathExplode.mdl" )
            call SetUnitTypeCaster( d )
            call SetUnitTypeDamage( d, 9 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 20 )
            call SetUnitTypeEP( d, 24 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.4 * REGENERATION_INTERVAL )
            call SetUnitTypeManaRegeneration( d, 0.9 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 225 )
            call SetUnitTypeMaxMana( d, 200 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 285 )
            call SetUnitTypeStartMana( d, 135 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer BOTANIST_UNIT_ID = 'E00A'
            endglobals

            // Botanist
            set d = InitUnitTypeEx( BOTANIST_UNIT_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodHeroKeeperoftheGrove.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NightElfSmallDeathExplode\\NightElfSmallDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            call AddUnitHeroAbility( d, Fertilizer_SPELL_ID )
            call AddUnitHeroAbility( d, NaturalEmbrace_SPELL_ID )
            //call AddUnitHeroAbility( d, TonelessMist_SPELL_ID )
            call AddUnitHeroAbility( d, WonderSeeds_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNKeeperOfTheGroove.blp" )
            call SetUnitTypeImpactZ( d, 69 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, BOTANIST_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BOTANIST_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BOTANIST_PISSED3_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BOTANIST_PISSED4_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BOTANIST_PISSED5_SOUND_TYPE )
            call AddUnitTypePissedSound( d, BOTANIST_PISSED6_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 320 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 15 )
            call SetUnitTypeAgilityPerLevel( d, 0.75 )
            call SetUnitTypeIntelligence( d, 18 )
            call SetUnitTypeIntelligencePerLevel( d, 1.35 )
            call SetUnitTypePrimaryAttribute( d, 3 )
            call SetUnitTypeStrength( d, 16 )
            call SetUnitTypeStrengthPerLevel( d, 0.9 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer TREANT_UNIT_ID = 'e00B'
            endglobals

            // Treant
            set d = InitUnitTypeEx( TREANT_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeDamage( d, 14 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 3 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 15 )
            call SetUnitTypeEP( d, 15 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.7 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeSpeed( d, 320 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer HEADHUNTRESS_UNIT_ID = 'E00C'
            endglobals

            // Headhuntress
            set d = InitUnitTypeEx( HEADHUNTRESS_UNIT_ID )
            call AddUnitTypeAbility( d, KidneyShot_SPELL_ID )
            call AddUnitTypeAbility( d, Libertine_SPELL_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodHeroMoonPriestess.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NightElfSmallDeathExplode\\NightElfSmallDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            call AddUnitHeroAbility( d, Barrage_SPELL_ID )
            call AddUnitHeroAbility( d, EasyPrey_SPELL_ID )
            call AddUnitHeroAbility( d, KittyJump_SPELL_ID )
            call AddUnitHeroAbility( d, SpellDisconnection_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNPriestessOfTheMoon.blp" )
            call SetUnitTypeImpactZ( d, 69 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, HEADHUNTRESS_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, HEADHUNTRESS_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, HEADHUNTRESS_PISSED3_SOUND_TYPE )
            call AddUnitTypePissedSound( d, HEADHUNTRESS_PISSED4_SOUND_TYPE )
            call AddUnitTypePissedSound( d, HEADHUNTRESS_PISSED5_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 320 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 21 )
            call SetUnitTypeAgilityPerLevel( d, 3.15 )
            call SetUnitTypeIntelligence( d, 14 )
            call SetUnitTypeIntelligencePerLevel( d, 1.2 )
            call SetUnitTypePrimaryAttribute( d, 2 )
            call SetUnitTypeStrength( d, 17 )
            call SetUnitTypeStrengthPerLevel( d, 2.2 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_NIGHTELF_UNIT_ID = 'e00G'
            endglobals

            // Research Center (Nightelf, Page 1)
            set d = InitUnitTypeEx( RESEARCH_CENTER_NIGHTELF_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NECancelDeath\\NECancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_NIGHTELF_PAGE_2_UNIT_ID = 'e00I'
            endglobals

            // Research Center (Nightelf, Page 2)
            set d = InitUnitTypeEx( RESEARCH_CENTER_NIGHTELF_PAGE_2_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NECancelDeath\\NECancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
        endfunction
    endscope

    scope Naga
        public function Naga_Init takes nothing returns nothing
            local UnitType d

            globals
                constant integer CORAL_BED_UNIT_ID = 'n01R'
            endglobals

            // Coral Bed
            set d = InitUnitTypeEx( CORAL_BED_UNIT_ID )
            call AddUnitTypeAbility( d, GHOST_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeUpgradesInstantly( d )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 200)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer NAGA_TIER1_UNIT_ID = 'n01S'
            endglobals

            // Naga - Tier 1
            set d = InitUnitTypeEx( NAGA_TIER1_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeMaxLife( d, 4000 )
            call SetUnitTypeScale( d, 0.8 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeStartMana( d, 40 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 12 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MURGUL_REAVER_UNIT_ID = 'n030'
            endglobals

            // Murgul Reaver
            set d = InitUnitTypeEx( MURGUL_REAVER_UNIT_ID )
            call AddUnitTypeAbility( d, Feedback_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonSmallDeathExplode\\DemonSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 10 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 2 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 28 )
            call SetUnitTypeDrop( d, 26 )
            call SetUnitTypeEP( d, 29 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.75 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 420 )
            call SetUnitTypeScale( d, 1.2 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 230, 230, 230, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, Feedback_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer NAGA_TIER2_UNIT_ID = 'n01T'
            endglobals

            // Naga - Tier 2
            set d = InitUnitTypeEx( NAGA_TIER2_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1250 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 5000 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 16 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer DRAGON_TURTLE_UNIT_ID = 'n01X'
            endglobals

            // Dragon Turtle
            set d = InitUnitTypeEx( DRAGON_TURTLE_UNIT_ID )
            call AddUnitTypeAbility( d, ToadReflection_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodHellScream.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcLargeDeathExplode\\OrcLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 19 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 7 )
            call SetUnitTypeDamageType( d, DMG_TYPE_SIEGE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 27 )
            call SetUnitTypeEP( d, 28 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1.2 * REGENERATION_INTERVAL )
            call SetUnitTypeMelee( d )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.7 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer NAGA_TIER3_UNIT_ID = 'n01U'
            endglobals

            // Naga - Tier 3
            set d = InitUnitTypeEx( NAGA_TIER3_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1750 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 6000 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 20 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MYRMIDON_UNIT_ID = 'n01Y'
            endglobals

            // Myrmidon
            set d = InitUnitTypeEx( MYRMIDON_UNIT_ID )
            call AddUnitTypeAbility( d, Slam_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodTauren.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 12 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 30 )
            call SetUnitTypeEP( d, 33 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 3 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 565 )
            call SetUnitTypeScale( d, 0.9 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 320 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer NAGA_TIER4_UNIT_ID = 'n01V'
            endglobals

            // Naga - Tier 4
            set d = InitUnitTypeEx( NAGA_TIER4_UNIT_ID )
            call AddUnitTypeAbility( d, AdvancedTraining_SPELL_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 2250 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 7000 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 1000 )
            call AddShopUnitSupply( d, RESERVE_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeSupplyProduced( d, 24 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SNAP_DRAGON_UNIT_ID = 'n01Z'
            endglobals

            // Snap Dragon
            set d = InitUnitTypeEx( SNAP_DRAGON_UNIT_ID )
            call AddUnitTypeAbility( d, SlowPoison_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LIGHT )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodGrunt.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 21 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 7 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 31 )
            call SetUnitTypeEP( d, 32 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 480 )
            call SetUnitTypeScale( d, 0.95 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            call AddUnitTypeResearchTypeId( d, SlowPoison_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SIREN_UNIT_ID = 'n01W'
            endglobals

            // Siren
            set d = InitUnitTypeEx( SIREN_UNIT_ID )
            call AddUnitTypeAbility( d, BubbleArmor_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_UNARMORED )
            call SetUnitTypeAutomaticAbility( d, BubbleArmor_SPELL_ID )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodWitchDoctor.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeCaster( d )
            call SetUnitTypeDamage( d, 9 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 20 )
            call SetUnitTypeEP( d, 24 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.4 * REGENERATION_INTERVAL )
            call SetUnitTypeManaRegeneration( d, 0.6 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 290 )
            call SetUnitTypeMaxMana( d, 120 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeStartMana( d, 120 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 1 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_NAGA_UNIT_ID = 'h00P'
            endglobals

            // Research Center (Naga, Page 1)
            set d = InitUnitTypeEx( RESEARCH_CENTER_NAGA_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESEARCH_CENTER_NAGA_PAGE_2_UNIT_ID = 'h012'
            endglobals

            // Research Center (Naga, Page 2)
            set d = InitUnitTypeEx( RESEARCH_CENTER_NAGA_PAGE_2_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Naga\\NagaDeath\\NagaDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
        endfunction
    endscope

    scope Miscellaneous
        public function Miscellaneous_Init takes nothing returns nothing
            local UnitType d

            globals
                constant integer TAVERN_UNIT_ID = 'n01K'
            endglobals

            // Tavern
            set d = InitUnitTypeEx( TAVERN_UNIT_ID )
            call AddUnitTypeAbility( d, GHOST_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeUpgradesInstantly( d )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 200)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer FOUNTAIN_UNIT_ID = 'n000'
            endglobals

            // Fountain
            set d = InitUnitTypeEx( FOUNTAIN_UNIT_ID )
            call AddUnitTypeAbility( d, BUY_SHOP_ITEM_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call AddUnitTypeAbility( d, ManaRegenerationAuraNeutral_SPELL_ID )
            call AddUnitTypeAbility( d, MightAura_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.4 )
            call AddShopUnitSupply( d, ShopInformation_UNIT_ID )
            call AddShopItemSupply( d, ChaosSword_SET_ITEM_ID )
            call AddShopItemSupply( d, FrostArmor_SET_ITEM_ID )
            call AddShopItemSupply( d, HealingWard_ITEM_ID )
            call AddShopItemSupply( d, HeartOfTheHards_SET_ITEM_ID )
            call AddShopItemSupply( d, LifeArmor_SET_ITEM_ID )
            call AddShopItemSupply( d, MedaillonOfTheStrivingGod_SET_ITEM_ID )
            call AddShopItemSupply( d, MightyHammer_SET_ITEM_ID )
            call AddShopItemSupply( d, Nethermask_SET_ITEM_ID )
            call AddShopItemSupply( d, PrismaticCape_SET_ITEM_ID )
            call AddShopItemSupply( d, SuperCarrot_ITEM_ID )
            call AddShopItemSupply( d, WindBoots_SET_ITEM_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer GOBLIN_SHOP_UNIT_ID = 'h00R'
            endglobals

            // Goblin Shop
            set d = InitUnitTypeEx( GOBLIN_SHOP_UNIT_ID )
            call AddUnitTypeAbility( d, BUY_SHOP_ITEM_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call AddUnitTypeAbility( d, SHARED_CONTROL_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 500 )
            call AddShopUnitSupply( d, ShopInformation_UNIT_ID )
            call AddShopItemSupply( d, ChimeraEgg_ITEM_ID )
            call AddShopItemSupply( d, ElixirOfTheGrowth_ITEM_ID )
            //call AddShopItemSupply( d, FriendshipBracelet_ITEM_ID )
            call AddShopItemSupply( d, HealingPotion_ITEM_ID )
            call AddShopItemSupply( d, HealingPotionBloodOrange_ITEM_ID )
            call AddShopItemSupply( d, MecaPenguin_ITEM_ID )
            call AddShopItemSupply( d, ScrollOfRage_ITEM_ID )
            call AddShopItemSupply( d, SpiderEgg_ITEM_ID )
            call AddShopItemSupply( d, StaffOfAbolition_ITEM_ID )
            call AddShopItemSupply( d, TownPortal_ITEM_ID )
            call AddShopItemSupply( d, VolatileManaPotion_ITEM_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

           globals
                constant integer WORKSHOP_UNIT_ID = 'h010'
            endglobals

            // Workshop
            set d = InitUnitTypeEx( WORKSHOP_UNIT_ID )
            call AddUnitTypeAbility( d, BUY_SHOP_ITEM_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call AddUnitTypeAbility( d, SHARED_CONTROL_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 500 )
            call AddShopUnitSupply( d, ShopInformation_UNIT_ID )
            call AddShopItemSupply( d, CamouflageSuit_ITEM_ID )
            call AddShopItemSupply( d, ElectroNet_ITEM_ID )
            call AddShopUnitSupply( d, GLAIVE_THROWER_UNIT_ID )
            call AddShopItemSupply( d, Lens_ITEM_ID )
            call AddShopUnitSupply( d, SIEGE_TIN_UNIT_ID )
            call AddShopItemSupply( d, Trap_ITEM_ID )
            call AddShopUnitSupply( d, WORKER_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SECONDHAND_DEALER_UNIT_ID = 'o00H'
            endglobals

            // Secondhand Dealer
            set d = InitUnitTypeEx( SECONDHAND_DEALER_UNIT_ID )
            call AddUnitTypeAbility( d, BUY_SHOP_ITEM_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 500 )
            call AddShopUnitSupply( d, ShopInformation_UNIT_ID )
            call AddShopItemSupply( d, AstralGauntlets_ITEM_ID )
            call AddShopItemSupply( d, BeltOfTheCelt_ITEM_ID )
            call AddShopItemSupply( d, FenixsFeather_ITEM_ID )
            call AddShopItemSupply( d, FlyingSheep_ITEM_ID )
            call AddShopItemSupply( d, FrozenShard_ITEM_ID )
            call AddShopItemSupply( d, GexxoSlippers_ITEM_ID )
            call AddShopItemSupply( d, GoldenRing_ITEM_ID )
            call AddShopItemSupply( d, Lollipop_MANUFACTURED_ITEM_ID )
            call AddShopItemSupply( d, IllusionaryStaff_ITEM_ID )
            call AddShopItemSupply( d, RobeOfThePope_ITEM_ID )
            call AddShopItemSupply( d, SpidermanSocks_ITEM_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MARKET_UNIT_ID = 'h00W'
            endglobals

            // Market
            set d = InitUnitTypeEx( MARKET_UNIT_ID )
            call AddUnitTypeAbility( d, BUY_SHOP_ITEM_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1 )
            call AddShopUnitSupply( d, ShopInformation_UNIT_ID )
            call AddShopItemSupply( d, CareBear_ITEM_ID )
            call AddShopItemSupply( d, GiantAxe_ITEM_ID )
            call AddShopItemSupply( d, GloveOfTheBeast_ITEM_ID )
            call AddShopItemSupply( d, HeartStone_ITEM_ID )
            call AddShopItemSupply( d, JeweledDaggerOfGreed_ITEM_ID )
            call AddShopItemSupply( d, OrbOfWisdom_ITEM_ID )
            call AddShopItemSupply( d, PotionOfTheInconspicuousShape_ITEM_ID )
            call AddShopItemSupply( d, RegenerationPotion_ITEM_ID )
            call AddShopItemSupply( d, RhythmicDrum_ITEM_ID )
            call AddShopItemSupply( d, Trident_ITEM_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer FANATICAL_MECHANICIAN_UNIT_ID = 'N016'
            endglobals

            // FanaticalMechanician
            set d = InitUnitTypeEx( FANATICAL_MECHANICIAN_UNIT_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanLargeDeathExplode\\HumanLargeDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            //call AddUnitHeroAbility( d, BattleGolem_SPELL_ID )
            //call AddUnitHeroAbility( d, BlastFurnace_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNHeroTinker.blp" )
            call SetUnitTypeImpactZ( d, 69 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, FANATICAL_MECHANIC_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, FANATICAL_MECHANIC_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, FANATICAL_MECHANIC_PISSED3_SOUND_TYPE )
            call AddUnitTypePissedSound( d, FANATICAL_MECHANIC_PISSED4_SOUND_TYPE )
            call AddUnitTypePissedSound( d, FANATICAL_MECHANIC_PISSED5_SOUND_TYPE )
            call AddUnitTypePissedSound( d, FANATICAL_MECHANIC_PISSED6_SOUND_TYPE )
            call AddUnitTypePissedSound( d, FANATICAL_MECHANIC_PISSED7_SOUND_TYPE )
            call AddUnitTypePissedSound( d, FANATICAL_MECHANIC_PISSED8_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 300 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 7 )
            call SetUnitTypeAgilityPerLevel( d, 1 )
            call SetUnitTypeIntelligence( d, 18 )
            call SetUnitTypeIntelligencePerLevel( d, 2 )
            call SetUnitTypePrimaryAttribute( d, 3 )
            call SetUnitTypeStrength( d, 24 )
            call SetUnitTypeStrengthPerLevel( d, 3 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer BATTLE_GOLEM_LEVEL1_UNIT_ID = 'n018'
            endglobals

            // Battle Golem (Level 1)
            set d = InitUnitTypeEx( BATTLE_GOLEM_LEVEL1_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDamage( d, 15 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeSpeed( d, 160 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer BATTLE_GOLEM_LEVEL2_UNIT_ID = 'n019'
            endglobals

            // Battle Golem (Level 2)
            set d = InitUnitTypeEx( BATTLE_GOLEM_LEVEL2_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDamage( d, 20 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 700 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeSpeed( d, 160 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer BATTLE_GOLEM_LEVEL3_UNIT_ID = 'n01A'
            endglobals

            // Battle Golem (Level 3)
            set d = InitUnitTypeEx( BATTLE_GOLEM_LEVEL3_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDamage( d, 25 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 900 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeSpeed( d, 160 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer FLAG_UNIT_ID = 'n003'
            endglobals

            // Flag
            set d = InitUnitTypeEx( FLAG_UNIT_ID )
            call AddUnitTypeAbility( d, LifeRegenerationAura_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 1 )
            call SetUnitTypeMaxLife( d, 1500 )
            call SetUnitTypeScale( d, 2.5 )
            call SetUnitTypeSightRange( d, 1000 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer WORKER_UNIT_ID = 'h00M'
            endglobals

            // Worker
            set d = InitUnitTypeEx( WORKER_UNIT_ID )
            //call AddUnitTypeAbility( d, HARVESTING_SPELL_ID )
            call AddUnitTypeAbility( d, REPAIR_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodFootman.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 15 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 2 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 25 )
            call SetUnitTypeEP( d, 10 )
            call SetUnitTypeGoldCost( d, 125 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.5 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 165 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeShopMaxCharges( d, 3 )
            call SetUnitTypeShopRefreshInterval( d, 15 )
            call SetUnitTypeShopRefreshIntervalStart( d, 15 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 210, 210, 210, 255)
            call SetUnitTypeSupplyUsed( d, 0 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MERCENARY_CAMP_UNIT_ID = 'n00I'
            endglobals

            // Mercenary Camp
            set d = InitUnitTypeEx( MERCENARY_CAMP_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 0.8 )
            call AddShopItemSupply( d, ShopInformation_ITEM_ID )
            call AddShopUnitSupply( d, ADJUTANT_UNIT_ID )
            call AddShopUnitSupply( d, BATTLE_SHIP_UNIT_ID )
            call AddShopUnitSupply( d, DIRE_WOLF_UNIT_ID )
            call AddShopUnitSupply( d, DOJO_THE_MOJO_UNIT_ID )
            call AddShopUnitSupply( d, DWARVES_UNIT_ID )
            call AddShopUnitSupply( d, FRIENDLY_WOMAN_UNIT_ID )
            call AddShopUnitSupply( d, ICE_TROLL_PRIEST_UNIT_ID )
            call AddShopUnitSupply( d, OGRE_BRAT_UNIT_ID )
            call AddShopUnitSupply( d, SILVER_TAIL_UNIT_ID )
            call AddShopUnitSupply( d, TAUREN_UNIT_ID )
            call AddShopUnitSupply( d, TUSKAR_UNIT_ID )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer TRAVELLING_TRADER_UNIT_ID = 'N00L'
            endglobals

            // Travelling Trader
            set d = InitUnitTypeEx( TRAVELLING_TRADER_UNIT_ID )
            call AddUnitTypeAbility( d, EmployHenchman_SPELL_ID )
            call AddUnitTypeAbility( d, EsteemInCoins_SPELL_ID )
            call SetUnitTypeArmor( d, -2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Other\\HumanBloodCinematicEffect\\HumanBloodCinematicEffect.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanLargeDeathExplode\\HumanLargeDeathExplode.mdl" )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeEP( d, 50 )
            call AddUnitHeroAbility( d, CrowdPuller_SPELL_ID )
            call AddUnitHeroAbility( d, FieryBoots_ACTIVATION_SPELL_ID )
            call AddUnitHeroAbility( d, Payday_SPELL_ID )
            call AddUnitHeroAbility( d, Sales_SPELL_ID )
            call SetUnitTypeImage( d, "ReplaceableTextures\\CommandButtons\\BTNHeroAlchemist.blp" )
            call SetUnitTypeImpactZ( d, 69 )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeMaxMana( d, 100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 800 )
            call AddUnitTypePissedSound( d, TRAVELLING_TRADER_PISSED_SOUND_TYPE )
            call AddUnitTypePissedSound( d, TRAVELLING_TRADER_PISSED2_SOUND_TYPE )
            call AddUnitTypePissedSound( d, TRAVELLING_TRADER_PISSED3_SOUND_TYPE )
            call AddUnitTypePissedSound( d, TRAVELLING_TRADER_PISSED4_SOUND_TYPE )
            call AddUnitTypePissedSound( d, TRAVELLING_TRADER_PISSED5_SOUND_TYPE )
            call AddUnitTypePissedSound( d, TRAVELLING_TRADER_PISSED6_SOUND_TYPE )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call SetUnitTypeAgility( d, 16 )
            call SetUnitTypeAgilityPerLevel( d, 1.95 )
            call SetUnitTypeIntelligence( d, 15 )
            call SetUnitTypeIntelligencePerLevel( d, 1.5 )
            call SetUnitTypePrimaryAttribute( d, 1 )
            call SetUnitTypeStrength( d, 19 )
            call SetUnitTypeStrengthPerLevel( d, 2.7 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MASTER_WIZARD_UNIT_ID = 'n00M'
            endglobals

            // Master Wizard
            set d = InitUnitTypeEx( MASTER_WIZARD_UNIT_ID )
            call AddUnitTypeAbility( d, CashDiscount_SPELL_ID )
            call AddUnitTypeAbility( d, ChainLightning_SPELL_ID )
            call AddUnitTypeAbility( d, DivineShield_SPELL_ID )
            call AddUnitTypeAbility( d, Downgrade_SPELL_ID )
            call AddUnitTypeAbility( d, EarlyPromotion_SPELL_ID )
            call AddUnitTypeAbility( d, Harmagedon2_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call AddUnitTypeAbility( d, PoisonFountain_SPELL_ID )
            call AddUnitTypeAbility( d, RequestReinforcements_SPELL_ID )
            call AddUnitTypeAbility( d, STOP_EX_SPELL_ID )
            call AddUnitTypeAbility( d, SummonFaust_SPELL_ID )
            call AddUnitTypeAbility( d, SummonPeq_SPELL_ID )
            //call AddUnitTypeAbility( d, SwitchShops_SPELL_ID )
            call SetUnitTypeImpactZ( d, 100 )
            call SetUnitTypeManaRegeneration( d, 2 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeMaxMana( d, 1000 )
            call SetUnitTypeScale( d, 1.5 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeStartMana( d, 100 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer POISONED_FOUNTAIN_UNIT_ID = 'n00O'
            endglobals

            // Poisoned Fountain
            set d = InitUnitTypeEx( POISONED_FOUNTAIN_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ALTAR_UNIT_ID = 'n00T'
            endglobals

            // Altar
            set d = InitUnitTypeEx( ALTAR_UNIT_ID )
            call AddUnitTypeAbility( d, GHOST_SPELL_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call SetUnitTypeMaxLife( d, 150000 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeUpgradesInstantly( d )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 200)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer CATAPULT_UNIT_ID = 'o00G'
            endglobals

            // Catapult
            set d = InitUnitTypeEx( CATAPULT_UNIT_ID )
            call AddUnitTypeAbility( d, ArtilleryAttack_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDamage( d, 35 )
            call SetUnitTypeDamageDices( d, 9 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 50 )
            call SetUnitTypeGoldCost( d, 450 )
            call SetUnitTypeImpactZ( d, 25 )
            call SetUnitTypeMaxLife( d, 800 )
            call SetUnitTypeMissileArc( d, 0.8 )
            call SetUnitTypeMissileDummyUnitId( d, 'n026' )
            call SetUnitTypeMissileSpeed( d, 1100 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 400 )
            call SetUnitTypeSpecialAttack( d )
            call SetUnitTypeSplash( d )
            call SetUnitTypeSplashAffectionAlly( d )
            call SetUnitTypeSplashAffectionEnemy( d )
            call SetUnitTypeSplashAffectionGround( d )
            call SetUnitTypeSplashAreaRange( d, 450 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer CHIMERA_UNIT_ID = 'e009'
            endglobals

            // Chimera
            set d = InitUnitTypeEx( CHIMERA_UNIT_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodChimaera.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDamage( d, 36 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 8 )
            call SetUnitTypeDamageType( d, DMG_TYPE_SIEGE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 65 )
            call SetUnitTypeEP( d, 50 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 1400 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeSightRange( d, 700 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeSplash( d )
            call SetUnitTypeSplashAffectionAlly( d )
            call SetUnitTypeSplashAffectionEnemy( d )
            call SetUnitTypeSplashAffectionGround( d )
            call SetUnitTypeSplashAreaRange( d, 400 )
            call SetUnitTypeSplashDamageFactor( d, 0.7 )
            call SetUnitTypeSplashWindowAngle( d, 360 * RAD_TO_DEG )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SPOUT_SPIDER_UNIT_ID = 'n00H'
            endglobals

            // Spout Spider
            set d = InitUnitTypeEx( SPOUT_SPIDER_UNIT_ID )
            call AddUnitTypeAbility( d, LayEgg_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodCryptFiend.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 27 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 37 )
            call SetUnitTypeEP( d, 30 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1.7 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 800 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer OGRE_BRAT_UNIT_ID = 'n00J'
            endglobals

            // Ogre Brat
            set d = InitUnitTypeEx( OGRE_BRAT_UNIT_ID )
            call AddUnitTypeAbility( d, Bash_OgreBrat_OgreBrat_SPELL_ID )
            call AddUnitTypeAbility( d, ShockWave_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodKnight.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 24 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 7 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 48 )
            call SetUnitTypeEP( d, 44 )
            call SetUnitTypeGoldCost( d, 400 )
            call SetUnitTypeImpactZ( d, 100 )
            call SetUnitTypeLifeRegeneration( d, 2 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 1300 )
            call SetUnitTypeScale( d, 1.65 )
            call SetUnitTypeShopMaxCharges( d, 1 )
            call SetUnitTypeShopRefreshInterval( d, 100 )
            call SetUnitTypeShopRefreshIntervalStart( d, 220 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 255, 160, 160, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ICE_TROLL_PRIEST_UNIT_ID = 'n00K'
            endglobals

            // Ice Troll Priest
            set d = InitUnitTypeEx( ICE_TROLL_PRIEST_UNIT_ID )
            call AddUnitTypeAbility( d, FrostBolt_SPELL_ID )
            call AddUnitTypeAbility( d, Heal_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeAutomaticAbility( d, Heal_SPELL_ID )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodWitchDoctor.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 16 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 8 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 28 )
            call SetUnitTypeEP( d, 20 )
            call SetUnitTypeGoldCost( d, 200 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.5 * REGENERATION_INTERVAL )
            call SetUnitTypeManaRegeneration( d, 0.75 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 750 )
            call SetUnitTypeMaxMana( d, 200 )
            call SetUnitTypeScale( d, 1.5 )
            call SetUnitTypeShopMaxCharges( d, 2 )
            call SetUnitTypeShopRefreshInterval( d, 50 )
            call SetUnitTypeShopRefreshIntervalStart( d, 150 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeStartMana( d, 100 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeVertexColor(d, 190, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer DOJO_THE_MOJO_UNIT_ID = 'n00Z'
            endglobals

            // Dojo the Mojo
            set d = InitUnitTypeEx( DOJO_THE_MOJO_UNIT_ID )
            call AddUnitTypeAbility( d, DiversionaryTactics_SPELL_ID )
            call AddUnitTypeAbility( d, Riposte_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodWitchDoctor.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 17 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_CHAOS )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 80 )
            call SetUnitTypeEP( d, 60 )
            call SetUnitTypeGoldCost( d, 600 )
            call SetUnitTypeImpactZ( d, 100 )
            call SetUnitTypeLifeRegeneration( d, 2.5 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 2250 )
            call SetUnitTypeScale( d, 1.45 )
            call SetUnitTypeShopMaxCharges( d, 1 )
            call SetUnitTypeShopRefreshInterval( d, 100 )
            call SetUnitTypeShopRefreshIntervalStart( d, 220 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 320 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)


            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer TAUREN_UNIT_ID = 'o00I'
            endglobals

            // Tauren
            set d = InitUnitTypeEx( TAUREN_UNIT_ID )
            call AddUnitTypeAbility( d, Reincarnation_SPELL_ID )
            call SetUnitTypeArmor( d, 3 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodTauren.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcLargeDeathExplode\\OrcLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 49 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 13 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 46 )
            call SetUnitTypeEP( d, 68 )
            call SetUnitTypeGoldCost( d, 500 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 3 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 1450 )
            call SetUnitTypeScale( d, 1.2 )
            call SetUnitTypeShopMaxCharges( d, 1 )
            call SetUnitTypeShopRefreshInterval( d, 40 )
            call SetUnitTypeShopRefreshIntervalStart( d, 300 )
            call SetUnitTypeSightRange( d, 430 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeSpeed( d, 260 )
            call SetUnitTypeSplash( d )
            call SetUnitTypeSplashAffectionEnemy( d )
            call SetUnitTypeSplashAffectionGround( d )
            call SetUnitTypeSplashDamageFactor( d, 1 )
            call SetUnitTypeSplashAreaRange( d, 200 )
            call SetUnitTypeSplashWindowAngle( d, 360 * RAD_TO_DEG )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer FAUST_UNIT_ID = 'n00N'
            endglobals

            // Faust
            set d = InitUnitTypeEx( FAUST_UNIT_ID )
            call AddUnitTypeAbility( d, SHARED_CONTROL_SPELL_ID )
            call AddUnitTypeAbility( d, SummonFaust_AttackGraphic_AttackGraphic_SPELL_ID )
            call SetUnitTypeArmor( d, 8 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodAbomination.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 45 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 7 )
            call SetUnitTypeDamageType( d, DMG_TYPE_CHAOS )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 200 )
            call SetUnitTypeEP( d, 100 )
            call SetUnitTypeImpactZ( d, 135 )
            call SetUnitTypeLifeRegeneration( d, -9 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 3000 )
            call SetUnitTypeScale( d, 0.25 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeSplash( d )
            call SetUnitTypeSplashAffectionAir( d )
            call SetUnitTypeSplashAffectionEnemy( d )
            call SetUnitTypeSplashAffectionGround( d )
            call SetUnitTypeSplashDamageFactor( d, 0.6 )
            call SetUnitTypeSplashAreaRange( d, 250 )
            call SetUnitTypeSplashWindowAngle( d, 250 * RAD_TO_DEG )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer LIGHTNING_TOWER_UNIT_ID = 'o00F'
            endglobals

            // Lightning Tower
            set d = InitUnitTypeEx( LIGHTNING_TOWER_UNIT_ID )
            call AddUnitTypeAbility( d, LightningAttack_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDamage( d, 30 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 45 )
            call SetUnitTypeGoldCost( d, 550 )
            call SetUnitTypeImpactZ( d, 80 )
            call SetUnitTypeMaxLife( d, 1200 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeSpecialAttack( d )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer GOLD_TOWER_UNIT_ID = 'h00C'
            endglobals

            // Gold Tower
            set d = InitUnitTypeEx( GOLD_TOWER_UNIT_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 10 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeMaxLife( d, 500 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 300 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer GUARD_TOWER_NEW_BUILD_UNIT_ID = 'h00D'
            endglobals

            // Guard Tower (New Build)
            set d = InitUnitTypeEx( GUARD_TOWER_NEW_BUILD_UNIT_ID )
            call AddUnitTypeAbility( d, SHARED_CONTROL_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDamage( d, 20 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 250 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeLifeRegeneration( d, 1 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 700 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer GUARD_TOWER_UPGRADE_UNIT_ID = 'h00S'
            endglobals

            // Guard Tower (Upgrade)
            set d = InitUnitTypeEx( GUARD_TOWER_UPGRADE_UNIT_ID )
            call AddUnitTypeAbility( d, SHARED_CONTROL_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDamage( d, 20 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 250 )
            call SetUnitTypeImpactZ( d, 120 )
            call SetUnitTypeLifeRegeneration( d, 1 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 700 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MECA_PENGUIN_UNIT_ID = 'n00G'
            endglobals

            // Meca Penguin
            set d = InitUnitTypeEx( MECA_PENGUIN_UNIT_ID )
            call SetUnitTypeDecay( d )
            call SetUnitTypeMaxLife( d, 100 )
            call SetUnitTypeScale( d, 1.5 )
            call SetUnitTypeSpeed( d, 170 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MYSTICAL_TOWER_UNIT_ID = 'h00Q'
            endglobals

            // Mystical Tower
            set d = InitUnitTypeEx( MYSTICAL_TOWER_UNIT_ID )
            call AddUnitTypeAbility( d, MysticalAttack_SPELL_ID )
            call SetUnitTypeArmor( d, 10 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HCancelDeath\\HCancelDeath.mdl" )
            call SetUnitTypeDamage( d, 9 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 100 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 1000 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer PEQ_UNIT_ID = 'n01G'
            endglobals

            // Peq
            set d = InitUnitTypeEx( PEQ_UNIT_ID )
            call AddUnitTypeAbility( d, CripplingWave_SPELL_ID )
            call AddUnitTypeAbility( d, SHARED_CONTROL_SPELL_ID )
            call AddUnitTypeAbility( d, SummonPeqqiBeast_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_HERO )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodAbomination.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 33 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 250 )
            call SetUnitTypeEP( d, 150 )
            call SetUnitTypeImpactZ( d, 135 )
            call SetUnitTypeLifeRegeneration( d, -11 * REGENERATION_INTERVAL )
            call SetUnitTypeManaRegeneration( d, 3 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 2500 )
            call SetUnitTypeMaxMana( d, 1000 )
            call SetUnitTypeScale( d, 0.35 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeStartMana( d, 1000 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer PEQQI_BEAST_UNIT_ID = 'n001'
            endglobals

            // Peqqi Beast
            set d = InitUnitTypeEx( PEQQI_BEAST_UNIT_ID )
            call AddUnitTypeAbility( d, SHARED_CONTROL_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodGargoyle.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 10 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDrop( d, 15 )
            call SetUnitTypeEP( d, 15 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.65 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 300 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SILVER_TAIL_UNIT_ID = 'e00F'
            endglobals

            // Silver Tail
            set d = InitUnitTypeEx( SILVER_TAIL_UNIT_ID )
            call AddUnitTypeAbility( d, Evasion_SILVER_TAIL_SPELL_ID )
            call AddUnitTypeAbility( d, SilverSpores_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LIGHT )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\NightElf\\NightElfBlood\\NightElfBloodHippogryph.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\NightElf\\NightElfLargeDeathExplode\\NightElfLargeDeathExplode.mdl" )
            call SetUnitTypeCanNotBeRevived(d)
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 20 )
            call SetUnitTypeEP( d, 20 )
            call SetUnitTypeGoldCost( d, 150 )
            call SetUnitTypeImpactZ( d, 10 )
            call SetUnitTypeLifeRegeneration( d, 2 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 450 )
            call SetUnitTypeScale( d, 0.95 )
            call SetUnitTypeShopMaxCharges( d, 3 )
            call SetUnitTypeShopRefreshInterval( d, 45 )
            call SetUnitTypeShopRefreshIntervalStart( d, 200 )
            call SetUnitTypeSightRange( d, 850 )
            call SetUnitTypeSpeed( d, 350 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer UNIT_SHREDDER_UNIT_ID = 'n02S'
            endglobals

            // Unit Shredder
            set d = InitUnitTypeEx( UNIT_SHREDDER_UNIT_ID )
            call AddUnitTypeAbility( d, Invulnerability_SPELL_ID )
            call AddUnitTypeAbility( d, SHARED_CONTROL_SPELL_ID )
            call AddUnitTypeAbility( d, STOP_EX_SPELL_ID )
            call SetUnitTypeDamage( d, 90 )
            call SetUnitTypeDamageDices( d, 5 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeMaxLife( d, 750 )
            call SetUnitTypeScale( d, 1.6 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 500 )
            call AddShopUnitSupply( d, ShopInformation_UNIT_ID )
            call AddShopUnitSupply( d, UNIT_SHREDDER_RELEASED_UNIT_ID )
            call SetUnitTypeVertexColor(d, 190, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer UNIT_SHREDDER_RELEASED_UNIT_ID = 'n02R'
            endglobals

            // Unit Shredder (released)
            set d = InitUnitTypeEx( UNIT_SHREDDER_RELEASED_UNIT_ID )
            call AddUnitTypeAbility( d, SHARED_CONTROL_SPELL_ID )
            call SetUnitTypeArmor( d, 20 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeCanNotBeInited(d)
            call SetUnitTypeDamage( d, 90 )
            call SetUnitTypeDamageDices( d, 5 )
            call SetUnitTypeDamageDicesSides( d, 6 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 28 )
            call SetUnitTypeEP( d, 300 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 4000 )
            call SetUnitTypeScale( d, 1.75 )
            call SetUnitTypeShared(d)
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeShopMaxCharges( d, 1 )
            call SetUnitTypeShopRefreshInterval( d, 600 )
            call SetUnitTypeShopRefreshIntervalStart( d, 600 )
            call SetUnitTypeSpeed( d, 280 )
            call SetUnitTypeVertexColor(d, 190, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer GLAIVE_THROWER_UNIT_ID = 'e00J'
            endglobals

            // Glaive Thrower
            set d = InitUnitTypeEx( GLAIVE_THROWER_UNIT_ID )
            call AddUnitTypeAbility( d, LinearBoomerang_SPELL_ID )
            call SetUnitTypeArmor( d, 10 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDamage( d, 150 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 1000 )
            call SetUnitTypeImpactZ( d, 75 )
            call SetUnitTypeMaxLife( d, 2500 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeSightRange( d, 450 )
            call SetUnitTypeShopMaxCharges( d, 2 )
            call SetUnitTypeShopRefreshInterval( d, 900 )
            call SetUnitTypeShopRefreshIntervalStart( d, 900 )
            call SetUnitTypeSpecialAttack( d )
            call SetUnitTypeSpeed( d, 200 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SIEGE_TIN_UNIT_ID = 'h013'
            endglobals

            // Siege Tin
            set d = InitUnitTypeEx( SIEGE_TIN_UNIT_ID )
            call AddUnitTypeAbility( d, FreeRoad_SPELL_ID )
            call SetUnitTypeArmor( d, 20 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDamage( d, 117 )
            call SetUnitTypeDamageDices( d, 6 )
            call SetUnitTypeDamageDicesSides( d, 11 )
            call SetUnitTypeDamageType( d, DMG_TYPE_SIEGE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 2500 )
            call SetUnitTypeImpactZ( d, 45 )
            call SetUnitTypeMaxLife( d, 5000 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 450 )
            call SetUnitTypeShopMaxCharges( d, 2 )
            call SetUnitTypeShopRefreshInterval( d, 900 )
            call SetUnitTypeShopRefreshIntervalStart( d, 900 )
            call SetUnitTypeSpeed( d, 200 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer ADJUTANT_UNIT_ID = 'n01P'
            endglobals

            // Adjutant
            set d = InitUnitTypeEx( ADJUTANT_UNIT_ID )
            call AddUnitTypeAbility( d, RefillMana_SPELL_ID )
            call AddUnitTypeAbility( d, Rust_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDamage( d, 17 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 8 )
            call SetUnitTypeDamageType( d, DMG_TYPE_MAGIC )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 35 )
            call SetUnitTypeEP( d, 25 )
            call SetUnitTypeGoldCost( d, 280 )
            call SetUnitTypeImpactZ( d, 100 )
            call SetUnitTypeLifeRegeneration( d, 0.65 * REGENERATION_INTERVAL )
            call SetUnitTypeManaRegeneration( d, 0.75 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 850 )
            call SetUnitTypeMaxMana( d, 300 )
            call SetUnitTypeScale( d, 1.05 )
            call SetUnitTypeShopMaxCharges( d, 2 )
            call SetUnitTypeShopRefreshInterval( d, 70 )
            call SetUnitTypeShopRefreshIntervalStart( d, 300 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeStartMana( d, 300 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer BATTLE_SHIP_UNIT_ID = 'h00V'
            endglobals

            // Battle Ship
            set d = InitUnitTypeEx( BATTLE_SHIP_UNIT_ID )
            call AddUnitTypeAbility( d, ArtilleryAttack_SPELL_ID )
            call SetUnitTypeArmor( d, 5 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDamage( d, 65 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_SIEGE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 100 )
            call SetUnitTypeEP( d, 150 )
            call SetUnitTypeGoldCost( d, 600 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeMaxLife( d, 1000 )
            call SetUnitTypeMissileArc( d, 0.3 )
            call SetUnitTypeMissileDummyUnitId( d, 'n02Q' )
            call SetUnitTypeMissileSpeed( d, 900 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeShopMaxCharges( d, 2 )
            call SetUnitTypeShopRefreshInterval( d, 70 )
            call SetUnitTypeShopRefreshIntervalStart( d, 180 )
            call SetUnitTypeSightRange( d, 1000 )
            call SetUnitTypeSpecialAttack( d )
            call SetUnitTypeSpeed( d, 250 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeSplash( d )
            call SetUnitTypeSplashAffectionEnemy( d )
            call SetUnitTypeSplashAffectionGround( d )
            call SetUnitTypeSplashAreaRange( d, 350 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer DWARVES_UNIT_ID = 'h00N'
            endglobals

            // Dwarves
            set d = InitUnitTypeEx( DWARVES_UNIT_ID )
            call AddUnitTypeAbility( d, ArtilleryAttack_SPELL_ID )
            call AddUnitTypeAbility( d, DiversionShot_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDamage( d, 26 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 7 )
            call SetUnitTypeDamageType( d, DMG_TYPE_SIEGE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 30 )
            call SetUnitTypeEP( d, 25 )
            call SetUnitTypeGoldCost( d, 280 )
            call SetUnitTypeImpactZ( d, 25 )
            call SetUnitTypeLifeRegeneration( d, 0.55 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 700 )
            call SetUnitTypeMissileArc( d, 0.8 )
            call SetUnitTypeMissileDummyUnitId( d, 'n01N' )
            call SetUnitTypeMissileSpeed( d, 1300 )
            call SetUnitTypeScale( d, 1.05 )
            call SetUnitTypeShopMaxCharges( d, 2 )
            call SetUnitTypeShopRefreshInterval( d, 70 )
            call SetUnitTypeShopRefreshIntervalStart( d, 220 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpecialAttack( d )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeSplash( d )
            call SetUnitTypeSplashAffectionAlly( d )
            call SetUnitTypeSplashAffectionEnemy( d )
            call SetUnitTypeSplashAffectionGround( d )
            call SetUnitTypeSplashAreaRange( d, 250 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SPIDERLY_EGG_UNIT_ID = 'n02G'
            endglobals

            // Spiderly Egg
            set d = InitUnitTypeEx( SPIDERLY_EGG_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeMaxLife( d, 150 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeWard(d)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SPIDERLY_EGG2_UNIT_ID = 'n02H'
            endglobals

            // Spiderly Egg2
            set d = InitUnitTypeEx( SPIDERLY_EGG2_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeMaxLife( d, 150 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeWard(d)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SPIDERLY_UNIT_ID = 'n02J'
            endglobals

            // Spiderly
            set d = InitUnitTypeEx( SPIDERLY_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodLarge0.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 7 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 3 )
            call SetUnitTypeEP( d, 2 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.35 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 150 )
            call SetUnitTypeScale( d, 0.75 )
            call SetUnitTypeSightRange( d, 275 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer RESERVE_UNIT_ID = 'n02F'
            endglobals

            // Reserve
            set d = InitUnitTypeEx( RESERVE_UNIT_ID )
            call AddUnitTypeAbility( d, Suicide_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Human\\HumanBlood\\HumanBloodFootman.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Human\\HumanSmallDeathExplode\\HumanSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 9 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 5 )
            call SetUnitTypeEP( d, 3 )
            call SetUnitTypeGoldCost( d, 50 )
            call SetUnitTypeImpactZ( d, 45 )
            call SetUnitTypeLifeRegeneration( d, 0.5 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 350 )
            call SetUnitTypeScale( d, 1.35 )
            call SetUnitTypeShopMaxCharges( d, 3 )
            call SetUnitTypeShopRefreshInterval( d, 35 )
            call SetUnitTypeShopRefreshIntervalStart( d, 35 )
            call SetUnitTypeSightRange( d, 450 )
            call SetUnitTypeSpeed( d, 290 )
            call SetUnitTypeSupplyUsed( d, 6 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            call AddUnitTypeResearchTypeId( d, UpgradeArmor_RESEARCH_ID )
            call AddUnitTypeResearchTypeId( d, UpgradeAttackRate_RESEARCH_ID )
            call AddUnitTypeResearchTypeId( d, UpgradeDamage_RESEARCH_ID )
            call AddUnitTypeResearchTypeId( d, UpgradePower_RESEARCH_ID )

            call AddUnitTypeResearchTypeId( d, CriticalStrikes_RESEARCH_ID )
            call AddUnitTypeResearchTypeId( d, MassProduction_RESEARCH_ID )
            call AddUnitTypeResearchTypeId( d, RegenerativeHerbs_RESEARCH_ID )
            call AddUnitTypeResearchTypeId( d, SparklingScales_RESEARCH_ID )
            call AddUnitTypeResearchTypeId( d, UpgradeSpeed_RESEARCH_ID )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer TUSKAR_UNIT_ID = 'n01L'
            endglobals

            // Tuskar
            set d = InitUnitTypeEx( TUSKAR_UNIT_ID )
            call AddUnitTypeAbility( d, Net_SPELL_ID )
            call AddUnitTypeAbility( d, RapidFire_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodWitchDoctor.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 43 )
            call SetUnitTypeDamageDices( d, 2 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_PIERCE )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 40 )
            call SetUnitTypeEP( d, 33 )
            call SetUnitTypeGoldCost( d, 350 )
            call SetUnitTypeImpactZ( d, 100 )
            call SetUnitTypeLifeRegeneration( d, 1.05 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 1150 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeShopMaxCharges( d, 1 )
            call SetUnitTypeShopRefreshInterval( d, 80 )
            call SetUnitTypeShopRefreshIntervalStart( d, 220 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer DIRE_WOLF_UNIT_ID = 'n01Q'
            endglobals

            // Dire Wolf
            set d = InitUnitTypeEx( DIRE_WOLF_UNIT_ID )
            call AddUnitTypeAbility( d, CriticalStrike_TerrorWolf_TerrorWolf_SPELL_ID )
            call AddUnitTypeAbility( d, DreadCall_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodWitchDoctor.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcSmallDeathExplode\\OrcSmallDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 44 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 9 )
            call SetUnitTypeDamageType( d, DMG_TYPE_CHAOS )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 95 )
            call SetUnitTypeEP( d, 60 )
            call SetUnitTypeGoldCost( d, 1000 )
            call SetUnitTypeImpactZ( d, 40 )
            call SetUnitTypeLifeRegeneration( d, 3.5 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 2500 )
            call SetUnitTypeScale( d, 1.6 )
            call SetUnitTypeShopMaxCharges( d, 1 )
            call SetUnitTypeShopRefreshInterval( d, 250 )
            call SetUnitTypeShopRefreshIntervalStart( d, 500 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 250 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer FRIENDLY_WOMAN_UNIT_ID = 'n02Z'
            endglobals

            // Friendly Woman
            set d = InitUnitTypeEx( FRIENDLY_WOMAN_UNIT_ID )
            call AddUnitTypeAbility( d, WhipLash_SPELL_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodNecromancer.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 21 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 10 )
            call SetUnitTypeDamageType( d, DMG_TYPE_CHAOS )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 32 )
            call SetUnitTypeEP( d, 60 )
            call SetUnitTypeGoldCost( d, 300 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 1.35 * REGENERATION_INTERVAL )
            call SetUnitTypeManaRegeneration( d, 2.25 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 975 )
            call SetUnitTypeMaxMana( d, 200 )
            call SetUnitTypeScale( d, 1.4 )
            call SetUnitTypeShopMaxCharges( d, 1 )
            call SetUnitTypeShopRefreshInterval( d, 50 )
            call SetUnitTypeShopRefreshIntervalStart( d, 120 )
            call SetUnitTypeSightRange( d, 750 )
            call SetUnitTypeSpeed( d, 315 )
            call SetUnitTypeStartMana( d, 125 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer WAR_ENGINEER_UNIT_ID = 'n01O'
            endglobals

            // War Engineer
            set d = InitUnitTypeEx( WAR_ENGINEER_UNIT_ID )
            call AddUnitTypeAbility( d, REPAIR_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodNecromancer.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Undead\\UndeadLargeDeathExplode\\UndeadLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 19 )
            call SetUnitTypeDamageDices( d, 3 )
            call SetUnitTypeDamageDicesSides( d, 4 )
            call SetUnitTypeDamageType( d, DMG_TYPE_CHAOS )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 35 )
            call SetUnitTypeEP( d, 30 )
            call SetUnitTypeGoldCost( d, 300 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.85 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 1000 )
            call SetUnitTypeScale( d, 1.6 )
            call SetUnitTypeShopMaxCharges( d, 2 )
            call SetUnitTypeShopRefreshInterval( d, 70 )
            call SetUnitTypeShopRefreshIntervalStart( d, 180 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeSupplyUsed( d, 0 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SHOP_INFORMATION_UNIT_ID = 'n02X'
            endglobals

            // Shop Information
            set d = InitUnitTypeEx( SHOP_INFORMATION_UNIT_ID )
            call SetUnitTypeCanNotBeInited(d)
            call SetUnitTypeShopMaxCharges( d, 1 )
            call SetUnitTypeShopRefreshInterval( d, 1 )
            call SetUnitTypeShopRefreshIntervalStart( d, 0 )

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer CROWD_PULLER_UNIT_ID = 'n02I'
            endglobals

            // CrowdPuller
            set d = InitUnitTypeEx( CROWD_PULLER_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeImpactZ( d, 180 )
            call SetUnitTypeMaxLife( d, 100 )
            call SetUnitTypeScale( d, 1.65 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeWard(d)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SOUL_VESSEL_UNIT_ID = 'n02O'
            endglobals

            // Soul Vessel
            set d = InitUnitTypeEx( SOUL_VESSEL_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 3 )
            call SetUnitTypeMaxLife( d, 100 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 150 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeWard(d)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer TRAP_UNIT_ID = 'n027'
            endglobals

            // Trap
            set d = InitUnitTypeEx( TRAP_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeGoldCost( d, 75 )
            call SetUnitTypeMaxLife( d, 150 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer TRAP_BUILT_UP_UNIT_ID = 'n028'
            endglobals

            // Trap Built Up
            set d = InitUnitTypeEx( TRAP_BUILT_UP_UNIT_ID )
            call AddUnitTypeAbility( d, MATSUGAN_SPELL_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeMaxLife( d, 150 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeWard(d)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MURLOC_NIGHTSTALKER_UNIT_ID = 'n032'
            endglobals

            // Murloc Nightstalker
            set d = InitUnitTypeEx( MURLOC_NIGHTSTALKER_UNIT_ID )
            call SetUnitTypeArmor( d, 1 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Demon\\DemonLargeDeathExplode\\DemonLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 10 )
            call SetUnitTypeDamageDices( d, 1 )
            call SetUnitTypeDamageDicesSides( d, 2 )
            call SetUnitTypeDamageType( d, DMG_TYPE_CHAOS )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 60 )
            call SetUnitTypeEP( d, 60 )
            call SetUnitTypeImpactZ( d, 60 )
            call SetUnitTypeLifeRegeneration( d, 0.5 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 800 )
            call SetUnitTypeScale( d, 1.6 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 255, 200, 200, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer SEA_GIANT_UNIT_ID = 'n031'
            endglobals

            // Sea Giant
            set d = InitUnitTypeEx( SEA_GIANT_UNIT_ID )
            call AddUnitTypeAbility( d, Pulverize_SPELL_ID )
            call SetUnitTypeArmor( d, 2 )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_LARGE )
            call SetUnitTypeBlood( d, "Objects\\Spawnmodels\\Orc\\Orcblood\\OrcBloodGrunt.mdl" )
            call SetUnitTypeBloodExplosion( d, "Objects\\Spawnmodels\\Orc\\OrcLargeDeathExplode\\OrcLargeDeathExplode.mdl" )
            call SetUnitTypeDamage( d, 24 )
            call SetUnitTypeDamageDices( d, 4 )
            call SetUnitTypeDamageDicesSides( d, 5 )
            call SetUnitTypeDamageType( d, DMG_TYPE_NORMAL )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeDrop( d, 150 )
            call SetUnitTypeEP( d, 150 )
            call SetUnitTypeImpactZ( d, 160 )
            call SetUnitTypeLifeRegeneration( d, 5 * REGENERATION_INTERVAL )
            call SetUnitTypeMaxLife( d, 1400 )
            call SetUnitTypeScale( d, 1 )
            call SetUnitTypeSightRange( d, 600 )
            call SetUnitTypeSpeed( d, 270 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer HEALING_WARD_UNIT_ID = 'n02W'
            endglobals

            // Healing Ward
            set d = InitUnitTypeEx( HEALING_WARD_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_MEDIUM )
            call SetUnitTypeDecay( d )
            call SetUnitTypeDecayTime( d, 30 )
            call SetUnitTypeMaxLife( d, 25 )
            call SetUnitTypeScale( d, 1.15 )
            call SetUnitTypeSightRange( d, 500 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)
            call SetUnitTypeWard(d)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer GRASS_UNIT_ID = 'n014'
            endglobals

            // Grass
            set d = InitUnitTypeEx( GRASS_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDecay( d )
            call SetUnitTypeMaxLife( d, 150 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer BRICK_UNIT_ID = 'n015'
            endglobals

            // Brick
            set d = InitUnitTypeEx( BRICK_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDecay( d )
            call SetUnitTypeMaxLife( d, 150 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            globals
                constant integer MARBLE_UNIT_ID = 'n01B'
            endglobals

            // Marble
            set d = InitUnitTypeEx( MARBLE_UNIT_ID )
            call SetUnitTypeArmorType( d, ARMOR_TYPE_FORT )
            call SetUnitTypeDecay( d )
            call SetUnitTypeMaxLife( d, 150 )
            call SetUnitTypeScale( d, 1.25 )
            call SetUnitTypeVertexColor(d, 255, 255, 255, 255)

            //////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

            call SaveIntegerWJ( "UnitTypes", "Soldat", 'h001' )
            call SaveIntegerWJ( "UnitTypes", "Scharfschuetze", 'h006' )
            call SaveIntegerWJ( "UnitTypes", "Ritter", 'h008' )
            call SaveIntegerWJ( "UnitTypes", "Priester", 'h00A' )
            call SaveIntegerWJ( "UnitTypes", "Magierin", 'H003' )
            call SaveIntegerWJ( "UnitTypes", "Paladin", 'H004' )
            call SaveIntegerWJ( "UnitTypes", "Infernal", INFERNAL_UNIT_ID )

            call SaveIntegerWJ( "UnitTypes", "Schamane", 'o001' )
            call SaveIntegerWJ( "UnitTypes", "Raeuber", 'o003' )
            call SaveIntegerWJ( "UnitTypes", "Grunzer", 'o005' )
            call SaveIntegerWJ( "UnitTypes", "Windreiter", 'o007' )
            call SaveIntegerWJ( "UnitTypes", "Medizinmann", 'O00B' )
            call SaveIntegerWJ( "UnitTypes", "Schwertkaempfer", 'O008' )

            call SaveIntegerWJ( "UnitTypes", "Ghul", 'u001' )
            call SaveIntegerWJ( "UnitTypes", "Gruftbestie", 'u003' )
            call SaveIntegerWJ( "UnitTypes", "Gargoyle", GARGOYLE_UNIT_ID )
            call SaveIntegerWJ( "UnitTypes", "Totenbeschwoerer", 'u005' )
            call SaveIntegerWJ( "UnitTypes", "Skelettkrieger", 'u00B' )
            call SaveIntegerWJ( "UnitTypes", "Monstrositaet", 'u007' )
            call SaveIntegerWJ( "UnitTypes", "DunklerReiter", 'U009' )
            call SaveIntegerWJ( "UnitTypes", "Lich", 'U00A' )
            call SaveIntegerWJ( "UnitTypes", "Skelettkaempfer", 'u00B' )
            call SaveIntegerWJ( "UnitTypes", "Zombie1", 'n008' )
            call SaveIntegerWJ( "UnitTypes", "Zombie2", 'n009' )
            call SaveIntegerWJ( "UnitTypes", "Zombie3", 'n00A' )

            call SaveIntegerWJ( "UnitTypes", "Bogenschuetze", 'e001' )
            call SaveIntegerWJ( "UnitTypes", "Jaegerin", 'e003' )
            call SaveIntegerWJ( "UnitTypes", "Dryade", 'e005' )
            call SaveIntegerWJ( "UnitTypes", "Bergriese", 'e007' )
            call SaveIntegerWJ( "UnitTypes", "Botaniker", 'E00A' )
            call SaveIntegerWJ( "UnitTypes", "Kopfgeldjaegerin", 'E00C' )
            call SaveIntegerWJ( "UnitTypes", "Treant", 'e00B' )

            call SaveIntegerWJ( "UnitTypes", "EistrollPriester", 'n00K' )
            call SaveIntegerWJ( "UnitTypes", "Dojo", 'n00Z' )
            call SaveIntegerWJ( "UnitTypes", "Oger", 'n00J' )
            call SaveIntegerWJ( "UnitTypes", "Faust", 'n00N' )
            call SaveIntegerWJ( "UnitTypes", "Speispinne", 'n00H' )
            call SaveIntegerWJ( "UnitTypes", "Schimaere", 'e009' )
        endfunction
    endscope

    public function Init takes nothing returns nothing
        call Human_Human_Init()
        call Orc_Orc_Init()
        call Undead_Undead_Init()
        call Nightelf_Nightelf_Init()
        call Naga_Naga_Init()
        call Miscellaneous_Miscellaneous_Init()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Units.j

//file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Weather.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
scope Weather
    public function Init takes nothing returns nothing
        call Mist_Init()
        call Rain_Init()
        call Snow_Init()
        call Sun_Init()
    endfunction
endscope

//end of file: D:\Warcraft III\Mapping\WFW\Data\Initialization\Weather.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\AstralGauntlets.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("AstralGauntlets")
    globals
        public constant integer ITEM_ID = 'I01H'

        private constant real BONUS_INTELLIGENCE = 2.
        private constant real BONUS_STRENGTH = 2.
        private constant real BONUS_SUMMON_DAMAGE = 15.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        integer amount = 1
    endstruct

    public function Drop takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, AstralGauntlets_SCOPE_ID)
        local integer amount = d.amount - 1
        local UnitType manipulatingUnitType = manipulatingUnit.type
        if (amount == 0) then
            call d.destroy()
            call FlushAttachedIntegerById(manipulatingUnitId, AstralGauntlets_SCOPE_ID)
            //! runtextmacro RemoveEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = amount
        endif
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, -BONUS_INTELLIGENCE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, -BONUS_STRENGTH )
    endfunction

    private function Damage_Conditions takes unit target returns boolean
        if ( IsUnitType( target, UNIT_TYPE_SUMMONED ) == false ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit manipulatingUnit, real damageAmount, Unit target returns real
        local Data d = GetAttachedIntegerById(manipulatingUnit.id, AstralGauntlets_SCOPE_ID)
        local unit targetSelf
        if (d != NULL) then
            set targetSelf = target.self
            if ( Damage_Conditions( targetSelf ) ) then
                set damageAmount = damageAmount + d.amount * BONUS_SUMMON_DAMAGE
                call DestroyEffectWJ(AddSpecialEffectTargetWJ(TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT))
            endif
            set targetSelf = null
        endif
        return damageAmount
    endfunction

    private function Damage_Event takes nothing returns nothing
        set DAMAGE_AMOUNT = Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, AstralGauntlets_SCOPE_ID)
        local UnitType manipulatingUnitType = manipulatingUnit.type
        if (d == NULL) then
            set d = Data.create()
            call AttachIntegerById(manipulatingUnitId, AstralGauntlets_SCOPE_ID, d)
            //! runtextmacro AddEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = d.amount + 1
        endif
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, BONUS_INTELLIGENCE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, BONUS_STRENGTH )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 275)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 50)
        call SetItemTypeRefreshIntervalStart(d, 140)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_UNBLOCKABLE_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\AstralGauntlets.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\BeltOfTheCelt.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("BeltOfTheCelt")
    globals
        public constant integer ITEM_ID = 'I01C'

        private constant real BONUS_STRENGTH = 5.
    endglobals

    public function Drop takes Unit manipulatingUnit returns nothing
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnit.type, -BONUS_STRENGTH )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnit.type, BONUS_STRENGTH )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 350)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 30)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\BeltOfTheCelt.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\CamouflageSuit.j
//TESH.scrollpos=130
//TESH.alwaysfold=0
//! runtextmacro Scope("CamouflageSuit")
    globals
        public constant integer ITEM_ID = 'I02C'
        public constant integer SPELL_ID = 'A08I'

        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Other\\Silence\\SilenceAreaBirth.mdl"
        private constant real AREA_RANGE = 500.
        private constant real DURATION = 15.
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\NightElf\\FaerieDragonInvis\\FaerieDragon_Invis.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
    endglobals

    private struct Data
        timer durationTimer
        Unit target
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, CamouflageSuit_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, CamouflageSuit_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_ORDER_EXECUTE" )
        call RemoveUnitInvisibility( target )
    endfunction

    public function Death takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, CamouflageSuit_SCOPE_ID)
        if (d != NULL) then
            call Ending(d, d.durationTimer, target)
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, CamouflageSuit_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    public function OrderExecute takes Unit target, integer triggerOrder returns nothing
        local Data d = GetAttachedIntegerById(target.id, CamouflageSuit_SCOPE_ID)
        if (d != NULL) then
            if ((triggerOrder != STOP_ORDER_ID) and (triggerOrder != HOLD_POSITION_ORDER_ID)) then
                call Ending(d, d.durationTimer, target)
            endif
        endif
    endfunction

    private function OrderExecute_Event takes nothing returns nothing
        call OrderExecute( ORDERED_UNIT, TRIGGER_ORDER )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    private function StartTarget takes Unit target returns nothing
        local timer durationTimer
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById( targetId, CamouflageSuit_SCOPE_ID )
        local boolean isNew = (d == NULL)
        local unit targetSelf = target.self
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT ) )
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger( durationTimer, CamouflageSuit_SCOPE_ID, d )
            call AttachIntegerById( targetId, CamouflageSuit_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_ORDER_EXECUTE" )
        else
            set durationTimer = d.durationTimer
        endif
        if ( isNew ) then
            call AddUnitInvisibility( target )
        endif
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null

        if ( GetUnitCurrentOrder( targetSelf ) == ATTACK_ORDER_ID ) then
            call IssueImmediateOrderById(targetSelf, STOP_ORDER_ID)
        endif
        set targetSelf = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit enumUnit
        set casterSelf = null
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, casterX, casterY ) )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if (enumUnit != null) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call StartTarget(GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 400)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 100)
        call SetItemTypeRefreshIntervalStart(d, 100)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_ORDER_EXECUTE", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function OrderExecute_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\CamouflageSuit.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\CareBear.j
//TESH.scrollpos=159
//TESH.alwaysfold=0
//! runtextmacro Scope("CareBear")
    globals
        public constant integer ITEM_ID = 'I015'
        public constant integer SPELL_ID = 'A07C'

        private constant real ACCELERATION = 200.
        private constant real AREA_RANGE = 350.
        private constant string DUMMY_UNIT_EFFECT_PATH = "Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl"
        private constant string DUMMY_UNIT_EFFECT_ATTACHMENT_POINT = "overhead"
        private constant integer DUMMY_UNIT_ID = 'n02T'
        private group ENUM_GROUP
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\NightElf\\Taunt\\TauntCaster.mdl"
        private constant real SPEED_START = 150.
        private constant real DURATION_FACTOR = SPEED_START / ACCELERATION
        private constant real STUN_DURATION = 10.
        private constant real STUN_HERO_DURATION = 4.
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED_START * UPDATE_TIME
        private constant real SPEED_ADD = ACCELERATION * UPDATE_TIME
        private constant real LENGTH_ADD = SPEED_ADD * UPDATE_TIME
    endglobals

    private struct Data
        Unit caster
        unit dummyUnit
        effect dummyUnitEffect
        timer durationTimer
        real lengthX
        real lengthXAdd
        real lengthY
        real lengthYAdd
        group targetGroup
        real targetX
        real targetY
        timer updateTimer
    endstruct

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function Ending_RemoveDummyUnit takes nothing returns nothing
        local real duration
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, CareBear_SCOPE_ID)
        local Unit caster = d.caster
        local unit dummyUnit = d.dummyUnit
        local unit enumUnit
        local real targetX = d.targetX
        local real targetY = d.targetY
        call SetUnitAnimationByIndex( dummyUnit, 2 )
        call RemoveUnitTimed( dummyUnit, 3 )
        call FlushAttachedInteger( durationTimer, CareBear_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, targetX, targetY ) )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if ( IsUnitType( enumUnit, UNIT_TYPE_HERO ) ) then
                    set duration = STUN_HERO_DURATION
                else
                    set duration = STUN_DURATION
                endif
                call SetUnitStunTimed( GetUnit(enumUnit), 1, duration )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, CareBear_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local effect dummyUnitEffect = d.dummyUnitEffect
        local real targetX = d.targetX
        local real targetY = d.targetY
        local timer updateTimer = d.updateTimer
        call FlushAttachedInteger( updateTimer, CareBear_SCOPE_ID )
        call DestroyTimerWJ( updateTimer )
        set updateTimer = null
        call SetUnitAnimationByIndex( dummyUnit, 4 )
        call SetUnitXWJ( dummyUnit, targetX )
        call SetUnitYWJ( dummyUnit, targetY )
        call DestroyEffectWJ( dummyUnitEffect )
        set dummyUnitEffect = null
        call TimerStart( durationTimer, 0.8, false, function Ending_RemoveDummyUnit )
        set durationTimer = null
    endfunction

    private function Move takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, CareBear_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local real lengthX = d.lengthX + d.lengthXAdd
        local real lengthY = d.lengthY + d.lengthYAdd
        set d.lengthX = lengthX
        set d.lengthY = lengthY
        call SetUnitXWJ( dummyUnit, GetUnitX( dummyUnit ) + lengthX )
        call SetUnitYWJ( dummyUnit, GetUnitY( dummyUnit ) + lengthY )
        set dummyUnit = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local real angle
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local real distance = DistanceByCoordinates( casterX, casterY, targetX, targetY )
        local timer durationTimer = CreateTimerWJ()
        local unit dummyUnit
        local group targetGroup = CreateGroupWJ()
        local timer updateTimer = CreateTimerWJ()
        if ( distance != 0 ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
        else
            set angle = GetUnitFacingWJ( casterSelf )
        endif
        set casterSelf = null
        set dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, angle )
        set d.caster = caster
        set d.dummyUnit = dummyUnit
        set d.dummyUnitEffect = AddSpecialEffectTargetWJ( DUMMY_UNIT_EFFECT_PATH, dummyUnit, DUMMY_UNIT_EFFECT_ATTACHMENT_POINT )
        set d.durationTimer = durationTimer
        set d.lengthX = LENGTH * Cos(angle)
        set d.lengthXAdd = LENGTH_ADD * Cos(angle)
        set d.lengthY = LENGTH * Sin(angle)
        set d.lengthYAdd = LENGTH_ADD * Sin(angle)
        set d.targetGroup = CreateGroupWJ()
        set d.targetX = targetX
        set d.targetY = targetY
        set d.updateTimer = updateTimer
        call AttachInteger( durationTimer, CareBear_SCOPE_ID, d )
        call AttachInteger( updateTimer, CareBear_SCOPE_ID, d )
        call SetUnitAnimationByIndex( dummyUnit, 0 )
        set dummyUnit = null
        call TimerStart( updateTimer, UPDATE_TIME, true, function Move )
        set updateTimer = null
        call TimerStart( durationTimer, -DURATION_FACTOR + SquareRoot( DURATION_FACTOR * DURATION_FACTOR + distance / ACCELERATION * 2 ), false, function Ending )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call SetItemTypeGoldCost(d, 150)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 30)
        call SetItemTypeRefreshIntervalStart(d, 120)

        call InitEffectType( DUMMY_UNIT_EFFECT_PATH )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\CareBear.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\ChaosSword.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("ChaosSword")
    globals
        public constant integer ITEM_ID = 'I01T'
        public constant integer SET_ITEM_ID = 'I01W'

        private constant real BONUS_AGILITY = 3.
        private constant real BONUS_ARMOR_BREAK_RELATIVE = 1.
        private constant real BONUS_INTELLIGENCE = 3.
        private constant real BONUS_STRENGTH = 3.
    endglobals

    public function Drop takes Unit manipulatingUnit returns nothing
        local UnitType manipulatingUnitType = manipulatingUnit.type
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnitType, -BONUS_AGILITY )
        call AddUnitArmorBreakRelativeBonus( manipulatingUnit, -BONUS_ARMOR_BREAK_RELATIVE )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, -BONUS_INTELLIGENCE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, -BONUS_STRENGTH )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        local UnitType manipulatingUnitType = manipulatingUnit.type
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnitType, BONUS_AGILITY )
        call AddUnitArmorBreakRelativeBonus( manipulatingUnit, BONUS_ARMOR_BREAK_RELATIVE )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, BONUS_INTELLIGENCE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, BONUS_STRENGTH )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 1350)

        set d = InitItemTypeEx(SET_ITEM_ID)
        call SetItemTypeGoldCost(d, 1350)
        call SetItemTypeMaxCharges(d, 1)

        call CreateSetSimple2(AstralGauntlets_ITEM_ID, Lollipop_ITEM_ID, SET_ITEM_ID, ITEM_ID)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\ChaosSword.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\ChimeraEgg.j
//TESH.scrollpos=12
//TESH.alwaysfold=0
//! runtextmacro Scope("ChimeraEgg")
    globals
        public constant integer ITEM_ID = 'I00D'
        public constant integer SPELL_ID = 'A01K'

        private constant real DURATION = 120.
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl"
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local Unit chimera = CreateUnitEx( caster.owner, CHIMERA_UNIT_ID, GetUnitX(casterSelf), GetUnitY(casterSelf), GetUnitFacingWJ(casterSelf) )
        local unit chimeraSelf = chimera.self
        set casterSelf = null
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, GetUnitX( chimeraSelf ), GetUnitY(chimeraSelf) ) )
        call UnitApplyTimedLifeWJ( chimeraSelf, DURATION )
        set chimeraSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 300)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 80)
        call SetItemTypeRefreshIntervalStart(d, 200)

        call InitEffectType( SPECIAL_EFFECT_PATH )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\ChimeraEgg.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\ElectroNet.j
//TESH.scrollpos=129
//TESH.alwaysfold=0
//! runtextmacro Scope("ElectroNet")
    globals
        public constant integer ITEM_ID = 'I02D'
        public constant integer SPELL_ID = 'A08H'

        private constant integer DUMMY_UNIT_ID = 'n033'
        private constant real SPEED = 600.
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
    endglobals

    private struct Data
        real angle
        Unit caster
        unit dummyUnit
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        real x
        real y
        real z
    endstruct

    private function Ending takes Data d, unit dummyUnit, boolean isTargetNotNull, timer moveTimer, Unit target returns nothing
        local integer targetId = target.id
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 2 )
        call RemoveUnitTimed( dummyUnit, 2 )
        call FlushAttachedInteger( moveTimer, ElectroNet_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        if ( isTargetNotNull ) then
            set targetId = target.id
            call RemoveIntegerFromTableById( targetId, ElectroNet_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, ElectroNet_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
            endif
        endif
    endfunction

    private function Death_ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        set d.target = NULL
        call RemoveIntegerFromTableById( targetId, ElectroNet_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, ElectroNet_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, ElectroNet_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( targetId, ElectroNet_SCOPE_ID, iteration )
                call Death_ResetTarget( d, target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    //! runtextmacro Scope("Buff")
        globals
            private constant real Buff_DAMAGE_PER_INTERVAL = 30.
            private constant real Buff_DURATION_HIGH = 10.
            private constant real Buff_DURATION_MAX_LIFE = 1200.
            private constant real Buff_DURATION_LOW = 4.
            private constant real Buff_INTERVAL = 2.
            private constant string Buff_TARGET_EFFECT_PATH = "Abilities\\Weapons\\Bolt\\BoltImpact.mdl"
            private constant string Buff_TARGET_EFFECT_ATTACHMENT_POINT = "chest"
        endglobals

        private struct Buff_Data
            Unit caster
            timer durationTimer
            timer intervalTimer
            Unit target
        endstruct

        private function Buff_Ending takes Buff_Data d, timer durationTimer, Unit target returns nothing
            local timer intervalTimer = d.intervalTimer
            local integer targetId = target.id
            call d.destroy()
            call FlushAttachedInteger( durationTimer, Buff_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call FlushAttachedInteger( intervalTimer, Buff_SCOPE_ID )
            call DestroyTimerWJ( intervalTimer )
            set intervalTimer = null
            call FlushAttachedIntegerById( targetId, Buff_SCOPE_ID )
            //! runtextmacro RemoveEventById( "targetId", "Buff_EVENT_DEATH" )
            call RemoveUnitStun( target, 3 )
        endfunction

        public function Buff_Death takes Unit target returns nothing
            local Buff_Data d = GetAttachedIntegerById(target.id, Buff_SCOPE_ID)
            if (d != NULL) then
                call Buff_Ending(d, d.durationTimer, target)
            endif
        endfunction

        private function Buff_Death_Event takes nothing returns nothing
            call Buff_Death( DYING_UNIT )
        endfunction

        private function Buff_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Buff_Data d = GetAttachedInteger(durationTimer, Buff_SCOPE_ID)
            call Buff_Ending( d, durationTimer, d.target )
            set durationTimer = null
        endfunction

        private function Buff_Interval takes nothing returns nothing
            local timer intervalTimer = GetExpiredTimer()
            local Buff_Data d = GetAttachedInteger(intervalTimer, Buff_SCOPE_ID)
            local Unit target = d.target
            set intervalTimer = null
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( Buff_TARGET_EFFECT_PATH, target.self, Buff_TARGET_EFFECT_ATTACHMENT_POINT ) )
            call UnitDamageUnitEx( d.caster, target, Buff_DAMAGE_PER_INTERVAL, null )
        endfunction

        public function Buff_Start takes Unit caster, Unit target returns nothing
            local timer durationTimer
            local timer intervalTimer
            local integer targetId = target.id
            local Buff_Data d = GetAttachedIntegerById( targetId, Buff_SCOPE_ID )
            local boolean isNew = ( d == NULL )
            local unit targetSelf = target.self
            local real duration = Buff_DURATION_LOW + (Buff_DURATION_HIGH - Buff_DURATION_LOW) * (1 - Min(GetUnitState(targetSelf, UNIT_STATE_MAX_LIFE) / Buff_DURATION_MAX_LIFE, 1))
            if ( d == NULL ) then
                set d = Buff_Data.create()
                set durationTimer = CreateTimerWJ()
                set intervalTimer = CreateTimerWJ()
                set d.caster = caster
                set d.durationTimer = durationTimer
                set d.intervalTimer = intervalTimer
                set d.target = target
                call AttachInteger( durationTimer, Buff_SCOPE_ID, d )
                call AttachInteger( intervalTimer, Buff_SCOPE_ID, d )
                call AttachIntegerById( targetId, Buff_SCOPE_ID, d )
                //! runtextmacro AddEventById( "targetId", "Buff_EVENT_DEATH" )
                call TimerStart( intervalTimer, Buff_INTERVAL, true, function Buff_Interval )
                call AddUnitStun( target, 3 )
            else
                set durationTimer = d.durationTimer
            endif
            set d.caster = caster
            call TimerStart( durationTimer, duration, false, function Buff_EndingByTimer )
            set durationTimer = null
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( Buff_TARGET_EFFECT_PATH, targetSelf, Buff_TARGET_EFFECT_ATTACHMENT_POINT ) )
            set targetSelf = null
            call UnitDamageUnitEx( caster, target, Buff_DAMAGE_PER_INTERVAL, null )
        endfunction

        public function Buff_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Buff_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Buff_Death_Event" )
            call InitEffectType( Buff_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function TargetConditions takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitInvulnerability( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_INVULNERABLE
        endif
        return null
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local Unit caster
        local real distanceX
        local real distanceY
        local real distanceZ
        local boolean isTargetNotNull
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, ElectroNet_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local boolean reachesTarget
        local Unit target = d.target
        local unit targetSelf = target.self
        local boolean isTargetNull = ( target == NULL )
        local real targetX
        local real targetY
        local real targetZ
        local real x = d.x
        local real y = d.y
        local real z = d.z
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
            set targetSelf = null
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( x, y, z, targetX, targetY, targetZ ) <= LENGTH )
        if ( reachesTarget ) then
            set x = targetX
            set y = targetY
            set z = targetZ
        else
            set distanceZ = targetZ - z
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, targetX, targetY ) )
            set distanceX = targetX - x
            set distanceY = targetY - y
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = LENGTH * Cos( angleLengthXYZ )
            set x = x + lengthXY * Cos( angleXY )
            set y = y + lengthXY * Sin( angleXY )
            set z = z + LENGTH * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        if ( reachesTarget ) then
            set caster = d.caster
            set isTargetNotNull = (isTargetNull == false)
            call Ending( d, dummyUnit, isTargetNotNull, moveTimer, target )
            if ( isTargetNotNull ) then
                if ( TargetConditions( caster.owner, target ) == null ) then
                    call Buff_Buff_Start( caster, target )
                endif
            endif
        else
            set d.x = x
            set d.y = y
            set d.z = z
        endif
        set dummyUnit = null
        set moveTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local real angle
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local real casterZ = GetUnitZ(casterSelf, casterX, casterY)
        local Data d
        local unit dummyUnit
        local timer moveTimer
        local integer targetId
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        local real targetZ = GetUnitZ(targetSelf, targetX, targetY)
        set casterSelf = null
        set targetSelf = null
        if ( ( casterX != targetX ) or ( casterY != targetY ) or (casterZ != targetZ) ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
            set d = Data.create()
            set moveTimer = CreateTimerWJ()
            set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, casterX, casterY, angle )
            set targetId = target.id
            set d.angle = angle
            set d.caster = caster
            set d.dummyUnit = dummyUnit
            set d.moveTimer = moveTimer
            set d.target = target
            set d.x = casterX
            set d.y = casterY
            set d.z = casterZ
            call AttachInteger( moveTimer, ElectroNet_SCOPE_ID, d )
            call AddIntegerToTableById( targetId, ElectroNet_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, ElectroNet_SCOPE_ID ) == TABLE_STARTED ) then
                //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            endif
            call SetUnitAnimationByIndex( dummyUnit, 0 )
            call SetUnitZ(dummyUnit, casterX, casterY, casterZ)
            set dummyUnit = null
            call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
            set moveTimer = null
        else
            call Buff_Buff_Start( caster, target )
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 150)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 70)
        call SetItemTypeRefreshIntervalStart(d, 70)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )

        call Buff_Buff_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\ElectroNet.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\ElixirOfTheGrowth.j
//TESH.scrollpos=72
//TESH.alwaysfold=0
//! runtextmacro Scope("ElixirOfTheGrowth")
    globals
        public constant integer ITEM_ID = 'I009'
        public constant integer SPELL_ID = 'A01F'

        private constant real BONUS_ATTRIBUTE = 15.
        private constant real BONUS_SCALE = 0.3
        private constant real DURATION = 60.
        private constant real SCALE_TIME = 2.
    endglobals

    private struct Data
        Unit caster
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local integer casterId = caster.id
        local integer casterType = caster.type
        call FlushAttachedIntegerById( casterId, ElixirOfTheGrowth_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        call FlushAttachedInteger( durationTimer, ElixirOfTheGrowth_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call AddUnitScaleTimed( caster, -BONUS_SCALE, SCALE_TIME )
        call AddHeroAgilityBonus( caster, casterType, -BONUS_ATTRIBUTE )
        call AddHeroIntelligenceBonus( caster, casterType, -BONUS_ATTRIBUTE )
        call AddHeroStrengthBonus( caster, casterType, -BONUS_ATTRIBUTE )
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, ElixirOfTheGrowth_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, ElixirOfTheGrowth_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster, real casterX, real casterY, real casterZ returns nothing
        local integer casterId = caster.id
        local UnitType casterType
        local Data d = GetAttachedIntegerById(casterId, ElixirOfTheGrowth_SCOPE_ID)
        local timer durationTimer
        if ( d == NULL ) then
            set casterType = caster.type
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById( casterId, ElixirOfTheGrowth_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger( durationTimer, ElixirOfTheGrowth_SCOPE_ID, d )
            call AddHeroAgilityBonus( caster, casterType, BONUS_ATTRIBUTE )
            call AddHeroIntelligenceBonus( caster, casterType, BONUS_ATTRIBUTE )
            call AddHeroStrengthBonus( caster, casterType, BONUS_ATTRIBUTE )
            call AddUnitScaleTimed( caster, BONUS_SCALE, SCALE_TIME )
        else
            set durationTimer = d.durationTimer
        endif
        call PlaySoundFromTypeAtPosition( ELIXIR_OF_THE_GROWTH_SOUND_TYPE, casterX, casterY, casterZ )
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        local unit casterSelf = CASTER.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        call SpellEffect( CASTER, casterX, casterY, GetUnitZ(casterSelf, casterX, casterY) )
        set casterSelf = null
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 150)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 45)
        call SetItemTypeRefreshIntervalStart(d, 100)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitAbility(SPELL_ID)
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\ElixirOfTheGrowth.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\ExperimentalElixir.j
//TESH.scrollpos=12
//TESH.alwaysfold=0
//! runtextmacro Scope("ExperimentalElixir")
    globals
        public constant integer ITEM_ID = 'I01A'
        public constant integer SPELL_ID = 'A07J'

        private constant integer BONUS_EP = 50
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Human\\Polymorph\\PolyMorphTarget.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "head"
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT ) )
        call AddUnitEP( casterSelf, BONUS_EP )
        set casterSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 500)
        call SetItemTypeMaxCharges(d, 5)
        call SetItemTypeRefreshInterval(d, 30)
        call SetItemTypeRefreshIntervalStart(d, 30)

        call InitEffectType( CASTER_EFFECT_PATH )
        call InitItemType( ITEM_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\ExperimentalElixir.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\FenixsFeather.j
//TESH.scrollpos=15
//TESH.alwaysfold=0
//! runtextmacro Scope("FenixsFeather")
    globals
        public constant integer ITEM_ID = 'I023'

        private constant real BONUS_DAMAGE = 60.
        private constant real BONUS_MAX_MANA = 250.
        private constant real KILL_CHANCE = 0.05
        private constant string KILL_EFFECT_PATH = "Abilities\\Spells\\Items\\WandOfNeutralization\\NeutralizationMissile.mdl"
        private constant string KILL_EFFECT_ATTACHMENT_POINT = "chest"
        private constant real STUN_CHANCE = 0.15
        private constant real STUN_DURATION = 5.
    endglobals

    private struct Data
        integer amount
    endstruct

    private function Conditions takes Unit manipulatingUnit, player manipulatingUnitOwner, unit target returns boolean
        if (GetAttachedIntegerById( manipulatingUnit.id, FenixsFeather_SCOPE_ID ) == NULL) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit manipulatingUnit, Unit target returns nothing
        local unit targetSelf = target.self
        local UnitType targetType
        if (Conditions( manipulatingUnit, manipulatingUnit.owner, targetSelf )) then
            set targetType = target.type
            if ( GetRandomReal( 0.01, 1 ) <= STUN_CHANCE ) then
                call SetUnitStunTimed( target, 1, STUN_DURATION )
            endif
            if ((IsUnitTypeSpawn(targetType) or (targetType.id == RESERVE_UNIT_ID)) and GetRandomReal(0.01, 1) <= KILL_CHANCE) then
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( KILL_EFFECT_PATH, targetSelf, KILL_EFFECT_ATTACHMENT_POINT ) )
                call UnitDamageUnitEx( manipulatingUnit, target, GetUnitState(targetSelf, UNIT_STATE_LIFE), null )
            endif
        endif
        set targetSelf = null
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function Drop takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, FenixsFeather_SCOPE_ID)
        local integer amount = d.amount - 1
        if (amount == 0) then
            call d.destroy()
            call FlushAttachedIntegerById( manipulatingUnitId, FenixsFeather_SCOPE_ID )
            //! runtextmacro RemoveEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = amount
        endif
        call AddUnitDamageBonus( manipulatingUnit, -BONUS_DAMAGE )
        call AddUnitMaxMana( manipulatingUnit, -BONUS_MAX_MANA )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, FenixsFeather_SCOPE_ID)
        if (d == NULL) then
            set d = Data.create()
            set d.amount = 1
            call AttachIntegerById( manipulatingUnitId, FenixsFeather_SCOPE_ID, d )
            //! runtextmacro AddEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = d.amount + 1
        endif
        call AddUnitDamageBonus( manipulatingUnit, BONUS_DAMAGE )
        call AddUnitMaxMana( manipulatingUnit, BONUS_MAX_MANA )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 3500)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 240)
        call SetItemTypeRefreshIntervalStart(d, 500)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        call InitEffectType( KILL_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\FenixsFeather.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\FlyingSheep.j
//TESH.scrollpos=196
//TESH.alwaysfold=0
//! runtextmacro Scope("FlyingSheep")
    globals
        public constant integer ITEM_ID = 'I01J'
        public constant integer SPELL_ID = 'A06K'

        private constant real AREA_RANGE = 250.
        private constant real DAMAGE = 150.
        private constant string DUMMY_UNIT_EFFECT_PATH = "Abilities\\Weapons\\DemolisherFireMissile\\DemolisherFireMissile.mdl"
        private constant string DUMMY_UNIT_EFFECT_ATTACHMENT_POINT = "origin"
        private constant integer DUMMY_UNIT_ID = 'h00Y'
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = 500 * UPDATE_TIME
    endglobals

    private struct Data
        Unit caster
        unit dummyUnit
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        real x
        real y
        real z
    endstruct

    private function Ending takes Data d, unit dummyUnit, boolean isTargetNotNull, timer moveTimer, Unit target returns nothing
        local integer targetId
        call d.destroy()
        call SetUnitAnimation( dummyUnit, "death" )
        call RemoveUnitTimed( dummyUnit, 2 )
        if ( isTargetNotNull ) then
            set targetId = target.id
            call RemoveIntegerFromTableById( targetId, FlyingSheep_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, FlyingSheep_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
            endif
        endif
        call FlushAttachedInteger( moveTimer, FlyingSheep_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
    endfunction

    private function ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        set d.target = NULL
        call RemoveIntegerFromTableById( targetId, FlyingSheep_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, FlyingSheep_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, FlyingSheep_SCOPE_ID )
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById( targetId, FlyingSheep_SCOPE_ID, iteration )
                call ResetTarget( d, target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if (GetUnitInvulnerability(GetUnit(FILTER_UNIT_SELF)) > 0) then
            return false
        endif
        return true
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local Unit caster
        local real distanceX
        local real distanceY
        local real distanceZ
        local unit enumUnit
        local boolean isTargetNotNull
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, FlyingSheep_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local boolean reachesTarget
        local Unit target = d.target
        local boolean isTargetNull = ( target == NULL )
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        local real x = d.x
        local real y = d.y
        local real z = d.z
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
            set targetSelf = null
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( x, y, z, targetX, targetY, targetZ ) <= LENGTH )
        if ( reachesTarget ) then
            set x = targetX
            set y = targetY
            set z = targetZ
        else
            set distanceZ = targetZ - z
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, targetX, targetY ) )
            set distanceX = targetX - x
            set distanceY = targetY - y
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = LENGTH * Cos( angleLengthXYZ )
            set x = x + lengthXY * Cos( angleXY )
            set y = y + lengthXY * Sin( angleXY )
            set z = z + LENGTH * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        if ( reachesTarget ) then
            set caster = d.caster
            set isTargetNotNull = ( isTargetNull == false )
            call DestroyEffectWJ(AddSpecialEffectTargetWJ(DUMMY_UNIT_EFFECT_PATH, dummyUnit, DUMMY_UNIT_EFFECT_ATTACHMENT_POINT))
            call Ending( d, dummyUnit, isTargetNotNull, moveTimer, target )
            set TEMP_PLAYER = caster.owner
            call GroupEnumUnitsInRangeWithCollision(ENUM_GROUP, x, y, AREA_RANGE, TARGET_CONDITIONS)
            set enumUnit = FirstOfGroup(ENUM_GROUP)
            if (enumUnit != null) then
                loop
                    call GroupRemoveUnit(ENUM_GROUP, enumUnit)
                    call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), DAMAGE )
                    set enumUnit = FirstOfGroup(ENUM_GROUP)
                    exitwhen (enumUnit == null)
                endloop
            endif
        else
            set d.x = x
            set d.y = y
            set d.z = z
        endif
        set moveTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster)
        local Data d = Data.create()
        local unit dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, GetUnitFacingWJ( casterSelf ) )
        local timer moveTimer = CreateTimerWJ()
        local integer targetId = target.id
        set casterSelf = null
        set d.caster = caster
        set d.dummyUnit = dummyUnit
        set d.target = target
        set d.x = casterX
        set d.y = casterY
        set d.z = casterZ
        call AttachInteger( moveTimer, FlyingSheep_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, FlyingSheep_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, FlyingSheep_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call SetUnitZ( dummyUnit, casterX, casterY, casterZ )
        call PlaySoundFromTypeOnUnit( FLYING_SHEEP_SOUND_TYPE, dummyUnit )
        set dummyUnit = null
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 200)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 60)
        call SetItemTypeRefreshIntervalStart(d, 200)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ(function TargetConditions)
        call InitUnitType( DUMMY_UNIT_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\FlyingSheep.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\FriendshipBracelet.j
//TESH.scrollpos=364
//TESH.alwaysfold=0
//! runtextmacro Scope("FriendshipBracelet")
    private struct Data
        Unit caster
        timer delayTimer
        Unit target
    endstruct

    globals
        public constant integer ITEM_ID = 'I01I'
        public constant integer SPELL_ID = 'A040'

        private constant real EFFECT_LIGHTNING_DURATION = 0.3
        private constant string EFFECT_LIGHTNING_PATH = "CLPB"
        private constant real JUMP_DELAY = 0.175
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function Ending_Target takes Data d, Unit target returns nothing
        local integer targetId = target.id
        call RemoveIntegerFromTableById(targetId, FriendshipBracelet_SCOPE_ID, d)
        if (CountIntegersInTableById(targetId, FriendshipBracelet_SCOPE_ID) == TABLE_EMPTY) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DECAY" )
        endif
    endfunction

    private function Ending takes Unit caster, Data d, timer delayTimer, boolean isTargetNotNull, Unit target returns nothing
        call d.destroy()
        call RemoveUnitRemainingReference( caster )
        call FlushAttachedInteger( delayTimer, FriendshipBracelet_SCOPE_ID )
        call DestroyTimerWJ( delayTimer )
        if ( isTargetNotNull ) then
            call Ending_Target(d, target)
        endif
    endfunction

    private function TargetConditions_Single takes player casterOwner, Unit checkingUnit returns boolean
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) == false ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitMagicImmunity( checkingUnit ) > 0 ) then
            return false
        endif
        if ( GetUnitInvulnerability( checkingUnit ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return false
        endif
        return true
    endfunction

    //! runtextmacro Scope("Buff")
        globals
            private constant real Buff_AREA_RANGE = 500.
            private constant real Buff_DURATION = 10.
            private group Buff_ENUM_GROUP
            private constant real Buff_MAX_RANGE = 800.
            private constant real Buff_MAX_RANGE_SQUARE = Buff_MAX_RANGE * Buff_MAX_RANGE
            private constant integer Buff_MAX_TARGETS_AMOUNT = 4
            private trigger Buff_RIP_TRIGGER
            private boolexpr Buff_TARGET_CONDITIONS
            private constant real Buff_UPDATE_TIME = 0.035
        endglobals

        private struct Buff_Data
            timer durationTimer
            Unit array targets[Buff_MAX_TARGETS_AMOUNT]
            integer targetsCount
            timer updateTimer
        endstruct

        globals
            private Buff_Data Buff_RIP_TRIGGER_D
            private Buff_Data Buff_RIP_TRIGGER_TARGET
        endglobals

        //! runtextmacro Scope("Target")
            globals
                private constant string Target_EFFECT_LIGHTNING_PATH = "SPLK"
                //! runtextmacro CreateTableKey("Target_OTHER_TARGET_KEY")
                //! runtextmacro CreateTableKey("Target_TARGET_KEY")
            endglobals

            private struct Target_Data
                lightning effectLightning
                Unit otherTarget
                Unit target
            endstruct

            private function Target_Ending takes Target_Data d, Unit otherTarget, Unit target returns nothing
                local integer targetId = target.id
                local lightning effectLightning = d.effectLightning
                local integer otherTargetId = d.otherTarget.id
                call d.destroy()
                call DestroyLightningEx(effectLightning)
                set effectLightning = null
                call RemoveIntegerFromTableById(otherTargetId, Target_OTHER_TARGET_KEY, d)
                call RemoveIntegerFromTableById(otherTargetId, Target_SCOPE_ID, d)
                call RemoveIntegerFromTableById(targetId, Target_TARGET_KEY, d)
                call RemoveIntegerFromTableById(targetId, Target_SCOPE_ID, d)
            endfunction

            public function Target_EndingByEnding takes Unit target returns nothing
                local Target_Data d
                local integer targetId = target.id
                local integer iteration = CountIntegersInTableById(targetId, Target_SCOPE_ID)
                local Unit otherTarget
                loop
                    set d = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                    set otherTarget = d.otherTarget
                    if (otherTarget == target) then
                        call Target_Ending(d, target, d.target)
                    else
                        call Target_Ending(d, d.otherTarget, target)
                    endif
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                endloop
            endfunction

            private function Target_Rip takes integer count, Data d, Target_Data e, Unit otherTarget, Unit target returns nothing
            call BJDebugMsg("rip between "+GetUnitName(target.self)+"; "+GetUnitName(e.otherTarget.self)+" with "+I2S(count))
                if (count == -1) then
                    set Buff_RIP_TRIGGER_D = d
                    set Buff_RIP_TRIGGER_TARGET = target
                    call RunTrigger(Buff_RIP_TRIGGER)
                else
                    call Target_Ending(e, otherTarget, target)
                endif
            endfunction

            public function Target_Update takes Buff_Data d, Unit target returns nothing
                local real differenceX
                local real differenceY
                local Target_Data e
                local integer iteration
                local Unit otherTarget
                local unit otherTargetSelf
                local real otherTargetX
                local real otherTargetY
                local integer targetId = target.id
                local integer count = CountIntegersInTableById(targetId, Target_TARGET_KEY)
                local unit targetSelf
                local real targetX
                local real targetY
                local real targetZ
                if (count > TABLE_EMPTY) then
                    set iteration = count
                    set targetSelf = target.self
                    set targetX = GetUnitX(targetSelf)
                    set targetY = GetUnitY(targetSelf)
                    set targetZ = GetUnitZ(targetSelf, targetX, targetY) + GetUnitOutpactZ(target)
                    set targetSelf = null
                    loop
                        set e = GetIntegerFromTableById(targetId, Target_TARGET_KEY, iteration)
                        set otherTarget = e.otherTarget
                        set otherTargetSelf = otherTarget.self
                        set otherTargetX = GetUnitX(otherTargetSelf)
                        set differenceX = otherTargetX - targetX
                        set otherTargetY = GetUnitY(otherTargetSelf)
                        set differenceY = otherTargetY - targetY
                        if (differenceX * differenceX + differenceY * differenceY > Buff_MAX_RANGE_SQUARE) then
                            set count = count - 1
                            call Target_Rip(count, d, e, otherTarget, target)
                        else
                            call MoveLightningEx(e.effectLightning, false, targetX, targetY, targetZ, otherTargetX, otherTargetY, GetUnitZ(otherTargetSelf, otherTargetX, otherTargetY) + GetUnitImpactZ(otherTarget))
                        endif
                        set iteration = iteration - 1
                        exitwhen (iteration < 0)
                    endloop
                endif
                set otherTargetSelf = null
            endfunction

            public function Target_Start takes Unit target, Unit otherTarget returns nothing
                local Target_Data d = Target_Data.create()
                local integer otherTargetId = otherTarget.id
                local unit otherTargetSelf = otherTarget.self
                local real otherTargetX = GetUnitX(otherTargetSelf)
                local real otherTargetY = GetUnitY(otherTargetSelf)
                local integer targetId = target.id
                local unit targetSelf = target.self
                local real targetX = GetUnitX(targetSelf)
                local real targetY = GetUnitY(targetSelf)
                local lightning effectLightning = AddLightningWJ(Target_EFFECT_LIGHTNING_PATH, targetX, targetY, GetUnitZ(targetSelf, targetX, targetY) + GetUnitOutpactZ(target), otherTargetX, otherTargetY, GetUnitZ(otherTargetSelf, otherTargetX, otherTargetY) + GetUnitImpactZ(otherTarget))
                set otherTargetSelf = null
                set targetSelf = null
                set d.effectLightning = effectLightning
                set d.otherTarget = otherTarget
                set d.target = target
                call AddIntegerToTableById(otherTargetId, Target_OTHER_TARGET_KEY, d)
                call AddIntegerToTableById(otherTargetId, Target_SCOPE_ID, d)
                call AddIntegerToTableById(targetId, Target_TARGET_KEY, d)
                call AddIntegerToTableById(targetId, Target_SCOPE_ID, d)
                //call SetLightningColor(effectLightning, 255, 255, 255, 255)
                set effectLightning = null
            endfunction
        //! runtextmacro Endscope()

        private function Buff_TargetEnding takes Unit target returns nothing
            local integer targetId = target.id
            call FlushAttachedIntegerById(targetId, Buff_SCOPE_ID)
            //! runtextmacro RemoveEventById( "targetId", "Buff_EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "targetId", "Buff_EVENT_DEATH" )
            call BJDebugMsg("target ending")
            call Target_Target_EndingByEnding(target)
            call BJDebugMsg("target ending2")
        endfunction

        private function Buff_Ending takes Buff_Data d, timer durationTimer returns nothing
            local integer count = d.targetsCount
            local integer iteration = count
            local Unit array targets
            local timer updateTimer = d.updateTimer
            call BJDebugMsg("all ending")
            loop
                set targets[iteration] = d.targets[iteration]
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call d.destroy()
            call FlushAttachedInteger(durationTimer, Buff_SCOPE_ID)
            call DestroyTimerWJ(durationTimer)
            loop
                call Buff_TargetEnding(targets[iteration])
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call FlushAttachedInteger(updateTimer, Buff_SCOPE_ID)
            call DestroyTimerWJ(updateTimer)
            set updateTimer = null
        endfunction

        public function Buff_Death takes Unit target returns nothing
            local integer count
            local Buff_Data d = GetAttachedIntegerById(target.id, Buff_SCOPE_ID)
            if (d != NULL) then
                set count = d.targetsCount - 1
                if (count == -1) then
                    call Buff_Ending(d, d.durationTimer)
                else
                    call Buff_TargetEnding(target)
                    set d.targetsCount = count
                endif
            endif
        endfunction

        private function Buff_Death_Event takes nothing returns nothing
            call Buff_Death(DYING_UNIT)
        endfunction

        private function Buff_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Buff_Data d = GetAttachedInteger(durationTimer, Buff_SCOPE_ID)
            call Buff_Ending(d, durationTimer)
            set durationTimer = null
        endfunction

        private function Buff_RipTrig takes nothing returns nothing
            local Buff_Data d = Buff_RIP_TRIGGER_D
            local Unit target = Buff_RIP_TRIGGER_TARGET
            local integer count = d.targetsCount - 1
            if (count == -1) then
                call Buff_Ending(d, d.durationTimer)
            else
                call Buff_TargetEnding(target)
                set d.targetsCount = count
            endif
        endfunction

        public function Buff_Damage takes real damageAmount, Unit damageSource, Unit target returns real
            local Buff_Data d = GetAttachedIntegerById(target.id, Buff_SCOPE_ID)
            local integer iteration
            local Unit target2
            if (d != NULL) then
                set iteration = d.targetsCount
                set damageAmount = damageAmount / (iteration + 1)
                loop
                    set target2 = d.targets[iteration]
                    if (target2 != target) then
                        call UnitDamageUnitEx(damageSource, target2, damageAmount, null)
                    endif
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                endloop
            endif
            return damageAmount
        endfunction

        private function Buff_Damage_Event takes nothing returns nothing
            set DAMAGE_AMOUNT = Buff_Damage( DAMAGE_AMOUNT, DAMAGE_SOURCE, TRIGGER_UNIT )
        endfunction

        private function Buff_TargetConditions takes nothing returns boolean
            set FILTER_UNIT = GetUnit(GetFilterUnit())
            if (TargetConditions_Single(TEMP_PLAYER, FILTER_UNIT) == false) then
                return false
            endif
            if (GetAttachedIntegerById(FILTER_UNIT.id, Buff_SCOPE_ID) != NULL) then
                return false
            endif
            return true
        endfunction

        private function Buff_Update takes nothing returns nothing
            local timer updateTimer = GetExpiredTimer()
            local Buff_Data d = GetAttachedInteger(updateTimer, Buff_SCOPE_ID)
            local integer iteration = d.targetsCount
            loop
                call Target_Target_Update(d, d.targets[iteration])
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
        endfunction

        public function Buff_Start takes Unit caster, player casterOwner, unit target returns nothing
            local unit casterSelf = caster.self
            local integer count
            local Buff_Data d
            local timer durationTimer
            local Unit enumUnit
            local integer enumUnitId
            local unit enumUnitSelf
            local integer iteration
            local integer iteration2
            local Unit array targets
            local real targetX = GetUnitX(target)
            local real targetY = GetUnitY(target)
            local timer updateTimer
            set TEMP_PLAYER = casterOwner
            call GroupEnumUnitsInRangeWithCollision(Buff_ENUM_GROUP, targetX, targetY, Buff_AREA_RANGE, Buff_TARGET_CONDITIONS)
            if ((GetUnitState(casterSelf, UNIT_STATE_LIFE) > 0) and (GetAttachedIntegerById(caster.id, Buff_SCOPE_ID) == NULL)) then
                call GroupAddUnit(Buff_ENUM_GROUP, casterSelf)
            endif
            set casterSelf = null
            set enumUnitSelf = GetNearestUnit(Buff_ENUM_GROUP, targetX, targetY)
            if (enumUnitSelf != null) then
                set count = 0
                set d = Buff_Data.create()
                set durationTimer = CreateTimerWJ()
                set updateTimer = CreateTimerWJ()
                set iteration = 0
                set d.durationTimer = durationTimer
                set d.updateTimer = updateTimer
                loop
                    set enumUnit = GetUnit(enumUnitSelf)
                    set enumUnitId = enumUnit.id
                    call GroupRemoveUnit(Buff_ENUM_GROUP, enumUnitSelf)
                    call AttachIntegerById(enumUnitId, Buff_SCOPE_ID, d)
                    //! runtextmacro AddEventById( "enumUnitId", "Buff_EVENT_DAMAGE" )
                    //! runtextmacro AddEventById( "enumUnitId", "Buff_EVENT_DEATH" )
                    set targets[iteration] = enumUnit
                    set d.targets[iteration] = targets[iteration]
                    if (iteration != 0) then
                        set iteration2 = count - 1
                        loop
                            call Target_Target_Start(enumUnit, targets[iteration2])
                            set iteration2 = iteration2 - 1
                            exitwhen (iteration2 < 0)
                        endloop
                    endif
                    set enumUnitSelf = FirstOfGroup(Buff_ENUM_GROUP)
                    exitwhen (enumUnitSelf == null)
                    set iteration = iteration + 1
                    exitwhen (iteration == Buff_MAX_TARGETS_AMOUNT)
                    set count = count + 1
                endloop
                if (iteration == Buff_MAX_TARGETS_AMOUNT) then
                    set enumUnitSelf = null
                endif
                set d.targetsCount = count
                call AttachInteger(durationTimer, Buff_SCOPE_ID, d)
                call AttachInteger(updateTimer, Buff_SCOPE_ID, d)
                call TimerStart(updateTimer, Buff_UPDATE_TIME, true, function Buff_Update)
                set updateTimer = null
                //call TimerStart(durationTimer, Buff_DURATION, false, function Buff_EndingByTimer)
                set durationTimer = null
            endif
        endfunction

        public function Buff_Init takes nothing returns nothing
            set Buff_ENUM_GROUP = CreateGroupWJ()
            //! runtextmacro CreateEvent( "Buff_EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY", "1", "function Buff_Damage_Event" )
            //! runtextmacro CreateEvent( "Buff_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Buff_Death_Event" )
            set Buff_RIP_TRIGGER = CreateTriggerWJ()
            set Buff_TARGET_CONDITIONS = ConditionWJ( function Buff_TargetConditions )
            call AddTriggerCode(Buff_RIP_TRIGGER, function Buff_RipTrig)
        endfunction
    //! runtextmacro Endscope()

    private function Impact takes nothing returns nothing
        local player casterOwner
        local timer delayTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(delayTimer, FriendshipBracelet_SCOPE_ID)
        local Unit caster = d.caster
        local integer jumpsAmount
        local Unit target = d.target
        local unit targetSelf
        call Ending_Target(d, target)
        if (target == NULL) then
            call Ending( caster, d, delayTimer, false, NULL )
        else
            set casterOwner = caster.owner
            set targetSelf = target.self
            call Ending( caster, d, delayTimer, true, target )
            if ( TargetConditions_Single( casterOwner, target ) ) then
                call Buff_Buff_Start(caster, casterOwner, targetSelf)
            endif
            set casterOwner = null
            set targetSelf = null
        endif
        set delayTimer = null
    endfunction

    public function Decay takes Unit target returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById(targetId, FriendshipBracelet_SCOPE_ID)
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById(targetId, FriendshipBracelet_SCOPE_ID, iteration)
                call Ending_Target(d, target)
                set d.target = NULL
                set iteration = iteration - 1
                exitwhen (iteration < TABLE_STARTED)
            endloop
        endif
    endfunction

    private function Decay_Event takes nothing returns nothing
        call Decay(TRIGGER_UNIT)
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local Data d = Data.create()
        local timer delayTimer = CreateTimerWJ()
        local integer targetId = target.id
        //call DestroyLightningTimedEx( AddLightningBetweenUnits( EFFECT_LIGHTNING_PATH, caster, target ), EFFECT_LIGHTNING_DURATION )
        set d.caster = caster
        set d.delayTimer = delayTimer
        set d.target = target
        call AddUnitRemainingReference( caster )
        call AttachInteger( delayTimer, FriendshipBracelet_SCOPE_ID, d )
        call AddIntegerToTableById(targetId, FriendshipBracelet_SCOPE_ID, d)
        if (CountIntegersInTableById(targetId, FriendshipBracelet_SCOPE_ID) == TABLE_STARTED) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DECAY" )
        endif
        call TimerStart( delayTimer, JUMP_DELAY, false, function Impact )
        set delayTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 75)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 60)
        call SetItemTypeRefreshIntervalStart(d, 160)

        //! runtextmacro CreateEvent( "EVENT_DECAY", "UnitFinishesDecaying_EVENT_KEY", "0", "function Decay_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Buff_Buff_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\FriendshipBracelet.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\FrostArmor.j
//TESH.scrollpos=123
//TESH.alwaysfold=0
//! runtextmacro Scope("FrostArmor")
    globals
        public constant integer ITEM_ID = 'I01Q'
        public constant integer SET_ITEM_ID = 'I01X'

        private constant real BONUS_ARMOR = 5.
        private constant real BONUS_MAX_LIFE = 150.
    endglobals

    private struct Data
        integer amount
    endstruct

    public function Drop takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, FrostArmor_SCOPE_ID)
        local integer amount = d.amount - 1
        if (amount == NULL) then
            call d.destroy()
            call FlushAttachedIntegerById( manipulatingUnitId, FrostArmor_SCOPE_ID )
            //! runtextmacro RemoveEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = amount
        endif
        call AddUnitArmorBonus( manipulatingUnit, -BONUS_ARMOR )
        call AddUnitMaxLife( manipulatingUnit, -BONUS_MAX_LIFE )
    endfunction

    //! runtextmacro Scope("Slow")
        globals
            private constant real Slow_BONUS_ATTACK_RATE = -0.5
            private constant real Slow_BONUS_SPEED = -50.
            private constant real Slow_DURATION = 4.
            private constant string Slow_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl"
            private constant string Slow_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Slow_Data
            timer durationTimer
            Unit target
            effect targetEffect
        endstruct

        private function Slow_Ending takes Slow_Data d, timer durationTimer, Unit target returns nothing
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call FlushAttachedInteger( durationTimer, Slow_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call FlushAttachedIntegerById( targetId, Slow_SCOPE_ID )
            //! runtextmacro RemoveEventById( "targetId", "Slow_EVENT_DEATH" )
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
            call AddUnitAttackRate( target, -Slow_BONUS_ATTACK_RATE )
            call AddUnitSpeedBonus( target, -Slow_BONUS_SPEED )
            call RemoveUnitFrostSlow(target)
        endfunction

        public function Slow_Death takes Unit target returns nothing
            local Slow_Data d = GetAttachedIntegerById( target.id, Slow_SCOPE_ID )
            if ( d != NULL ) then
                call Slow_Ending( d, d.durationTimer, target )
            endif
        endfunction

        private function Slow_Death_Event takes nothing returns nothing
            call Slow_Death( DYING_UNIT )
        endfunction

        private function Slow_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Slow_Data d = GetAttachedInteger(durationTimer, Slow_SCOPE_ID)
            call Slow_Ending( d, durationTimer, d.target )
            set durationTimer = null
        endfunction

        public function Slow_Start takes Unit target returns nothing
            local timer durationTimer
            local integer targetId = target.id
            local Slow_Data d = GetAttachedIntegerById( targetId, Slow_SCOPE_ID )
            if ( d == NULL ) then
                set d = Slow_Data.create()
                set durationTimer = CreateTimerWJ()
                set d.durationTimer = durationTimer
                set d.target = target
                call AttachInteger( durationTimer, Slow_SCOPE_ID, d )
                call AttachIntegerById( targetId, Slow_SCOPE_ID, d )
                //! runtextmacro AddEventById( "targetId", "Slow_EVENT_DEATH" )
                call AddUnitAttackRate( target, Slow_BONUS_ATTACK_RATE )
                call AddUnitSpeedBonus( target, Slow_BONUS_SPEED )
                call AddUnitFrostSlow(target)
            else
                set durationTimer = d.durationTimer
                call DestroyEffectWJ( d.targetEffect )
            endif
            set d.targetEffect = AddSpecialEffectTargetWJ( Slow_TARGET_EFFECT_PATH, target.self, Slow_TARGET_EFFECT_ATTACHMENT_POINT )
            call TimerStart( durationTimer, Slow_DURATION, false, function Slow_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Slow_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Slow_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Slow_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    private function Damage_TargetConditions takes Unit manipulatingUnit, unit target returns boolean
        if ( GetAttachedIntegerById(manipulatingUnit.id, FrostArmor_SCOPE_ID) == NULL ) then
            return false
        endif
        if (GetUnitState(target, UNIT_STATE_LIFE) <= 0) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_MELEE_ATTACKER ) == false ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit manipulatingUnit, Unit target returns nothing
        if ( Damage_TargetConditions( manipulatingUnit, target.self ) ) then
            call Slow_Slow_Start(target)
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( TRIGGER_UNIT, DAMAGE_SOURCE )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, FrostArmor_SCOPE_ID)
        if (d == NULL) then
            set d = Data.create()
            set d.amount = 1
            call AttachIntegerById( manipulatingUnitId, FrostArmor_SCOPE_ID, d )
            //! runtextmacro AddEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = d.amount + 1
        endif
        call AddUnitArmorBonus( manipulatingUnit, BONUS_ARMOR )
        call AddUnitMaxLife( manipulatingUnit, BONUS_MAX_LIFE )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 1000)

        set d = InitItemTypeEx(SET_ITEM_ID)
        call SetItemTypeGoldCost(d, 1000)
        call SetItemTypeMaxCharges(d, 1)

        call CreateSetSimple2(FrozenShard_ITEM_ID, HeartStone_ITEM_ID, SET_ITEM_ID, ITEM_ID)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY", "0", "function Damage_Event" )
        call Slow_Slow_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\FrostArmor.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\FrozenShard.j
//TESH.scrollpos=95
//TESH.alwaysfold=0
//! runtextmacro Scope("FrozenShard")
    globals
        public constant integer ITEM_ID = 'I026'

        private constant real BONUS_ARMOR = 1.
        private constant real BONUS_MAX_LIFE = -30.
        private constant string MANIPULATING_UNIT_EFFECT_PATH = "Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl"
        private constant string MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT = "weapon"
    endglobals

    private struct Data
        integer amount
        effect manipulatingUnitEffect
    endstruct

    //! runtextmacro Scope("Buff")
        globals
            private constant real Buff_BONUS_SPEED_START = -30.
            private constant real Buff_BONUS_SPEED_ADD = -30.
            private constant real Buff_DURATION = 4.
            private constant string Buff_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl"
            private constant string Buff_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Buff_Data
            real bonusSpeed
            timer durationTimer
            Unit target
            effect targetEffect
        endstruct

        private function Buff_Ending takes Buff_Data d, timer durationTimer, Unit target returns nothing
            local real bonusSpeed = d.bonusSpeed
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call FlushAttachedInteger( durationTimer, Buff_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call FlushAttachedIntegerById( targetId, Buff_SCOPE_ID )
            //! runtextmacro RemoveEventById( "targetId", "Buff_EVENT_DEATH" )
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
            call AddUnitSpeedBonus( target, -bonusSpeed )
            call RemoveUnitFrostSlow(target)
        endfunction

        public function Buff_Death takes Unit target returns nothing
            local Buff_Data d = GetAttachedIntegerById( target.id, Buff_SCOPE_ID )
            if ( d != NULL ) then
                call Buff_Ending( d, d.durationTimer, target )
            endif
        endfunction

        private function Buff_Death_Event takes nothing returns nothing
            call Buff_Death( DYING_UNIT )
        endfunction

        private function Buff_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Buff_Data d = GetAttachedInteger(durationTimer, Buff_SCOPE_ID)
            call Buff_Ending( d, durationTimer, d.target )
            set durationTimer = null
        endfunction

        public function Buff_Start takes integer amount, Unit target returns nothing
            local real bonusSpeed = Buff_BONUS_SPEED_START + (amount - 1) * Buff_BONUS_SPEED_ADD
            local timer durationTimer
            local real oldBonusSpeed
            local integer targetId = target.id
            local Buff_Data d = GetAttachedIntegerById( targetId, Buff_SCOPE_ID )
            local boolean isNew = (d == NULL)
            local unit targetSelf = target.self
            if ( isNew ) then
                set d = Buff_Data.create()
                set durationTimer = CreateTimerWJ()
                set d.bonusSpeed = bonusSpeed
                set d.durationTimer = durationTimer
                set d.target = target
                call AttachInteger( durationTimer, Buff_SCOPE_ID, d )
                call AttachIntegerById( targetId, Buff_SCOPE_ID, d )
                //! runtextmacro AddEventById( "targetId", "Buff_EVENT_DEATH" )
            else
                set durationTimer = d.durationTimer
                set oldBonusSpeed = d.bonusSpeed
                call DestroyEffectWJ( d.targetEffect )
            endif
            set d.targetEffect = AddSpecialEffectTargetWJ( Buff_TARGET_EFFECT_PATH, targetSelf, Buff_TARGET_EFFECT_ATTACHMENT_POINT )
            set targetSelf = null
            if (isNew) then
                call AddUnitSpeedBonus( target, bonusSpeed )
                call AddUnitFrostSlow(target)
            elseif (bonusSpeed > oldBonusSpeed) then
                set d.bonusSpeed = bonusSpeed
                call AddUnitSpeedBonus( target, bonusSpeed - oldBonusSpeed )
            endif
            call TimerStart( durationTimer, Buff_DURATION, false, function Buff_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Buff_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Buff_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Buff_Death_Event" )
            call InitEffectType( Buff_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function Damage_Conditions takes Unit manipulatingUnit, Unit target returns boolean
        if (GetUnitTypeSpeed(target.type) <= 0) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit manipulatingUnit, Unit target returns nothing
        local Data d = GetAttachedIntegerById( manipulatingUnit.id, FrozenShard_SCOPE_ID )
        if (d != NULL) then
            if (Damage_Conditions(manipulatingUnit, target)) then
                call Buff_Buff_Start(d.amount, target)
            endif
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function Drop takes Unit manipulatingUnit returns nothing
        local effect manipulatingUnitEffect
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, FrozenShard_SCOPE_ID)
        local integer amount = d.amount - 1
        if (amount == NULL) then
            set manipulatingUnitEffect = d.manipulatingUnitEffect
            call d.destroy()
            call DestroyEffectWJ( manipulatingUnitEffect )
            set manipulatingUnitEffect = null
            call FlushAttachedIntegerById( manipulatingUnitId, FrozenShard_SCOPE_ID )
            //! runtextmacro RemoveEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = amount
        endif
        call AddUnitArmorBonus( manipulatingUnit, -BONUS_ARMOR )
        call AddUnitMaxLife( manipulatingUnit, -BONUS_MAX_LIFE )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, FrozenShard_SCOPE_ID)
        if (d == NULL) then
            set d = Data.create()
            set d.amount = 1
            set d.manipulatingUnitEffect = AddSpecialEffectTargetWJ( MANIPULATING_UNIT_EFFECT_PATH, manipulatingUnit.self, MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT )
            call AttachIntegerById( manipulatingUnitId, FrozenShard_SCOPE_ID, d )
            //! runtextmacro AddEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = d.amount + 1
        endif
        call AddUnitArmorBonus( manipulatingUnit, BONUS_ARMOR )
        call AddUnitMaxLife( manipulatingUnit, BONUS_MAX_LIFE )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 250)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 40)
        call SetItemTypeRefreshIntervalStart(d, 200)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        call Buff_Buff_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\FrozenShard.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\GexxoSlippers.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("GexxoSlippers")
    globals
        public constant integer ITEM_ID = 'I01F'

        private constant real BONUS_AGILITY = 1.
        private constant real BONUS_INTELLIGENCE = 1.
        private constant real BONUS_SPEED = 15.
        private constant string MANIPULATING_UNIT_EFFECT_PATH = "Units\\Critters\\Skink\\Skink.mdl"
        private constant string MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT = "foot left"
        private constant string MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT2 = "foot right"
    endglobals

    private struct Data
        integer amount = 1
        effect manipulatingUnitEffect
        effect manipulatingUnitEffect2
    endstruct

    public function Drop takes Unit manipulatingUnit returns nothing
        local effect manipulatingUnitEffect
        local effect manipulatingUnitEffect2
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, GexxoSlippers_SCOPE_ID)
        local integer amount = d.amount - 1
        local integer manipulatingUnitType = manipulatingUnit.type
        if (amount == 0) then
            set manipulatingUnitEffect = d.manipulatingUnitEffect
            set manipulatingUnitEffect2 = d.manipulatingUnitEffect2
            call d.destroy()
            call FlushAttachedIntegerById(manipulatingUnitId, GexxoSlippers_SCOPE_ID)
            call DestroyEffectWJ(manipulatingUnitEffect)
            set manipulatingUnitEffect = null
            call DestroyEffectWJ(manipulatingUnitEffect2)
            set manipulatingUnitEffect2 = null
        else
            set d.amount = amount
        endif
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnitType, -BONUS_AGILITY )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, -BONUS_INTELLIGENCE )
        call AddUnitSpeedBonus(manipulatingUnit, -BONUS_SPEED)
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, GexxoSlippers_SCOPE_ID)
        local unit manipulatingUnitSelf
        local UnitType manipulatingUnitType = manipulatingUnit.type
        if (d == NULL) then
            set d = Data.create()
            set manipulatingUnitSelf = manipulatingUnit.self
            set d.manipulatingUnitEffect = AddSpecialEffectTargetWJ(MANIPULATING_UNIT_EFFECT_PATH, manipulatingUnitSelf, MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT)
            set d.manipulatingUnitEffect2 = AddSpecialEffectTargetWJ(MANIPULATING_UNIT_EFFECT_PATH, manipulatingUnitSelf, MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT2)
            set manipulatingUnitSelf = null
            call AttachIntegerById(manipulatingUnitId, GexxoSlippers_SCOPE_ID, d)
        else
            set d.amount = d.amount + 1
        endif
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnitType, BONUS_AGILITY )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, BONUS_INTELLIGENCE )
        call AddUnitSpeedBonus(manipulatingUnit, BONUS_SPEED)
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 135)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 30)
        call SetItemTypeRefreshIntervalStart(d, 120)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\GexxoSlippers.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\GiantAxe.j
//TESH.scrollpos=57
//TESH.alwaysfold=0
//! runtextmacro Scope("GiantAxe")
    globals
        public constant integer ITEM_ID = 'I01R'

        private constant real AREA_RANGE = 125.
        private constant real BONUS_DAMAGE = 10.
        private constant real BONUS_STRENGTH = 6.
        private group ENUM_GROUP
        private constant real SPLASH_FACTOR = 0.3
        private boolexpr TARGET_CONDITIONS
        private constant string VICTIM_EFFECT_PATH = "Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl"
        private constant string VICTIM_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        integer amount
    endstruct

    private function TargetConditions takes nothing returns boolean
        if (IsUnitEnemy(FILTER_UNIT_SELF, TEMP_PLAYER) == false) then
            return false
        endif
        return true
    endfunction

    public function Damage takes real damageAmount, Unit manipulatingUnit, Unit target returns nothing
        local Data d = GetAttachedIntegerById( manipulatingUnit.id, GiantAxe_SCOPE_ID )
        local unit enumUnit
        local unit targetSelf
        if (d != NULL) then
            set damageAmount = damageAmount * SPLASH_FACTOR
            set targetSelf = target.self
            set TEMP_PLAYER = manipulatingUnit.owner
            call GroupEnumUnitsInRangeWithCollision(ENUM_GROUP, GetUnitX(targetSelf), GetUnitY(targetSelf), AREA_RANGE, TARGET_CONDITIONS)
            set targetSelf = null
            set enumUnit = FirstOfGroup(ENUM_GROUP)
            if (enumUnit != null) then
                loop
                    call GroupRemoveUnit(ENUM_GROUP, enumUnit)
                    call DestroyEffectWJ( AddSpecialEffectTargetWJ( VICTIM_EFFECT_PATH, enumUnit, VICTIM_EFFECT_ATTACHMENT_POINT ) )
                    call UnitDamageUnitEx( manipulatingUnit, GetUnit(enumUnit), damageAmount, null )
                    set enumUnit = FirstOfGroup(ENUM_GROUP)
                    exitwhen (enumUnit == null)
                endloop
            endif
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_AMOUNT, DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function Drop takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, GiantAxe_SCOPE_ID)
        local integer amount = d.amount - 1
        if (amount == NULL) then
            call d.destroy()
            call FlushAttachedIntegerById( manipulatingUnitId, GiantAxe_SCOPE_ID )
            //! runtextmacro RemoveEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = amount
        endif
        call AddUnitDamageBonus( manipulatingUnit, -BONUS_DAMAGE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnit.type, -BONUS_STRENGTH )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, GiantAxe_SCOPE_ID)
        if (d == NULL) then
            set d = Data.create()
            set d.amount = 1
            call AttachIntegerById( manipulatingUnitId, GiantAxe_SCOPE_ID, d )
            //! runtextmacro AddEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = d.amount + 1
        endif
        call AddUnitDamageBonus( manipulatingUnit, BONUS_DAMAGE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnit.type, BONUS_STRENGTH )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 850)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 240)
        call SetItemTypeRefreshIntervalStart(d, 240)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\GiantAxe.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\GloveOfTheBeast.j
//TESH.scrollpos=14
//TESH.alwaysfold=0
//! runtextmacro Scope("GloveOfTheBeast")
    globals
        public constant integer ITEM_ID = 'I001'

        private constant real BONUS_AGILITY = 7.
        private constant real BONUS_STRENGTH = 3.
        private constant real CHANCE = 0.3
        private constant string MANIPULATING_UNIT_EFFECT_PATH = "Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl"
        private constant string MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real RESTORATION_FACTOR = 0.4
    endglobals

    private struct Data
        integer amount
    endstruct

    private function Damage_Conditions takes Unit manipulatingUnit, player manipulatingUnitOwner, unit victim returns boolean
        if ( GetAttachedIntegerById( manipulatingUnit.id, GloveOfTheBeast_SCOPE_ID ) == NULL ) then
            return false
        endif
        if ( IsUnitAlly( victim, manipulatingUnitOwner ) ) then
            return false
        endif
        if ( IsUnitType( victim, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetRandomReal( 0.01, 1 ) > CHANCE ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit manipulatingUnit, Unit victim returns nothing
        if ( Damage_Conditions( manipulatingUnit, manipulatingUnit.owner, victim.self ) ) then
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( MANIPULATING_UNIT_EFFECT_PATH, manipulatingUnit.self, MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT ) )
            call HealUnitBySpell( manipulatingUnit, GetHeroAgilityTotal( manipulatingUnit ) * RESTORATION_FACTOR )
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function Drop takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, GloveOfTheBeast_SCOPE_ID)
        local integer amount = d.amount - 1
        local UnitType manipulatingUnitType = manipulatingUnit.type
        if (amount == 0) then
            call d.destroy()
            call FlushAttachedIntegerById( manipulatingUnitId, GloveOfTheBeast_SCOPE_ID )
            //! runtextmacro RemoveEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = amount
        endif
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnitType, -BONUS_AGILITY )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, -BONUS_STRENGTH )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, GloveOfTheBeast_SCOPE_ID)
        local UnitType manipulatingUnitType = manipulatingUnit.type
        if (d == NULL) then
            set d = Data.create()
            set d.amount = 1
            call AttachIntegerById( manipulatingUnitId, GloveOfTheBeast_SCOPE_ID, d )
            //! runtextmacro AddEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = d.amount + 1
        endif
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnitType, BONUS_AGILITY )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, BONUS_STRENGTH )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 750)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 50)
        call SetItemTypeRefreshIntervalStart(d, 150)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        call InitEffectType( MANIPULATING_UNIT_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\GloveOfTheBeast.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\GoldCoin.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("GoldCoin")
    globals
        public constant integer ITEM_ID = 'I00V'

        private constant integer GOLD_AMOUNT_HIGH = 125
        private constant integer GOLD_AMOUNT_LOW = 75
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Items\\ResourceItems\\ResourceEffectTarget.mdl"
    endglobals

    public function PickUp takes item coin, Unit manipulatingUnit returns nothing
        local real coinX = GetItemX( coin )
        local real coinY = GetItemY( coin )
        local real coinZ = GetItemZ( coin, coinX, coinY )
        local texttag dropTextTag
        local integer goldAmount
        local player manipulatingUnitOwner = manipulatingUnit.owner
        local unit manipulatingUnitSelf = manipulatingUnit.self
        local real manipulatingUnitX = GetUnitX(manipulatingUnitSelf)
        local real manipulatingUnitY = GetUnitY(manipulatingUnitSelf)
        local integer salesAbilityLevel = GetUnitAbilityLevel( manipulatingUnit.self, Sales_SPELL_ID )
        set manipulatingUnitSelf = null
        if ( salesAbilityLevel > 0 ) then
            set goldAmount = R2I( GetRandomInt(GOLD_AMOUNT_LOW, GOLD_AMOUNT_HIGH) * ( 1 + Sales_BONUS_GOLD_COIN_RELATIVE[salesAbilityLevel] + GetHeroIntelligenceTotal( manipulatingUnit ) * Sales_BONUS_GOLD_COIN_RELATIVE_PER_INTELLIGENCE_POINT[salesAbilityLevel] ) )
        else
            set goldAmount = GetRandomInt(GOLD_AMOUNT_LOW, GOLD_AMOUNT_HIGH)
        endif
        set dropTextTag = CreateRisingTextTag( "+" + I2S( goldAmount ), 0.024, manipulatingUnitX, manipulatingUnitY, GetUnitZ(manipulatingUnitSelf, manipulatingUnitX, manipulatingUnitY), 80, 255, 204, 0, 255, 0, 3 )
        call SetPlayerState( manipulatingUnitOwner, PLAYER_STATE_RESOURCE_GOLD, GetPlayerState( manipulatingUnitOwner, PLAYER_STATE_RESOURCE_GOLD ) + goldAmount )
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, coinX, coinY ) )
        call PlaySoundFromTypeAtPositionForPlayer( RECEIVE_GOLD_SOUND_TYPE, coinX, coinY, coinZ, manipulatingUnitOwner )
        if ( dropTextTag != null ) then
            call LimitTextTagVisibilityToPlayer( dropTextTag, manipulatingUnitOwner )
            set dropTextTag = null
        endif
        set CoinIsPickedUp_AMOUNT = goldAmount
        set TRIGGER_PLAYER = manipulatingUnitOwner
        set manipulatingUnitOwner = null
        call RunTrigger(CoinIsPickedUp_DUMMY_TRIGGER)
    endfunction

    public function Init takes nothing returns nothing
        call InitItemTypeEx( ITEM_ID )
        call InitEffectType( SPECIAL_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\GoldCoin.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\GoldenRing.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("GoldenRing")
    globals
        public constant integer ITEM_ID = 'I01G'

        private constant real BONUS_LIFE_REGENERATION = 2. * REGENERATION_INTERVAL
        private constant real BONUS_STRENGTH = 3.
    endglobals

    public function Drop takes Unit manipulatingUnit returns nothing
        call AddUnitLifeRegenerationBonus(manipulatingUnit, -BONUS_LIFE_REGENERATION)
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnit.type, -BONUS_STRENGTH )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        call AddUnitLifeRegenerationBonus(manipulatingUnit, BONUS_LIFE_REGENERATION)
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnit.type, BONUS_STRENGTH )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 200)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 30)
        call SetItemTypeRefreshIntervalStart(d, 120)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\GoldenRing.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\HealingPotion.j
//TESH.scrollpos=8
//TESH.alwaysfold=0
//! runtextmacro Scope("HealingPotion")
    globals
        public constant integer ITEM_ID = 'I00U'
        public constant integer SPELL_ID = 'A02E'

        private constant real REFRESHED_LIFE = 350.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        call DestroyEffectTimed( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, caster.self, TARGET_EFFECT_ATTACHMENT_POINT ), 2 )
        call HealUnitBySpell( caster, REFRESHED_LIFE )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 175)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 60)
        call SetItemTypeRefreshIntervalStart(d, 60)

        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\HealingPotion.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\HealingPotionBloodOrange.j
//TESH.scrollpos=112
//TESH.alwaysfold=0
//! runtextmacro Scope("HealingPotionBloodOrange")
    globals
        public constant integer ITEM_ID = 'I028'
        public constant integer SPELL_ID = 'A080'

        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private constant string CASTER_EFFECT2_PATH = "Abilities\\Spells\\Undead\\Possession\\PossessionTarget.mdl"
        private constant string CASTER_EFFECT2_ATTACHMENT_POINT = "overhead"
        private constant real DURATION = 15.
        private constant real REFRESHED_LIFE = 200.
        private constant real RESTORATION_FACTOR = 0.15
    endglobals

    private struct Data
        Unit caster
        effect casterEffect
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local effect casterEffect = d.casterEffect
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById( casterId, HealingPotionBloodOrange_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DISPEL" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call FlushAttachedInteger( durationTimer, HealingPotionBloodOrange_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
    endfunction

    public function Dispel takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, HealingPotionBloodOrange_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit caster returns nothing
        call Dispel( caster )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, HealingPotionBloodOrange_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    private function Damage_Conditions takes Unit caster, player casterOwner, unit target returns boolean
        if ( GetAttachedIntegerById( caster.id, HealingPotionBloodOrange_SCOPE_ID ) == NULL ) then
            return false
        endif
        if ( IsUnitAlly( target, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, real damageAmount, Unit target returns nothing
        if ( Damage_Conditions( caster, caster.owner, target.self ) ) then
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT2_PATH, caster.self, CASTER_EFFECT2_ATTACHMENT_POINT ) )
            call HealUnitBySpell( caster, damageAmount * RESTORATION_FACTOR )
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local Data d = GetAttachedIntegerById(casterId, HealingPotionBloodOrange_SCOPE_ID)
        local timer durationTimer
        call DestroyEffectTimed( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT ), 2 )
        if ( d == NULL ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById( casterId, HealingPotionBloodOrange_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_DISPEL" )
            //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
            call AttachInteger( durationTimer, HealingPotionBloodOrange_SCOPE_ID, d )
        else
            set durationTimer = d.durationTimer
            call DestroyEffectWJ( d.casterEffect )
        endif
        set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
        call PlaySoundFromTypeAtPosition( POTION_OF_THE_INCONSPICUOUS_SHAPE_SOUND_TYPE, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) )
        set casterSelf = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
        call HealUnitBySpell( caster, REFRESHED_LIFE )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 175)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 60)
        call SetItemTypeRefreshIntervalStart(d, 60)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitEffectType( CASTER_EFFECT2_PATH )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\HealingPotionBloodOrange.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\HealingWard.j
//TESH.scrollpos=108
//TESH.alwaysfold=0
//! runtextmacro Scope("HealingWard")
    globals
        public constant integer ITEM_ID = 'I018'
        public constant integer SPELL_ID = 'A07I'

        private constant real AREA_RANGE = 400.
        private constant real DURATION = 30.
        private group ENUM_GROUP
        private constant real INTERVAL = 1.
        private constant real RELATIVE_REFRESHED_LIFE_PER_INTERVAL = 0.04
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant string WARD_EFFECT_PATH = "Abilities\\Spells\\Orc\\CommandAura\\CommandAura.mdl"
        private constant string WARD_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        timer intervalTimer
        Unit ward
        effect wardEffect
    endstruct

    public function Death takes Unit ward returns nothing
        local timer intervalTimer
        local effect wardEffect
        local integer wardId = ward.id
        local Data d = GetAttachedIntegerById( wardId, HealingWard_SCOPE_ID )
        if ( d != NULL ) then
            set intervalTimer = d.intervalTimer
            set wardEffect = d.wardEffect
            call d.destroy()
            call FlushAttachedInteger( intervalTimer, HealingWard_SCOPE_ID )
            call DestroyTimerWJ( intervalTimer )
            set intervalTimer = null
            call FlushAttachedIntegerById( wardId, HealingWard_SCOPE_ID )
            //! runtextmacro RemoveEventById( "wardId", "EVENT_DEATH" )
            call DestroyEffectWJ( wardEffect )
            set wardEffect = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitEnemy( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        return true
    endfunction

    private function Interval takes Unit ward returns nothing
        local unit enumUnit
        local unit wardSelf = ward.self
        set TEMP_PLAYER = ward.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, GetUnitX(wardSelf), GetUnitY(wardSelf), AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call DestroyEffectTimed(AddSpecialEffectTargetWJ(TARGET_EFFECT_PATH, enumUnit, TARGET_EFFECT_ATTACHMENT_POINT), 1)
                call HealUnitBySpell(GetUnit(enumUnit), RELATIVE_REFRESHED_LIFE_PER_INTERVAL * GetUnitState(enumUnit, UNIT_STATE_MAX_LIFE))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set wardSelf = null
    endfunction

    private function IntervalByTimer takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, HealingWard_SCOPE_ID)
        set intervalTimer = null
        call Interval( d.ward )
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local Data d = Data.create()
        local timer intervalTimer = CreateTimerWJ()
        local Unit ward = CreateUnitEx( caster.owner, HEALING_WARD_UNIT_ID, targetX, targetY, STANDARD_ANGLE )
        local integer wardId = ward.id
        local unit wardSelf = ward.self
        set d.intervalTimer = intervalTimer
        set d.ward = ward
        set d.wardEffect = AddSpecialEffectTargetWJ( WARD_EFFECT_PATH, wardSelf, WARD_EFFECT_ATTACHMENT_POINT )
        call AttachInteger( intervalTimer, HealingWard_SCOPE_ID, d )
        call AttachIntegerById( wardId, HealingWard_SCOPE_ID, d )
        //! runtextmacro AddEventById( "wardId", "EVENT_DEATH" )
        call PlaySoundFromTypeOnUnit( HEALING_WARD_SOUND_TYPE, wardSelf )
        call TimerStart( intervalTimer, INTERVAL, true, function IntervalByTimer )
        call Interval( ward )
        call UnitApplyTimedLifeWJ( wardSelf, DURATION )
        set wardSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 400)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 80)
        call SetItemTypeRefreshIntervalStart(d, 300)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitEffectType( WARD_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\HealingWard.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\HeartOfTheHards.j
//TESH.scrollpos=58
//TESH.alwaysfold=0
//! runtextmacro Scope("HeartOfTheHards")
    globals
        public constant integer ITEM_ID = 'I024'
        public constant integer SET_ITEM_ID = 'I025'
        public constant integer SPELL_ID = 'A04H'

        private constant real BONUS_ARMOR_BY_SPELL = 0.15
        private constant real BONUS_MAX_LIFE = 400.
        private constant real DURATION = 5.
    endglobals

    private struct Data
        Unit caster
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById( casterId, HeartOfTheHards_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        call FlushAttachedInteger( durationTimer, HeartOfTheHards_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call RemoveUnitInvulnerabilityWithEffect( caster )
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, HeartOfTheHards_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, HeartOfTheHards_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, HeartOfTheHards_SCOPE_ID)
        local timer durationTimer
        if ( d == NULL ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById( caster.id, HeartOfTheHards_SCOPE_ID, d )
            //! runtextmacro AddEventById( "caster.id", "EVENT_DEATH" )
            call AttachInteger( durationTimer, HeartOfTheHards_SCOPE_ID, d )
            call AddUnitInvulnerabilityWithEffect( caster )
        else
            set durationTimer = d.durationTimer
        endif
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Drop takes Unit manipulatingUnit returns nothing
        call AddUnitArmorBySpellBonus( manipulatingUnit, -BONUS_ARMOR_BY_SPELL )
        call RemoveUnitCriticalStrikeImmunity( manipulatingUnit )
        call AddUnitMaxLife( manipulatingUnit, -BONUS_MAX_LIFE )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        call AddUnitArmorBySpellBonus( manipulatingUnit, BONUS_ARMOR_BY_SPELL )
        call AddUnitCriticalStrikeImmunity( manipulatingUnit )
        call AddUnitMaxLife( manipulatingUnit, BONUS_MAX_LIFE )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 1000)

        set d = InitItemTypeEx(SET_ITEM_ID)
        call SetItemTypeGoldCost(d, 1000)
        call SetItemTypeMaxCharges(d, 1)

        call CreateSetSimple2(HeartStone_ITEM_ID, Lollipop_ITEM_ID, SET_ITEM_ID, ITEM_ID)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\HeartOfTheHards.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\HeartStone.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("HeartStone")
    globals
        public constant integer ITEM_ID = 'I00E'

        private constant real BONUS_MAX_LIFE = 220.
    endglobals

    public function Drop takes Unit manipulatingUnit returns nothing
        call RemoveUnitCriticalStrikeImmunity( manipulatingUnit )
        call AddUnitMaxLife( manipulatingUnit, -BONUS_MAX_LIFE )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        call AddUnitCriticalStrikeImmunity( manipulatingUnit )
        call AddUnitMaxLife( manipulatingUnit, BONUS_MAX_LIFE )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 600)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 50)
        call SetItemTypeRefreshIntervalStart(d, 150)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\HeartStone.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\IllusionaryStaff.j
//TESH.scrollpos=63
//TESH.alwaysfold=0
//! runtextmacro Scope("IllusionaryStaff")
    globals
        public constant integer ITEM_ID = 'I017'
        public constant integer SPELL_ID = 'A07H'

        private constant real DAMAGE_BONUS = 20.
        private constant real DURATION = 60.
        private constant real HERO_DAMAGE_FACTOR = 0.3
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"
    endglobals

    public function DecayEnd takes Unit illusion returns nothing
        local integer illusionId = illusion.id
        if (GetAttachedBooleanById(illusionId, IllusionaryStaff_SCOPE_ID)) then
            call FlushAttachedBooleanById(illusionId, IllusionaryStaff_SCOPE_ID)
            //! runtextmacro RemoveEventById( "illusionId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "illusionId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( TRIGGER_UNIT )
    endfunction

    private function Damage_Conditions takes Unit target returns boolean
        set TEMP_UNIT_SELF = target.self
        if (IsUnitType(TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL)) then
            return false
        endif
        if (IsUnitType(TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE)) then
            return false
        endif
        if (GetUnitMagicImmunity(target) > 0) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit illusion, real damageAmount, Unit target returns real
        if ( GetAttachedBooleanById(illusion.id, IllusionaryStaff_SCOPE_ID) ) then
            if (Damage_Conditions(target)) then
                if (IsUnitType(illusion.self, UNIT_TYPE_HERO)) then
                    return (damageAmount + damageAmount * HERO_DAMAGE_FACTOR * ( 1 + GetUnitDamageBySpellBonus( illusion ) - GetUnitArmorBySpellBonus( target ) ))
                else
                    return (damageAmount + DAMAGE_BONUS)
                endif
            endif
        endif
        return damageAmount
    endfunction

    private function Damage_Event takes nothing returns nothing
        set DAMAGE_AMOUNT = Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local Unit illusion = CreateIllusion( target, caster.owner )
        local integer illusionId = illusion.id
        local unit illusionSelf = illusion.self
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, GetUnitX( illusionSelf ), GetUnitY( illusionSelf ) ) )
        call AttachBooleanById(illusionId, IllusionaryStaff_SCOPE_ID, true)
        //! runtextmacro AddEventById( "illusionId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "illusionId", "EVENT_DECAY_END" )
        call AddUnitArmorRelativeBonus( illusion, -1 )
        call UnitApplyTimedLifeWJ( illusionSelf, DURATION )
        set illusionSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 125)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 60)
        call SetItemTypeRefreshIntervalStart(d, 80)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_DAMAGE_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\IllusionaryStaff.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\JeweledDaggerOfGreed.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("JeweledDaggerOfGreed")
    globals
        public constant integer ITEM_ID = 'I003'

        private constant real BONUS_DAMAGE = 12.
        private constant real BONUS_RELATIVE_DROP_BY_KILL = 0.35
    endglobals

    public function Drop takes Unit manipulatingUnit returns nothing
        call AddUnitDamageBonus( manipulatingUnit, -BONUS_DAMAGE )
        call AddUnitDropByKillRelativeBonus( manipulatingUnit, -BONUS_RELATIVE_DROP_BY_KILL )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        call AddUnitDamageBonus( manipulatingUnit, BONUS_DAMAGE )
        call AddUnitDropByKillRelativeBonus( manipulatingUnit, BONUS_RELATIVE_DROP_BY_KILL )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 650)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 50)
        call SetItemTypeRefreshIntervalStart(d, 150)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\JeweledDaggerOfGreed.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\Lens.j
//TESH.scrollpos=276
//TESH.alwaysfold=0
//! runtextmacro Scope("Lens")
    globals
        public constant integer ITEM_ID = 'I02B'
        public constant integer SPELL_ID = 'A08F'

        private constant real AREA_RANGE = 325.
        private constant string CASTER_EFFECT_PATH = "Objects\\InventoryItems\\Rune\\Rune.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "overhead"
        private constant real DURATION = 10.
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        timer durationTimer
        Unit caster
        effect casterEffect
        group targetGroup
        timer updateTimer
    endstruct

    private function GetCasterData takes Unit caster returns Data
        return caster.id
    endfunction

    //! runtextmacro Scope("Target")
        globals
            private constant real Target_DAMAGE_FACTOR = 0.25
            private group Target_ENUM_GROUP
        endglobals

        private struct Target_Data
            group casterGroup
        endstruct

        private function Target_Ending takes unit caster, group casterGroup, Target_Data d, Unit target, group targetGroup returns nothing
            local integer targetId
            call GroupRemoveUnit( casterGroup, caster )
            call GroupRemoveUnit( targetGroup, target.self )
            if (FirstOfGroup(casterGroup) == null) then
                set targetId = target.id
                call d.destroy()
                call DestroyGroupWJ(casterGroup)
                call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                call RemoveUnitAnyDamageEvents(target)
            endif
        endfunction

        public function Target_EndingByEnding takes unit caster, Unit target, group targetGroup returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            call Target_Ending(caster, d.casterGroup, d, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Unit caster
            local unit casterSelf
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            local group casterGroup = d.casterGroup
            local integer iteration = CountUnits(casterGroup)
            if (iteration > 0) then
                loop
                    set casterSelf = FirstOfGroup(casterGroup)
                    set caster = GetUnit(casterSelf)
                    call Target_Ending( casterSelf, casterGroup, d, target, GetCasterData(caster).targetGroup )
                    set iteration = iteration - 1
                    exitwhen (iteration < 1)
                endloop
            endif
            set casterGroup = null
            set casterSelf = null
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_AnyDamage takes real damageAmount, Unit damageSource, Unit target returns real
            local unit caster
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            if (d != NULL) then
                set caster = FirstOfGroup(d.casterGroup)
                if (IsUnitType(caster, UNIT_TYPE_DEAD) == false) then
                    call UnitDamageUnitEx( damageSource, GetUnit(caster), Target_DAMAGE_FACTOR * damageAmount, null )
                endif
                set caster = null
                return 0.
            endif
            return damageAmount
        endfunction

        public function Target_Start takes unit caster, Unit target returns nothing
            local group casterGroup
            local integer targetId = target.id
            local Target_Data d = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
            local boolean isNew = (d == NULL)
            if (isNew) then
                set casterGroup = CreateGroupWJ()
                set d = Target_Data.create()
                set d.casterGroup = casterGroup
                call AttachIntegerById(targetId, Target_SCOPE_ID, d)
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
                call AddUnitAnyDamageEvents(target)
            else
                set casterGroup = d.casterGroup
            endif
            call GroupAddUnit(casterGroup, caster)
            set casterGroup = null
        endfunction

        public function Target_Init takes nothing returns nothing
            set Target_ENUM_GROUP = CreateGroupWJ()
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    private function Ending takes Data d, timer durationTimer returns nothing
        local Unit caster = d.caster
        local effect casterEffect = d.casterEffect
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local unit enumUnit
        local group targetGroup = d.targetGroup
        local timer updateTimer = d.updateTimer
        call d.destroy()
        call FlushAttachedIntegerById(casterId, Lens_SCOPE_ID)
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call DestroyTimerWJ( durationTimer )
        loop
            set enumUnit = FirstOfGroup( targetGroup )
            exitwhen ( enumUnit == null )
            call Target_Target_EndingByEnding( casterSelf, GetUnit(enumUnit), targetGroup )
        endloop
        set casterSelf = null
        call DestroyGroupWJ(targetGroup)
        set targetGroup = null
        call DestroyTimerWJ(updateTimer)
        set updateTimer = null
    endfunction

    private function Death_Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Lens_SCOPE_ID)
        call Ending(d, durationTimer)
        set durationTimer = null
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Lens_SCOPE_ID)
        if ( d != NULL ) then
            call TimerStart(d.durationTimer, 0, false, function Death_Ending)
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( TRIGGER_UNIT )
    endfunction

    public function DecayEnd takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Lens_SCOPE_ID)
        if ( d != NULL ) then
            call Ending(d, d.durationTimer)
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( TRIGGER_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Lens_SCOPE_ID)
        call Ending(d, durationTimer)
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if (GetAttachedIntegerById(GetUnit(FILTER_UNIT_SELF).id, Lens_SCOPE_ID) != NULL) then
            return false
        endif
        return true
    endfunction

    private function Update takes Unit caster, group targetGroup returns nothing
        local Unit enumUnit
        local unit enumUnitSelf
        local player casterOwner = caster.owner
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        set TEMP_PLAYER = casterOwner
        set casterOwner = null
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( targetGroup )
        if ( enumUnitSelf != null ) then
            loop
                if ( IsUnitInGroup( enumUnitSelf, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( casterSelf, GetUnit(enumUnitSelf), targetGroup )
                else
                    call GroupRemoveUnit( targetGroup, enumUnitSelf )
                    call GroupAddUnit( ENUM_GROUP2, enumUnitSelf )
                endif
                set enumUnitSelf = FirstOfGroup( targetGroup )
                exitwhen ( enumUnitSelf == null )
            endloop
            set enumUnitSelf = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnitSelf )
                call GroupAddUnit( targetGroup, enumUnitSelf )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                if ( IsUnitInGroup( enumUnitSelf, targetGroup ) == false ) then
                    call GroupAddUnit( targetGroup, enumUnitSelf )
                    call Target_Target_Start(casterSelf, enumUnit)
                endif
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
            set enumUnitSelf = null
        endif
        set casterSelf = null
        set targetGroup = null
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, Lens_SCOPE_ID)
        set updateTimer = null
        call Update(d.caster, d.targetGroup)
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, Lens_SCOPE_ID)
        local timer durationTimer
        local group targetGroup
        local timer updateTimer
        if ( d == NULL ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set targetGroup = CreateGroupWJ()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT )
            set d.durationTimer = durationTimer
            set d.targetGroup = targetGroup
            set d.updateTimer = updateTimer
            call AttachIntegerById(casterId, Lens_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
            call AttachInteger(durationTimer, Lens_SCOPE_ID, d)
            call AttachInteger(updateTimer, Lens_SCOPE_ID, d)
            call TimerStart( updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            set updateTimer = null
            call Update(caster, targetGroup)
            set targetGroup = null
            call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
            set durationTimer = null
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 90)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 60)
        call SetItemTypeRefreshIntervalStart(d, 60)

        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( CASTER_EFFECT_PATH )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\Lens.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\LifeArmor.j
//TESH.scrollpos=281
//TESH.alwaysfold=0
//! runtextmacro Scope("LifeArmor")
    globals
        public constant integer ITEM_ID = 'I01S'
        public constant integer SET_ITEM_ID = 'I01Y'

        private constant real AREA_RANGE = 550.
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Other\\Drain\\DrainCaster.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 1.
        private constant real REFRESHED_LIFE = 1.25 * UPDATE_TIME
        private constant real REFRESHED_LIFE_HERO = 2. * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_LIFE = 0.005 * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_LIFE_HERO = 0.01 * UPDATE_TIME
    endglobals

    private struct Data
        integer amount
        Unit caster
        effect casterEffect
        group targetGroup
        timer updateTimer
    endstruct

    private function GetCasterData takes Unit caster returns Data
        return caster.id
    endfunction

    //! runtextmacro Scope("Target")
        globals
            private group Target_ENUM_GROUP
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            group casterGroup
            effect targetEffect
        endstruct

        private function Target_Ending takes unit caster, group casterGroup, Target_Data d, Unit target, group targetGroup returns nothing
            local effect targetEffect
            local integer targetId
            call GroupRemoveUnit( casterGroup, caster )
            call GroupRemoveUnit( targetGroup, target.self )
            if (FirstOfGroup(casterGroup) == null) then
                set targetEffect = d.targetEffect
                set targetId = target.id
                call d.destroy()
                call DestroyGroupWJ(casterGroup)
                call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                call DestroyEffectWJ( targetEffect )
                set targetEffect = null
            endif
        endfunction

        public function Target_EndingByEnding takes unit caster, Unit target, group targetGroup returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            call Target_Ending(caster, d.casterGroup, d, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Unit caster
            local unit casterSelf
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            local group casterGroup = d.casterGroup
            local integer iteration = CountUnits(casterGroup)
            if (iteration > 0) then
                loop
                    set casterSelf = FirstOfGroup(casterGroup)
                    set caster = GetUnit(casterSelf)
                    call Target_Ending( casterSelf, casterGroup, d, target, GetCasterData(caster).targetGroup )
                    set iteration = iteration - 1
                    exitwhen (iteration < 1)
                endloop
            endif
            set casterGroup = null
            set casterSelf = null
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Heal takes unit caster, Unit target returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            local unit targetSelf
            if (FirstOfGroup(d.casterGroup) == caster) then
                set targetSelf = target.self
                if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
                    call AddUnitState( targetSelf, UNIT_STATE_LIFE, REFRESHED_RELATIVE_LIFE_HERO * GetUnitState( targetSelf, UNIT_STATE_MAX_LIFE ) + REFRESHED_LIFE_HERO )
                else
                    call AddUnitState( targetSelf, UNIT_STATE_LIFE, REFRESHED_RELATIVE_LIFE * GetUnitState( targetSelf, UNIT_STATE_MAX_LIFE ) + REFRESHED_LIFE )
                endif
                set targetSelf = null
            endif
        endfunction

        public function Target_Start takes unit caster, Unit target returns nothing
            local group casterGroup
            local integer targetId = target.id
            local Target_Data d = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
            local boolean isNew = (d == NULL)
            if (isNew) then
                set casterGroup = CreateGroupWJ()
                set d = Target_Data.create()
                set d.casterGroup = casterGroup
                set d.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
                call AttachIntegerById(targetId, Target_SCOPE_ID, d)
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            else
                set casterGroup = d.casterGroup
            endif
            call GroupAddUnit(casterGroup, caster)
            set casterGroup = null
        endfunction

        public function Target_Init takes nothing returns nothing
            set Target_ENUM_GROUP = CreateGroupWJ()
            //! runtextmacro CreateEvent( "TargeT_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function Ending takes Unit caster, Data d, boolean remove returns nothing
        local effect casterEffect = d.casterEffect
        local integer casterId
        local unit casterSelf = caster.self
        local unit enumUnit
        local group targetGroup = d.targetGroup
        local timer updateTimer = d.updateTimer
        call d.destroy()
        if (remove) then
            set casterId = caster.id
            call FlushAttachedIntegerById(casterId, LifeArmor_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_REVIVE" )
        endif
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        loop
            set enumUnit = FirstOfGroup( targetGroup )
            exitwhen ( enumUnit == null )
            call Target_Target_EndingByEnding( casterSelf, GetUnit(enumUnit), targetGroup )
        endloop
        set casterSelf = null
        if (remove) then
            call DestroyGroupWJ(targetGroup)
            call DestroyTimerWJ(updateTimer)
        else
            call PauseTimer( updateTimer )
        endif
        set targetGroup = null
        set updateTimer = null
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, LifeArmor_SCOPE_ID)
        if ( d != NULL ) then
            call Ending(caster, d, false)
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( TRIGGER_UNIT )
    endfunction

    public function Drop takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, LifeArmor_SCOPE_ID)
        local integer amount = d.amount - 1
        if (amount == 0) then
            call Ending( caster, GetAttachedIntegerById(caster.id, LifeArmor_SCOPE_ID), true )
        else
            set d.amount = amount
        endif
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) >= GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_MAX_LIFE ) ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes Unit caster, group targetGroup returns nothing
        local Unit enumUnit
        local unit enumUnitSelf
        local player casterOwner = caster.owner
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        set TEMP_PLAYER = casterOwner
        set casterOwner = null
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( targetGroup )
        if ( enumUnitSelf != null ) then
            loop
                if ( IsUnitInGroup( enumUnitSelf, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( casterSelf, GetUnit(enumUnitSelf), targetGroup )
                else
                    call GroupRemoveUnit( targetGroup, enumUnitSelf )
                    call GroupAddUnit( ENUM_GROUP2, enumUnitSelf )
                endif
                set enumUnitSelf = FirstOfGroup( targetGroup )
                exitwhen ( enumUnitSelf == null )
            endloop
            set enumUnitSelf = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnitSelf )
                call GroupAddUnit( targetGroup, enumUnitSelf )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                if ( IsUnitInGroup( enumUnitSelf, targetGroup ) == false ) then
                    call GroupAddUnit( targetGroup, enumUnitSelf )
                    call Target_Target_Start(casterSelf, enumUnit)
                endif
                call Target_Target_Heal(casterSelf, enumUnit)
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
            set enumUnitSelf = null
        endif
        set casterSelf = null
        set targetGroup = null
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, LifeArmor_SCOPE_ID)
        set updateTimer = null
        call Update(d.caster, d.targetGroup)
    endfunction

    public function Revive takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, LifeArmor_SCOPE_ID)
        if ( d != NULL ) then
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT )
            call TimerStart( d.updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            call Update( caster, d.targetGroup )
        endif
    endfunction

    private function Revive_Event takes nothing returns nothing
        call Revive( REVIVING_UNIT )
    endfunction

    public function PickUp takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, LifeArmor_SCOPE_ID)
        local group targetGroup
        local timer updateTimer
        if ( d == NULL ) then
            set d = Data.create()
            set targetGroup = CreateGroupWJ()
            set updateTimer = CreateTimerWJ()
            set d.amount = 1
            set d.caster = caster
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT )
            set d.targetGroup = targetGroup
            set d.updateTimer = updateTimer
            call AttachIntegerById(casterId, LifeArmor_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_REVIVE" )
            call AttachInteger(updateTimer, LifeArmor_SCOPE_ID, d)
            call TimerStart( updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            set updateTimer = null
            call Update(caster, targetGroup)
            set targetGroup = null
        else
            set d.amount = d.amount + 1
        endif
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 1500)

        set d = InitItemTypeEx(SET_ITEM_ID)
        call SetItemTypeGoldCost(d, 1500)
        call SetItemTypeMaxCharges(d, 1)

        call CreateSetSimple2(GoldenRing_ITEM_ID, GoldenRing_ITEM_ID, SET_ITEM_ID, ITEM_ID)

        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_REVIVE", "UnitFinishesReviving_EVENT_KEY", "0", "function Revive_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( CASTER_EFFECT_PATH )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\LifeArmor.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\Lollipop.j
//TESH.scrollpos=8
//TESH.alwaysfold=0
//! runtextmacro Scope("Lollipop")
    globals
        public constant integer ITEM_ID = 'I01O'
        public constant integer MANUFACTURED_ITEM_ID = 'I02A'

        private constant real BONUS_LIFE_REGENERATION = 1.5 * REGENERATION_INTERVAL
        private constant real BONUS_MANA_REGENERATION = 1.5 * REGENERATION_INTERVAL
    endglobals

    public function Drop takes Unit manipulatingUnit returns nothing
        call AddUnitLifeRegenerationBonus(manipulatingUnit, -BONUS_LIFE_REGENERATION)
        call AddUnitManaRegenerationBonus(manipulatingUnit, -BONUS_MANA_REGENERATION)
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        call AddUnitLifeRegenerationBonus(manipulatingUnit, BONUS_LIFE_REGENERATION)
        call AddUnitManaRegenerationBonus(manipulatingUnit, BONUS_MANA_REGENERATION)
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 300)

        set d = InitItemTypeEx(MANUFACTURED_ITEM_ID)
        call SetItemTypeGoldCost(d, 300)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 30)
        call SetItemTypeRefreshIntervalStart(d, 90)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\Lollipop.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\MecaPenguin.j
//TESH.scrollpos=165
//TESH.alwaysfold=0
//! runtextmacro Scope("MecaPenguin")
    globals
        public constant integer ITEM_ID = 'I005'
        public constant integer SPELL_ID = 'A00E'

        private constant real AREA_RANGE = 250.
        private constant real DAMAGE = 140.
        private group ENUM_GROUP
        private constant real INTERVAL = 1.
        private constant integer MAX_COUNTS_AMOUNT = 3
        private constant real DURATION = MAX_COUNTS_AMOUNT * INTERVAL
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Other\\Doom\\DoomDeath.mdl"
        private constant real SPEED = 160.
        private constant real START_OFFSET = 50.
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        Unit caster
        timer countdownTimer
        integer countsAmount
        timer durationTimer
        real lengthX
        real lengthY
        timer moveTimer
        Unit penguin
    endstruct

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if (GetUnitInvulnerability(GetUnit(FILTER_UNIT_SELF)) > 0) then
            return false
        endif
        return true
    endfunction

    private function Ending takes Data d, timer durationTimer, Unit penguin, player protectedPlayer returns nothing
        local timer countdownTimer = d.countdownTimer
        local unit enumUnit
        local Unit caster = d.caster
        local timer moveTimer = d.moveTimer
        local unit penguinSelf = penguin.self
        local real penguinX = GetUnitX( penguinSelf )
        local real penguinY = GetUnitY( penguinSelf )
        set penguinSelf = null
        call d.destroy()
        call FlushAttachedInteger( countdownTimer, MecaPenguin_SCOPE_ID )
        call DestroyTimerWJ( countdownTimer )
        set countdownTimer = null
        call FlushAttachedInteger( durationTimer, MecaPenguin_SCOPE_ID)
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( moveTimer, MecaPenguin_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        set moveTimer = null
        call FlushAttachedIntegerById( penguin.id, MecaPenguin_SCOPE_ID )
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, penguinX, penguinY ) )
        call RemoveUnitEx( penguin )
        set TEMP_PLAYER = protectedPlayer
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, penguinX, penguinY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), DAMAGE )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, MecaPenguin_SCOPE_ID)
        local Unit penguin = d.penguin
        call Ending( d, durationTimer, penguin, penguin.owner )
        set durationTimer = null
    endfunction

    public function Select takes Unit penguin, player triggerPlayer returns nothing
        local Data d = GetAttachedIntegerById( penguin.id, MecaPenguin_SCOPE_ID )
        if ( d != NULL ) then
            if ( d.caster.owner == triggerPlayer ) then
                call Ending( d, d.durationTimer, penguin, null )
            endif
        endif
    endfunction

    private function Countdown takes nothing returns nothing
        local timer countdownTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(countdownTimer, MecaPenguin_SCOPE_ID)
        local integer countsAmount = d.countsAmount - 1
        local Unit penguin = d.penguin
        local unit penguinSelf = penguin.self
        set countdownTimer = null
        set d.countsAmount = countsAmount
        call CreateRisingTextTag( I2S( countsAmount ), 0.03, GetUnitX(penguinSelf), GetUnitY(penguinSelf), 0, 75, 200, 200, 200, 255, 1, 3 )
        set penguinSelf = null
    endfunction

    private function Move takes nothing returns nothing
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, MecaPenguin_SCOPE_ID)
        local Unit penguin = d.penguin
        local unit penguinSelf = penguin.self
        local real penguinX = GetUnitX( penguinSelf )
        local real penguinY = GetUnitY( penguinSelf )
        set moveTimer = null
        call SetUnitXYIfNotBlocked( penguinSelf, penguinX, penguinY, penguinX + d.lengthX, penguinY + d.lengthY )
        set penguinSelf = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local real angle
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local timer countdownTimer = CreateTimerWJ()
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local real lengthX
        local real lengthY
        local timer moveTimer = CreateTimerWJ()
        local real partX
        local real partY
        local Unit penguin
        if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
        else
            set angle = GetUnitFacingWJ( casterSelf )
        endif
        set casterSelf = null
        set partX = Cos( angle )
        set partY = Sin( angle )
        set penguin = CreateUnitEx( NEUTRAL_PASSIVE_PLAYER, MECA_PENGUIN_UNIT_ID, casterX + START_OFFSET * partX, casterY + START_OFFSET * partY, angle )
        set d.caster = caster
        set d.countdownTimer = countdownTimer
        set d.countsAmount = MAX_COUNTS_AMOUNT
        set d.durationTimer = durationTimer
        set d.lengthX = LENGTH * partX
        set d.lengthY = LENGTH * partY
        set d.moveTimer = moveTimer
        set d.penguin = penguin
        call AttachInteger( countdownTimer, MecaPenguin_SCOPE_ID, d )
        call AttachInteger( durationTimer, MecaPenguin_SCOPE_ID, d )
        call AttachInteger( moveTimer, MecaPenguin_SCOPE_ID, d )
        call AttachIntegerById( penguin.id, MecaPenguin_SCOPE_ID, d )
        call SetUnitAnimationByIndex( penguin.self, 4 )
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
        call TimerStart( countdownTimer, INTERVAL, true, function Countdown )
        set countdownTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 125)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 55)
        call SetItemTypeRefreshIntervalStart(d, 90)
    
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\MecaPenguin.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\MedaillonOfTheStrivingGod.j
//TESH.scrollpos=3
//TESH.alwaysfold=0
//! runtextmacro Scope("MedaillonOfTheStrivingGod")
    globals
        public constant integer ITEM_ID = 'I020'
        public constant integer SET_ITEM_ID = 'I029'

        private constant real BONUS_INTELLIGENCE = 7.
        private constant real BONUS_RELATIVE_MANA_REGENERATION = 0.8
        private constant real BONUS_STRENGTH = 4.
    endglobals

    public function Drop takes Unit manipulatingUnit, Item manipulatedItem returns nothing
        local integer manipulatedItemId = manipulatedItem.id
        local real bonusManaRegeneration = GetAttachedRealById(manipulatedItemId, MedaillonOfTheStrivingGod_SCOPE_ID)
        local UnitType manipulatingUnitType = manipulatingUnit.type
        call FlushAttachedRealById(manipulatedItemId, MedaillonOfTheStrivingGod_SCOPE_ID)
        call AddUnitManaRegenerationBonus( manipulatingUnit, -bonusManaRegeneration )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, -BONUS_INTELLIGENCE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, -BONUS_STRENGTH )
    endfunction

    public function PickUp takes Unit manipulatingUnit, Item manipulatedItem returns nothing
        local real bonusManaRegeneration = GetUnitManaRegeneration(manipulatingUnit) * BONUS_RELATIVE_MANA_REGENERATION
        local UnitType manipulatingUnitType = manipulatingUnit.type
        call AttachRealById(manipulatedItem.id, MedaillonOfTheStrivingGod_SCOPE_ID, bonusManaRegeneration)
        call AddUnitManaRegenerationBonus( manipulatingUnit, bonusManaRegeneration )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, BONUS_INTELLIGENCE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, BONUS_STRENGTH )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 750)

        set d = InitItemTypeEx(SET_ITEM_ID)
        call SetItemTypeGoldCost(d, 750)
        call SetItemTypeMaxCharges(d, 1)

        call CreateSetSimple(MedaillonOfTheStrivingGod_ITEM_ID, SET_ITEM_ID, ITEM_ID)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\MedaillonOfTheStrivingGod.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\MightyHammer.j
//TESH.scrollpos=203
//TESH.alwaysfold=0
//! runtextmacro Scope("MightyHammer")
    globals
        public constant integer ITEM_ID = 'I002'
        public constant integer SET_ITEM_ID = 'I01Z'
        public constant integer SPELL_ID = 'A04D'

        private constant real BONUS_STRENGTH = 10.
        private constant real DAMAGE_PER_ATTRIBUTE_POINT = 1.5
        private constant integer DUMMY_UNIT_ID = 'h00T'
        private constant real SPEED = 600.
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
    endglobals

    private struct Data
        Unit caster
        real damageAmount
        unit dummyUnit
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        real x
        real y
        real z
    endstruct

    private function Ending takes Data d, boolean isTargetNotNull, unit dummyUnit, timer moveTimer, Unit target returns nothing
        local integer targetId
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 1 )
        call RemoveUnitTimed( dummyUnit, 2 )
        call FlushAttachedInteger( moveTimer, MightyHammer_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        if ( isTargetNotNull ) then
            set targetId = target.id
            call RemoveIntegerFromTableById( targetId, MightyHammer_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, MightyHammer_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
            endif
        endif
    endfunction

    private function Death_ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        call RemoveIntegerFromTableById( targetId, MightyHammer_SCOPE_ID, d )
        set d.target = NULL
        if ( CountIntegersInTableById( targetId, MightyHammer_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, MightyHammer_SCOPE_ID )
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById( targetId, MightyHammer_SCOPE_ID, iteration )
                call Death_ResetTarget( d, target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function TargetConditions takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitInvulnerability( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_INVULNERABLE
        endif
        if ( GetUnitMagicImmunity( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        return null
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local Unit caster
        local real damageAmount
        local real distanceX
        local real distanceY
        local real distanceZ
        local boolean isTargetNotNull
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, MightyHammer_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local real dummyUnitX = d.x
        local real dummyUnitY = d.y
        local real dummyUnitZ = d.z
        local boolean reachesTarget
        local Unit target = d.target
        local boolean isTargetNull = ( target == null )
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
            set targetSelf = null
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( dummyUnitX, dummyUnitY, dummyUnitZ, targetX, targetY, targetZ ) <= LENGTH )
        if ( reachesTarget ) then
            set dummyUnitX = targetX
            set dummyUnitY = targetY
            set dummyUnitZ = targetZ
        else
            set distanceZ = targetZ - dummyUnitZ
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( dummyUnitX, dummyUnitY, targetX, targetY ) )
            set distanceX = targetX - dummyUnitX
            set distanceY = targetY - dummyUnitY
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = LENGTH * Cos( angleLengthXYZ )
            set dummyUnitX = dummyUnitX + lengthXY * Cos( angleXY )
            set dummyUnitY = dummyUnitY + lengthXY * Sin( angleXY )
            set dummyUnitZ = dummyUnitZ + LENGTH * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, dummyUnitX )
        call SetUnitY( dummyUnit, dummyUnitY )
        call SetUnitZ( dummyUnit, dummyUnitX, dummyUnitY, dummyUnitZ )
        if ( reachesTarget ) then
            set isTargetNotNull = ( isTargetNull == false )
            if ( isTargetNotNull ) then
                set damageAmount = d.damageAmount
            endif
            call Ending( d, isTargetNotNull, dummyUnit, moveTimer, target )
            if ( isTargetNotNull ) then
                if ( TargetConditions( caster.owner, target ) == null ) then
                    call UnitDamageUnitBySpell( caster, target, damageAmount )
                endif
            endif
        else
            set d.x = dummyUnitX
            set d.y = dummyUnitY
            set d.z = dummyUnitZ
        endif
        set moveTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster)
        local Data d = Data.create()
        local unit dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, GetUnitFacingWJ( casterSelf ) )
        local timer moveTimer = CreateTimer()
        local integer targetId = target.id
        set casterSelf = null
        set d.caster = caster
        set d.damageAmount = ( GetHeroAgilityTotal( caster ) + GetHeroIntelligenceTotal( caster ) + GetHeroStrengthTotal( caster ) ) * DAMAGE_PER_ATTRIBUTE_POINT
        set d.dummyUnit = dummyUnit
        set d.moveTimer = moveTimer
        set d.target = target
        set d.x = casterX
        set d.y = casterY
        set d.z = casterZ
        call AttachInteger( moveTimer, MightyHammer_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, MightyHammer_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, MightyHammer_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call SetUnitZ( dummyUnit, casterX, casterY, casterZ )
        set dummyUnit = null
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Drop takes Unit manipulatingUnit returns nothing
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnit.type, -BONUS_STRENGTH )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnit.type, BONUS_STRENGTH )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 1000)

        set d = InitItemTypeEx(SET_ITEM_ID)
        call SetItemTypeGoldCost(d, 1000)
        call SetItemTypeMaxCharges(d, 1)

        call CreateSetSimple(GiantAxe_ITEM_ID, SET_ITEM_ID, ITEM_ID)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\MightyHammer.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\Nethermask.j
//TESH.scrollpos=81
//TESH.alwaysfold=0
//! runtextmacro Scope("Nethermask")
    globals
        public constant integer ITEM_ID = 'I00C'
        public constant integer SET_ITEM_ID = 'I027'

        private constant real BONUS_RELATIVE_MANA_REGENERATION = 0.4
    endglobals

    private struct Data
        real bonusManaRegeneration
    endstruct

    //! runtextmacro Scope("Use")
        globals
            public constant integer Use_SPELL_ID = 'A04F'

            private constant real Use_BONUS_RELATIVE_SPELL_ARMOR = 0.5
            private constant real Use_BONUS_RELATIVE_SPELL_DAMAGE = 0.5
            private constant string Use_CASTER_EFFECT_PATH = "Abilities\\Spells\\Human\\MagicSentry\\MagicSentryCaster.mdl"
            private constant string Use_CASTER_EFFECT_ATTACHMENT_POINT = "overhead"
            private constant real Use_DURATION = 15.
        endglobals

        private struct Use_Data
            Unit caster
            effect casterEffect
            timer durationTimer
        endstruct

        private function Use_Ending takes Unit caster, Use_Data d, timer durationTimer returns nothing
            local effect casterEffect = d.casterEffect
            local integer casterId = caster.id
            call d.destroy()
            call FlushAttachedIntegerById( casterId, Use_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "Use_EVENT_DEATH" )
            call DestroyEffectWJ( casterEffect )
            set casterEffect = null
            call FlushAttachedInteger( durationTimer, Use_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call AddUnitArmorBySpellBonus( caster, -Use_BONUS_RELATIVE_SPELL_ARMOR )
            call AddUnitDamageBySpellBonus( caster, -Use_BONUS_RELATIVE_SPELL_DAMAGE )
        endfunction

        public function Use_Death takes Unit caster returns nothing
            local Use_Data d = GetAttachedIntegerById(caster.id, Nethermask_SCOPE_ID)
            if ( d != NULL ) then
                call Use_Ending( caster, d, d.durationTimer )
            endif
        endfunction

        private function Use_Death_Event takes nothing returns nothing
            call Use_Death( DYING_UNIT )
        endfunction

        private function Use_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Use_Data d = GetAttachedInteger(durationTimer, Use_SCOPE_ID)
            call Use_Ending( d.caster, d, durationTimer )
            set durationTimer = null
        endfunction

        public function Use_SpellEffect takes Unit caster returns nothing
            local integer casterId = caster.id
            local Use_Data d = GetAttachedIntegerById(casterId, Use_SCOPE_ID)
            local timer durationTimer
            local boolean isNew = (d == NULL)
            if ( isNew ) then
                set d = Use_Data.create()
                set durationTimer = CreateTimerWJ()
                set d.durationTimer = durationTimer
                set d.caster = caster
                call AttachIntegerById( casterId, Use_SCOPE_ID, d )
                //! runtextmacro AddEventById( "casterId", "Use_EVENT_DEATH" )
                call AttachInteger( durationTimer, Use_SCOPE_ID, d )
            else
                set durationTimer = d.durationTimer
                call DestroyEffectWJ( d.casterEffect )
            endif
            set d.casterEffect = AddSpecialEffectTargetWJ( Use_CASTER_EFFECT_PATH, caster.self, Use_CASTER_EFFECT_ATTACHMENT_POINT )
            if (isNew) then
                call AddUnitArmorBySpellBonus( caster, Use_BONUS_RELATIVE_SPELL_ARMOR )
                call AddUnitDamageBySpellBonus( caster, Use_BONUS_RELATIVE_SPELL_DAMAGE )
            else
            endif
            call TimerStart( durationTimer, Use_DURATION, false, function Use_EndingByTimer )
            set durationTimer = null
        endfunction

        private function Use_SpellEffect_Event takes nothing returns nothing
            call Use_SpellEffect( CASTER )
        endfunction

        public function Use_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Use_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Use_Death_Event" )
            call InitEffectType( Use_CASTER_EFFECT_PATH )
            call InitAbility( Use_SPELL_ID )
            //! runtextmacro AddNewEventById( "Use_EVENT_CAST", "Use_SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function Use_SpellEffect_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Drop takes Unit manipulatingUnit, Item mask returns nothing
        local integer maskId = mask.id
        local Data d = GetAttachedIntegerById(maskId, Nethermask_SCOPE_ID)
        local real bonusManaRegeneration = -d.bonusManaRegeneration
        call d.destroy()
        call FlushAttachedIntegerById(maskId, Nethermask_SCOPE_ID)
        call AddUnitManaRegenerationBonus(manipulatingUnit, bonusManaRegeneration)
    endfunction

    public function PickUp takes Unit manipulatingUnit, Item mask returns nothing
        local real bonusManaRegeneration = GetUnitManaRegeneration(manipulatingUnit) * BONUS_RELATIVE_MANA_REGENERATION
        local Data d = Data.create()
        set d.bonusManaRegeneration = bonusManaRegeneration
        call AttachIntegerById(mask.id, Nethermask_SCOPE_ID, d)
        call AddUnitManaRegenerationBonus(manipulatingUnit, bonusManaRegeneration)
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 900)

        set d = InitItemTypeEx(SET_ITEM_ID)
        call SetItemTypeGoldCost(d, 900)
        call SetItemTypeMaxCharges(d, 1)

        call CreateSetSimple(OrbOfWisdom_ITEM_ID, SET_ITEM_ID, ITEM_ID)

        call Use_Use_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\Nethermask.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\OrbOfWisdom.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("OrbOfWisdom")
    globals
        public constant integer ITEM_ID = 'I01U'

        private constant real BONUS_RELATIVE_MANA_REGENERATION = 0.5
    endglobals

    public function Drop takes Unit manipulatingUnit, Item manipulatedItem returns nothing
        local integer manipulatedItemId = manipulatedItem.id
        local real bonusManaRegeneration = GetAttachedRealById(manipulatedItemId, OrbOfWisdom_SCOPE_ID)
        call FlushAttachedRealById(manipulatedItemId, OrbOfWisdom_SCOPE_ID)
        call AddUnitManaRegenerationBonus( manipulatingUnit, -bonusManaRegeneration )
    endfunction

    public function PickUp takes Unit manipulatingUnit, Item manipulatedItem returns nothing
        local real bonusManaRegeneration = GetUnitManaRegeneration(manipulatingUnit) * BONUS_RELATIVE_MANA_REGENERATION
        call AttachRealById(manipulatedItem.id, OrbOfWisdom_SCOPE_ID, bonusManaRegeneration)
        call AddUnitManaRegenerationBonus( manipulatingUnit, bonusManaRegeneration )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 750)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 30)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\OrbOfWisdom.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\PotionOfTheInconspicuousShape.j
//TESH.scrollpos=84
//TESH.alwaysfold=0
//! runtextmacro Scope("PotionOfTheInconspicuousShape")
    globals
        public constant integer ITEM_ID = 'I006'
        public constant integer SPELL_ID = 'A01A'

        private constant real BONUS_EVADE_CHANCE = 0.5
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Undead\\Possession\\PossessionTarget.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "overhead"
        private constant real DURATION = 15.
    endglobals

    private struct Data
        Unit caster
        effect casterEffect
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local effect casterEffect = d.casterEffect
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById( casterId, PotionOfTheInconspicuousShape_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DISPEL" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call FlushAttachedInteger( durationTimer, PotionOfTheInconspicuousShape_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call AddUnitEvasionChance( caster, -BONUS_EVADE_CHANCE )
    endfunction

    public function Dispel takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, PotionOfTheInconspicuousShape_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit caster returns nothing
        call Dispel( caster )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, PotionOfTheInconspicuousShape_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local Data d = GetAttachedIntegerById(casterId, PotionOfTheInconspicuousShape_SCOPE_ID)
        local timer durationTimer
        local boolean isNew = (d == NULL)
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById( casterId, PotionOfTheInconspicuousShape_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_DISPEL" )
            call AttachInteger( durationTimer, PotionOfTheInconspicuousShape_SCOPE_ID, d )
        else
            set durationTimer = d.durationTimer
            call DestroyEffectWJ( d.casterEffect )
        endif
        set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
        if (isNew) then
            call AddUnitEvasionChance( caster, BONUS_EVADE_CHANCE )
        endif
        call PlaySoundFromTypeAtPosition( POTION_OF_THE_INCONSPICUOUS_SHAPE_SOUND_TYPE, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) )
        set casterSelf = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 125)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 80)
        call SetItemTypeRefreshIntervalStart(d, 200)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( CASTER_EFFECT_PATH )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\PotionOfTheInconspicuousShape.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\PrismaticCape.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("PrismaticCape")
    globals
        public constant integer ITEM_ID = 'I004'
        public constant integer SET_ITEM_ID = 'I021'

        private constant real BONUS_AGILITY = 8.
        private constant real BONUS_RELATIVE_EVADE_CHANCE = 0.15
        private constant real BONUS_INTELLIGENCE = 8.
        private constant real BONUS_STRENGTH = 8.
    endglobals

    private struct Data
        real bonusEvadeChance
    endstruct

    public function Drop takes Item manipulatedItem, Unit manipulatingUnit returns nothing
        local integer manipulatedItemId = manipulatedItem.id
        local Data d = GetAttachedIntegerById(manipulatedItemId, PrismaticCape_SCOPE_ID)
        local real bonusEvadeChance = -d.bonusEvadeChance
        local UnitType manipulatingUnitType = manipulatingUnit.type
        call d.destroy()
        call FlushAttachedIntegerById( manipulatedItemId, PrismaticCape_SCOPE_ID )
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnitType, -BONUS_AGILITY )
        call AddUnitEvasionChance( manipulatingUnit, bonusEvadeChance )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, -BONUS_INTELLIGENCE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, -BONUS_STRENGTH )
    endfunction

    public function PickUp takes Item manipulatedItem, Unit manipulatingUnit returns nothing
        local Data d = Data.create()
        local real bonusEvadeChance = ( 1 - GetUnitEvasionChance( manipulatingUnit ) ) * BONUS_RELATIVE_EVADE_CHANCE
        local UnitType manipulatingUnitType = manipulatingUnit.type
        set d.bonusEvadeChance = bonusEvadeChance
        call AttachIntegerById( manipulatedItem.id, PrismaticCape_SCOPE_ID, d )
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnitType, BONUS_AGILITY )
        call AddUnitEvasionChance( manipulatingUnit, bonusEvadeChance )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnitType, BONUS_INTELLIGENCE )
        call AddHeroStrengthBonus( manipulatingUnit, manipulatingUnitType, BONUS_STRENGTH )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 1300)

        set d = InitItemTypeEx(SET_ITEM_ID)
        call SetItemTypeGoldCost(d, 1300)
        call SetItemTypeMaxCharges(d, 1)

        call CreateSetSimple3(BeltOfTheCelt_ITEM_ID, SpidermanSocks_ITEM_ID, RobeOfThePope_ITEM_ID, SET_ITEM_ID, ITEM_ID)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\PrismaticCape.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\RegenerationPotion.j
//TESH.scrollpos=12
//TESH.alwaysfold=0
//! runtextmacro Scope("RegenerationPotion")
    globals
        public constant integer ITEM_ID = 'I011'
        public constant integer SPELL_ID = 'A045'

        private constant real REFRESHED_LIFE = 185.
        private constant real REFRESHED_MANA = 185.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\AIre\\AIreTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        call DestroyEffectTimed( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, casterSelf, TARGET_EFFECT_ATTACHMENT_POINT ), 2 )
        call HealUnitBySpell( caster, REFRESHED_LIFE )
        call AddUnitState( casterSelf, UNIT_STATE_MANA, REFRESHED_MANA )
        set casterSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 150)
        call SetItemTypeMaxCharges(d, 3)
        call SetItemTypeRefreshInterval(d, 30)
        call SetItemTypeRefreshIntervalStart(d, 60)

        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\RegenerationPotion.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\RhythmicDrum.j
//TESH.scrollpos=118
//TESH.alwaysfold=0
//! runtextmacro Scope("RhythmicDrum")
    globals
        public constant integer ITEM_ID = 'I019'

        private constant real AREA_RANGE = 750.
        private constant real BONUS_CRITICAL_STRIKE = 0.1
        private constant real BONUS_RELATIVE_SPEED = 0.2
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\NightElf\\ThornsAura\\ThornsAura.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        Unit caster
        effect casterEffect
        group targetGroup
        timer updateTimer
    endstruct

    private function GetCasterData takes Unit caster returns Data
        return GetAttachedIntegerById(caster.id, RhythmicDrum_SCOPE_ID)
    endfunction

    //! runtextmacro Scope("Target")
        globals
            private group Target_ENUM_GROUP
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            real bonusSpeed
            group casterGroup
            effect targetEffect
        endstruct

        private function Target_Ending takes unit caster, group casterGroup, Target_Data d, Unit target, group targetGroup returns nothing
            local real bonusSpeed
            local effect targetEffect
            local integer targetId
            call GroupRemoveUnit( casterGroup, caster )
            call GroupRemoveUnit( targetGroup, target.self )
            if (FirstOfGroup(casterGroup) == null) then
                set bonusSpeed = -d.bonusSpeed
                set targetEffect = d.targetEffect
                set targetId = target.id
                call d.destroy()
                call DestroyGroupWJ(casterGroup)
                call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                call DestroyEffectWJ( targetEffect )
                set targetEffect = null
                call AddUnitCriticalStrike( target, -BONUS_CRITICAL_STRIKE )
                call AddUnitSpeedBonus( target, bonusSpeed )
            endif
        endfunction

        public function Target_EndingByDeath takes unit caster, Unit target, group targetGroup returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            call Target_Ending(caster, d.casterGroup, d, target, targetGroup)
        endfunction

        public function Target_EndingByUpdate takes unit caster, Unit target, group targetGroup returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            call Target_Ending(caster, d.casterGroup, d, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Unit caster
            local unit casterSelf
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            local group casterGroup = d.casterGroup
            local integer iteration = CountUnits(casterGroup)
            if (iteration > 0) then
                loop
                    set casterSelf = FirstOfGroup(casterGroup)
                    set caster = GetUnit(casterSelf)
                    call Target_Ending( casterSelf, casterGroup, d, target, GetCasterData(caster).targetGroup )
                    set iteration = iteration - 1
                    exitwhen (iteration < 1)
                endloop
            endif
            set casterGroup = null
            set casterSelf = null
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes unit caster, Unit target returns nothing
            local real bonusSpeed = BONUS_RELATIVE_SPEED * GetUnitSpeed( target )
            local group casterGroup
            local integer targetId = target.id
            local Target_Data d = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
            local boolean isNew = (d == NULL)
            if (isNew) then
                set casterGroup = CreateGroupWJ()
                set d = Target_Data.create()
                set d.casterGroup = casterGroup
                set d.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
                call AttachIntegerById(targetId, Target_SCOPE_ID, d)
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            else
                set casterGroup = d.casterGroup
            endif
            set d.bonusSpeed = bonusSpeed
            call GroupAddUnit(casterGroup, caster)
            set casterGroup = null
            if (isNew) then
                call AddUnitCriticalStrike( target, BONUS_CRITICAL_STRIKE )
                call AddUnitSpeedBonus( target, bonusSpeed )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            set Target_ENUM_GROUP = CreateGroupWJ()
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Ending takes Unit caster, Data d, boolean destroy returns nothing
        local effect casterEffect = d.casterEffect
        local integer casterId
        local unit casterSelf = caster.self
        local unit enumUnit
        local group targetGroup = d.targetGroup
        if (destroy) then
            set casterId = caster.id
            call d.destroy()
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_REVIVE" )
        endif
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        loop
            set enumUnit = FirstOfGroup( targetGroup )
            exitwhen ( enumUnit == null )
            call Target_Target_EndingByDeath( casterSelf, GetUnit(enumUnit), targetGroup )
        endloop
        set casterSelf = null
        if (destroy) then
            call DestroyGroupWJ(targetGroup)
            call PauseTimer( d.updateTimer )
        else
            call DestroyTimerWJ(d.updateTimer)
        endif
        set targetGroup = null
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, RhythmicDrum_SCOPE_ID)
        if ( d != NULL ) then
            call Ending(caster, d, false)
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    public function Drop takes Unit caster returns nothing
        call Ending( caster, GetAttachedIntegerById(caster.id, RhythmicDrum_SCOPE_ID), true )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitEnemy( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes Unit caster, Data d, group targetGroup returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit enumUnit
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByUpdate( casterSelf, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                call Target_Target_Start(casterSelf, GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set casterSelf = null
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, RhythmicDrum_SCOPE_ID)
        set updateTimer = null
        call Update( d.caster, d, d.targetGroup )
    endfunction

    public function Revive takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, RhythmicDrum_SCOPE_ID)
        if ( d != NULL ) then
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT )
            call TimerStart( d.updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            call Update( caster, d, d.targetGroup )
        endif
    endfunction

    private function Revive_Event takes nothing returns nothing
        call Revive( REVIVING_UNIT )
    endfunction

    public function PickUp takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, RhythmicDrum_SCOPE_ID)
        local boolean isNew = ( d == NULL )
        local group targetGroup
        local timer updateTimer
        if ( isNew ) then
            set d = Data.create()
            set targetGroup = CreateGroupWJ()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT )
            set d.targetGroup = targetGroup
            set d.updateTimer = updateTimer
            call AttachIntegerById(casterId, RhythmicDrum_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_REVIVE" )
            call AttachInteger(updateTimer, RhythmicDrum_SCOPE_ID, d)
            call TimerStart( updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            set updateTimer = null
        else
            set targetGroup = d.targetGroup
            set updateTimer = d.updateTimer
        endif
        call Update( caster, d, targetGroup )
        set targetGroup = null
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 1500)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 200)
        call SetItemTypeRefreshIntervalStart(d, 400)

        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_REVIVE", "UnitFinishesReviving_EVENT_KEY", "0", "function Revive_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( CASTER_EFFECT_PATH )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\RhythmicDrum.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\RobeOfThePope.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("RobeOfThePope")
    globals
        public constant integer ITEM_ID = 'I01E'

        private constant real BONUS_ARMOR = 3.
        private constant real BONUS_INTELLIGENCE = 8.
    endglobals

    public function Drop takes Unit manipulatingUnit returns nothing
        call AddUnitArmorBonus( manipulatingUnit, -BONUS_ARMOR )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnit.type, -BONUS_INTELLIGENCE )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        call AddUnitArmorBonus( manipulatingUnit, BONUS_ARMOR )
        call AddHeroIntelligenceBonus( manipulatingUnit, manipulatingUnit.type, BONUS_INTELLIGENCE )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 560)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 30)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\RobeOfThePope.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\Runes.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Runes")
    globals
        public constant integer LIFE_RUNE_ITEM_ID = 'I012'
        public constant integer MANA_RUNE_ITEM_ID = 'I013'
        public constant integer SHIELD_RUNE_ITEM_ID = 'I01B'

        private constant string AREA_EFFECT_PATH = "RunesSpecial.mdl"
        private constant real AREA_RANGE = 600.
        private constant integer DUMMY_UNIT_ID = 'n02E'
        private group ENUM_GROUP
        private constant real FADE_TIME = 0.75
        private constant real LIFE_RELATIVE_REFRESHED_LIFE = 0.2
        private constant real LIFE_HERO_RELATIVE_REFRESHED_LIFE = 0.1
        private constant string LIFE_TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\AIhe\\AIheTarget.mdl"
        private constant string LIFE_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real MANA_RELATIVE_REFRESHED_MANA = 0.2
        private constant real MANA_HERO_RELATIVE_REFRESHED_MANA = 0.2
        private constant string MANA_TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl"
        private constant string MANA_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        public integer array RUNES
        public integer RUNES_COUNT = -1
        private constant real SHIELD_DURATION = 5
        private constant real SHIELD_HERO_DURATION = 2.5
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        unit dummyUnit
    endstruct

    private function Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Runes_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        call DestroyDummyScale( dummyUnit )
        call DestroyDummyVertexColor( dummyUnit )
        call RemoveUnitWJ( dummyUnit )
        set dummyUnit = null
        call FlushAttachedInteger( durationTimer, Runes_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    public function PickUp takes Unit caster, item rune, integer runeTypeId returns nothing
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local unit enumUnit
        local real runeX = GetItemX( rune )
        local real runeY = GetItemY( rune )
        local unit dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, runeX, runeY, GetRandomReal( 0, 2 * PI ) )
        local real runeZ = GetItemZ( rune, runeX, runeY )
        local real runeVertexColorRed
        local real runeVertexColorGreen
        local real runeVertexColorBlue
        if ( runeTypeId == LIFE_RUNE_ITEM_ID ) then
            set runeVertexColorRed = 255
            set runeVertexColorGreen = 255
            set runeVertexColorBlue = 0
        elseif ( runeTypeId == MANA_RUNE_ITEM_ID ) then
            set runeVertexColorRed = 0
            set runeVertexColorGreen = 255
            set runeVertexColorBlue = 255
        else
            set runeVertexColorRed = 255
            set runeVertexColorGreen = 0
            set runeVertexColorBlue = 255
        endif
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, runeX, runeY ) )
        call PlaySoundFromTypeAtPosition( REFRESH_SOUND_TYPE, runeX, runeY, runeZ )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, runeX, runeY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            if ( runeTypeId == LIFE_RUNE_ITEM_ID ) then
                loop
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call DestroyEffectTimed( AddSpecialEffectTargetWJ( LIFE_TARGET_EFFECT_PATH, enumUnit, LIFE_TARGET_EFFECT_ATTACHMENT_POINT ), 2 )
                    if ( IsUnitType( enumUnit, UNIT_TYPE_HERO ) ) then
                        call HealUnitBySpell( GetUnit(enumUnit), GetUnitState( enumUnit, UNIT_STATE_MAX_LIFE ) * LIFE_HERO_RELATIVE_REFRESHED_LIFE )
                    else
                        call HealUnitBySpell( GetUnit(enumUnit), GetUnitState( enumUnit, UNIT_STATE_MAX_LIFE ) * LIFE_RELATIVE_REFRESHED_LIFE )
                    endif
                    set enumUnit = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            elseif ( runeTypeId == MANA_RUNE_ITEM_ID ) then
                loop
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call DestroyEffectWJ( AddSpecialEffectTargetWJ( MANA_TARGET_EFFECT_PATH, enumUnit, MANA_TARGET_EFFECT_ATTACHMENT_POINT ) )
                    if ( IsUnitType( enumUnit, UNIT_TYPE_HERO ) ) then
                        call AddUnitState( enumUnit, UNIT_STATE_MANA, GetUnitState( enumUnit, UNIT_STATE_MAX_MANA ) * MANA_HERO_RELATIVE_REFRESHED_MANA )
                    else
                        call AddUnitState( enumUnit, UNIT_STATE_MANA, GetUnitState( enumUnit, UNIT_STATE_MAX_MANA ) * MANA_RELATIVE_REFRESHED_MANA )
                    endif
                    set enumUnit = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            else
                loop
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    if ( IsUnitType( enumUnit, UNIT_TYPE_HERO ) ) then
                        call SetUnitInvulnerabilityTimed( GetUnit(enumUnit), SHIELD_HERO_DURATION )
                    else
                        call SetUnitInvulnerabilityTimed( GetUnit(enumUnit), SHIELD_DURATION )
                    endif
                    set enumUnit = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endif
        set d.dummyUnit = dummyUnit
        call AttachInteger( durationTimer, Runes_SCOPE_ID, d )
        call SetUnitAnimationByIndex( dummyUnit, 3 )
        call InitDummyScale( dummyUnit, 1 )
        call AddDummyScaleTimed(dummyUnit, 4, FADE_TIME)
        call InitDummyVertexColor( dummyUnit, runeVertexColorRed, runeVertexColorGreen, runeVertexColorBlue, 255 )
        call AddDummyVertexColorTimed( dummyUnit, 0, 0, 0, -255, FADE_TIME )
        call TimerStart( durationTimer, FADE_TIME, false, function Ending )
        set durationTimer = null
    endfunction

    public function PickUp_Conditions takes integer runeTypeId returns boolean
        return ((runeTypeId == LIFE_RUNE_ITEM_ID) or (runeTypeId == MANA_RUNE_ITEM_ID) or (runeTypeId == SHIELD_RUNE_ITEM_ID))
    endfunction

    private function AddRune takes integer whichRune returns nothing
        set RUNES_COUNT = RUNES_COUNT + 1
        set RUNES[RUNES_COUNT] = whichRune
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )

        set d = InitItemTypeEx(LIFE_RUNE_ITEM_ID)
        call SetItemTypeGoldCost(d, 50)
        call SetItemTypeMaxCharges(d, 4)
        call SetItemTypeRefreshInterval(d, 30)
        call SetItemTypeRefreshIntervalStart(d, 90)
        call AddRune( LIFE_RUNE_ITEM_ID )

        call InitEffectType( LIFE_TARGET_EFFECT_PATH )

        set d = InitItemTypeEx(MANA_RUNE_ITEM_ID)
        call SetItemTypeGoldCost(d, 50)
        call SetItemTypeMaxCharges(d, 3)
        call SetItemTypeRefreshInterval(d, 20)
        call SetItemTypeRefreshIntervalStart(d, 70)
        call AddRune( MANA_RUNE_ITEM_ID )

        call InitEffectType( MANA_TARGET_EFFECT_PATH )

        call InitItemTypeEx(SHIELD_RUNE_ITEM_ID)
        call AddRune( SHIELD_RUNE_ITEM_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\Runes.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\ScrollOfRage.j
//TESH.scrollpos=137
//TESH.alwaysfold=0
//! runtextmacro Scope("ScrollOfRage")
    globals
        public constant integer ITEM_ID = 'I007'
        public constant integer SPELL_ID = 'A01B'

        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\NightElf\\BattleRoar\\RoarCaster.mdl"
        private constant real AREA_RANGE = 500.
        private constant real BONUS_RELATIVE_DAMAGE = 0.4
        private constant real BONUS_RELATIVE_SPEED = 0.3
        private constant real DURATION = 45.
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\NightElf\\BattleRoar\\RoarTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "overhead"
    endglobals

    private struct Data
        real bonusDamage
        real bonusSpeed
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local real bonusDamage = d.bonusDamage
        local real bonusSpeed = d.bonusSpeed
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, ScrollOfRage_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, ScrollOfRage_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call AddUnitDamageBonus( target, -bonusDamage )
        call AddUnitSpeedBonus( target, -bonusSpeed )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, ScrollOfRage_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, ScrollOfRage_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    private function StartTarget takes Unit target returns nothing
        local real bonusDamage = (GetUnitDamage( target ) + GetUnitTypeDamageDices( target.type )) * BONUS_RELATIVE_DAMAGE
        local real bonusSpeed = GetUnitSpeed( target ) * BONUS_RELATIVE_SPEED
        local timer durationTimer
        local real oldBonusDamage
        local real oldBonusSpeed
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById( targetId, ScrollOfRage_SCOPE_ID )
        local boolean isNew = (d == NULL)
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger( durationTimer, ScrollOfRage_SCOPE_ID, d )
            call AttachIntegerById( targetId, ScrollOfRage_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        else
            set durationTimer = d.durationTimer
            set oldBonusDamage = d.bonusDamage
            set oldBonusSpeed = d.bonusSpeed
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.bonusDamage = bonusDamage
        set d.bonusSpeed = bonusSpeed
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            call AddUnitDamageBonus( target, bonusDamage )
            call AddUnitSpeedBonus( target, bonusSpeed )
        else
            call AddUnitDamageBonus( target, bonusDamage - oldBonusDamage )
            call AddUnitSpeedBonus( target, bonusSpeed - oldBonusSpeed )
        endif
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit enumUnit
        set casterSelf = null
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, casterX, casterY ) )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if (enumUnit != null) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call StartTarget(GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 500)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 80)
        call SetItemTypeRefreshIntervalStart(d, 200)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\ScrollOfRage.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\Sets.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Sets")
    globals
        private constant string MANIPULATING_UNIT_EFFECT_PATH = "Abilities\\Spells\\Items\\TomeOfRetraining\\TomeOfRetrainingCaster.mdl"
        private constant string MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    public function PickUp takes Item manipulatedItem, ItemType manipulatedItemType, Unit manipulatingUnit returns nothing
        local boolean found
        local boolean array founds
        local integer iteration
        local integer iteration2
        local integer manipulatedItemTypeId = manipulatedItemType.id
        local Set d = GetItemTypeSet(manipulatedItemTypeId)
        local player manipulatingUnitOwner = manipulatingUnit.owner
        local unit manipulatingUnitSelf
        local string s
        local Item specificItem
        local integer specificItemTypeId
        if (d != NULL) then
            set iteration = 3 * ShiftInventory_ROWS_AMOUNT - 1
            loop
                set founds[iteration] = false
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            set iteration = CountSetItemTypes(d)
            loop
                set found = false
                set iteration2 = 3 * ShiftInventory_ROWS_AMOUNT - 1
                set specificItemTypeId = GetSetItemType(d, iteration)
                loop
                    set specificItem = GetUnitItemInSlot(manipulatingUnit, iteration2)
                    if (((specificItem.type.id == specificItemTypeId) or ((specificItemTypeId == Lollipop_ITEM_ID) and (specificItem.type.id == Lollipop_MANUFACTURED_ITEM_ID))) and (founds[iteration2] == false)) then
                        set found = true
                        set founds[iteration2] = true
                    endif
                    exitwhen (found)
                    set iteration2 = iteration2 - 1
                    exitwhen (iteration2 < 0)
                endloop
                exitwhen (iteration2 < 0)
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            if (iteration < 0) then
                set iteration = CountSetItemTypes(d)
                set manipulatingUnitSelf = manipulatingUnit.self
                set s = ColorStrings_GOLD
                loop
                    set specificItemTypeId = GetSetItemType(d, iteration)
                    set s = s + GetObjectName(specificItemTypeId)
                    if (GetUnitItemOfType(manipulatingUnit, specificItemTypeId) == NULL) then
                        call RemoveItemEx(GetUnitItemOfType(manipulatingUnit, Lollipop_MANUFACTURED_ITEM_ID))
                    else
                        call RemoveItemEx(GetUnitItemOfType(manipulatingUnit, specificItemTypeId))
                    endif
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                    set s = s + " + "
                endloop
                set iteration = CountSetProductItemTypes(d)
                set s = s + " --> "
                loop
                    set specificItemTypeId = GetSetProductItemType(d, iteration)
                    set s = s + GetObjectName(specificItemTypeId)
                    call UnitAddItem(manipulatingUnitSelf, CreateItemEx(specificItemTypeId, 0, 0).self)
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                    set s = s + " + "
                endloop
                call DisplayTextTimedWJ(s + ColorStrings_RESET, 10, manipulatingUnitOwner)
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( MANIPULATING_UNIT_EFFECT_PATH, manipulatingUnitSelf, MANIPULATING_UNIT_EFFECT_ATTACHMENT_POINT ) )
                set manipulatingUnitSelf = null
            else
                set iteration = 3 * ShiftInventory_ROWS_AMOUNT - 1
                set s = ""
                loop
                    set founds[iteration] = false
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                endloop
                set iteration = CountSetItemTypes(d)
                loop
                    set found = false
                    set iteration2 = 3 * ShiftInventory_ROWS_AMOUNT - 1
                    set specificItemTypeId = GetSetItemType(d, iteration)
                    loop
                        set specificItem = GetUnitItemInSlot(manipulatingUnit, iteration2)
                        if ((specificItem.type.id == specificItemTypeId) and (founds[iteration2] == false)) then
                            set found = true
                            set founds[iteration2] = true
                        endif
                        exitwhen (found)
                        set iteration2 = iteration2 - 1
                        exitwhen (iteration2 < 0)
                    endloop
                    if (iteration2 > -1) then
                        set s = s + ColorStrings_GREEN
                    else
                        set s = s + ColorStrings_RED
                    endif
                    set s = s + GetObjectName(specificItemTypeId) + ColorStrings_RESET
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                    set s = s + ColorStrings_GOLD + " + " + ColorStrings_RESET
                endloop
                set iteration = CountSetProductItemTypes(d)
                set s = s + ColorStrings_GOLD + " --> "
                loop
                    set specificItemTypeId = GetSetProductItemType(d, iteration)
                    set s = s + GetObjectName(specificItemTypeId)
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                    set s = s + " + "
                endloop
                call Error(manipulatingUnitOwner, s + ColorStrings_RESET)
                call AddPlayerState(manipulatingUnitOwner, PLAYER_STATE_RESOURCE_GOLD, GetItemTypeGoldCost(manipulatedItemType))
            endif
        endif
        set manipulatingUnitOwner = null
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\Sets.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\ShiftInventory.j
//TESH.scrollpos=194
//TESH.alwaysfold=0
//! runtextmacro Scope("ShiftInventory")
    globals
        public constant integer DISABLED_ITEM_ID = 'I01K'
        public constant integer ITEM_ID = 'I01L'
        public constant integer RESEARCH_ID = 'R012'
        public constant integer SPELL_ID = 'A07P'

        private boolexpr CASTER_CONDITIONS
        private constant integer COLUMN_AMOUNT = 2
        private group ENUM_GROUP
        public constant integer ROWS_AMOUNT = 3
        private constant integer SHIFTER_OFF_POSITION = 2
        private constant integer SHIFTER_ON_POSITION = 3
    endglobals

    public struct Data
        Item array hiddenItems[ROWS_AMOUNT]
        Item shifterOff
        Item shifterOn
        boolean right = false
    endstruct

    public function Death takes Item whichItem returns nothing
        local integer iteration
        local integer whichItemId = whichItem.id
        local Data d = GetAttachedIntegerById(whichItemId, ShiftInventory_SCOPE_ID)
        if (d != NULL) then
            set iteration = ROWS_AMOUNT
            loop
                if (d.hiddenItems[iteration] == whichItem) then
                    set d.hiddenItems[iteration] = NULL
                endif
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call FlushAttachedIntegerById(whichItemId, ShiftInventory_SCOPE_ID)
        endif
    endfunction

    public function GetCasterData takes Unit caster returns Data
        return GetAttachedIntegerById(caster.id, ShiftInventory_SCOPE_ID)
    endfunction

    private function Shift takes Unit caster, Data d, boolean off returns nothing
        local unit casterSelf = caster.self
        local integer iteration = ROWS_AMOUNT - 1
        local integer offState = B2I(off)
        local integer onState = B2I(off == false)
        local integer rowStart
        local Item specificItem
        local item specificItemSelf
        local Item specificItem2
        local item specificItem2Self
        if (off) then
            set d.right = false
            set specificItem = d.shifterOff
        else
            set d.right = true
            set specificItem = d.shifterOn
        endif
        set specificItemSelf = specificItem.self
        call SetItemDroppable(specificItemSelf, true)
        set UnitDropsItem_IGNORE_NEXT = true
        call SetItemPosition(specificItemSelf, 0, 0)
        call SetItemVisible(specificItemSelf, false)
        if (off) then
            set specificItem = d.shifterOn
        else
            set specificItem = d.shifterOff
        endif
        set specificItemSelf = specificItem.self
        call SetItemVisible(specificItemSelf, true)
        call UnitAddItem(casterSelf, specificItemSelf)
        call SetItemDroppable(specificItemSelf, false)
        call UnitDropItemSlot(casterSelf, specificItemSelf, SHIFTER_OFF_POSITION + onState)
        loop
            set rowStart = iteration * COLUMN_AMOUNT
            set specificItem = GetItem(UnitItemInSlot(casterSelf, rowStart + offState))
            set specificItem2 = d.hiddenItems[iteration]
            set d.hiddenItems[iteration] = specificItem
            if (specificItem != NULL) then
                set specificItemSelf = specificItem.self
                call AttachIntegerById(specificItem.id, ShiftInventory_SCOPE_ID, d)
                set UnitDropsItem_IGNORE_NEXT = true
                call SetItemPosition(specificItemSelf, 0, 0)
                call SetItemVisible(specificItemSelf, false)
            endif
            call UnitDropItemSlot(casterSelf, UnitItemInSlot(casterSelf, rowStart + onState), rowStart + offState)
            if (specificItem2 != NULL) then
                set specificItem2Self = specificItem2.self
                call FlushAttachedIntegerById(specificItem2.id, ShiftInventory_SCOPE_ID)
                call SetItemVisible(specificItem2Self, true)
                set UnitAcquiresItem_IGNORE_NEXT = true
                call UnitAddItem(casterSelf, specificItem2Self)
                call UnitDropItemSlot(casterSelf, specificItem2Self, rowStart + onState)
            endif
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        set casterSelf = null
        set specificItemSelf = null
        set specificItem2Self = null
    endfunction

    //! runtextmacro Scope("Off")
        globals
            public constant integer Off_ITEM_ID = 'I01M'
            public constant integer Off_SPELL_ID = 'A07R'
        endglobals

        public function Off_SpellEffect takes Unit caster returns nothing
            call Shift(caster, GetAttachedIntegerById(caster.id, ShiftInventory_SCOPE_ID), true)
        endfunction

        private function Off_SpellEffect_Event takes nothing returns nothing
            call Off_SpellEffect( CASTER )
        endfunction

        public function Off_Init takes nothing returns nothing
            //! runtextmacro AddNewEventById( "Off_EVENT_CAST", "Off_SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function Off_SpellEffect_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function SpellEffect takes Unit caster returns nothing
        call Shift(caster, GetAttachedIntegerById(caster.id, ShiftInventory_SCOPE_ID), false)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    private function Start takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local Data d = Data.create()
        local integer iteration = ROWS_AMOUNT - 1
        local Item shifterOff = CreateItemEx(Off_Off_ITEM_ID, 0, 0)
        local Item shifterOn = CreateItemEx(ITEM_ID, 0, 0)
        local item shifterOnSelf = shifterOn.self
        loop
            set d.hiddenItems[iteration] = NULL
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        set d.shifterOff = shifterOff
        set d.shifterOn = shifterOn
        call AttachIntegerById(caster.id, ShiftInventory_SCOPE_ID, d)
        call SetItemVisible(shifterOff.self, false)
        call UnitAddItem(casterSelf, shifterOnSelf)
        call UnitDropItemSlot(casterSelf, shifterOnSelf, SHIFTER_ON_POSITION)
        set casterSelf = null
        set shifterOnSelf = null
    endfunction

    private function CasterConditions_Single takes Unit caster returns boolean
        if (IsUnitType(caster.self, UNIT_TYPE_HERO) == false) then
            return false
        endif
        if (IsUnitIllusionWJ(caster)) then
            return false
        endif
        return true
    endfunction

    private function CasterConditions takes nothing returns boolean
        return CasterConditions_Single(GetUnit(GetFilterUnit()))
    endfunction

    public function Appearance takes Unit caster returns nothing
        local unit casterSelf
        local item shifter
        if (CasterConditions_Single(caster)) then
            if (GetPlayerTechCount(caster.owner, RESEARCH_ID, true) > 0) then
                call Start(caster)
            else
                set casterSelf = caster.self
                set shifter = CreateItemEx(DISABLED_ITEM_ID, 0, 0).self
                call UnitAddItem(casterSelf, shifter)
                call UnitDropItemSlot(casterSelf, shifter, SHIFTER_ON_POSITION)
                set casterSelf = null
                set shifter = null
            endif
        endif
    endfunction

    public function ResearchFinish takes player casterOwner returns nothing
        local unit enumUnit
        call GroupEnumUnitsOfPlayer(ENUM_GROUP, casterOwner, CASTER_CONDITIONS)
        set enumUnit = FirstOfGroup(ENUM_GROUP)
        if (enumUnit != null) then
            loop
                call GroupRemoveUnit(ENUM_GROUP, enumUnit)
                call RemoveItemEx(GetItem(UnitItemInSlot(enumUnit, SHIFTER_ON_POSITION)))
                call Start(GetUnit(enumUnit))
                set enumUnit = FirstOfGroup(ENUM_GROUP)
                exitwhen (enumUnit == null)
            endloop
        endif
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d
        local ItemType e

        set d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 500)

        set e = InitItemTypeEx(DISABLED_ITEM_ID)

        set e = InitItemTypeEx(ITEM_ID)

        set CASTER_CONDITIONS = ConditionWJ(function CasterConditions)
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Off_Off_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\ShiftInventory.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\SpiderEgg.j
//TESH.scrollpos=12
//TESH.alwaysfold=0
//! runtextmacro Scope("SpiderEgg")
    globals
        public constant integer ITEM_ID = 'I008'
        public constant integer SPELL_ID = 'A01D'

        private constant real DURATION = 80.
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl"
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local Unit spawn = CreateUnitEx( caster.owner, SPOUT_SPIDER_UNIT_ID, GetUnitX(casterSelf), GetUnitY(casterSelf), GetUnitFacingWJ(casterSelf) )
        local unit spawnSelf = spawn.self
        set casterSelf = null
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, GetUnitX(spawnSelf), GetUnitY(spawnSelf) ) )
        call UnitApplyTimedLifeWJ( spawnSelf, DURATION )
        set spawnSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 350)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 50)
        call SetItemTypeRefreshIntervalStart(d, 150)

        call InitEffectType( SPECIAL_EFFECT_PATH )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\SpiderEgg.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\SpidermanSocks.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("SpidermanSocks")
    globals
        public constant integer ITEM_ID = 'I01D'

        private constant real BONUS_AGILITY = 7.
    endglobals

    public function Drop takes Unit caster returns nothing
        call AddHeroAgilityBonus( caster, caster.type, -BONUS_AGILITY )
    endfunction

    public function PickUp takes Unit caster returns nothing
        call AddHeroAgilityBonus( caster, caster.type, BONUS_AGILITY )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 420)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 70)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\SpidermanSocks.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\StaffOfAbolition.j
//TESH.scrollpos=18
//TESH.alwaysfold=0
//! runtextmacro Scope("StaffOfAbolition")
    globals
        public constant integer ITEM_ID = 'I00F'
        public constant integer SPELL_ID = 'A01J'

        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Other\\Silence\\SilenceAreaBirth.mdl"
        private constant real AREA_RANGE = 250.
        private constant real DAMAGE_SUMMON = 200.
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local Unit enumUnit
        local unit enumUnitSelf
        call DestroyEffectTimed( AddSpecialEffectWJ( AREA_EFFECT_PATH, targetX, targetY ), 2 )
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if (enumUnitSelf != null) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call DispelUnit( enumUnit, true, true, true )
                if (IsUnitType(enumUnitSelf, UNIT_TYPE_SUMMONED)) then
                    call UnitDamageUnitBySpell( caster, enumUnit, DAMAGE_SUMMON )
                endif
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 200)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 30)
        call SetItemTypeRefreshIntervalStart(d, 60)

        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\StaffOfAbolition.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\SuperCarrot.j
//TESH.scrollpos=129
//TESH.alwaysfold=0
//! runtextmacro Scope("SuperCarrot")
    globals
        public constant integer ITEM_ID = 'I016'
        public constant integer SPELL_ID = 'A07D'

        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Human\\Flare\\FlareCaster.mdl"
        private constant integer DUMMY_UNIT_ID = 'n02U'
        private constant real DURATION = 30.
    endglobals

    private struct Data
        fogmodifier dummyFogModifier
        unit dummyUnit
        timer durationTimer
    endstruct

    private function Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, SuperCarrot_SCOPE_ID)
        local fogmodifier dummyFogModifier = d.dummyFogModifier
        local unit dummyUnit = d.dummyUnit
        local player casterOwner = GetOwningPlayer( dummyUnit )
        call d.destroy()
        call FlushAttachedInteger( casterOwner, SuperCarrot_SCOPE_ID )
        set casterOwner = null
        call DestroyFogModifierWJ( dummyFogModifier )
        set dummyFogModifier = null
        call RemoveUnitWJ( dummyUnit )
        set dummyUnit = null
        call FlushAttachedInteger( durationTimer, SuperCarrot_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
    endfunction

    //! runtextmacro Scope("Effect")
        globals
            private constant integer Effect_DUMMY_UNIT_ID = 'n02V'
            private constant real Effect_DURATION = 1.
            private constant real Effect_HEIGHT_START = 200.
            private constant real Effect_UPDATE_TIME = 0.035
            private constant real Effect_HEIGHT_ADD = 1100 * Effect_UPDATE_TIME
        endglobals

        private struct Effect_Data
            unit dummyUnit
            timer durationTimer
            timer updateTimer
        endstruct

        private function Effect_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Effect_Data d = GetAttachedInteger(durationTimer, Effect_SCOPE_ID)
            local unit dummyUnit = d.dummyUnit
            local timer updateTimer = d.updateTimer
            call d.destroy()
            call RemoveUnitWJ( dummyUnit )
            set dummyUnit = null
            call FlushAttachedInteger( durationTimer, Effect_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            call FlushAttachedInteger( updateTimer, Effect_SCOPE_ID )
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endfunction

        private function Effect_Move takes nothing returns nothing
            local timer updateTimer = GetExpiredTimer()
            local Effect_Data d = GetAttachedInteger(updateTimer, Effect_SCOPE_ID)
            local unit dummyUnit = d.dummyUnit
            local real dummyUnitX = GetUnitX(dummyUnit)
            local real dummyUnitY = GetUnitY(dummyUnit)
            local real newZ = GetUnitZ( dummyUnit, dummyUnitX, dummyUnitY ) + Effect_HEIGHT_ADD
            set updateTimer = null
            call SetUnitZ( dummyUnit, dummyUnitX, dummyUnitY, newZ )
            set dummyUnit = null
        endfunction

        public function Effect_Start takes player casterOwner, real x, real y returns nothing
            local Effect_Data d = Effect_Data.create()
            local unit dummyUnit = CreateUnitWJ( casterOwner, Effect_DUMMY_UNIT_ID, x, y, 0 )
            local timer durationTimer = CreateTimerWJ()
            local timer updateTimer = CreateTimerWJ()
            set d.dummyUnit = dummyUnit
            set d.durationTimer = durationTimer
            set d.updateTimer = updateTimer
            call AttachInteger( durationTimer, Effect_SCOPE_ID, d )
            call AttachInteger( updateTimer, Effect_SCOPE_ID, d )
            call SetUnitZ( dummyUnit, x, y, Effect_HEIGHT_START )
            set dummyUnit = null
            call TimerStart( updateTimer, Effect_UPDATE_TIME, true, function Effect_Move )
            set updateTimer = null
            call TimerStart( durationTimer, Effect_DURATION, false, function Effect_Ending )
            set durationTimer = null
        endfunction

        public function Effect_Init takes nothing returns nothing
            call InitUnitType( Effect_DUMMY_UNIT_ID )
        endfunction
    //! runtextmacro Endscope()

    public function SpellEffect takes Unit caster returns nothing
        local player casterOwner = caster.owner
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = GetAttachedInteger(casterOwner, SuperCarrot_SCOPE_ID)
        local fogmodifier dummyFogModifier
        local unit dummyUnit
        local timer durationTimer
        set casterSelf = null
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, casterX, casterY ) )
        if ( d == NULL ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set dummyFogModifier = CreateFogModifierCircleWJ( casterOwner, FOG_OF_WAR_VISIBLE, CENTER_X, CENTER_Y, 99999, false, false )
            set dummyUnit = CreateUnitWJ( casterOwner, DUMMY_UNIT_ID, CENTER_X, CENTER_Y, 0 )
            set d.dummyFogModifier = dummyFogModifier
            set d.dummyUnit = dummyUnit
            set dummyUnit = null
            set d.durationTimer = durationTimer
            call AttachInteger( casterOwner, SuperCarrot_SCOPE_ID, d )
            call AttachInteger( durationTimer, SuperCarrot_SCOPE_ID, d )
            call FogModifierStart( dummyFogModifier )
            set dummyFogModifier = null
        else
            set durationTimer = d.durationTimer
        endif
        call TimerStart( durationTimer, DURATION, false, function Ending )
        set durationTimer = null
        call Effect_Effect_Start(casterOwner, casterX, casterY)
        set casterOwner = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 250)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 45)
        call SetItemTypeRefreshIntervalStart(d, 200)

        call InitEffectType( AREA_EFFECT_PATH )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Effect_Effect_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\SuperCarrot.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\TownPortal.j
//TESH.scrollpos=7
//TESH.alwaysfold=0
//! runtextmacro Scope("TownPortal")
    globals
        public constant integer ITEM_ID = 'I000'
        public constant integer SPELL_ID = 'A042'
    endglobals

    public function EndCast takes Unit caster returns nothing
        call RemoveUnitInvulnerability(caster)
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    public function Channel takes Unit caster returns nothing
        call AddUnitInvulnerability(caster)
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 200)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 80)
        call SetItemTypeRefreshIntervalStart(d, 200)

        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\TownPortal.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\Trap.j
//TESH.scrollpos=216
//TESH.alwaysfold=0
//! runtextmacro Scope("Trap")
    globals
        public constant integer ITEM_ID = 'I01N'
        public constant integer SPELL_ID = 'A02W'

        private constant real ACTIVATION_RANGE = 250.
        private constant real ACTIVATION_TIME = 5.
        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl"
        private constant real DURATION = 160.
        private constant real EFFECT_RANGE = 500.
        private group ENUM_GROUP
        private constant real INTERVAL = 1.
        private boolexpr TARGET_CONDITIONS
        private constant real TRIGGER_DURATION = 2.
    endglobals

    private struct Data
        timer dummyTimer
        Unit trap
    endstruct

    //! runtextmacro Scope("Slow")
        globals
            private constant real Slow_BONUS_SPEED = -80.
            private constant real Slow_DURATION = 5.
            private constant string Slow_TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\slow\\slowtarget.mdl"
            private constant string Slow_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Slow_Data
            timer durationTimer
            Unit target
            effect targetEffect
        endstruct

        private function Slow_Ending takes Slow_Data d, timer durationTimer, Unit target returns nothing
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call FlushAttachedInteger( durationTimer, Slow_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call FlushAttachedIntegerById( targetId, Slow_SCOPE_ID )
            //! runtextmacro RemoveEventById( "targetId", "Slow_EVENT_DEATH" )
            //! runtextmacro RemoveEventById( "targetId", "Slow_EVENT_DISPEL" )
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
            call AddUnitSpeedBonus( target, -Slow_BONUS_SPEED )
        endfunction

        public function Slow_Dispel takes Unit target returns nothing
            local Slow_Data d = GetAttachedIntegerById( target.id, Slow_SCOPE_ID )
            if ( d != NULL ) then
                call Slow_Ending( d, d.durationTimer, target )
            endif
        endfunction

        private function Slow_Dispel_Event takes nothing returns nothing
            call Slow_Dispel( TRIGGER_UNIT )
        endfunction

        public function Slow_Death takes Unit target returns nothing
            call Slow_Dispel( target )
        endfunction

        private function Slow_Death_Event takes nothing returns nothing
            call Slow_Death( DYING_UNIT )
        endfunction

        private function Slow_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Slow_Data d = GetAttachedInteger( durationTimer, Slow_SCOPE_ID )
            call Slow_Ending( d, durationTimer, d.target )
            set durationTimer = null
        endfunction

        public function Slow_Start takes Unit target returns nothing
            local integer targetId = target.id
            local Slow_Data d = GetAttachedIntegerById( targetId, Slow_SCOPE_ID )
            local timer durationTimer
            if ( d == NULL ) then
                set d = Slow_Data.create()
                set durationTimer = CreateTimerWJ()
                call AttachInteger( durationTimer, Slow_SCOPE_ID, d )
                call AttachIntegerById( targetId, Slow_SCOPE_ID, d )
                //! runtextmacro AddEventById( "targetId", "Slow_EVENT_DEATH" )
                //! runtextmacro AddEventById( "targetId", "Slow_EVENT_DISPEL" )
                call AddUnitSpeedBonus( target, Slow_BONUS_SPEED )
            else
                set durationTimer = d.durationTimer
                call DestroyEffectWJ( d.targetEffect )
            endif
            set d.targetEffect = AddSpecialEffectTargetWJ( Slow_TARGET_EFFECT_PATH, target.self, Slow_TARGET_EFFECT_ATTACHMENT_POINT )
            call TimerStart( durationTimer, Slow_DURATION, false, function Slow_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Slow_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Slow_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Slow_Death_Event" )
            //! runtextmacro CreateEvent( "Slow_EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_NEGATIVE", "0", "function Slow_Dispel_Event" )
            call InitEffectType( Slow_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function Ending takes Data d, Unit trap returns nothing
        local timer dummyTimer = d.dummyTimer
        call d.destroy()
        call FlushAttachedInteger( dummyTimer, Trap_SCOPE_ID )
        call DestroyTimerWJ( dummyTimer )
        set dummyTimer = null
        call FlushAttachedIntegerById( trap.id, Trap_SCOPE_ID )
    endfunction

    public function Death takes Unit trap returns nothing
        local integer trapId = trap.id
        local Data d = GetAttachedIntegerById( trapId, Trap_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( d, trap )
            //! runtextmacro RemoveEventById( "trapId", "EVENT_DEATH" )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Trigger takes nothing returns nothing
        local unit enumUnit
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, Trap_SCOPE_ID)
        local Unit trap = d.trap
        local unit trapSelf = trap.self
        local real trapX = GetUnitX( trapSelf )
        local real trapY = GetUnitY( trapSelf )
        set intervalTimer = null
        call KillUnit( trapSelf )
        set trapSelf = null
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, trapX, trapY ) )
        set TEMP_PLAYER = trap.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, trapX, trapY, EFFECT_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call Slow_Slow_Start( GetUnit(enumUnit) )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function Interval takes nothing returns nothing
        local unit enumUnit
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, Trap_SCOPE_ID)
        local Unit trap = d.trap
        local unit trapSelf = trap.self
        set TEMP_PLAYER = trap.owner
        call GroupEnumUnitsInRangeWJ( ENUM_GROUP, GetUnitX( trapSelf ), GetUnitY( trapSelf ), ACTIVATION_RANGE, TARGET_CONDITIONS )
        set trapSelf = null
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set enumUnit = null
            call RemoveUnitGhost( trap )
            call TimerStart( intervalTimer, TRIGGER_DURATION, false, function Trigger )
        endif
        set intervalTimer = null
    endfunction

    private function Activation takes nothing returns nothing
        local timer activationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger( activationTimer, Trap_SCOPE_ID )
        call AddUnitGhost( d.trap )
        call TimerStart( activationTimer, INTERVAL, true, function Interval )
        set activationTimer = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local timer activationTimer = CreateTimerWJ()
        local Data d = Data.create()
        local Unit trap = CreateUnitEx( caster.owner, TRAP_BUILT_UP_UNIT_ID, targetX, targetY, STANDARD_ANGLE )
        local integer trapId = trap.id
        local unit trapSelf = trap.self
        set d.dummyTimer = activationTimer
        set d.trap = trap
        call AttachInteger( activationTimer, Trap_SCOPE_ID, d )
        call AttachIntegerById( trapId, Trap_SCOPE_ID, d )
        //! runtextmacro AddEventById( "trapId", "EVENT_DEATH" )
        call SetUnitAnimation(trapSelf, "birth")
        call UnitApplyTimedLifeWJ( trapSelf, DURATION )
        set trapSelf = null
        call TimerStart( activationTimer, ACTIVATION_TIME, false, function Activation )
        set activationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect(CASTER, TARGET_X, TARGET_Y)
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 125)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 60)
        call SetItemTypeRefreshIntervalStart(d, 60)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Slow_Slow_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\Trap.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\Trident.j
//TESH.scrollpos=98
//TESH.alwaysfold=0
//! runtextmacro Scope("Trident")
    globals
        public constant integer ITEM_ID = 'I01V'

        private constant real BONUS_ARMOR = 3.
        private constant real BONUS_DAMAGE = 5.
        private constant real CHANCE = 0.2
    endglobals

    private struct Data
        integer amount
    endstruct

    public function Drop takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, Trident_SCOPE_ID)
        local integer amount = d.amount - 1
        if (amount == NULL) then
            call d.destroy()
            call FlushAttachedIntegerById( manipulatingUnitId, Trident_SCOPE_ID )
            //! runtextmacro RemoveEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = amount
        endif
        call AddUnitArmorBonus( manipulatingUnit, -BONUS_ARMOR )
        call AddUnitDamageBonus( manipulatingUnit, -BONUS_DAMAGE )
    endfunction

    //! runtextmacro Scope("Knockback")
        globals
            private constant real Knockback_DURATION = 0.75
            private SoundType array Knockback_EFFECT_SOUND_TYPES
            private constant real Knockback_SPEED_ADD = -300. * Knockback_DURATION
            private constant real Knockback_SPEED = 450. * Knockback_DURATION
            private constant string Knockback_TARGET_EFFECT_PATH = "Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl"
            private constant string Knockback_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
            private constant real Knockback_UPDATE_TIME = 0.035
            private constant real Knockback_LENGTH = Knockback_SPEED * Knockback_UPDATE_TIME
            private constant real Knockback_LENGTH_ADD = Knockback_SPEED * Knockback_UPDATE_TIME
        endglobals

        private struct Knockback_Data
            timer durationTimer
            real lengthX
            real lengthY
            Unit target
            timer updateTimer
        endstruct

        private function Knockback_Ending takes Knockback_Data d, timer durationTimer, Unit target returns nothing
            local integer targetId = target.id
            local timer updateTimer = d.updateTimer
            call d.destroy()
            call FlushAttachedInteger(durationTimer, Knockback_SCOPE_ID)
            call DestroyTimerWJ(durationTimer)
            call FlushAttachedIntegerById(targetId, Knockback_SCOPE_ID)
            call RemoveIntegerFromTableById(targetId, Knockback_SCOPE_ID, d)
            if (CountIntegersInTableById(targetId, Knockback_SCOPE_ID) == TABLE_EMPTY) then
                //! runtextmacro RemoveEventById( "targetId", "Knockback_EVENT_DEATH" )
            endif
            call FlushAttachedInteger(updateTimer, Knockback_SCOPE_ID)
            call DestroyTimerWJ(updateTimer)
            set updateTimer = null
        endfunction

        public function Knockback_Death takes Unit target returns nothing
            local Knockback_Data d
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById(targetId, Knockback_SCOPE_ID)
            if (iteration > TABLE_EMPTY) then
                loop
                    set d = GetIntegerFromTableById(targetId, Knockback_SCOPE_ID, iteration)
                    call Knockback_Ending(d, d.durationTimer, target)
                    set iteration = iteration - 1
                    exitwhen (iteration < TABLE_STARTED)
                endloop
            endif
        endfunction

        private function Knockback_Death_Event takes nothing returns nothing
            call Knockback_Death(DYING_UNIT)
        endfunction

        private function Knockback_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Knockback_Data d = GetAttachedInteger(durationTimer, Knockback_SCOPE_ID)
            call Knockback_Ending(d, durationTimer, d.target)
            set durationTimer = null
        endfunction

        private function Knockback_Move takes nothing returns nothing
            local timer updateTimer = GetExpiredTimer()
            local Knockback_Data d = GetAttachedInteger(updateTimer, Knockback_SCOPE_ID)
            local unit target = d.target.self
            local real targetX = GetUnitX(target)
            local real targetY = GetUnitY(target)
            set updateTimer = null
            call DestroyEffectWJ(AddSpecialEffectTargetWJ(Knockback_TARGET_EFFECT_PATH, target, Knockback_TARGET_EFFECT_ATTACHMENT_POINT))
            //if ((IsUnitType(target, UNIT_TYPE_FLYING) and (IsTerrainPathable( newX, newY, PATHING_TYPE_WALKABILITY ) == false)) or (IsUnitType(target, UNIT_TYPE_GROUND) and (IsTerrainPathable( newX, newY, PATHING_TYPE_FLYABILITY ) == false))) then
                call SetUnitXYIfNotBlocked( target, targetX, targetY, targetX + d.lengthX, targetY + d.lengthY )
            //endif
            set target = null
        endfunction

        public function Knockback_Start takes Unit caster, Unit target returns nothing
            local unit casterSelf = caster.self
            local Knockback_Data d = Knockback_Data.create()
            local timer durationTimer = CreateTimerWJ()
            local integer targetId = target.id
            local unit targetSelf = target.self
            local real angle = Atan2(GetUnitY(targetSelf) - GetUnitY(casterSelf), GetUnitX(targetSelf) - GetUnitX(casterSelf))
            local timer updateTimer = CreateTimerWJ()
            set casterSelf = null
            set d.durationTimer = durationTimer
            set d.lengthX = Knockback_LENGTH * Cos(angle)
            set d.lengthY = Knockback_LENGTH * Sin(angle)
            set d.target = target
            set d.updateTimer = updateTimer
            call AttachInteger(durationTimer, Knockback_SCOPE_ID, d)
            call AddIntegerToTableById(targetId, Knockback_SCOPE_ID, d)
            if (CountIntegersInTableById(targetId, Knockback_SCOPE_ID) == TABLE_STARTED) then
                //! runtextmacro AddEventById( "targetId", "Knockback_EVENT_DEATH" )
            endif
            call AttachInteger(updateTimer, Knockback_SCOPE_ID, d)
            call PlaySoundFromTypeOnUnit( Knockback_EFFECT_SOUND_TYPES[GetRandomInt(0, 2)], targetSelf )
            set targetSelf = null
            call TimerStart(updateTimer, Knockback_UPDATE_TIME, true, function Knockback_Move)
            set updateTimer = null
            call TimerStart(durationTimer, Knockback_DURATION, true, function Knockback_EndingByTimer)
            set durationTimer = null
        endfunction

        public function Knockback_Init takes nothing returns nothing
            set Knockback_EFFECT_SOUND_TYPES[0] = TRIDENT_SOUND_TYPE
            set Knockback_EFFECT_SOUND_TYPES[1] = TRIDENT_SOUND1_TYPE
            set Knockback_EFFECT_SOUND_TYPES[2] = TRIDENT_SOUND2_TYPE
            //! runtextmacro CreateEvent( "Knockback_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Knockback_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    private function Conditions takes Unit manipulatingUnit, player manipulatingUnitOwner, unit target returns boolean
        if ( GetAttachedIntegerById( manipulatingUnit.id, Trident_SCOPE_ID ) == NULL ) then
            return false
        endif
        if ( IsUnitAlly( target, manipulatingUnitOwner ) ) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetRandomReal( 0.01, 1 ) > CHANCE ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit manipulatingUnit, Unit target returns nothing
        if ( Conditions( manipulatingUnit, manipulatingUnit.owner, target.self ) ) then
            call Knockback_Knockback_Start(manipulatingUnit, target)
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        local integer manipulatingUnitId = manipulatingUnit.id
        local Data d = GetAttachedIntegerById(manipulatingUnitId, Trident_SCOPE_ID)
        if (d == NULL) then
            set d = Data.create()
            set d.amount = 1
            call AttachIntegerById( manipulatingUnitId, Trident_SCOPE_ID, d )
            //! runtextmacro AddEventById( "manipulatingUnitId", "EVENT_DAMAGE" )
        else
            set d.amount = d.amount + 1
        endif
        call AddUnitArmorBonus( manipulatingUnit, BONUS_ARMOR )
        call AddUnitDamageBonus( manipulatingUnit, BONUS_DAMAGE )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 600)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 240)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        call Knockback_Knockback_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\Trident.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\VolatileManaPotion.j
//TESH.scrollpos=97
//TESH.alwaysfold=0
//! runtextmacro Scope("VolatileManaPotion")
    globals
        public constant integer ITEM_ID = 'I00A'
        public constant integer SPELL_ID = 'A01H'

        private constant real DURATION = 20.
        private constant real INTERVAL = 1.
        private constant real LOSS_FACTOR = 0.5
        private constant real REFRESHED_MANA = 300.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant string TARGET_EFFECT2_PATH = "Abilities\\Spells\\Undead\\ReplenishMana\\ReplenishManaCaster.mdl"
        private constant string TARGET_EFFECT2_ATTACHMENT_POINT = "origin"
        private constant integer WAVES_AMOUNT = R2I(DURATION / INTERVAL)
    endglobals

    private struct Data
        Unit caster
        real decayingManaPerInterval
        timer durationTimer
        timer intervalTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local integer casterId = caster.id
        local timer intervalTimer = d.intervalTimer
        call RemoveIntegerFromTableById( casterId, VolatileManaPotion_SCOPE_ID, d )
        if ( CountIntegersInTableById( casterId, VolatileManaPotion_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        endif
        call FlushAttachedInteger( durationTimer, VolatileManaPotion_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( intervalTimer, VolatileManaPotion_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
    endfunction

    public function Death takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d
        local integer iteration = CountIntegersInTableById( casterId, VolatileManaPotion_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( casterId, VolatileManaPotion_SCOPE_ID, iteration )
                call Ending( caster, d, d.durationTimer )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, VolatileManaPotion_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    private function DecayMana takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, VolatileManaPotion_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        set intervalTimer = null
        call DestroyEffectTimed( AddSpecialEffectTargetWJ( TARGET_EFFECT2_PATH, casterSelf, TARGET_EFFECT2_ATTACHMENT_POINT ), 2 )
        call AddUnitState( casterSelf, UNIT_STATE_MANA, -d.decayingManaPerInterval )
        set casterSelf = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local real casterMana = GetUnitState( casterSelf, UNIT_STATE_MANA )
        local real casterManaDifference = GetUnitState( casterSelf, UNIT_STATE_MAX_MANA ) - casterMana
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        local real refreshedMana = Min(casterManaDifference, REFRESHED_MANA)
        set d.caster = caster
        set d.decayingManaPerInterval = refreshedMana * LOSS_FACTOR / WAVES_AMOUNT
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        call AddIntegerToTableById( casterId, VolatileManaPotion_SCOPE_ID, d )
        if ( CountIntegersInTableById( casterId, VolatileManaPotion_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
        endif
        call AttachInteger( durationTimer, VolatileManaPotion_SCOPE_ID, d )
        call AttachInteger( intervalTimer, VolatileManaPotion_SCOPE_ID, d )
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, casterSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
        call PlaySoundFromTypeOnUnit( REFRESH_MANA_SOUND_TYPE, casterSelf )
        call TimerStart( intervalTimer, INTERVAL, true, function DecayMana )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
        call SetUnitState( casterSelf, UNIT_STATE_MANA, casterMana + refreshedMana )
        set casterSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 100)
        call SetItemTypeMaxCharges(d, 2)
        call SetItemTypeRefreshInterval(d, 40)
        call SetItemTypeRefreshIntervalStart(d, 70)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT2_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\VolatileManaPotion.j

//file: D:\Warcraft III\Mapping\WFW\Data\Items\WindBoots.j
//TESH.scrollpos=125
//TESH.alwaysfold=0
//! runtextmacro Scope("WindBoots")
    globals
        public constant integer ITEM_ID = 'I00B'
        public constant integer SET_ITEM_ID = 'I022'
        public constant integer SPELL_ID = 'A04E'

        private constant real BONUS_AGILITY = 6.
        private constant real BONUS_SPEED = 25.
        private constant integer DUMMY_UNIT_ID = 'n02K'
        private constant real DUMMY_UNIT_HEIGHT = 150
        private constant real MAX_LENGTH = 550.
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Human\\FlakCannons\\FlakTarget.mdl"
        private constant real SPEED = 700.
        private constant real DURATION = MAX_LENGTH / SPEED
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
    endglobals

    private struct Data
        Unit caster
        unit dummyUnit
        timer durationTimer
        real lengthX
        real lengthY
        timer updateTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local unit dummyUnit = d.dummyUnit
        local timer updateTimer = d.updateTimer
        call FlushAttachedIntegerById( casterId, WindBoots_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_ORDER" )
        call SetUnitAnimationByIndex( dummyUnit, 2 )
        call RemoveUnitTimed( dummyUnit, 4 )
        call FlushAttachedInteger( durationTimer, WindBoots_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( updateTimer, WindBoots_SCOPE_ID )
        call DestroyTimerWJ( updateTimer )
        set updateTimer = null
        call AddUnitPathing( caster )
        call SetUnitPosition( casterSelf, GetUnitX( casterSelf ), GetUnitY( casterSelf ) )
        set casterSelf = null
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, WindBoots_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death(DYING_UNIT)
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, WindBoots_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    private function Move takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, WindBoots_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local unit dummyUnit = d.dummyUnit
        local real newX = casterX + d.lengthX
        local real newY = casterY + d.lengthY
        set updateTimer = null
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, newX, newY ) )
        call SetUnitXYIfNotBlocked( casterSelf, casterX, casterY, newX, newY )
        call SetUnitXWJ( dummyUnit, newX )
        call SetUnitYWJ( dummyUnit, newY )
        call SetUnitZ( dummyUnit, newX, newY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster) + DUMMY_UNIT_HEIGHT )
        set casterSelf = null
        set dummyUnit = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local real angle
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local unit dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, casterX, casterY, STANDARD_ANGLE )
        local timer durationTimer = CreateTimerWJ()
        local timer updateTimer = CreateTimerWJ()
        if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
        else
            set angle = GetUnitFacingWJ( casterSelf )
        endif
        set d.caster = caster
        set d.dummyUnit = dummyUnit
        set d.durationTimer = durationTimer
        set d.lengthX = LENGTH * Cos(angle)
        set d.lengthY = LENGTH * Sin(angle)
        set d.updateTimer = updateTimer
        call AttachIntegerById( casterId, WindBoots_SCOPE_ID, d )
        //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro AddEventById( "casterId", "EVENT_ORDER" )
        call AttachInteger( durationTimer, WindBoots_SCOPE_ID, d )
        call AttachInteger( updateTimer, WindBoots_SCOPE_ID, d )
        call RemoveUnitPathing( caster )
        call SetUnitTimeScale( dummyUnit, 2 )
        call SetUnitAnimationByIndex( dummyUnit, 2 )
        call SetUnitAnimationByIndex( dummyUnit, 0 )
        call SetUnitZ( dummyUnit, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitImpactZ(caster) + DUMMY_UNIT_HEIGHT )
        set casterSelf = null
        set dummyUnit = null
        call TimerStart( updateTimer, UPDATE_TIME, true, function Move )
        set updateTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Order takes Unit caster returns string
    //    local Data d = GetAttachedInteger(caster, WindBoots_SCOPE_ID)
    //    if ( d != NULL ) then
    //        return ""
    //    endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        call Order( ORDERED_UNIT )
    endfunction

    public function Drop takes Unit manipulatingUnit returns nothing
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnit.type, -BONUS_AGILITY )
        call AddUnitSpeedBonus( manipulatingUnit, -BONUS_SPEED )
    endfunction

    public function PickUp takes Unit manipulatingUnit returns nothing
        call AddHeroAgilityBonus( manipulatingUnit, manipulatingUnit.type, BONUS_AGILITY )
        call AddUnitSpeedBonus( manipulatingUnit, BONUS_SPEED )
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeGoldCost(d, 350)

        set d = InitItemTypeEx(SET_ITEM_ID)
        call SetItemTypeGoldCost(d, 350)
        call SetItemTypeMaxCharges(d, 1)

        call CreateSetSimple3(GexxoSlippers_ITEM_ID, GexxoSlippers_ITEM_ID, GexxoSlippers_ITEM_ID, SET_ITEM_ID, ITEM_ID)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_ORDER", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Items\WindBoots.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\AutomaticRevival.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("AutomaticRevival")
    globals
        constant integer REVIVE_ORDER_ID = 852027
    endglobals

    private struct Data
        Unit hero
    endstruct

    private function Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, AutomaticRevival_SCOPE_ID)
        local Unit hero = d.hero
        local Unit townHall = GetPlayerTownHall(hero.owner)
        call d.destroy()
        call FlushAttachedInteger( durationTimer, AutomaticRevival_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null

        if (townHall != NULL) then
            call IssueTargetOrderById(townHall.self, REVIVE_ORDER_ID, hero.self)
        endif
    endfunction

    public function Revivable takes Unit hero returns nothing
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        set d.hero = hero
        call AttachInteger(durationTimer, AutomaticRevival_SCOPE_ID, d)
        call TimerStart( durationTimer, 0, false, function Ending )
        set durationTimer = null
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\AutomaticRevival.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\CameraDialog.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("CameraDialog")
    globals
        private constant real FADE_TIME = 0.75
        private constant real INTERVAL = 200.
        private constant real LOWER_CAP = 1300.
        private constant real TEXT_TIME = 2.
        private constant real UPPER_CAP = 2200.
    endglobals

    private struct Data
        real currentDistance
        dialog dummyDialog
        timer fadeTimer
        player whichPlayer
    endstruct

    private function Ending takes Data d, dialog dummyDialog, player whichPlayer returns nothing
        call d.destroy()
        call FlushAttachedInteger( dummyDialog, CameraDialog_SCOPE_ID )
        call DestroyDialogWJ( dummyDialog )
        call FlushAttachedInteger( whichPlayer, CameraDialog_SCOPE_ID )
    endfunction

    public function Death takes dialog dyingDialog, player whichPlayer returns nothing
        local Data d = GetAttachedInteger( dyingDialog, CameraDialog_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( d, dyingDialog, whichPlayer )
        endif
    endfunction

    private function ShowDialog takes Data d, player whichPlayer returns nothing
        local real currentDistance = d.currentDistance
        local dialog dummyDialog = d.dummyDialog
        call ClearDialog( dummyDialog )
        if ( currentDistance > LOWER_CAP ) then
            call AddDialogButtonWJ( dummyDialog, "Zoom in", 0 )
        endif
        if ( currentDistance < UPPER_CAP ) then
            call AddDialogButtonWJ( dummyDialog, "Zoom out", 0 )
        endif
        call DisplayTextTimedWJ( ColorStrings_GOLD + "Current Distance: " + R2S(currentDistance) + ColorStrings_RESET, TEXT_TIME, whichPlayer )
        call AddDialogButtonWJ( dummyDialog, "Ready", 0 )
        call SetCameraFieldEx( CAMERA_FIELD_TARGET_DISTANCE, currentDistance, whichPlayer )
        call DisplayDialogWJ( dummyDialog, whichPlayer, true )
        set dummyDialog = null
    endfunction

    private function ShowDialogByTimer takes nothing returns nothing
        local timer fadeTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(fadeTimer, CameraDialog_SCOPE_ID)
        local player whichPlayer = d.whichPlayer
        call FlushAttachedInteger( fadeTimer, CameraDialog_SCOPE_ID )
        call DestroyTimerWJ( fadeTimer )
        set fadeTimer = null
        call ShowDialog( d, whichPlayer )
        set whichPlayer = null
    endfunction

    public function DialogClick takes button clickedButton, dialog dummyDialog, player whichPlayer returns nothing
        local string caption
        local real currentDistance
        local Data d = GetAttachedInteger( dummyDialog, CameraDialog_SCOPE_ID )
        local timer fadeTimer
        if ( d != NULL ) then
            set caption = GetButtonCaption(clickedButton)
            if ( caption == "Ready" ) then
                call Ending( d, dummyDialog, whichPlayer )
            else
                set currentDistance = d.currentDistance
                set fadeTimer = CreateTimerWJ()
                if ( caption == "Zoom in" ) then
                    set currentDistance = Max( currentDistance - INTERVAL, LOWER_CAP )
                else
                    set currentDistance = Min( currentDistance + INTERVAL, UPPER_CAP )
                endif
                set d.currentDistance = currentDistance
                call AttachInteger( fadeTimer, CameraDialog_SCOPE_ID, d )
                call SetCameraFieldAcceleratedTimed( CAMERA_FIELD_TARGET_DISTANCE, currentDistance, 0, false, FADE_TIME, whichPlayer )
                call TimerStart( fadeTimer, FADE_TIME, false, function ShowDialogByTimer )
                set fadeTimer = null
            endif
        endif
    endfunction

    public function Chat takes string chatMessage, player whichPlayer returns nothing
        local Data d
        local dialog dummyDialog
        local real value
        local string valueString
        set chatMessage = StringCase( chatMessage, false )
        if ( SubString(chatMessage, 0, 2) == "-c" ) then
            set d = GetAttachedInteger( whichPlayer, CameraDialog_SCOPE_ID )
            if (d == NULL) then
                set valueString = SubString(chatMessage, 3, StringLength(chatMessage))
                if (valueString == null) then
                    if ( GetDisplayedDialog( whichPlayer ) == null ) then
                        set d = Data.create()
                        set dummyDialog = CreateDialogWJ()
                        set d.currentDistance = GetCameraFieldWJ(CAMERA_FIELD_TARGET_DISTANCE, whichPlayer)
                        set d.dummyDialog = dummyDialog
                        set d.whichPlayer = whichPlayer
                        call AttachInteger( dummyDialog, CameraDialog_SCOPE_ID, d )
                        set dummyDialog = null
                        call AttachInteger( whichPlayer, CameraDialog_SCOPE_ID, d )
                        call ShowDialog( d, whichPlayer )
                    endif
                elseif (SubString(chatMessage, 2, 3) == " ") then
                    set value = S2R(valueString)
                    if ( value == 0 ) then
                        call DisplayTextTimedWJ( ColorStrings_YELLOW + "Value invalid or zero", 0, whichPlayer)
                    elseif ( value < LOWER_CAP ) then
                        call DisplayTextTimedWJ( ColorStrings_YELLOW + "Value out of bounds, set to " + R2S(LOWER_CAP), 0, whichPlayer)
                        call SetCameraFieldValue( CAMERA_FIELD_TARGET_DISTANCE, value, whichPlayer )
                    elseif ( value > UPPER_CAP ) then
                        call DisplayTextTimedWJ( ColorStrings_YELLOW + "Value out of bounds, set to " + R2S(UPPER_CAP), 0, whichPlayer)
                        call SetCameraFieldValue( CAMERA_FIELD_TARGET_DISTANCE, value, whichPlayer )
                    else
                        call SetCameraFieldValue( CAMERA_FIELD_TARGET_DISTANCE, value, whichPlayer )
                    endif
                endif
            endif
        endif
    endfunction

    function RefreshCamera takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        local player specificPlayer
        loop
            set specificPlayer = PlayerWJ( iteration )
            if ( GetPlayerSlotState( specificPlayer ) == PLAYER_SLOT_STATE_PLAYING ) then
                call SetCameraFieldWJ( CAMERA_FIELD_TARGET_DISTANCE, GetCameraFieldWJ(CAMERA_FIELD_TARGET_DISTANCE, specificPlayer), 2, specificPlayer )
            endif
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set specificPlayer = null
    endfunction

    public function Start takes nothing returns nothing
        call TimerStart( CreateTimerWJ(), 2, true, function RefreshCamera )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        loop
            call SetCameraFieldEx(CAMERA_FIELD_TARGET_DISTANCE, STANDARD_CAMERA_TARGET_DISTANCE, PlayerWJ(iteration))
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\CameraDialog.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\CameraSmooth.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("CameraSmooth")
    public function Chat takes string chatMessage, player whichPlayer returns nothing
        set chatMessage = StringCase( chatMessage, false )
        if ( SubString( chatMessage, 0, 4 ) == "-cs " ) then
            call DisplayTextTimedWJ("|cff00ff00Camera smoothing factor successfully set.|r", HINT_TEXT_DURATION, whichPlayer)
            call SetCameraSmoothingFactor( GetLocalPlayer(), S2R( SubString( chatMessage, 4, StringLength( chatMessage ) ) ) )
        endif
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\CameraSmooth.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Clear.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Clear")
    public function Chat takes string chatMessage, player whichPlayer returns nothing
        set chatMessage = StringCase( chatMessage, false )
        if ( SubString( chatMessage, 0, 6 ) == "-clear" ) then
            call ClearTextMessagesWJ(whichPlayer)
        endif
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Clear.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Creeps.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Creeps")
    globals
        private constant string RESPAWN_EFFECT_PATH = "Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl"
        private constant string RESPAWN_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    //! runtextmacro Scope("Market")
        globals
            private group Market_CREEP_GROUP
            private integer array Market_CREEP_UNIT_IDS
            private integer Market_CREEP_UNIT_IDS_COUNT = -1
            private constant integer Market_CREEPS_AMOUNT = 2
            private constant real Market_RESPAWN_TIME = 30.
        endglobals

        private struct Market_Data
            group creepGroup
            timer respawnTimer
            rect targetRect
        endstruct

        //! runtextmacro Scope("Release")
            globals
                private constant real Release_DURATION = 1.
            endglobals

            private struct Release_Data
                Unit creep
            endstruct

            private function Release_Ending takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local Release_Data d = GetAttachedInteger(durationTimer, Release_SCOPE_ID)
                local Unit creep = d.creep
                call FlushAttachedInteger(durationTimer, Release_SCOPE_ID)
                call DestroyTimerWJ(durationTimer)
                set durationTimer = null
                call RemoveUnitAttackSilence(creep)
                call RemoveUnitInvulnerability(creep)
            endfunction

            public function Release_Start takes Unit creep returns nothing
                local Release_Data d = Release_Data.create()
                local timer durationTimer = CreateTimerWJ()
                set d.creep = creep
                call AttachInteger(durationTimer, Release_SCOPE_ID, d)
                call AddUnitAttackSilence(creep)
                call AddUnitInvulnerability(creep)
                call TimerStart(durationTimer, Release_DURATION, false, function Release_Ending)
                set durationTimer = null
            endfunction
        //! runtextmacro Endscope()

        public function Market_StartCreeps takes group creepGroup, Market_Data d, rect targetRect returns nothing
            local real angle
            local Unit creep
            local integer creepId
            local unit creepSelf
            local integer iteration = Market_CREEPS_AMOUNT
            loop
                set angle = GetRandomReal(0, 2 * PI)
                set creep = CreateUnitEx(NEUTRAL_AGGRESSIVE_PLAYER, Market_CREEP_UNIT_IDS[GetRandomInt(0, Market_CREEP_UNIT_IDS_COUNT)], GetRandomReal(GetRectMinX(targetRect), GetRectMaxX(targetRect)), GetRandomReal(GetRectMinY(targetRect), GetRectMaxY(targetRect)), angle)
                set creepId = creep.id
                set creepSelf = creep.self
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( RESPAWN_EFFECT_PATH, creepSelf, RESPAWN_EFFECT_ATTACHMENT_POINT ) )
                call AttachIntegerById(creepId, Market_SCOPE_ID, d)
                //! runtextmacro AddEventById( "creepId", "Market_EVENT_DEATH" )
                call GroupAddUnit(creepGroup, creepSelf)
                call Release_Release_Start(creep)
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
            set creepSelf = null
        endfunction

        private function Market_Respawn takes nothing returns nothing
            local timer respawnTimer = GetExpiredTimer()
            local Market_Data d = GetAttachedInteger(respawnTimer, Market_SCOPE_ID)
            set respawnTimer = null
            call Market_StartCreeps(d.creepGroup, d, d.targetRect)
        endfunction

        public function Market_Death takes Unit creep returns nothing
            local group creepGroup
            local integer creepId = creep.id
            local Market_Data d = GetAttachedIntegerById(creepId, Market_SCOPE_ID)
            if ( d != NULL ) then
                set creepGroup = d.creepGroup
                call FlushAttachedIntegerById(creepId, Market_SCOPE_ID)
                //! runtextmacro RemoveEventById( "creepId", "Market_EVENT_DEATH" )
                call GroupRemoveUnit(creepGroup, creep.self)
                if (FirstOfGroup(creepGroup) == null) then
                    call TimerStart(d.respawnTimer, Market_RESPAWN_TIME, false, function Market_Respawn)
                endif
                set creepGroup = null
            endif
        endfunction

        private function Market_Death_Event takes nothing returns nothing
            call Market_Death( DYING_UNIT )
        endfunction

        public function Market_Start takes integer period returns nothing
            local group creepGroup = CreateGroupWJ()
            local Market_Data d = Market_Data.create()
            local timer respawnTimer = CreateTimerWJ()
            //! runtextmacro RotateRectAroundCenter("CREEPS_MARKET_RECT", "PI")
            set d.creepGroup = creepGroup
            set d.respawnTimer = respawnTimer
            set d.targetRect = dummyRect
            call AttachInteger(respawnTimer, Market_SCOPE_ID, d)
            set respawnTimer = null
            call Market_StartCreeps(creepGroup, d, dummyRect)
            set creepGroup = null
            set dummyRect = null
        endfunction

        private function Market_AddCreepUnitTypeId takes integer whichUnitTypeId returns nothing
            set Market_CREEP_UNIT_IDS_COUNT = Market_CREEP_UNIT_IDS_COUNT + 1
            set Market_CREEP_UNIT_IDS[Market_CREEP_UNIT_IDS_COUNT] = whichUnitTypeId
        endfunction

        public function Market_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Market_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Market_Death_Event" )
            call Market_AddCreepUnitTypeId(MURLOC_NIGHTSTALKER_UNIT_ID)
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("MercenaryCamp")
        globals
            private group MercenaryCamp_CREEP_GROUP
            private integer array MercenaryCamp_CREEP_UNIT_IDS
            private integer MercenaryCamp_CREEP_UNIT_IDS_COUNT = -1
            private constant integer MercenaryCamp_CREEPS_AMOUNT = 1
            private constant real MercenaryCamp_RESPAWN_TIME = 30.
        endglobals

        private struct MercenaryCamp_Data
            group creepGroup
            timer respawnTimer
            rect targetRect
        endstruct

        //! runtextmacro Scope("Release")
            globals
                private constant real Release_DURATION = 1.
            endglobals

            private struct Release_Data
                Unit creep
            endstruct

            private function Release_Ending takes nothing returns nothing
                local timer durationTimer = GetExpiredTimer()
                local Release_Data d = GetAttachedInteger(durationTimer, Release_SCOPE_ID)
                local Unit creep = d.creep
                call FlushAttachedInteger(durationTimer, Release_SCOPE_ID)
                call DestroyTimerWJ(durationTimer)
                set durationTimer = null
                call RemoveUnitAttackSilence(creep)
                call RemoveUnitInvulnerability(creep)
            endfunction

            public function Release_Start takes Unit creep returns nothing
                local Release_Data d = Release_Data.create()
                local timer durationTimer = CreateTimerWJ()
                set d.creep = creep
                call AttachInteger(durationTimer, Release_SCOPE_ID, d)
                call AddUnitAttackSilence(creep)
                call AddUnitInvulnerability(creep)
                call TimerStart(durationTimer, Release_DURATION, false, function Release_Ending)
                set durationTimer = null
            endfunction
        //! runtextmacro Endscope()

        public function MercenaryCamp_StartCreeps takes group creepGroup, MercenaryCamp_Data d, rect targetRect returns nothing
            local real angle
            local Unit creep
            local integer creepId
            local unit creepSelf
            local integer iteration = MercenaryCamp_CREEPS_AMOUNT
            loop
                set angle = GetRandomReal(0, 2 * PI)
                set creep = CreateUnitEx(NEUTRAL_AGGRESSIVE_PLAYER, MercenaryCamp_CREEP_UNIT_IDS[GetRandomInt(0, MercenaryCamp_CREEP_UNIT_IDS_COUNT)], GetRandomReal(GetRectMinX(targetRect), GetRectMaxX(targetRect)), GetRandomReal(GetRectMinY(targetRect), GetRectMaxY(targetRect)), angle)
                set creepId = creep.id
                set creepSelf = creep.self
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( RESPAWN_EFFECT_PATH, creepSelf, RESPAWN_EFFECT_ATTACHMENT_POINT ) )
                call AttachIntegerById(creepId, MercenaryCamp_SCOPE_ID, d)
                //! runtextmacro AddEventById( "creepId", "MercenaryCamp_EVENT_DEATH" )
                call GroupAddUnit(creepGroup, creepSelf)
                call Release_Release_Start(creep)
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
            set creepSelf = null
        endfunction

        private function MercenaryCamp_Respawn takes nothing returns nothing
            local timer respawnTimer = GetExpiredTimer()
            local MercenaryCamp_Data d = GetAttachedInteger(respawnTimer, MercenaryCamp_SCOPE_ID)
            set respawnTimer = null
            call MercenaryCamp_StartCreeps(d.creepGroup, d, d.targetRect)
        endfunction

        public function MercenaryCamp_Death takes Unit creep returns nothing
            local group creepGroup
            local integer creepId = creep.id
            local MercenaryCamp_Data d = GetAttachedIntegerById(creepId, MercenaryCamp_SCOPE_ID)
            if ( d != NULL ) then
                set creepGroup = d.creepGroup
                call FlushAttachedIntegerById(creepId, MercenaryCamp_SCOPE_ID)
                //! runtextmacro RemoveEventById( "creepId", "MercenaryCamp_EVENT_DEATH" )
                call GroupRemoveUnit(creepGroup, creep.self)
                if (FirstOfGroup(creepGroup) == null) then
                    call TimerStart(d.respawnTimer, MercenaryCamp_RESPAWN_TIME, false, function MercenaryCamp_Respawn)
                endif
                set creepGroup = null
            endif
        endfunction

        private function MercenaryCamp_Death_Event takes nothing returns nothing
            call MercenaryCamp_Death( DYING_UNIT )
        endfunction

        public function MercenaryCamp_Start takes integer period returns nothing
            local group creepGroup = CreateGroupWJ()
            local MercenaryCamp_Data d = MercenaryCamp_Data.create()
            local timer respawnTimer = CreateTimerWJ()
            //! runtextmacro RotateRectAroundCenter("CREEPS_MERCENARY_CAMP_RECT", "PI")
            set d.creepGroup = creepGroup
            set d.respawnTimer = respawnTimer
            set d.targetRect = dummyRect
            call AttachInteger(respawnTimer, MercenaryCamp_SCOPE_ID, d)
            set respawnTimer = null
            call MercenaryCamp_StartCreeps(creepGroup, d, dummyRect)
            set creepGroup = null
            set dummyRect = null
        endfunction

        private function MercenaryCamp_AddCreepUnitTypeId takes integer whichUnitTypeId returns nothing
            set MercenaryCamp_CREEP_UNIT_IDS_COUNT = MercenaryCamp_CREEP_UNIT_IDS_COUNT + 1
            set MercenaryCamp_CREEP_UNIT_IDS[MercenaryCamp_CREEP_UNIT_IDS_COUNT] = whichUnitTypeId
        endfunction

        public function MercenaryCamp_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "MercenaryCamp_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function MercenaryCamp_Death_Event" )
            call MercenaryCamp_AddCreepUnitTypeId(SEA_GIANT_UNIT_ID)
        endfunction
    //! runtextmacro Endscope()

    public function Start takes nothing returns nothing
        local integer iteration = 1
        loop
            call Market_Market_Start(iteration)
            call MercenaryCamp_MercenaryCamp_Start(iteration)
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
    endfunction

    public function Init takes nothing returns nothing
        call Market_Market_Init()
        call MercenaryCamp_MercenaryCamp_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Creeps.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Drop.j
//TESH.scrollpos=8
//TESH.alwaysfold=0
//! runtextmacro Scope("Drop")
    globals
        private integer HERO_KILL_MESSAGES_COUNT = -1
        private string array HERO_KILL_MESSAGES_FIRST_PART
        private string array HERO_KILL_MESSAGES_MIDDLE_PART
        private string array HERO_KILL_MESSAGES_LAST_PART
        private boolean array HERO_KILL_MESSAGES_INVERTED
    endglobals

    public function Death takes boolean deathCausedByEnemy, Unit dyingUnit, player dyingUnitOwner, UnitType dyingUnitType, real dyingUnitX, real dyingUnitY, real dyingUnitZ, Unit killingUnit, player killingUnitOwner, integer killingUnitTeam returns nothing
        local integer drop
        local texttag dropTextTag
        local integer iteration
        local integer random
        local player specificPlayer
        if ( deathCausedByEnemy ) then
            set drop = GetAttackDrop( killingUnit, dyingUnit, dyingUnitType )
            if ( IsUnitType(dyingUnit.self, UNIT_TYPE_HERO) ) then
                set random = GetRandomInt( 0, HERO_KILL_MESSAGES_COUNT )
                if (HERO_KILL_MESSAGES_INVERTED[random]) then
                    call DisplayTextTimedWJ( HERO_KILL_MESSAGES_FIRST_PART[random] + GetPlayerColorString( dyingUnitOwner ) + GetPlayerName(dyingUnitOwner) + ColorStrings_RESET + HERO_KILL_MESSAGES_MIDDLE_PART[random] + GetPlayerColorString( killingUnitOwner ) + GetPlayerName(killingUnitOwner) + ColorStrings_RESET + HERO_KILL_MESSAGES_LAST_PART[random], 15, GetLocalPlayer() )
                else
                    call DisplayTextTimedWJ( HERO_KILL_MESSAGES_FIRST_PART[random] + GetPlayerColorString( killingUnitOwner ) + GetPlayerName(killingUnitOwner) + ColorStrings_RESET + HERO_KILL_MESSAGES_MIDDLE_PART[random] + GetPlayerColorString( dyingUnitOwner ) + GetPlayerName(dyingUnitOwner) + ColorStrings_RESET + HERO_KILL_MESSAGES_LAST_PART[random], 15, GetLocalPlayer() )
                endif
            endif
            call SetPlayerState( dyingUnitOwner, PLAYER_STATE_GIVES_BOUNTY, 1 )
            if ( drop == GetUnitDrop( dyingUnit ) ) then
                call Infoboard_Additionboard_Additionboard_Drop(killingUnitOwner, drop)
            else
                set dyingUnitZ = dyingUnitZ + GetUnitOutpactZ( dyingUnit )
                if ( drop > 0 ) then
                    if ( GetUnitAbilityLevel( killingUnit.self, SHARED_CONTROL_SPELL_ID ) > 0 ) then
                        set iteration = CountTeamPlayersAlive(killingUnitTeam)
                        if (iteration > -1) then
                            set drop = drop / (iteration + 1)
                            loop
                                set specificPlayer = GetTeamPlayersAlive(killingUnitTeam, iteration)
                                call AddPlayerState( specificPlayer, PLAYER_STATE_RESOURCE_GOLD, drop )
                                call Infoboard_Additionboard_Additionboard_Drop(specificPlayer, drop)
                                set dropTextTag = CreateRisingTextTag( "+" + I2S( drop ), 0.024, dyingUnitX, dyingUnitY, dyingUnitZ, 80, 255, 204, 0, 255, 0, 3 )
                                if ( dropTextTag != null ) then
                                    call LimitTextTagVisibilityToPlayer( dropTextTag, specificPlayer )
                                    set dropTextTag = null
                                endif
                                set iteration = iteration - 1
                                exitwhen ( iteration < 0 )
                            endloop
                        endif
                    else
                        call AddPlayerState( killingUnitOwner, PLAYER_STATE_RESOURCE_GOLD, drop )
                        call Infoboard_Additionboard_Additionboard_Drop(killingUnitOwner, drop)
                        set dropTextTag = CreateRisingTextTag( "+" + I2S( drop ), 0.024, dyingUnitX, dyingUnitY, dyingUnitZ, 80, 255, 204, 0, 255, 0, 3 )
                        if ( dropTextTag != null ) then
                            call LimitTextTagVisibilityToPlayer( dropTextTag, killingUnitOwner )
                            set dropTextTag = null
                        endif
                    endif
                endif
            endif
        endif
        set specificPlayer = null
    endfunction

    private function AddHeroKillMessage takes string firstPart, string middlePart, string lastPart, boolean inverted returns nothing
        set HERO_KILL_MESSAGES_COUNT = HERO_KILL_MESSAGES_COUNT + 1
        set HERO_KILL_MESSAGES_FIRST_PART[HERO_KILL_MESSAGES_COUNT] = firstPart
        set HERO_KILL_MESSAGES_MIDDLE_PART[HERO_KILL_MESSAGES_COUNT] = middlePart
        set HERO_KILL_MESSAGES_LAST_PART[HERO_KILL_MESSAGES_COUNT] = lastPart
        set HERO_KILL_MESSAGES_INVERTED[HERO_KILL_MESSAGES_COUNT] = inverted
    endfunction

    public function Init takes nothing returns nothing
        call AddHeroKillMessage("", " got smashed by ", "", true)
        call AddHeroKillMessage("", " made ", " kiss the ground.", false)
        call AddHeroKillMessage("", " used falcon punch against ", "", false)
        call AddHeroKillMessage("", " could not read the situation ", " created", true)
        call AddHeroKillMessage("", "'s fate was sealed by ", "", true)
        call AddHeroKillMessage("", " was garbage-collected by ", "", true)
        call AddHeroKillMessage("", " was too imba for ", "", false)
        call AddHeroKillMessage("", " divided ", " by zero", false)
        call AddHeroKillMessage("", " has been squashed to fit into a can because of ", "", true)
        call AddHeroKillMessage("", " now sees ", " from the worm's-eye view", true)
        call AddHeroKillMessage("", " was just too much to begin with for ", "", false)
        call AddHeroKillMessage("", " toasted ", "", false)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Drop.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Experience.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Experience")
    globals
        private constant real AREA_RANGE = 1500.
        public boolean array DISABLED
        private constant real EP_HERO_LEVEL_FACTOR = 65.
        private group ENUM_GROUP
        private real array LEVEL_FACTOR
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        local real distance
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_HERO ) == false ) then
            return false
        endif
        if ( IsUnitIllusionWJ( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        set distance = DistanceByCoordinates( TEMP_REAL, TEMP_REAL2, GetUnitX(FILTER_UNIT_SELF), GetUnitY(FILTER_UNIT_SELF) )
        set TEMP_INTEGER = TEMP_INTEGER + 1
        if ( distance == 0 ) then
            set TEMP_INTEGER2 = TEMP_INTEGER2 + 1
        else
            set TEMP_REAL3 = TEMP_REAL3 + distance
        endif
        return true
    endfunction

    private function Death_Conditions takes boolean deathCausedByEnemy, player killingUnitOwner, integer killingUnitTeam returns boolean
        if ( DISABLED[killingUnitTeam] ) then
            return false
        endif
        if ( deathCausedByEnemy == false ) then
            return false
        endif
        return true
    endfunction

    public function Death takes boolean deathCausedByEnemy, Unit dyingUnit, UnitType dyingUnitType, real dyingUnitX, real dyingUnitY, player killingUnitOwner, integer killingUnitTeam returns nothing
        local unit enumUnit
        local real ep
        local integer previousLevel
        if ( Death_Conditions( deathCausedByEnemy, killingUnitOwner, killingUnitTeam ) ) then
            set TEMP_INTEGER = 0
            set TEMP_INTEGER2 = 0
            set TEMP_PLAYER = killingUnitOwner
            set TEMP_REAL = dyingUnitX
            set TEMP_REAL2 = dyingUnitY
            set TEMP_REAL3 = 0
            call GroupEnumUnitsInRangeWJ( ENUM_GROUP, dyingUnitX, dyingUnitY, AREA_RANGE, TARGET_CONDITIONS )
            set enumUnit = FirstOfGroup( ENUM_GROUP )
            if ( enumUnit != null ) then
                set ep = GetUnitTypeEP(dyingUnitType) + GetHeroLevel( dyingUnit.self ) * EP_HERO_LEVEL_FACTOR
                set previousLevel = GetHeroLevel( enumUnit )
                if ( TEMP_INTEGER2 > 0 ) then
                    loop
                        call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                        set previousLevel = GetHeroLevel( enumUnit )
                        call AddUnitEP( enumUnit, LEVEL_FACTOR[previousLevel] * ep / TEMP_INTEGER2 )
                        set enumUnit = FirstOfGroup( ENUM_GROUP )
                        exitwhen ( enumUnit == null )
                    endloop
                elseif ( TEMP_INTEGER > 1 ) then
                    loop
                        call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                        call AddUnitEP( enumUnit, LEVEL_FACTOR[previousLevel] * ep * ( 1 - DistanceByCoordinates( dyingUnitX, dyingUnitY, GetUnitX(enumUnit), GetUnitY(enumUnit) ) / TEMP_REAL3 ) )
                        set enumUnit = FirstOfGroup( ENUM_GROUP )
                        exitwhen ( enumUnit == null )
                    endloop
                else
                    call AddUnitEP( enumUnit, LEVEL_FACTOR[previousLevel] * ep )
                endif
            endif
        endif
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = GetTeams()
        loop
            set DISABLED[iteration] = false
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        set ENUM_GROUP = CreateGroupWJ()
        set LEVEL_FACTOR[1] = 1.5
        set LEVEL_FACTOR[2] = 1.45
        set LEVEL_FACTOR[3] = 1.4
        set LEVEL_FACTOR[4] = 1.36
        set LEVEL_FACTOR[5] = 1.32
        set LEVEL_FACTOR[6] = 1.29
        set LEVEL_FACTOR[7] = 1.26
        set LEVEL_FACTOR[8] = 1.23
        set LEVEL_FACTOR[9] = 1.2
        set LEVEL_FACTOR[10] = 1.18
        set LEVEL_FACTOR[11] = 1.16
        set LEVEL_FACTOR[12] = 1.14
        set LEVEL_FACTOR[13] = 1.12
        set LEVEL_FACTOR[14] = 1.1
        set LEVEL_FACTOR[15] = 1.09
        set LEVEL_FACTOR[16] = 1.08
        set TARGET_CONDITIONS = ConditionWJ(function TargetConditions)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Experience.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\ExtraGold.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("ExtraGold")
    globals
        public constant integer BONUS_GOLD = 13
        public constant real INTERVAL = 6.
    endglobals

    private function GiveGold takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        local player specificPlayer
        loop
            set specificPlayer = PlayerWJ( iteration )
            if (IsPlayerDead(specificPlayer) == false) then
                call AddPlayerState( specificPlayer, PLAYER_STATE_RESOURCE_GOLD, BONUS_GOLD + GoldTower_ExtraGold(GetPlayerTeam( specificPlayer )) )
            endif
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set specificPlayer = null
    endfunction

    public function Start takes nothing returns nothing
        call TimerStart( CreateTimerWJ(), INTERVAL, true, function GiveGold )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\ExtraGold.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\GoldTower.j
//TESH.scrollpos=138
//TESH.alwaysfold=0
//! runtextmacro Scope("GoldTower")
    globals
        private constant integer BONUS_GOLD = 3
        private constant real RELEASE_TIME = 75.
        private timer RELEASE_TIMER
        private constant real TIME_SCALE = 60 / RELEASE_TIME
        private Unit array TOWERS
        private integer TOWERS_COUNT
    endglobals

    private struct Data
        Unit tower
        real x
        real y
    endstruct

    public function Death takes boolean deathCausedByEnemy, Unit tower, Unit killingUnit returns nothing
        local integer towerId = tower.id
        local Data d = GetAttachedIntegerById( towerId, GoldTower_SCOPE_ID )
        local player killingUnitOwner
        local integer killingUnitTeam
        local player towerOwner
        local integer towerTeam
        if ( d != NULL ) then
            set killingUnitOwner = killingUnit.owner
            set killingUnitTeam = GetPlayerTeam(killingUnitOwner)
            set towerOwner = tower.owner
            set towerTeam = GetPlayerTeam(towerOwner)
            call FlushAttachedIntegerById( towerId, GoldTower_SCOPE_ID )
            if ( towerOwner != NEUTRAL_AGGRESSIVE_PLAYER ) then
                call RemoveSavedIntegerFromTable( SCOPE_PREFIX, I2S(towerTeam), d )
            endif
            if ( deathCausedByEnemy and ( killingUnitOwner != NEUTRAL_AGGRESSIVE_PLAYER ) ) then
                set towerOwner = GetTeamPlayers(killingUnitTeam, 0)
            else
                set towerOwner = NEUTRAL_AGGRESSIVE_PLAYER
            endif
            set killingUnitOwner = null
            //! runtextmacro RemoveEventById( "towerId", "EVENT_DEATH" )
            set tower = CreateUnitEx( towerOwner, GOLD_TOWER_UNIT_ID, d.x, d.y, STANDARD_ANGLE )
            set towerOwner = null
            set towerId = tower.id
            set d.tower = tower
            if ( deathCausedByEnemy ) then
                call AddSavedIntegerToTable( SCOPE_PREFIX, I2S(killingUnitTeam), tower )
            endif
            call AttachIntegerById( towerId, GoldTower_SCOPE_ID, d )
            //! runtextmacro AddEventById( "towerId", "EVENT_DEATH" )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( IsUnitEnemy(KILLING_UNIT.self, DYING_UNIT.owner), DYING_UNIT, KILLING_UNIT )
    endfunction

    public function ExtraGold takes integer whichTeam returns integer
        local Data d
        local texttag dropTextTag
        local integer iteration = CountSavedIntegersInTable( SCOPE_PREFIX, I2S(whichTeam) ) - 1
        local integer bonusGold = ( iteration + 1 ) * BONUS_GOLD
        local Unit tower
        local unit towerSelf
        local real x
        local real y
        loop
            exitwhen ( iteration < 0 )
            set d = GetSavedIntegerFromTable( SCOPE_PREFIX, I2S(whichTeam), iteration )
            set tower = d.tower
            set towerSelf = tower.self
            set x = d.x
            set y = d.y
            set dropTextTag = CreateRisingTextTag( "+" + I2S( BONUS_GOLD ), 0.023, x, y, GetUnitZ( towerSelf, x, y ) + GetUnitOutpactZ(tower), 80, 255, 204, 0, 255, 0, 3 )
            if ( dropTextTag != null ) then
                call LimitTextTagVisibilityToTeam( dropTextTag, whichTeam )
            endif
            set iteration = iteration - 1
        endloop
        set dropTextTag = null
        set towerSelf = null
        return bonusGold
    endfunction

    //! runtextmacro Scope("Release")
        public function Release_Ending takes nothing returns nothing
            local integer iteration = TOWERS_COUNT
            local integer iteration2
            local real sightRange = GetUnitTypeSightRange( GetUnitType(GOLD_TOWER_UNIT_ID) ) - 65
            local Unit tower
            local unit towerSelf
            call DestroyTimerWJ( RELEASE_TIMER )
            set RELEASE_TIMER = null
            loop
                set iteration2 = MAX_PLAYER_INDEX
                set tower = TOWERS[iteration]
                set towerSelf = tower.self
                call SetUnitInvulnerable( towerSelf, false )
                call SetUnitTimeScale( towerSelf, 1 )
                call SetUnitAnimationByIndex( towerSelf, 1 )
                call AddUnitSightRange( tower, sightRange )
                loop
                    call UnitShareVision( towerSelf, PlayerWJ( iteration2 ), false )
                    set iteration2 = iteration2 + 1
                    exitwhen ( iteration2 < 0 )
                endloop
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            set towerSelf = null
            call DisplayTextTimedWJ( ColorStrings_GOLD + "The Gold Towers are set up on their positions now. Occupied towers grant an extra income.", 30, GetLocalPlayer() )
        endfunction

        public function Release_Start takes real sightRange, Unit tower returns nothing
            local integer iteration = MAX_PLAYER_INDEX
            local unit towerSelf = tower.self
            call SetUnitInvulnerable( towerSelf, true )
            call AddUnitSightRange( tower, sightRange )
            loop
                call UnitShareVision( towerSelf, PlayerWJ( iteration ), true )
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            call SetUnitAnimationByIndex( towerSelf, 0 )
            call SetUnitTimeScale( towerSelf, TIME_SCALE )
            set towerSelf = null
        endfunction
    //! runtextmacro Endscope()

    private function StartTower takes real sightRange, real x, real y returns nothing
        local Data d
        local Unit tower
        local integer towerId
        set tower = CreateUnitEx( NEUTRAL_AGGRESSIVE_PLAYER, GOLD_TOWER_UNIT_ID, x, y, STANDARD_ANGLE )
        set towerId = tower.id
        set d.tower = tower
        set d.x = x
        set d.y = y
        set TOWERS_COUNT = TOWERS_COUNT + 1
        set TOWERS[TOWERS_COUNT] = tower
        call AttachIntegerById( towerId, GoldTower_SCOPE_ID, d )
        //! runtextmacro AddEventById( "towerId", "EVENT_DEATH" )
        call Release_Release_Start(sightRange, tower)
    endfunction

    public function Start takes nothing returns nothing
        local real angle
        local real centerTower2Angle
        local real difference2
        local real differenceX = GetRectCenterX( gg_rct_GoldTower ) - CENTER_X
        local real differenceY = GetRectCenterY( gg_rct_GoldTower ) - CENTER_Y
        local real difference = SquareRoot( differenceX * differenceX + differenceY * differenceY )
        local real centerTowerAngle = Atan2( differenceY, differenceX )
        local integer iteration = 0
        local real sightRange = -(GetUnitTypeSightRange( GetUnitType(GOLD_TOWER_UNIT_ID) ) - 65)
        local real x
        local real y
        set differenceX = GetRectCenterX( gg_rct_GoldTower2 ) - CENTER_X
        set differenceY = GetRectCenterY( gg_rct_GoldTower2 ) - CENTER_Y
        set centerTower2Angle = Atan2( differenceY, differenceX )
        set difference2 = SquareRoot( differenceX * differenceX + differenceY * differenceY )
        loop
            set angle = centerTowerAngle + iteration * PI / 2
            call StartTower(sightRange, CENTER_X + difference * Cos( angle ), CENTER_Y + difference * Sin( angle ))
            set angle = centerTower2Angle + iteration * PI / 2
            call StartTower(sightRange, CENTER_X + difference2 * Cos( angle ), CENTER_Y + difference2 * Sin( angle ))
            set iteration = iteration + 1
            exitwhen ( iteration > 3 )
        endloop
        call TimerStart( RELEASE_TIMER, RELEASE_TIME, false, function Release_Release_Ending )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "1", "function Death_Event" )
        set RELEASE_TIMER = CreateTimerWJ()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\GoldTower.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Hints.j
//TESH.scrollpos=61
//TESH.alwaysfold=0
//! runtextmacro Scope("Hints")
    globals
        private constant real DURATION = 15.
        private boolean array HIDDEN
        private string array HINTS
        private integer HINTS_COUNT = -1
        private constant real INTERVAL = 60.
        private timer INTERVAL_TIMER
    endglobals

    private function CreateHint takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        local integer random = GetRandomInt( 0, HINTS_COUNT )
        local player specificPlayer
        loop
            set specificPlayer = PlayerWJ( iteration )
            if ( HIDDEN[GetPlayerId(specificPlayer)] == false ) then
                call DisplayTextTimedWJ( ColorStrings_GOLD + "Hint " + I2S( random + 1 ) + " of " + I2S( HINTS_COUNT + 1 ) + " :" + ColorStrings_RESET + " " + HINTS[random], DURATION, specificPlayer )
                call PlaySoundFromTypeForPlayer( HINT_SOUND_TYPE, specificPlayer )
            endif
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set specificPlayer = null
    endfunction

    public function Chat takes string chatMessage, player whichPlayer returns nothing
        local integer whichPlayerId
        set chatMessage = StringCase( chatMessage, false )
        if ( chatMessage == "-hints" ) then
            set whichPlayerId = GetPlayerId(whichPlayer)
            set HIDDEN[whichPlayerId] = (HIDDEN[whichPlayerId] == false)
            if (HIDDEN[whichPlayerId]) then
                call DisplayTextTimedWJ( ColorStrings_RED + "No more hints shown to you." + ColorStrings_RESET, HINT_TEXT_DURATION, whichPlayer )
            else
                call DisplayTextTimedWJ( ColorStrings_GREEN + "Hints enabled again." + ColorStrings_RESET, HINT_TEXT_DURATION, whichPlayer)
            endif
        endif
    endfunction

    public function Start takes nothing returns nothing
        call TimerStart( CreateTimerWJ(), INTERVAL, true, function CreateHint )
    endfunction

    public function InitHint takes string text returns nothing
        set HINTS_COUNT = HINTS_COUNT + 1
        set HINTS[HINTS_COUNT] = text
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        loop
            set HIDDEN[iteration] = false
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set INTERVAL_TIMER = CreateTimerWJ()
        call InitHint( "Special thanks goes to: anXieTy, Dojo, Quillraven und The-Red-OrK and to the thousands of Footies that lost their lives during the tests")
        call InitHint( "After the upgrade of the town hall the spawn changes to the new unit type. Training the old type once suffices to return to it." )
        call InitHint( "The unit types within a race have different qualifications and disadvantages. Not everytime the representatives of higher tiers are superior to the others. Mix your troups and match yourself to the situation!" )
        call InitHint( "Chat message \"-c\" calls a dialog that lets you set your camera zoom or directly call \"-c value\"." )
        call InitHint( "The master wizards in the edges of your bases, which allow you to cast special events, use a team-shared manapool. Administrate it wisely and coordinate it with your comrades or declare a commander at the beginning." )
        call InitHint( "In 6on6 games players of one edge form a team. Events that refer to a team accordingly only affect members of the own corner." )
        call InitHint( "The goal of the game is to destroy all enemy town halls before they have done this to yours. The extermination of the forces might be useful but is not demanded." )
    //    call InitHint( "The more spawns the player possesses the longer it takes for a new unit to appear. The time span increases with each units by two percent." )
        //call InitHint( "The arenas only differ in appearances." )
        //call InitHint( "Graphic weather effects can be turned on/off via chat input \"-w\"." )
        call InitHint( "By researches improved abilities show the bonus only on future castings. Afore the completion of the research applied spell do not get the benefits." )
        call InitHint( "Abilities that are supported by the attributes of a hero, obtain the bonuses because of their stats at the beginning of performing the skill. Later changes do not count." )
        //call InitHint( "The terrain your units stand on influences them. Grass heals and marble refreshes the mental energies. Buildings are only erectable on bricky grounds.\n(The denotations here match the forest tileset, it is analog to the equivalent tiles of the other sets)" )
        call InitHint( "Gold coins and runes vanish after resting " + I2S( R2I(SpecialDrops_DURATION) ) + " seconds on the ground." )
        call InitHint( "Not all abilities are of magical nature. There are skills that can hit structures or mechanicals or even magic immune units and spells that are just the other way around." )
        call InitHint( "Each " + I2S( R2I(ExtraGold_INTERVAL) ) + " seconds you are granted " + I2S( ExtraGold_BONUS_GOLD ) + " extra gold." )
        call InitHint( "The upper movement speed limit equals " + I2S( R2I( Unit_Speed_Speed_UPPER_CAP ) ) + ", the lower is " + I2S( R2I( Unit_Speed_Speed_LOWER_CAP ) ) + "." )
        call InitHint( "Spawns and Reserves are able to reach silver and gold state, which award them with boosted values, by defeating hostile units in fights. Silver requires two murders, gold needs four kills." )
        call InitHint( "This map has a lot of interface changes. They will not vanish with the game's end as \"Warcraft 3\" resets to the normal interface only upon restart. So games that you play after this might show another style than they used to if you do not relaunch the program." )
        call InitHint( "If you have a german keyboard and \"Windows XP\", and you want to change the key functionality to the english version, you can press Alt+Shift to achieve this." )
        call InitHint( "A Unit dies when its life becomes below or equal to 0.405, destructables and items from 0.401 downwards on." )
        call InitHint( "The central fountain actually sells items. It's a commercial wishing well." )
        call InitHint( "The tooltips of buyable objects show the normal purchasing price. The actual amount can be lowered by the 'Cash Discount' ability. I hope you can calculate." )
        call InitHint( "Thanks to problems concerning customizing shopping the refreshing display may vary from the the original progress. However, the angular speed you can see is right and it only affects visibility as the refresh is controlled by own timers." )
        call InitHint( "Besides mana, the fountain grants nearby heroes additional experience in intervals but this only works if there is no enemy unit in range." )
        call InitHint( "Race-specific researches are only available for one race. Nevertheless, general ones like 'Upgrade Speed' from Human that do not refer to a special unit also apply to the spawns of the other races." )
        call InitHint( "Market and mercenary camp randomly decide their position at the beginning of the game. So you may find them swapped from your previous experience." )
        call InitHint( "Please be so good and pay the hardly-used infocard (quest menu) a visit. You can also find a list of commands there that can do useful stuff like toggling these hints off." )
        //call InitHint( "All trees are made of gold and are invulnerable. They always grow again and can be harvested by workers." )
        call InitHint( "Texttags are limited to 100 simultaneous instances :(" )
        call InitHint( "The infoboard (multiboard) shows kills and deaths of players and hero kills/hero deaths in brackets." )
        call InitHint( "You are able to see the enemy's Master Wizard's mana." )
        call InitHint( "None of the units really die here. They only play a less harmful version of dodgeball and act like their corpses are decaying to show their passionate sportsmanship." )
        call InitHint( "Each unit is able to attack air. However, melee ground units only do a reduced damage of (" + I2S(R2I(Air_DAMAGE_FACTOR * 100)) + "%) to them." )
        call InitHint( "Reserve gnolls, steam tanks and glaive throwers are classified as summoned." )
        call InitHint( "Hiring workers costs a bit but using the skill 'Repair' does not require extra payment." )
        call InitHint( "Heroes are automatically ordered to revive when they die if the town hall is able to do so at this moment." )
        call InitHint( "Your team's master wizard obtains " + I2S(R2I(MasterWizard_BONUS_MANA_PER_KILL)) + " for each kill you do (excluded are summoned units)." )

        call InitHint( "There are "+I2S(HINTS_COUNT + 2) + " hints." )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Hints.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Infoboard.j
//TESH.scrollpos=310
//TESH.alwaysfold=0
//! runtextmacro Scope("Infoboard")
    globals
        constant real MULTIBOARD_GAP_WIDTH = 0.001

        private constant real CHECK_INTERVAL = 0.035
        public integer COUNT = 0
        private constant integer HEAD_ROW = 0
        multiboard INFOBOARD
        private constant integer COLOR_COLUMN = 0
        private constant integer NAME_COLUMN = 1

        private constant real HEROES_COLUMN_WIDTH = 0.04
        private constant integer HEROES_START_GAP = 2
        private constant integer HEROES_LEVEL_COLUMN = 3
        private constant integer HEROES_COLUMN = 4
        private constant integer HEROES_MIDDLE_GAP = 5
        private constant integer HEROES2_LEVEL_COLUMN = 6
        private constant integer HEROES2_COLUMN = 7
        private constant integer HEROES_END_GAP = 8

        private constant integer KILLS_COLUMN = 9
        private constant integer DEATHS_COLUMN = 10

        private integer array DEATHS
        private integer array HERO_DEATHS
        private integer array HERO_KILLS
        private integer array KILLS
        private boolean MULTIBOARD_MINIMIZED
        private integer MULTIBOARD_STAGE
        private integer array PLAYERS_POSITION
        private boolean STARTED = false
    endglobals

    private struct Data
        integer column
    endstruct

    //! runtextmacro Scope("Additionboard")
        globals
            multiboard ADDBOARD
            private constant integer Additionboard_HEAD_ROW = 0
            private constant integer Additionboard_HEAD_ROW2 = 1
            private constant integer Additionboard_NAME_COLUMN = 0
            private constant integer Additionboard_GOLD_EARNED_COLUMN = 1
            private constant integer Additionboard_COINS_COLUMN = 2
            private constant integer Additionboard_ITEMS_PERMANENT_COLUMN = 3
            private constant integer Additionboard_ITEMS_CONSUMABLE_COLUMN = 4
            private constant integer Additionboard_MERCS_COLUMN = 5
            private constant integer Additionboard_RESEARCHES_COLUMN = 6

            private integer array Additionboard_GOLD_EARNED
            private integer array Additionboard_COINS
            private integer array Additionboard_COINS_GOLD
            private integer array Additionboard_ITEMS_PERMANENT
            private integer array Additionboard_ITEMS_CONSUMABLE
            private integer array Additionboard_MERCS
            private integer array Additionboard_RESEARCHES
            private integer array Additionboard_PLAYERS_POSITION
        endglobals

        public function Additionboard_Coin takes player whichPlayer, integer amount returns nothing
            local integer whichPlayerId = GetPlayerId(whichPlayer)
            local integer pos = Additionboard_PLAYERS_POSITION[whichPlayerId]
            if (pos != -1) then
                set Additionboard_COINS[whichPlayerId] = Additionboard_COINS[whichPlayerId] + 1
                set Additionboard_COINS_GOLD[whichPlayerId] = Additionboard_COINS_GOLD[whichPlayerId] + amount
                call SetMultiboardCellValue( ADDBOARD, Additionboard_COINS_COLUMN, pos, I2S(Additionboard_COINS[whichPlayerId]) + " (" + I2S(Additionboard_COINS_GOLD[whichPlayerId]) + ")" )
            endif
        endfunction

        public function Additionboard_Drop takes player whichPlayer, integer amount returns nothing
            local integer whichPlayerId = GetPlayerId(whichPlayer)
            local integer pos = Additionboard_PLAYERS_POSITION[whichPlayerId]
            if (pos != -1) then
                set Additionboard_GOLD_EARNED[whichPlayerId] = Additionboard_GOLD_EARNED[whichPlayerId] + amount
                call SetMultiboardCellValue( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, pos, I2S(Additionboard_GOLD_EARNED[whichPlayerId]) )
            endif
        endfunction

        public function Additionboard_ResearchFinish takes player whichPlayer returns nothing
            local integer whichPlayerId = GetPlayerId(whichPlayer)
            local integer pos = Additionboard_PLAYERS_POSITION[whichPlayerId]
            if (pos != -1) then
                set Additionboard_RESEARCHES[whichPlayerId] = Additionboard_RESEARCHES[whichPlayerId] + 1
                call SetMultiboardCellValue( ADDBOARD, Additionboard_RESEARCHES_COLUMN, pos, I2S(Additionboard_RESEARCHES[whichPlayerId]) )
            endif
        endfunction

        public function Additionboard_SellItemExecute takes player whichPlayer, item whichItem returns nothing
            local integer whichPlayerId = GetPlayerId(whichPlayer)
            local integer pos = Additionboard_PLAYERS_POSITION[whichPlayerId]
            if (pos != -1) then
                if (GetItemType(whichItem) == ITEM_TYPE_PERMANENT) then
                    set Additionboard_ITEMS_PERMANENT[whichPlayerId] = Additionboard_ITEMS_PERMANENT[whichPlayerId] + 1
                    call SetMultiboardCellValue( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, pos, I2S(Additionboard_ITEMS_PERMANENT[whichPlayerId]) )
                elseif (GetItemType(whichItem) == ITEM_TYPE_CHARGED) then
                    set Additionboard_ITEMS_CONSUMABLE[whichPlayerId] = Additionboard_ITEMS_CONSUMABLE[whichPlayerId] + 1
                    call SetMultiboardCellValue( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, pos, I2S(Additionboard_ITEMS_CONSUMABLE[whichPlayerId]) )
                endif
            endif
        endfunction

        public function Additionboard_SellUnitExecute takes player whichPlayer returns nothing
            local integer whichPlayerId = GetPlayerId(whichPlayer)
            local integer pos = Additionboard_PLAYERS_POSITION[whichPlayerId]
            if (pos != -1) then
                set Additionboard_MERCS[whichPlayerId] = Additionboard_MERCS[whichPlayerId] + 1
                call SetMultiboardCellValue( ADDBOARD, Additionboard_MERCS_COLUMN, pos, I2S(Additionboard_MERCS[whichPlayerId]) )
            endif
        endfunction

        private function Additionboard_CheckDisplay takes nothing returns nothing
            if (IsMultiboardMinimized(ADDBOARD)) then
                set MULTIBOARD_MINIMIZED = true
            else
                if (MULTIBOARD_MINIMIZED and (MULTIBOARD_STAGE == 1)) then
                    set MULTIBOARD_MINIMIZED = false
                    set MULTIBOARD_STAGE = 0
                    call DisplayMultiboard( ADDBOARD, GetLocalPlayer(), false )
                    call DisplayMultiboard( INFOBOARD, GetLocalPlayer(), true )
                endif
            endif
        endfunction

        public function Additionboard_Start takes nothing returns nothing
            local integer count = 2
            local integer iteration = MAX_PLAYER_INDEX
            local player specificPlayer
            set ADDBOARD = CreateMultiboardWJ()
            call MultiboardSetRowCount( ADDBOARD, 2 )
            call MultiboardSetColumnCount( ADDBOARD, 7 )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_NAME_COLUMN, Additionboard_HEAD_ROW, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_NAME_COLUMN, Additionboard_HEAD_ROW2, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, Additionboard_HEAD_ROW, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, Additionboard_HEAD_ROW2, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_COINS_COLUMN, Additionboard_HEAD_ROW, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_COINS_COLUMN, Additionboard_HEAD_ROW2, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, Additionboard_HEAD_ROW, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, Additionboard_HEAD_ROW2, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, Additionboard_HEAD_ROW, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, Additionboard_HEAD_ROW2, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_MERCS_COLUMN, Additionboard_HEAD_ROW, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_MERCS_COLUMN, Additionboard_HEAD_ROW2, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_RESEARCHES_COLUMN, Additionboard_HEAD_ROW, true, false )
            call SetMultiboardCellStyle( ADDBOARD, Additionboard_RESEARCHES_COLUMN, Additionboard_HEAD_ROW2, true, false )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_NAME_COLUMN, Additionboard_HEAD_ROW, "Player" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_NAME_COLUMN, Additionboard_HEAD_ROW2, "name" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, Additionboard_HEAD_ROW, "Gold" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, Additionboard_HEAD_ROW2, "earned" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_COINS_COLUMN, Additionboard_HEAD_ROW, "Coins" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_COINS_COLUMN, Additionboard_HEAD_ROW2, "collected" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, Additionboard_HEAD_ROW, "Items bought" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, Additionboard_HEAD_ROW2, "(perm.)" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, Additionboard_HEAD_ROW, "Items bought" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, Additionboard_HEAD_ROW2, "(cons.)" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_MERCS_COLUMN, Additionboard_HEAD_ROW, "Mercs" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_MERCS_COLUMN, Additionboard_HEAD_ROW2, "hired" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_RESEARCHES_COLUMN, Additionboard_HEAD_ROW, "Researches" )
            call SetMultiboardCellValue( ADDBOARD, Additionboard_RESEARCHES_COLUMN, Additionboard_HEAD_ROW2, "done" )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_NAME_COLUMN, Additionboard_HEAD_ROW, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_NAME_COLUMN, Additionboard_HEAD_ROW2, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, Additionboard_HEAD_ROW, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, Additionboard_HEAD_ROW2, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_COINS_COLUMN, Additionboard_HEAD_ROW, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_COINS_COLUMN, Additionboard_HEAD_ROW2, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, Additionboard_HEAD_ROW, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, Additionboard_HEAD_ROW2, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, Additionboard_HEAD_ROW, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, Additionboard_HEAD_ROW2, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_MERCS_COLUMN, Additionboard_HEAD_ROW, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_MERCS_COLUMN, Additionboard_HEAD_ROW2, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_RESEARCHES_COLUMN, Additionboard_HEAD_ROW, 255, 204, 51, 255 )
            call SetMultiboardCellColor( ADDBOARD, Additionboard_RESEARCHES_COLUMN, Additionboard_HEAD_ROW2, 255, 204, 51, 255 )
            loop
                set specificPlayer = PlayerWJ( iteration )
                if ( GetPlayerSlotState( specificPlayer ) == PLAYER_SLOT_STATE_PLAYING ) then
                    set Additionboard_COINS[iteration] = 0
                    set Additionboard_COINS_GOLD[iteration] = 0
                    set Additionboard_GOLD_EARNED[iteration] = 0
                    set Additionboard_ITEMS_PERMANENT[iteration] = 0
                    set Additionboard_ITEMS_CONSUMABLE[iteration] = 0
                    set Additionboard_MERCS[iteration] = 0
                    set Additionboard_RESEARCHES[iteration] = 0
                    set Additionboard_PLAYERS_POSITION[iteration] = count
                    call MultiboardSetRowCount( ADDBOARD, count + 1 )
                    call SetMultiboardCellStyle( ADDBOARD, Additionboard_NAME_COLUMN, count, true, false )
                    call SetMultiboardCellStyle( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, count, true, false )
                    call SetMultiboardCellStyle( ADDBOARD, Additionboard_COINS_COLUMN, count, true, false )
                    call SetMultiboardCellStyle( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, count, true, false )
                    call SetMultiboardCellStyle( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, count, true, false )
                    call SetMultiboardCellStyle( ADDBOARD, Additionboard_MERCS_COLUMN, count, true, false )
                    call SetMultiboardCellStyle( ADDBOARD, Additionboard_RESEARCHES_COLUMN, count, true, false )
                    call SetMultiboardCellValue( ADDBOARD, Additionboard_NAME_COLUMN, count, GetPlayerName( specificPlayer ) )
                    call SetMultiboardCellValue( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, count, I2S(Additionboard_GOLD_EARNED[iteration]) )
                    call SetMultiboardCellValue( ADDBOARD, Additionboard_COINS_COLUMN, count, I2S(Additionboard_COINS[iteration]) + " (" + I2S(Additionboard_COINS_GOLD[iteration]) + ")" )
                    call SetMultiboardCellValue( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, count, I2S(Additionboard_ITEMS_PERMANENT[iteration]) )
                    call SetMultiboardCellValue( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, count, I2S(Additionboard_ITEMS_CONSUMABLE[iteration]) )
                    call SetMultiboardCellValue( ADDBOARD, Additionboard_MERCS_COLUMN, count, I2S(Additionboard_MERCS[iteration]) )
                    call SetMultiboardCellValue( ADDBOARD, Additionboard_RESEARCHES_COLUMN, count, I2S(Additionboard_RESEARCHES[iteration]) )
                    call SetMultiboardCellColor( ADDBOARD, Additionboard_NAME_COLUMN, count, GetPlayerColorRed(specificPlayer), GetPlayerColorGreen(specificPlayer), GetPlayerColorBlue(specificPlayer), 255 )
                    call SetMultiboardCellColor( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, count, 255, 255, 255, 255 )
                    call SetMultiboardCellColor( ADDBOARD, Additionboard_COINS_COLUMN, count, 255, 255, 255, 255 )
                    call SetMultiboardCellColor( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, count, 255, 255, 255, 255 )
                    call SetMultiboardCellColor( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, count, 255, 255, 255, 255 )
                    call SetMultiboardCellColor( ADDBOARD, Additionboard_MERCS_COLUMN, count, 255, 255, 255, 255 )
                    call SetMultiboardCellColor( ADDBOARD, Additionboard_RESEARCHES_COLUMN, count, 255, 255, 255, 255 )
                    set count = count + 1
                else
                    set Additionboard_PLAYERS_POSITION[iteration] = -1
                endif
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            set Additionboard_PLAYERS_POSITION[PLAYER_NEUTRAL_AGGRESSIVE] = -1
            set Additionboard_PLAYERS_POSITION[PLAYER_NEUTRAL_PASSIVE] = -1
            call SetMultiboardColumnWidth( ADDBOARD, Additionboard_NAME_COLUMN, 0.07 )
            call SetMultiboardColumnWidth( ADDBOARD, Additionboard_GOLD_EARNED_COLUMN, 0.04 )
            call SetMultiboardColumnWidth( ADDBOARD, Additionboard_COINS_COLUMN, 0.06 )
            call SetMultiboardColumnWidth( ADDBOARD, Additionboard_ITEMS_PERMANENT_COLUMN, 0.06 )
            call SetMultiboardColumnWidth( ADDBOARD, Additionboard_ITEMS_CONSUMABLE_COLUMN, 0.06 )
            call SetMultiboardColumnWidth( ADDBOARD, Additionboard_MERCS_COLUMN, 0.05 )
            call SetMultiboardColumnWidth( ADDBOARD, Additionboard_RESEARCHES_COLUMN, 0.05 )
            call MultiboardSetTitleText( ADDBOARD, GetTimeString(COUNT) )
            call TimerStart( CreateTimerWJ(), CHECK_INTERVAL, true, function Additionboard_CheckDisplay )
        endfunction
    //! runtextmacro Endscope()

    private function Kill_Conditions takes boolean deathCausedByEnemy, boolean isDyingUnitStructure, integer killingUnitOwnerId returns boolean
        if (deathCausedByEnemy == false) then
            return false
        endif
        if ( isDyingUnitStructure ) then
            return false
        endif
        if ( PLAYERS_POSITION[killingUnitOwnerId] == -1 ) then
            return false
        endif
        return true
    endfunction

    private function Death_Conditions takes integer dyingUnitOwnerId, boolean isDyingUnitStructure returns boolean
        if ( isDyingUnitStructure ) then
            return false
        endif
        if ( PLAYERS_POSITION[dyingUnitOwnerId] == -1 ) then
            return false
        endif
        return true
    endfunction

    public function Death takes boolean deathCausedByEnemy, Unit dyingUnit, Unit killingUnit returns nothing
        local integer amount
        local integer dyingUnitOwnerId = GetPlayerId(dyingUnit.owner)
        local unit dyingUnitSelf = dyingUnit.self
        local boolean isDyingUnitStructure = IsUnitType(dyingUnitSelf, UNIT_TYPE_STRUCTURE)
        local integer killingUnitOwnerId = GetPlayerId(killingUnit.owner)
        local string text
        if ( Death_Conditions( dyingUnitOwnerId, isDyingUnitStructure ) ) then
            if (IsUnitType(dyingUnitSelf, UNIT_TYPE_HERO)) then
                set amount = HERO_DEATHS[dyingUnitOwnerId] + 1
                set HERO_DEATHS[dyingUnitOwnerId] = amount
                call SetMultiboardCellValue( INFOBOARD, DEATHS_COLUMN, PLAYERS_POSITION[dyingUnitOwnerId], I2S(DEATHS[dyingUnitOwnerId]) + " (" + I2S( amount ) + ")" )
            else
                set amount = DEATHS[dyingUnitOwnerId] + 1
                set DEATHS[dyingUnitOwnerId] = amount
                if (HERO_DEATHS[dyingUnitOwnerId] > 0) then
                    set text = I2S(amount) + " (" + I2S( HERO_DEATHS[dyingUnitOwnerId] ) + ")"
                else
                    set text = I2S(amount)
                endif
                call SetMultiboardCellValue( INFOBOARD, DEATHS_COLUMN, PLAYERS_POSITION[dyingUnitOwnerId], text )
            endif
        endif
        if ( Kill_Conditions( deathCausedByEnemy, isDyingUnitStructure, killingUnitOwnerId ) ) then
            if (IsUnitType(dyingUnitSelf, UNIT_TYPE_HERO)) then
                set amount = HERO_KILLS[killingUnitOwnerId] + 1
                set HERO_KILLS[killingUnitOwnerId] = amount
                call SetMultiboardCellValue( INFOBOARD, KILLS_COLUMN, PLAYERS_POSITION[killingUnitOwnerId], I2S(KILLS[killingUnitOwnerId]) + " (" + I2S( amount ) + ")" )
            else
                set amount = KILLS[killingUnitOwnerId] + 1
                set KILLS[killingUnitOwnerId] = amount
                if (HERO_KILLS[killingUnitOwnerId] > 0) then
                    set text = I2S(amount) + " (" + I2S( HERO_KILLS[killingUnitOwnerId] ) + ")"
                else
                    set text = I2S(amount)
                endif
                call SetMultiboardCellValue( INFOBOARD, KILLS_COLUMN, PLAYERS_POSITION[killingUnitOwnerId], text )
            endif
        endif
        set dyingUnitSelf = null
    endfunction

    public function LevelGain takes integer level, Unit whichUnit, player whichUnitOwner returns nothing
        local Data d = GetAttachedIntegerById(whichUnit.id, Infoboard_SCOPE_ID)
        if (d != NULL) then
            call SetMultiboardCellValue( INFOBOARD, d.column, PLAYERS_POSITION[GetPlayerId(whichUnitOwner)], I2S(level) )
        endif
    endfunction

    public function Appearance takes Unit whichUnit, player whichUnitOwner, UnitType whichUnitType returns nothing
        local integer column = -1
        local integer count = GetPlayerHeroCount(whichUnitOwner)
        local Data d
        local integer levelColumn
        local integer row
        if (STARTED == false) then
            return
        endif
        set row = PLAYERS_POSITION[GetPlayerId(whichUnitOwner)]
        if (count == 0) then
            set column = HEROES_COLUMN
            call SetMultiboardCellWidth( INFOBOARD, HEROES_START_GAP, row, HEROES_COLUMN_WIDTH * 4. / 16 - 3 * MULTIBOARD_GAP_WIDTH / 4 )
            call SetMultiboardCellWidth( INFOBOARD, HEROES_LEVEL_COLUMN, row, HEROES_COLUMN_WIDTH * 3. / 16 - 3 * MULTIBOARD_GAP_WIDTH / 4 )
            call SetMultiboardCellWidth( INFOBOARD, HEROES_COLUMN, row, HEROES_COLUMN_WIDTH / 4 - 3 * MULTIBOARD_GAP_WIDTH / 4 )
            call SetMultiboardCellWidth( INFOBOARD, HEROES_END_GAP, row, HEROES_COLUMN_WIDTH * 5. / 16 - 3 * MULTIBOARD_GAP_WIDTH / 4 )
        elseif (count == 1) then
            set column = HEROES2_COLUMN
            call SetMultiboardCellWidth( INFOBOARD, HEROES_START_GAP, row, HEROES_COLUMN_WIDTH / 16 - MULTIBOARD_GAP_WIDTH / 6 )
            call SetMultiboardCellWidth( INFOBOARD, HEROES_LEVEL_COLUMN, row, HEROES_COLUMN_WIDTH * 3. / 16 - MULTIBOARD_GAP_WIDTH / 6 )
            call SetMultiboardCellWidth( INFOBOARD, HEROES_COLUMN, row, HEROES_COLUMN_WIDTH / 4 - MULTIBOARD_GAP_WIDTH / 6 )
            call SetMultiboardCellWidth( INFOBOARD, HEROES2_LEVEL_COLUMN, row, HEROES_COLUMN_WIDTH * 3. / 16 - MULTIBOARD_GAP_WIDTH / 6 )
            call SetMultiboardCellWidth( INFOBOARD, HEROES2_COLUMN, row, HEROES_COLUMN_WIDTH / 4 - MULTIBOARD_GAP_WIDTH / 6 )
            call SetMultiboardCellWidth( INFOBOARD, HEROES_END_GAP, row, HEROES_COLUMN_WIDTH / 16 - MULTIBOARD_GAP_WIDTH / 6 )
        endif
        if (column != -1) then
            set levelColumn = column - 1
            set d = Data.create()
            set d.column = levelColumn
            call AttachIntegerById(whichUnit.id, Infoboard_SCOPE_ID, d)
            call SetMultiboardCellStyle( INFOBOARD, levelColumn, row, true, false )
            call SetMultiboardCellValue( INFOBOARD, levelColumn, row, I2S(GetHeroLevel(whichUnit.self)) )
            call SetMultiboardCellStyle( INFOBOARD, column, row, false, true )
            call SetMultiboardCellIcon( INFOBOARD, column, row, GetUnitTypeImage(whichUnitType) )
        endif
    endfunction

    private function CheckDisplay takes nothing returns nothing
        if (IsMultiboardMinimized(INFOBOARD) and (MULTIBOARD_STAGE == 0)) then
            set MULTIBOARD_MINIMIZED = false
            set MULTIBOARD_STAGE = 1
            call DisplayMultiboard( INFOBOARD, GetLocalPlayer(), false )
            call DisplayMultiboard( ADDBOARD, GetLocalPlayer(), true )
            call MultiboardMinimize(ADDBOARD, false)
        endif
    endfunction

    private function CountTime takes nothing returns nothing
        set COUNT = COUNT + 1
        if ( COUNT >= 86400 ) then
            call DestroyTimerWJ( GetExpiredTimer() )
        endif
        call MultiboardSetTitleText( INFOBOARD, ">> " + GetTimeString(COUNT) + " <<" )
        call MultiboardSetTitleText( ADDBOARD, ">> " + GetTimeString(COUNT) + " <<" )
    endfunction

    public function Start takes nothing returns nothing
        local integer count = 1
        local integer iteration = MAX_PLAYER_INDEX
        local player specificPlayer
        set INFOBOARD = CreateMultiboardWJ()
        set STARTED = true
        call MultiboardSetRowCount( INFOBOARD, 1 )
        call MultiboardSetColumnCount( INFOBOARD, 11 )
        call SetMultiboardCellStyle( INFOBOARD, COLOR_COLUMN, HEAD_ROW, false, false )
        call SetMultiboardCellStyle( INFOBOARD, NAME_COLUMN, HEAD_ROW, true, false )
        call SetMultiboardCellStyle( INFOBOARD, HEROES_START_GAP, HEAD_ROW, false, false )
        call SetMultiboardCellStyle( INFOBOARD, HEROES_LEVEL_COLUMN, HEAD_ROW, false, false )
        call SetMultiboardCellStyle( INFOBOARD, HEROES_COLUMN, HEAD_ROW, true, false )
        call SetMultiboardCellStyle( INFOBOARD, HEROES_MIDDLE_GAP, HEAD_ROW, false, false )
        call SetMultiboardCellStyle( INFOBOARD, HEROES2_LEVEL_COLUMN, HEAD_ROW, false, false )
        call SetMultiboardCellStyle( INFOBOARD, HEROES2_COLUMN, HEAD_ROW, false, false )
        call SetMultiboardCellStyle( INFOBOARD, HEROES_END_GAP, HEAD_ROW, false, false )
        call SetMultiboardCellStyle( INFOBOARD, KILLS_COLUMN, HEAD_ROW, true, false )
        call SetMultiboardCellStyle( INFOBOARD, DEATHS_COLUMN, HEAD_ROW, true, false )
        call SetMultiboardCellValue( INFOBOARD, NAME_COLUMN, HEAD_ROW, "Player name" )
        call SetMultiboardCellValue( INFOBOARD, HEROES_COLUMN, HEAD_ROW, "Heroes" )
        call SetMultiboardCellValue( INFOBOARD, KILLS_COLUMN, HEAD_ROW, "Kills" )
        call SetMultiboardCellValue( INFOBOARD, DEATHS_COLUMN, HEAD_ROW, "Deaths" )
        call SetMultiboardCellColor( INFOBOARD, NAME_COLUMN, HEAD_ROW, 255, 204, 51, 255 )
        call SetMultiboardCellColor( INFOBOARD, HEROES_COLUMN, HEAD_ROW, 255, 204, 51, 255 )
        call SetMultiboardCellColor( INFOBOARD, KILLS_COLUMN, HEAD_ROW, 255, 204, 51, 255 )
        call SetMultiboardCellColor( INFOBOARD, DEATHS_COLUMN, HEAD_ROW, 255, 204, 51, 255 )
        loop
            set specificPlayer = PlayerWJ( iteration )
            if ( GetPlayerSlotState( specificPlayer ) == PLAYER_SLOT_STATE_PLAYING ) then
                set DEATHS[iteration] = 0
                set HERO_DEATHS[iteration] = 0
                set HERO_KILLS[iteration] = 0
                set KILLS[iteration] = 0
                set PLAYERS_POSITION[iteration] = count
                call MultiboardSetRowCount( INFOBOARD, count + 1 )
                call SetMultiboardCellStyle( INFOBOARD, COLOR_COLUMN, count, false, true )
                call SetMultiboardCellStyle( INFOBOARD, NAME_COLUMN, count, true, false )
                call SetMultiboardCellStyle( INFOBOARD, HEROES_START_GAP, count, false, false )
                call SetMultiboardCellStyle( INFOBOARD, HEROES_LEVEL_COLUMN, count, false, false )
                call SetMultiboardCellStyle( INFOBOARD, HEROES_COLUMN, count, false, false )
                call SetMultiboardCellStyle( INFOBOARD, HEROES_MIDDLE_GAP, count, false, false )
                call SetMultiboardCellStyle( INFOBOARD, HEROES2_LEVEL_COLUMN, count, false, false )
                call SetMultiboardCellStyle( INFOBOARD, HEROES2_COLUMN, count, false, false )
                call SetMultiboardCellStyle( INFOBOARD, HEROES_END_GAP, count, false, false )
                call SetMultiboardCellStyle( INFOBOARD, KILLS_COLUMN, count, true, false )
                call SetMultiboardCellStyle( INFOBOARD, DEATHS_COLUMN, count, true, false )
                call SetMultiboardCellIcon( INFOBOARD, COLOR_COLUMN, count, GetPlayerColorImage(specificPlayer) )
                call SetMultiboardCellValue( INFOBOARD, NAME_COLUMN, count, GetPlayerName( specificPlayer ) )
                call SetMultiboardCellValue( INFOBOARD, KILLS_COLUMN, count, I2S(KILLS[iteration]) )
                call SetMultiboardCellValue( INFOBOARD, DEATHS_COLUMN, count, I2S(DEATHS[iteration]) )
                call SetMultiboardCellColor( INFOBOARD, NAME_COLUMN, count, GetPlayerColorRed(specificPlayer), GetPlayerColorGreen(specificPlayer), GetPlayerColorBlue(specificPlayer), 255 )
                call SetMultiboardCellColor( INFOBOARD, KILLS_COLUMN, count, 255, 255, 255, 255 )
                call SetMultiboardCellColor( INFOBOARD, DEATHS_COLUMN, count, 255, 255, 255, 255 )
                set count = count + 1
            else
                set PLAYERS_POSITION[iteration] = -1
            endif
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set MULTIBOARD_MINIMIZED = true
        set MULTIBOARD_STAGE = 1
        set PLAYERS_POSITION[PLAYER_NEUTRAL_AGGRESSIVE] = -1
        set PLAYERS_POSITION[PLAYER_NEUTRAL_PASSIVE] = -1
        call SetMultiboardColumnWidth( INFOBOARD, COLOR_COLUMN, 0.02 )
        call SetMultiboardColumnWidth( INFOBOARD, NAME_COLUMN, 0.07 )
        call SetMultiboardColumnWidth( INFOBOARD, HEROES_START_GAP, MULTIBOARD_GAP_WIDTH )
        call SetMultiboardColumnWidth( INFOBOARD, HEROES_COLUMN, HEROES_COLUMN_WIDTH - 6 * MULTIBOARD_GAP_WIDTH )
        call SetMultiboardColumnWidth( INFOBOARD, HEROES_LEVEL_COLUMN, MULTIBOARD_GAP_WIDTH )
        call SetMultiboardColumnWidth( INFOBOARD, HEROES_MIDDLE_GAP, MULTIBOARD_GAP_WIDTH )
        call SetMultiboardColumnWidth( INFOBOARD, HEROES2_COLUMN, MULTIBOARD_GAP_WIDTH )
        call SetMultiboardColumnWidth( INFOBOARD, HEROES2_LEVEL_COLUMN, MULTIBOARD_GAP_WIDTH )
        call SetMultiboardColumnWidth( INFOBOARD, HEROES_END_GAP, MULTIBOARD_GAP_WIDTH )
        call SetMultiboardColumnWidth( INFOBOARD, KILLS_COLUMN, 0.04 )
        call SetMultiboardColumnWidth( INFOBOARD, DEATHS_COLUMN, 0.04 )
        call MultiboardSetTitleText( INFOBOARD, GetTimeString(COUNT) )
        call DisplayMultiboard( INFOBOARD, GetLocalPlayer(), true )
        call TimerStart( CreateTimerWJ(), 1, true, function CountTime )
        call TimerStart( CreateTimerWJ(), CHECK_INTERVAL, true, function CheckDisplay )
        call Additionboard_Additionboard_Start()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Infoboard.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Infocard.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Infocard")
    public function Start takes nothing returns nothing
        local quest newQuest
        local string s
        
        set newQuest = CreateQuestWJ()
        
        call QuestSetDescription( newQuest, "-c: show camera dialog (-c value)\n\n-cs x: set camera smoothing factor to x (standard x=1.20)\n\n-m x: change background music to x\n(values for x: arthas, bloodelf, comrade, confrontation, credits, darka, darkv, doom, elf1, elf2, elf3, elfd, elfv, elfx, heroic, human1, human2, human3, humand, humanv, humanx, illidan, orc, orc1, orc2, orc3, orcd, orcv, orcx, lich, main, mistery, naga, pursuit, tension, undead1, undead2, undead3, undeadd, undeadv, undeadx, war2, war3)\n\n-hints: toggle hints on/off\n\n-sfx: future special effects on/off" )
        call QuestSetIconPath( newQuest, "ReplaceableTextures\\CommandButtons\\BTNUnsummonBuilding.blp" )
        call QuestSetRequired( newQuest, true )
        call QuestSetTitle( newQuest, "Commands" )

        set newQuest = CreateQuestWJ()
        
        set s = "Development:\nWaterKnight"
        
        set s = s + "\n\n"
        
        set s = s + "Ideas:\nanXieTy\nDojo\nThe-Red-OrK\nWaterKnight"
        
        set s = s + "\n\n"
        
        set s = s + "Testers:\nDojo\nThe-Red-OrK\nFrotty"
        
        set s = s + "\n\n"
        
        set s = s + "Imported material:\nRegeneration graphics (original \"BasicEarthFlash\" and \"BasicWaterFlash\", slightly modified by me) - JetFangInferno\nSales aura caster graphic (original \"Capitalism Aura\") - General Frank\nWhip sound: http://ftp.tux.org/pub/X-Windows/games/freeciv/incoming/sounds/whip.wav\nRest from Blizzard (partly reworked by me)"
        
        set s = s + "\n\n"
        
        set s = s + "optimized by Wc3Optimizer and Widgetizer (except editor version)"
        
        set s = s + "\n\n"
        
        set s = s + "Project thread: http://warcraft.ingame.de/forum/showthread.php?s=&threadid=143691"
        
        call QuestSetDescription( newQuest, s )
        call QuestSetIconPath( newQuest, "ReplaceableTextures\\CommandButtons\\BTNStormEarth&Fire.blp" )
        call QuestSetRequired( newQuest, false )
        call QuestSetTitle( newQuest, "Credits" )
        set newQuest = null
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Infocard.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Music.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Music")
    public function Chat takes string chatMessage, player whichPlayer returns nothing
        local string fileName
        set chatMessage = StringCase( chatMessage, false )
        if ( SubString( chatMessage, 0, 3 ) == "-m " ) then
            if ( GetLocalPlayer() == whichPlayer ) then
                set fileName = GetSavedString( SCOPE_PREFIX, SubString( chatMessage, 3, StringLength( chatMessage ) ) )
                if ( fileName != null ) then
                    call DisplayTextTimedWJ("|cff00ff00Now playing " + fileName + "|r.", HINT_TEXT_DURATION, whichPlayer)
                    call PlayMusic( fileName )
                endif
            endif
        endif
    endfunction

    public function InitTitle takes string key, string title returns nothing
        call SaveStringWJ(SCOPE_PREFIX, key, title)
    endfunction

    public function Init takes nothing returns nothing
        call InitTitle( "arthas", "Sound\\Music\\mp3Music\\ArthasTheme.mp3" )
        call InitTitle( "bloodelf", "Sound\\Music\\mp3Music\\BloodElfTheme.mp3" )
        call InitTitle( "comrade", "Sound\\Music\\mp3Music\\Comradeship.mp3" )
        call InitTitle( "confrontation", "Sound\\Music\\mp3Music\\TragicConfrontation.mp3" )
        call InitTitle( "credits", "Sound\\Music\\mp3Music\\Credits.mp3" )
        call InitTitle( "darka", "Sound\\Music\\mp3Music\\DarkAgents.mp3" )
        call InitTitle( "darkv", "Sound\\Music\\mp3Music\\DarkVictory.mp3" )
        call InitTitle( "doom", "Sound\\Music\\mp3Music\\Doom.mp3" )
        call InitTitle( "elf1", "Sound\\Music\\mp3Music\\NightElf1.mp3" )
        call InitTitle( "elf2", "Sound\\Music\\mp3Music\\NightElf2.mp3" )
        call InitTitle( "elf3", "Sound\\Music\\mp3Music\\NightElf3.mp3" )
        call InitTitle( "elfd", "Sound\\Music\\mp3Music\\NightElfDefeat.mp3" )
        call InitTitle( "elfv", "Sound\\Music\\mp3Music\\NightElfVictory.mp3" )
        call InitTitle( "elfx", "Sound\\Music\\mp3Music\\NightElfX1.mp3" )
        call InitTitle( "heroic", "Sound\\Music\\mp3Music\\HeroicVictory.mp3" )
        call InitTitle( "human1", "Sound\\Music\\mp3Music\\Human1.mp3" )
        call InitTitle( "human2", "Sound\\Music\\mp3Music\\Human2.mp3" )
        call InitTitle( "human3", "Sound\\Music\\mp3Music\\Human3.mp3" )
        call InitTitle( "humand", "Sound\\Music\\mp3Music\\HumanDefeat.mp3" )
        call InitTitle( "humanv", "Sound\\Music\\mp3Music\\HumanVictory.mp3" )
        call InitTitle( "humanx", "Sound\\Music\\mp3Music\\HumanX1.mp3" )
        call InitTitle( "illidan", "Sound\\Music\\mp3Music\\IllidansTheme.mp3" )
        call InitTitle( "orc", "Sound\\Music\\mp3Music\\OrcTheme.mp3" )
        call InitTitle( "orc1", "Sound\\Music\\mp3Music\\Orc1.mp3" )
        call InitTitle( "orc2", "Sound\\Music\\mp3Music\\Orc2.mp3" )
        call InitTitle( "orc3", "Sound\\Music\\mp3Music\\Orc3.mp3" )
        call InitTitle( "orcd", "Sound\\Music\\mp3Music\\OrcDefeat.mp3" )
        call InitTitle( "orcv", "Sound\\Music\\mp3Music\\OrcVictory.mp3" )
        call InitTitle( "orcx", "Sound\\Music\\mp3Music\\OrcX1.mp3" )
        call InitTitle( "lich", "Sound\\Music\\mp3Music\\LichKingTheme.mp3" )
        call InitTitle( "main", "Sound\\Music\\mp3Music\\Mainscreen.mp3" )
        call InitTitle( "mistery", "Sound\\Music\\mp3Music\\SadMistery.mp3" )
        call InitTitle( "naga", "Sound\\Music\\mp3Music\\NagaTheme.mp3" )
        call InitTitle( "pursuit", "Sound\\Music\\mp3Music\\PursuitTheme.mp3" )
        call InitTitle( "tension", "Sound\\Music\\mp3Music\\Tension.mp3" )
        call InitTitle( "undead1", "Sound\\Music\\mp3Music\\Undead1.mp3" )
        call InitTitle( "undead2", "Sound\\Music\\mp3Music\\Undead2.mp3" )
        call InitTitle( "undead3", "Sound\\Music\\mp3Music\\Undead3.mp3" )
        call InitTitle( "undeadd", "Sound\\Music\\mp3Music\\UndeadDefeat.mp3" )
        call InitTitle( "undeadv", "Sound\\Music\\mp3Music\\UndeadVictory.mp3" )
        call InitTitle( "undeadx", "Sound\\Music\\mp3Music\\UndeadX1.mp3" )
        call InitTitle( "war2", "Sound\\Music\\mp3Music\\War2IntroMusic.mp3" )
        call InitTitle( "war3x", "Sound\\Music\\mp3Music\\War3XMainScreen.mp3" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Music.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Regeneration.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Regeneration")
    globals
        private group ENUM_GROUP
        private timer REFRESH_TIMER
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        if ( GetUnitState( GetFilterUnit(), UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        return true
    endfunction

    public function Refresh takes nothing returns nothing
        local Unit enumUnit
        local unit enumUnitSelf
        local real timeOut = TimerGetTimeout(REFRESH_TIMER)
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if (enumUnitSelf != null) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call AddUnitState( enumUnitSelf, UNIT_STATE_LIFE, (GetUnitLifeRegeneration( enumUnit ) + GetUnitLifeRegenerationBonus( enumUnit )) * timeOut )
                call AddUnitState( enumUnitSelf, UNIT_STATE_MANA, (GetUnitManaRegeneration( enumUnit ) + GetUnitManaRegenerationBonus( enumUnit )) * timeOut )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        call TimerStart( REFRESH_TIMER, REGENERATION_INTERVAL * GetRandomReal(0.1, 0.3), false, function Refresh )
    endfunction

    public function Start takes nothing returns nothing
        call TimerStart( REFRESH_TIMER, REGENERATION_INTERVAL, false, function Refresh )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set REFRESH_TIMER = CreateTimerWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Regeneration.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\Shop.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Shop")
    //! runtextmacro Scope("ItemSupply")
        private struct ItemSupply_Data
            integer count
            integer array whichItemTypes[12]
        endstruct

        //! runtextmacro Scope("Refresh")
            public struct Refresh_Data
                integer amount
                timer intervalTimer
                Unit shop
                ItemType whichItemType
            endstruct

            public function Refresh_CountShopDatas takes integer shopId returns integer
                return CountIntegersInTableById(shopId, Refresh_SCOPE_ID)
            endfunction

            public function Refresh_GetShopDatas takes integer shopId, integer index returns Refresh_Data
                return GetIntegerFromTableById(shopId, Refresh_SCOPE_ID, index)
            endfunction

            private function Refresh_Interval takes nothing returns nothing
                local timer intervalTimer = GetExpiredTimer()
                local Refresh_Data d = GetAttachedInteger(intervalTimer, Refresh_SCOPE_ID)
                local integer amount = d.amount + 1
                local ItemType whichItemType = d.whichItemType
                set d.amount = amount
                call AddUnitSoldItemTypeId( d.shop.self, whichItemType.id, amount )
                if ( amount < GetItemTypeMaxCharges( whichItemType ) ) then
                    call TimerStart( intervalTimer, GetItemTypeRefreshInterval(whichItemType), false, function Refresh_Interval )
                endif
                set intervalTimer = null
            endfunction

            private function Refresh_Refresh takes nothing returns nothing
                local timer intervalTimer = GetExpiredTimer()
                local Refresh_Data d = GetAttachedInteger(intervalTimer, Refresh_SCOPE_ID)
                set intervalTimer = null
                call AddUnitSoldItemTypeId( d.shop.self, d.whichItemType.id, d.amount )
            endfunction

            public function Refresh_ItemSell takes Unit shop, ItemType soldItemType, boolean success returns nothing
                local integer amount
                local integer amount2
                local Refresh_Data d
                local Refresh_Data e
                local integer shopId = shop.id
                local integer iteration = CountIntegersInTableById(shopId, Refresh_SCOPE_ID)
                local unit shopSelf = shop.self
                local ItemType specificItemType
                loop
                    set d = GetIntegerFromTableById(shopId, Refresh_SCOPE_ID, iteration)
                    set amount = d.amount
                    set specificItemType = d.whichItemType
                    if (specificItemType == soldItemType) then
                        set e = d
                        if (success) then
                            set amount2 = amount
                            set d.amount = amount2 - 1
                            call AddUnitSoldItemTypeId( shopSelf, soldItemType.id, amount )
                        else
                            //if (GetItemTypeSet(soldItemType.id) == NULL) then
                                //call AddUnitSoldItemTypeIdEx( shopSelf, soldItemType.id, amount + 1, amount + 1 )
                            //else
                                call AddUnitSoldItemTypeId( shopSelf, soldItemType.id, amount + 1 )
                            //endif
                        endif
                    else
                        call AddUnitSoldItemTypeId( shopSelf, specificItemType.id, amount )
                    endif
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
                if (success) then
            //        if ( sellingUnitOwner == NEUTRAL_PASSIVE_PLAYER ) then
                        //call AddUnitSoldItemTypeId( shopSelf, soldItemTypeId, amount2 + 1 )
            //        endif
                    if ( amount2 == GetItemTypeMaxCharges(soldItemType) ) then
                        call TimerStart( e.intervalTimer, GetItemTypeRefreshInterval(soldItemType), false, function Refresh_Interval )
                    endif
                else
                    call TimerStart(e.intervalTimer, GetItemTypeRefreshInterval(soldItemType), false, function Refresh_Refresh)
                    //call AddUnitSoldItemTypeId( shopSelf, soldItemType.id, amount2 )
                endif
                set shopSelf = null
            endfunction

            public function Refresh_Start takes Unit shop, integer whichItemTypeId returns nothing
                local Refresh_Data d = Refresh_Data.create()
                local timer intervalTimer = CreateTimerWJ()
                local ItemType whichItemType = GetItemTypeWJ(whichItemTypeId)
                set d.amount = 0
                set d.intervalTimer = intervalTimer
                set d.shop = shop
                set d.whichItemType = whichItemType
                call AttachInteger( intervalTimer, Refresh_SCOPE_ID, d )
                call AddIntegerToTableById( shop.id, Refresh_SCOPE_ID, d )
                call AddUnitSoldItemTypeId( shop.self, whichItemTypeId, 0 )
                call TimerStart( intervalTimer, GetItemTypeRefreshInterval(whichItemType), false, function Refresh_Interval )
                set intervalTimer = null
            endfunction
        //! runtextmacro Endscope()

        public function ItemSupply_Start takes Unit shop, integer shopTypeId returns nothing
            local ItemSupply_Data d = GetAttachedIntegerById( shopTypeId, ItemSupply_SCOPE_ID )
            local integer iteration
            local unit shopSelf
            local integer specificItemTypeId
            if (d != NULL) then
                set iteration = d.count
                set shopSelf = shop.self
                call UnitAddAbility( shopSelf, SELL_ITEMS_SPELL_ID )
                call UnitAddAbility( shopSelf, SELL_UNITS_SPELL_ID )
                set shopSelf = null
                loop
                    call Refresh_Refresh_Start(shop, d.whichItemTypes[iteration])
                    set iteration = iteration - 1
                    exitwhen ( iteration < 0 )
                endloop
            endif
        endfunction

        function AddShopItemSupply takes UnitType shopType, integer whichItemTypeId returns nothing
            local integer count
            local integer shopTypeId = shopType.id
            local ItemSupply_Data d = GetAttachedIntegerById(shopTypeId, ItemSupply_SCOPE_ID)
            if (d == NULL) then
                set count = 0
                set d = ItemSupply_Data.create()
                set d.count = 0
                call AttachIntegerById(shopTypeId, ItemSupply_SCOPE_ID, d)
            else
                set count = d.count + 1
                set d.count = count
            endif
            set d.whichItemTypes[count] = whichItemTypeId
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("UnitSupply")
        private struct UnitSupply_Data
            integer count
            integer array whichUnitTypes[12]
        endstruct

        //! runtextmacro Scope("Refresh")
            public struct Refresh_Data
                integer amount
                timer intervalTimer
                Unit shop
                UnitType whichUnitType
            endstruct

            public function Refresh_CountShopDatas takes integer shopId returns integer
                return CountIntegersInTableById(shopId, Refresh_SCOPE_ID)
            endfunction

            public function Refresh_GetShopDatas takes integer shopId, integer index returns Refresh_Data
                return GetIntegerFromTableById(shopId, Refresh_SCOPE_ID, index)
            endfunction

            private function Refresh_Interval takes nothing returns nothing
                local timer intervalTimer = GetExpiredTimer()
                local Refresh_Data d = GetAttachedInteger(intervalTimer, Refresh_SCOPE_ID)
                local integer amount = d.amount + 1
                local UnitType whichUnitType = d.whichUnitType
                set d.amount = amount
                call AddUnitSoldUnitTypeId( d.shop.self, whichUnitType.id, amount )
                if ( amount < GetUnitTypeShopMaxCharges( whichUnitType ) ) then
                    call TimerStart( intervalTimer, GetUnitTypeShopRefreshInterval(whichUnitType), false, function Refresh_Interval )
                endif
                set intervalTimer = null
            endfunction

            public function Refresh_UnitSell takes Unit shop, UnitType soldUnitType, boolean success returns nothing
                local integer amount
                local Refresh_Data d
                local integer shopId = shop.id
                local integer supplyCount = CountIntegersInTableById(shopId, Refresh_SCOPE_ID)
                local integer iteration = supplyCount
                loop
                    set d = GetIntegerFromTableById(shopId, Refresh_SCOPE_ID, iteration)
                    exitwhen ( d.whichUnitType == soldUnitType )
                    set iteration = iteration - 1
                endloop
                set amount = d.amount
                if (success) then
                    set d.amount = amount - 1
                    if ( amount == GetUnitTypeShopMaxCharges(soldUnitType) ) then
                        call TimerStart( d.intervalTimer, GetUnitTypeShopRefreshInterval(soldUnitType), false, function Refresh_Interval )
                    endif
                else
                    set iteration = supplyCount
                    loop
                        set d = GetIntegerFromTableById(shopId, Refresh_SCOPE_ID, iteration)
                        call AddUnitSoldUnitTypeId( shop.self, soldUnitType.id, amount )
                        set iteration = iteration - 1
                        exitwhen ( iteration < 0 )
                    endloop
                endif
            endfunction

            public function Refresh_Start takes Unit shop, integer whichUnitTypeId returns nothing
                local Refresh_Data d = Refresh_Data.create()
                local timer intervalTimer = CreateTimerWJ()
                local UnitType whichUnitType = GetUnitType(whichUnitTypeId)
                set d.amount = 0
                set d.intervalTimer = intervalTimer
                set d.shop = shop
                set d.whichUnitType = whichUnitType
                call AttachInteger( intervalTimer, Refresh_SCOPE_ID, d )
                call AddIntegerToTableById( shop.id, Refresh_SCOPE_ID, d )
                call AddUnitSoldUnitTypeId( shop.self, whichUnitTypeId, 0 )
                call TimerStart( intervalTimer, GetUnitTypeShopRefreshInterval(whichUnitType), false, function Refresh_Interval )
                set intervalTimer = null
            endfunction
        //! runtextmacro Endscope()

        public function UnitSupply_Start takes Unit shop, integer shopTypeId returns nothing
            local UnitSupply_Data d = GetAttachedIntegerById( shopTypeId, UnitSupply_SCOPE_ID )
            local integer iteration
            local integer specificUnitTypeId
            if (d != NULL) then
                set iteration = d.count
                call UnitAddAbility( shop.self, SELL_UNITS_SPELL_ID )
                loop
                    call Refresh_Refresh_Start(shop, d.whichUnitTypes[iteration])
                    set iteration = iteration - 1
                    exitwhen ( iteration < 0 )
                endloop
            endif
        endfunction

        function AddShopUnitSupply takes UnitType shopType, integer whichUnitTypeId returns nothing
            local integer count
            local integer shopTypeId = shopType.id
            local UnitSupply_Data d = GetAttachedIntegerById(shopTypeId, UnitSupply_SCOPE_ID)
            if (d == NULL) then
                set count = 0
                set d = UnitSupply_Data.create()
                set d.count = 0
                call AttachIntegerById(shopTypeId, UnitSupply_SCOPE_ID, d)
            else
                set count = d.count + 1
                set d.count = count
            endif
            set d.whichUnitTypes[count] = whichUnitTypeId
        endfunction
    //! runtextmacro Endscope()

    public function FormChange takes Unit shop, integer shopTypeId returns nothing
        call ItemSupply_ItemSupply_Start(shop, shopTypeId)
        call UnitSupply_UnitSupply_Start(shop, shopTypeId)
    endfunction

    public function Appearance takes Unit shop, integer shopTypeId returns nothing
        call ItemSupply_ItemSupply_Start(shop, shopTypeId)
        call UnitSupply_UnitSupply_Start(shop, shopTypeId)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\Shop.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\ShopInformation.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("ShopInformation")
    globals
        public constant integer ITEM_ID = 'I01P'
        public constant integer UNIT_ID = 'n02X'
    endglobals

    private function Start takes Unit shop, player whichPlayer, boolean fromItem returns nothing
        local string colorString
        local Shop_ItemSupply_Refresh_Refresh_Data d
        local Shop_UnitSupply_Refresh_Refresh_Data e
        local timer intervalTimer
        local boolean isSet
        local string name
        local integer shopId = shop.id
        local integer iteration = Shop_ItemSupply_Refresh_Refresh_CountShopDatas(shopId)
        local integer specificObjectTypeId
        local boolean uneven
        if ( iteration - 1 * B2I(fromItem) > TABLE_EMPTY ) then
            call DisplayTextTimedWJ( ColorStrings_GOLD + "==============================" + ColorStrings_RESET, 15, whichPlayer )
            loop
                set d = Shop_ItemSupply_Refresh_Refresh_GetShopDatas(shopId, iteration)
                set specificObjectTypeId = d.whichItemType.id
                set isSet = (GetItemTypeSet(specificObjectTypeId) != NULL)
                set name = GetObjectName( specificObjectTypeId )
                set uneven = (iteration / 2 != iteration / 2.)
                if (specificObjectTypeId != ShopInformation_ITEM_ID) then
                    set intervalTimer = d.intervalTimer
                    if ( uneven ) then
                        set colorString = ColorStrings_FOOTY_DARK
                    else
                        set colorString = ColorStrings_FOOTY_LIGHT
                    endif
                    call DisplayTextTimedWJ( StringIfElse(StringIfElse(ColorStrings_SET_DARK, ColorStrings_SET_LIGHT, uneven), colorString, isSet) + SubString(name, B2I(isSet) * (ColorStrings_START_LENGTH + ColorStrings_BODY_LENGTH), StringLength(name)) + StringIf(StringIfElse(ColorStrings_SET_DARK, ColorStrings_SET_LIGHT, uneven), isSet) + " --> " + I2S( R2I( TimerGetElapsed( intervalTimer ) ) ) + " / " + I2S( R2I( TimerGetTimeout( intervalTimer ) ) ) + " seconds" + ColorStrings_RESET, 15, whichPlayer )
                endif
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
            call DisplayTextTimedWJ( ColorStrings_GOLD + "==============================" + ColorStrings_RESET, 15, whichPlayer )
        endif
        set iteration = Shop_UnitSupply_Refresh_Refresh_CountShopDatas(shopId)
        if ( iteration - 1 * B2I(fromItem == false) > TABLE_EMPTY ) then
            call DisplayTextTimedWJ( ColorStrings_GOLD + "==============================" + ColorStrings_RESET, 15, whichPlayer )
            loop
                set e = Shop_UnitSupply_Refresh_Refresh_GetShopDatas(shopId, iteration)
                set specificObjectTypeId = e.whichUnitType.id
                if (specificObjectTypeId != ShopInformation_UNIT_ID) then
                    set intervalTimer = e.intervalTimer
                    if ( iteration / 2 != iteration / 2. ) then
                        set colorString = ColorStrings_FOOTY_DARK
                    else
                        set colorString = ColorStrings_FOOTY_LIGHT
                    endif
                    call DisplayTextTimedWJ( colorString + GetObjectName( specificObjectTypeId ) + " --> " + I2S( R2I( TimerGetElapsed( intervalTimer ) ) ) + " / " + I2S( R2I( TimerGetTimeout( intervalTimer ) ) ) + " seconds" + ColorStrings_RESET, 15, whichPlayer )
                endif
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
            call DisplayTextTimedWJ( ColorStrings_GOLD + "==============================" + ColorStrings_RESET, 15, whichPlayer )
        endif
        set intervalTimer = null
    endfunction

    public function SellItemExecute takes Unit shop, Item soldItem, player whichPlayer returns nothing
        call RemoveItemEx(soldItem)
        call Start(shop, whichPlayer, true)
    endfunction

    public function SellUnitExecute takes Unit shop, unit soldUnit, player whichPlayer returns nothing
        call RemoveUnitWJ( soldUnit )
        call Start(shop, whichPlayer, false)
    endfunction

    public function Init takes nothing returns nothing
        local ItemType d = InitItemTypeEx(ITEM_ID)
        call SetItemTypeMaxCharges(d, 1)
        call SetItemTypeRefreshInterval(d, 1)
        call SetItemTypeRefreshIntervalStart(d, 0)

        call InitUnitType( UNIT_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\ShopInformation.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\SpawnInformation.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("SpawnInformation")
    globals
        private constant real TIME = 10.
    endglobals

    public function Chat takes string chatMessage, player whichPlayer returns nothing
        local integer spawnsAmount
        local real spawnTimeBasic
        local real spawnTimeIncrementRelative
        local integer SpawnTimer
        local integer SpawnUnitTypeId
        set chatMessage = StringCase( chatMessage, false )
        if ( chatMessage == "-si" ) then
            set SpawnTimer = GetAttachedInteger( TriggerPlayer, "SpawnTimer" )
            set SpawnUnitTypeId = GetAttachedInteger( SpawnTimer, "UnitTypeId" )
            if ( spawnUnitTypeId == null ) then
                call DisplayTextTimedWJ( "You do not train units at the moment.", TIME, whichPlayer )
            else
                set spawnsAmount = GetAttachedInteger( TriggerPlayer, "SpawnsAmount" )
                set spawnTimeBasic = GetAttachedReal( SpawnUnitTypeId, "SpawnTime" ) + GetAttachedReal( TriggerPlayer, "SpawnTime" + I2S( SpawnUnitTypeId ) )
                set spawnTimeIncrementRelative = spawnsAmount * Spawn_TIME_FACTOR
                call DisplayTextTimedToPlayer( "Currently, you form units of the type " + ColorStrings_GOLD + GetObjectName( spawnUnitTypeId ) + ColorStrings_RESET + " with a spawning time of " + ColorStrings_GOLD + R2S( spawnTimeBasic * ( 1 + spawnTimeIncrementRelative ) ) + ColorStrings_RESET + " (exclusive 'Advanced Training').\nThat value lies " + ColorStrings_GOLD + I2S( R2I( RoundTo( spawnTimeIncrementRelative * 100, 1 ) ) ) + ColorStrings_RESET + " percent over the basic level (" + ColorStrings_GOLD + R2S( spawnTimeBasic ) + ColorStrings_RESET + " (inclusive 'Mass Production' if researched)) since you command " + ColorStrings_GOLD + I2S( spawnsAmount ) + ColorStrings_RESET + " spawn unit(s).", TIME, triggerPlayer )
            endif
        endif
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\SpawnInformation.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\SpecialDrops.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("SpecialDrops")
    globals
        public constant real DURATION = 30.
    endglobals

    private struct Data
        timer durationTimer
        Item whichItem
    endstruct

    private function Ending takes Data d, Item whichItem returns nothing
        local timer durationTimer = d.durationTimer
        call d.destroy()
        call FlushAttachedInteger( durationTimer, SpecialDrops_SCOPE_ID )
        call FlushAttachedIntegerById( whichItem.id, SpecialDrops_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
    endfunction

    public function Item_Death takes Item whichItem returns nothing
        local Data d = GetAttachedIntegerById( whichItem.id, SpecialDrops_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( d, whichItem )
        endif
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, SpecialDrops_SCOPE_ID)
        call KillItem( d.whichItem.self )
    endfunction

    public function PickUp takes Item whichItem returns nothing
        local Data d = GetAttachedIntegerById( whichItem.id, SpecialDrops_SCOPE_ID )
        call Ending( d, whichItem )
    endfunction

    public function Start takes Item whichItem returns nothing
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        set d.durationTimer = durationTimer
        set d.whichItem = whichItem
        call AttachInteger( durationTimer, SpecialDrops_SCOPE_ID, d )
        call AttachIntegerById( whichItem.id, SpecialDrops_SCOPE_ID, d )
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    public function Source_Death takes boolean deathCausedByEnemy, boolean isDyingUnitStructure, real dyingUnitX, real dyingUnitY returns nothing
        local integer newItemTypeId
        local integer random
        if ( ( deathCausedByEnemy ) and ( isDyingUnitStructure == false ) ) then
            set random = GetRandomInt( 0, 9 )
            if ( random == 0 ) then
                set random = GetRandomInt( 0, 1 )
                if ( random == 0 ) then
                    set newItemTypeId = Runes_RUNES[GetRandomInt(0, Runes_RUNES_COUNT)]
                else
                    set newItemTypeId = GoldCoin_ITEM_ID
                endif
                call Start( CreateItemEx( newItemTypeId, dyingUnitX, dyingUnitY ) )
            endif
        endif
    endfunction

    public function Drop takes Item whichItem returns nothing
        call Start( whichItem )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\SpecialDrops.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\SpecialEffects.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("SpecialEffects")
    public function Chat takes string chatMessage, player whichPlayer returns nothing
        set chatMessage = StringCase( chatMessage, false )
        if ( chatMessage == "-sfx" ) then
            if ( IsPlayerInForce( whichPlayer, Effect_SHIP ) ) then
                call DisplayTextTimedWJ("|cff00ff00Effect creation is enabled again.|r", HINT_TEXT_DURATION, whichPlayer)
                call ForceRemovePlayer( Effect_SHIP, whichPlayer )
            else
                call DisplayTextTimedWJ("|cffff0000No more coded effects are created for you.|r", HINT_TEXT_DURATION, whichPlayer)
                call ForceAddPlayer( Effect_SHIP, whichPlayer )
            endif
        endif
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\SpecialEffects.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\System.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("System")
    globals
        public force SHIP
    endglobals

    public function Chat takes string chatMessage, player whichPlayer returns nothing
        set chatMessage = StringCase( chatMessage, false )
        if ( chatMessage == "-system" ) then
            if ( IsPlayerInForce( whichPlayer, SHIP ) ) then
                call DisplayTextTimedWJ("|cffff0000You are no longer displayed debug messages.|r", HINT_TEXT_DURATION, whichPlayer)
                call ForceRemovePlayer( SHIP, whichPlayer )
            else
                call DisplayTextTimedWJ("|cff00ff00You are now displayed debug messages.|r", HINT_TEXT_DURATION, whichPlayer)
                call ForceAddPlayer( SHIP, whichPlayer )
            endif
        endif
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        set SHIP = CreateForceWJ()
        loop
            exitwhen (GetPlayerName(PlayerWJ(iteration)) == "WaterKnight")
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        if (iteration > -1) then
            call ForceAddPlayer( SHIP, PlayerWJ(iteration) )
        endif
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\System.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\TimeOfDay.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("TimeOfDay")
    globals
        private constant integer DAWN_EFFECT_WEATHER_EFFECT_TYPE_ID = 'LRma'
        private constant integer DUSK_EFFECT_WEATHER_EFFECT_TYPE_ID = 'LRaa'
        private weathereffect EFFECT_WEATHER_EFFECT
    endglobals

    public function Dusk takes nothing returns nothing
        call RemoveWeatherEffectWJ( EFFECT_WEATHER_EFFECT )
        set EFFECT_WEATHER_EFFECT = AddWeatherEffectWJ( PLAY_RECT, DUSK_EFFECT_WEATHER_EFFECT_TYPE_ID )
        call EnableWeatherEffectWJ( EFFECT_WEATHER_EFFECT, null, true )
    endfunction

    public function Dawn takes nothing returns nothing
        call RemoveWeatherEffectWJ( EFFECT_WEATHER_EFFECT )
        set EFFECT_WEATHER_EFFECT = AddWeatherEffectWJ( PLAY_RECT, DAWN_EFFECT_WEATHER_EFFECT_TYPE_ID )
        call EnableWeatherEffectWJ( EFFECT_WEATHER_EFFECT, null, true )
    endfunction

    public function Start takes nothing returns nothing
        local integer newWeatherEffectTypeId
        if (dawn) then
            set newWeatherEffectTypeId = DAWN_EFFECT_WEATHER_EFFECT_TYPE_ID
        else
            set newWeatherEffectTypeId = DUSK_EFFECT_WEATHER_EFFECT_TYPE_ID
        endif
        set EFFECT_WEATHER_EFFECT = AddWeatherEffectWJ( PLAY_RECT, newWeatherEffectTypeId )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\TimeOfDay.j

//file: D:\Warcraft III\Mapping\WFW\Data\Misc\UnitRevaluation.j
//TESH.scrollpos=64
//TESH.alwaysfold=0
//! runtextmacro Scope("UnitRevaluation")
    globals
        private constant integer SPELL_ID = 'A078'

        private integer array KILLS_NEEDED
    endglobals

    private struct Data
        integer killsAmount
    endstruct

    public function RevaluatingUnit_Death takes Unit revaluatingUnit returns nothing
        local integer revaluatingUnitId = revaluatingUnit.id
        local Data d = GetAttachedIntegerById(revaluatingUnitId, UnitRevaluation_SCOPE_ID)
        if (d != NULL) then
            call d.destroy()
            call FlushAttachedIntegerById(revaluatingUnitId, UnitRevaluation_SCOPE_ID)
            //! runtextmacro RemoveEventById( "revaluatingUnitId", "EVENT_REVALUATION_UNIT_DEATH" )
        endif
    endfunction

    private function RevaluatingUnit_Death_Event takes nothing returns nothing
        call RevaluatingUnit_Death( DYING_UNIT )
    endfunction

    public function Revaluate takes Unit revaluatingUnit, integer level returns nothing
        local Data d = GetAttachedIntegerById(revaluatingUnit.id, UnitRevaluation_SCOPE_ID)
        if (d == NULL) then
            set d.killsAmount = KILLS_NEEDED[level]
        endif
    endfunction

    private function Source_Death_Conditions takes boolean deathCausedByEnemy, boolean isDyingUnitStructure, Unit revaluatingUnit, player revaluatingUnitOwner, UnitType revaluatingUnitType returns boolean
        set TEMP_UNIT_SELF = revaluatingUnit.self
        if ( isDyingUnitStructure ) then
            return false
        endif
        if ( deathCausedByEnemy == false ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if (IsUnitIllusionWJ(revaluatingUnit)) then
            return false
        endif
        if ( ( IsUnitTypeSpawn(revaluatingUnitType) == false ) and ( revaluatingUnitType.id != RESERVE_UNIT_ID ) ) then
            return false
        endif
        if ( Experience_DISABLED[GetPlayerTeam(revaluatingUnitOwner)] ) then
            return false
        endif
        return true
    endfunction

    public function Source_Death takes boolean deathCausedByEnemy, player dyingUnitOwner, boolean isDyingUnitStructure, Unit revaluatingUnit, player revaluatingUnitOwner, UnitType revaluatingUnitType returns nothing
        local Data d
        local integer killsAmount
        local integer iteration
        local integer oldLevel
        local integer revaluatingUnitId
        local integer supplyUsed
        if ( Source_Death_Conditions( deathCausedByEnemy, isDyingUnitStructure, revaluatingUnit, revaluatingUnitOwner, revaluatingUnitType ) ) then
            set supplyUsed = GetUnitSupplyUsed( revaluatingUnit )
            if ( supplyUsed > 0 ) then
                set iteration = REVALUATION_LEVELS_AMOUNT
                set revaluatingUnitId = revaluatingUnit.id
                set d = GetAttachedIntegerById(revaluatingUnitId, UnitRevaluation_SCOPE_ID)
                if (d == NULL) then
                    set d = Data.create()
                    set oldLevel = GetUnitRevaluation(revaluatingUnit)
                    if (oldLevel > 0) then
                        set killsAmount = KILLS_NEEDED[iteration] + 1
                    else
                        set killsAmount = 1
                    endif
                    call AttachIntegerById(revaluatingUnitId, UnitRevaluation_SCOPE_ID, d)
                    //! runtextmacro AddEventById( "revaluatingUnitId", "EVENT_REVALUATION_UNIT_DEATH" )
                else
                    set killsAmount = d.killsAmount + 1
                endif
                set d.killsAmount = killsAmount
                loop
                    exitwhen (killsAmount == KILLS_NEEDED[iteration])
                    set iteration = iteration - 1
                    exitwhen (iteration < 1)
                endloop
                if (iteration > 0) then
                    call SetUnitRevaluation(revaluatingUnit, iteration)
                endif
            endif
        endif
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_REVALUATING_UNIT_DEATH", "UnitDies_EVENT_KEY", "0", "function RevaluatingUnit_Death_Event" )
        set KILLS_NEEDED[1] = 2
        set KILLS_NEEDED[2] = 4
        call InitAbility( SPELL_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Misc\UnitRevaluation.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\BigGun.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("BigGun")
    globals
        public constant integer RESEARCH_ID = 'R014'
        public constant integer SPELL_ID = 'A087'
    endglobals

    public function ResearchFinish takes player researchingUnitOwner returns nothing
        local integer iteration = CountResearchTypeIdUnitTypes( RESEARCH_ID )
        local UnitType specificUnitType
        loop
            exitwhen ( iteration < 0 )
            set specificUnitType = GetResearchTypeIdUnitType(RESEARCH_ID, iteration )
            call SetUnitTypeSplashForPlayer( specificUnitType, researchingUnitOwner )
            set iteration = iteration - 1
        endloop
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType(RESEARCH_ID)
        call SetResearchTypeGoldCost(d, 1, 300)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\BigGun.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\CriticalStrikes.j
//TESH.scrollpos=17
//TESH.alwaysfold=0
//! runtextmacro Scope("CriticalStrikes")
    globals
        public constant integer RESEARCH_ID = 'R00S'

        private real array BONUS_CHANCE
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( FILTER_UNIT.owner != TEMP_PLAYER ) then
            return false
        endif
        if ( IsUnitTypeUsingResearchTypeId( FILTER_UNIT.type, RESEARCH_ID ) == false ) then
            return false
        endif
        return true
    endfunction

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusChance = BONUS_CHANCE[researchLevel]
        local unit enumUnit
        local integer iteration = CountResearchTypeIdUnitTypes(RESEARCH_ID)
        set TEMP_PLAYER = researchingUnitOwner
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call AddUnitCriticalStrike( GetUnit(enumUnit), bonusChance )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        loop
            exitwhen ( iteration < 0 )
            call AddUnitTypeCriticalStrikeForPlayer( GetResearchTypeIdUnitType(RESEARCH_ID, iteration), researchingUnitOwner, bonusChance )
            set iteration = iteration - 1
        endloop
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 800)
        call SetResearchTypeGoldCost(d, 2, 800)

        set BONUS_CHANCE[1] = 0.15
        set BONUS_CHANCE[2] = 0.15
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\CriticalStrikes.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\DoubleHead.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("DoubleHead")
    globals
        public constant integer RESEARCH_ID = 'R010'
    endglobals

    public function ResearchFinish takes player researchingUnitOwner returns nothing
        call CreateAltar( researchingUnitOwner )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 2000)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\DoubleHead.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\GoodWinds.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("GoodWinds")
    globals
        public constant integer RESEARCH_ID = 'R00Q'
    endglobals

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 800)
        call SetResearchTypeGoldCost(d, 2, 800)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\GoodWinds.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\GreaterFireball.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("GreaterFireball")
    globals
        public constant integer RESEARCH_ID = 'R01N'
    endglobals

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 350)
        call SetResearchTypeGoldCost(d, 2, 350)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\GreaterFireball.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\ImprovedFury.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("ImprovedFury")
    globals
        public constant integer RESEARCH_ID = 'R00N'
    endglobals

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 350)
        call SetResearchTypeGoldCost(d, 2, 350)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\ImprovedFury.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\ImprovedInspiration.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("ImprovedInspiration")
    globals
        public constant integer RESEARCH_ID = 'R00D'
    endglobals

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 350)
        call SetResearchTypeGoldCost(d, 2, 350)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\ImprovedInspiration.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\ImprovedRaiseDead.j
//TESH.scrollpos=1
//TESH.alwaysfold=0
//! runtextmacro Scope("ImprovedRaiseDead")
    globals
        public constant integer RESEARCH_ID = 'R00P'

        private real array BONUS_ARMOR
        private real array BONUS_DAMAGE
        private real array BONUS_LIFE
    endglobals

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusArmor = BONUS_ARMOR[researchLevel]
        local real bonusDamage = BONUS_DAMAGE[researchLevel]
        local real bonusLife = BONUS_LIFE[researchLevel]
        local integer iteration = CountResearchTypeIdUnitTypes(RESEARCH_ID)
        local UnitType specificUnitType
        loop
            exitwhen ( iteration < 0 )
            set specificUnitType = GetResearchTypeIdUnitType(RESEARCH_ID, iteration)
            call AddUnitTypeArmorForPlayer( specificUnitType, researchingUnitOwner, bonusArmor )
            call AddUnitTypeDamageForPlayer( specificUnitType, researchingUnitOwner, bonusDamage )
            call AddUnitTypeMaxLifeForPlayer( specificUnitType, researchingUnitOwner, bonusLife )
            set iteration = iteration - 1
        endloop
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 350)
        call SetResearchTypeGoldCost(d, 2, 350)

        set BONUS_ARMOR[1] = 1
        set BONUS_ARMOR[2] = 1
        set BONUS_DAMAGE[1] = 5
        set BONUS_DAMAGE[1] = 5
        set BONUS_LIFE[1] = 50
        set BONUS_LIFE[1] = 50
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\ImprovedRaiseDead.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\ImprovedWhipLash.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("ImprovedWhipLash")
    globals
        public constant integer RESEARCH_ID = 'R011'
    endglobals

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 800)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\ImprovedWhipLash.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\MassProduction.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("MassProduction")
    globals
        public constant integer RESEARCH_ID = 'R00O'

        private real array BONUS_RELATIVE_TIME
    endglobals

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusRelativeTime = BONUS_RELATIVE_TIME[researchLevel]
        local integer iteration = CountResearchTypeIdUnitTypes(RESEARCH_ID)
        local UnitType specificUnitType
        loop
            exitwhen ( iteration < 0 )
            set specificUnitType = GetResearchTypeIdUnitType(RESEARCH_ID, iteration)
            call AddUnitTypeSpawnTimeForPlayer( specificUnitType, researchingUnitOwner, GetUnitTypeSpawnTime( specificUnitType ) * bonusRelativeTime )
            set iteration = iteration - 1
        endloop
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 800)
        call SetResearchTypeGoldCost(d, 2, 800)

        set BONUS_RELATIVE_TIME[1] = -0.2
        set BONUS_RELATIVE_TIME[2] = -0.2
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\MassProduction.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\RegenerativeHerbs.j
//TESH.scrollpos=24
//TESH.alwaysfold=0
//! runtextmacro Scope("RegenerativeHerbs")
    globals
        public constant integer RESEARCH_ID = 'R00E'

        private real array BONUS_REGENERATION
        private group ENUM_GROUP
        private constant integer LEVELS_AMOUNT = 2
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( FILTER_UNIT.owner != TEMP_PLAYER ) then
            return false
        endif
        if ( IsUnitTypeUsingResearchTypeId( FILTER_UNIT.type, RESEARCH_ID ) == false ) then
            return false
        endif
        return true
    endfunction

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusRegeneration = BONUS_REGENERATION[researchLevel]
        local unit enumUnit
        local integer iteration = CountResearchTypeIdUnitTypes(RESEARCH_ID)
        set TEMP_PLAYER = researchingUnitOwner
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call AddUnitLifeRegeneration( GetUnit(enumUnit), bonusRegeneration )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        loop
            exitwhen ( iteration < 0 )
            call AddUnitTypeLifeRegenerationForPlayer( GetResearchTypeIdUnitType(RESEARCH_ID, iteration), researchingUnitOwner, bonusRegeneration )
            set iteration = iteration - 1
        endloop
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        local integer iteration = LEVELS_AMOUNT
        call SetResearchTypeGoldCost(d, 1, 800)
        call SetResearchTypeGoldCost(d, 2, 800)

        set BONUS_REGENERATION[1] = 0.1
        set BONUS_REGENERATION[2] = 0.1
        loop
            set BONUS_REGENERATION[iteration] = BONUS_REGENERATION[iteration] * REGENERATION_INTERVAL
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\RegenerativeHerbs.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\SecondaryTalent.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("SecondaryTalent")
    globals
        public constant integer RESEARCH_ID = 'R01M'
    endglobals

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 650)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\SecondaryTalent.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\SelfHealResearch.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("SelfHealResearch")
    globals
        public constant integer RESEARCH_ID = 'R00R'
    endglobals

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 350)
        call SetResearchTypeGoldCost(d, 2, 350)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\SelfHealResearch.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\SparklingScales.j
//TESH.scrollpos=18
//TESH.alwaysfold=0
//! runtextmacro Scope("SparklingScales")
    globals
        public constant integer RESEARCH_ID = 'R00T'

        private real array BONUS_ARMOR_BY_SPELL
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( FILTER_UNIT.owner != TEMP_PLAYER ) then
            return false
        endif
        if ( IsUnitTypeUsingResearchTypeId( FILTER_UNIT.type, RESEARCH_ID ) == false ) then
            return false
        endif
        return true
    endfunction

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusRelativeResistance = BONUS_ARMOR_BY_SPELL[researchLevel]
        local unit enumUnit
        local integer iteration = CountResearchTypeIdUnitTypes(RESEARCH_ID)
        local integer specificUnitTypeId
        set TEMP_PLAYER = researchingUnitOwner
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call AddUnitArmorBySpellBonus( GetUnit(enumUnit), bonusRelativeResistance )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        loop
            exitwhen ( iteration < 0 )
            call AddUnitTypeArmorBySpellForPlayer( GetResearchTypeIdUnitType(RESEARCH_ID, iteration), researchingUnitOwner, bonusRelativeResistance )
            set iteration = iteration - 1
        endloop
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 800)
        call SetResearchTypeGoldCost(d, 2, 800)

        set ENUM_GROUP = CreateGroupWJ()
        set BONUS_ARMOR_BY_SPELL[1] = 0.1
        set BONUS_ARMOR_BY_SPELL[2] = 0.1
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\SparklingScales.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradeArmor.j
//TESH.scrollpos=76
//TESH.alwaysfold=0
//! runtextmacro Scope("UpgradeArmor")
    globals
        private constant integer HUMAN_RESEARCH_ID = 'R001'
        private constant integer NAGA_RESEARCH_ID = 'R00M'
        private constant integer NIGHTELF_RESEARCH_ID = 'R007'
        private constant integer ORC_RESEARCH_ID = 'R003'
        public constant integer RESEARCH_ID = 'R00X'
        private integer array RESEARCH_TYPES_ID
        private integer RESEARCH_TYPES_ID_COUNT = -1
        private constant integer UNDEAD_RESEARCH_ID = 'R005'

        private real array BONUS_ARMOR
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( FILTER_UNIT.owner != TEMP_PLAYER ) then
            return false
        endif
        if ( IsUnitTypeUsingResearchTypeId( FILTER_UNIT.type, RESEARCH_ID ) == false ) then
            return false
        endif
        return true
    endfunction

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusArmor = BONUS_ARMOR[researchLevel]
        local unit enumUnit
        local integer iteration = CountResearchTypeIdUnitTypes( RESEARCH_ID )
        set TEMP_PLAYER = researchingUnitOwner
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call AddUnitArmor( GetUnit(enumUnit), bonusArmor )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        loop
            exitwhen ( iteration < 0 )
            call AddUnitTypeArmorForPlayer( GetResearchTypeIdUnitType(RESEARCH_ID, iteration), researchingUnitOwner, bonusArmor )
            set iteration = iteration - 1
        endloop
        set iteration = RESEARCH_TYPES_ID_COUNT
        loop
            exitwhen ( iteration < 0 )
            call SetPlayerTechResearched( researchingUnitOwner, RESEARCH_TYPES_ID[iteration], researchLevel )
            set iteration = iteration - 1
        endloop
        call SetPlayerTechResearched( researchingUnitOwner, RESEARCH_ID, researchLevel )
    endfunction

    public function ResearchFinish_Conditions takes integer thisResearchTypeId returns boolean
        local integer iteration = RESEARCH_TYPES_ID_COUNT
        loop
            if (RESEARCH_TYPES_ID[iteration] == thisResearchTypeId) then
                return true
            endif
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        return false
    endfunction

    private function InitResearchTypeId takes integer whichResearchTypeId returns nothing
        set RESEARCH_TYPES_ID_COUNT = RESEARCH_TYPES_ID_COUNT + 1
        set RESEARCH_TYPES_ID[RESEARCH_TYPES_ID_COUNT] = whichResearchTypeId
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d
        local integer iteration

        call InitResearchTypeId(HUMAN_RESEARCH_ID)
        call InitResearchTypeId(ORC_RESEARCH_ID)
        call InitResearchTypeId(UNDEAD_RESEARCH_ID)
        call InitResearchTypeId(NIGHTELF_RESEARCH_ID)
        call InitResearchTypeId(NAGA_RESEARCH_ID)
        set iteration = RESEARCH_TYPES_ID_COUNT
        loop
            exitwhen ( iteration < 0 )
            set d = InitResearchType(RESEARCH_TYPES_ID[iteration])
            call SetResearchTypeGoldCost(d, 1, 200)
            call SetResearchTypeGoldCost(d, 2, 225)
            call SetResearchTypeGoldCost(d, 3, 265)
            call SetResearchTypeGoldCost(d, 4, 300)
            call SetResearchTypeGoldCost(d, 5, 340)
            call SetResearchTypeGoldCost(d, 6, 285)
            call SetResearchTypeGoldCost(d, 7, 335)
            call SetResearchTypeGoldCost(d, 8, 390)
            call SetResearchTypeGoldCost(d, 9, 450)
            set iteration = iteration - 1
        endloop
        call InitResearchType( RESEARCH_ID )

        set BONUS_ARMOR[1] = 1
        set BONUS_ARMOR[2] = 1
        set BONUS_ARMOR[3] = 1
        set BONUS_ARMOR[4] = 1
        set BONUS_ARMOR[5] = 1
        set BONUS_ARMOR[6] = 1
        set BONUS_ARMOR[7] = 1
        set BONUS_ARMOR[8] = 1
        set BONUS_ARMOR[9] = 1
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradeArmor.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradeAttackRate.j
//TESH.scrollpos=78
//TESH.alwaysfold=0
//! runtextmacro Scope("UpgradeAttackRate")
    globals
        private constant integer HUMAN_RESEARCH_ID = 'R009'
        private constant integer NAGA_RESEARCH_ID = 'R00K'
        private constant integer NIGHTELF_RESEARCH_ID = 'R006'
        private constant integer ORC_RESEARCH_ID = 'R008'
        public constant integer RESEARCH_ID = 'R00W'
        private integer array RESEARCH_TYPES_ID
        private integer RESEARCH_TYPES_ID_COUNT = -1
        private constant integer UNDEAD_RESEARCH_ID = 'R00A'

        private real array BONUS_ATTACK_RATE
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( FILTER_UNIT.owner != TEMP_PLAYER ) then
            return false
        endif
        if ( IsUnitTypeUsingResearchTypeId( FILTER_UNIT.type, RESEARCH_ID ) == false ) then
            return false
        endif
        return true
    endfunction

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusRelativeAttackRate = BONUS_ATTACK_RATE[researchLevel]
        local Unit enumUnit
        local unit enumUnitSelf
        local integer iteration = CountResearchTypeIdUnitTypes( RESEARCH_ID )
        set TEMP_PLAYER = researchingUnitOwner
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call AddUnitAttackRate( enumUnit, bonusRelativeAttackRate )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        loop
            exitwhen ( iteration < 0 )
            call AddUnitTypeAttackRateForPlayer( GetResearchTypeIdUnitType( RESEARCH_ID, iteration ), researchingUnitOwner, bonusRelativeAttackRate )
            set iteration = iteration - 1
        endloop
        set iteration = RESEARCH_TYPES_ID_COUNT
        loop
            exitwhen ( iteration < 0 )
            call SetPlayerTechResearched( researchingUnitOwner, RESEARCH_TYPES_ID[iteration], researchLevel )
            set iteration = iteration - 1
        endloop
        call SetPlayerTechResearched( researchingUnitOwner, RESEARCH_ID, researchLevel )
    endfunction

    public function ResearchFinish_Conditions takes integer thisResearchTypeId returns boolean
        local integer iteration = RESEARCH_TYPES_ID_COUNT
        loop
            if (RESEARCH_TYPES_ID[iteration] == thisResearchTypeId) then
                return true
            endif
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        return false
    endfunction

    private function InitResearchTypeId takes integer whichResearchTypeId returns nothing
        set RESEARCH_TYPES_ID_COUNT = RESEARCH_TYPES_ID_COUNT + 1
        set RESEARCH_TYPES_ID[RESEARCH_TYPES_ID_COUNT] = whichResearchTypeId
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType(RESEARCH_ID)
        local integer iteration

        call InitResearchTypeId(HUMAN_RESEARCH_ID)
        call InitResearchTypeId(ORC_RESEARCH_ID)
        call InitResearchTypeId(UNDEAD_RESEARCH_ID)
        call InitResearchTypeId(NIGHTELF_RESEARCH_ID)
        call InitResearchTypeId(NAGA_RESEARCH_ID)
        set iteration = RESEARCH_TYPES_ID_COUNT
        loop
            exitwhen ( iteration < 0 )
            set d = InitResearchType(RESEARCH_TYPES_ID[iteration])
            call SetResearchTypeGoldCost(d, 1, 350)
            call SetResearchTypeGoldCost(d, 2, 380)
            call SetResearchTypeGoldCost(d, 3, 410)
            call SetResearchTypeGoldCost(d, 4, 440)
            call SetResearchTypeGoldCost(d, 5, 470)
            call SetResearchTypeGoldCost(d, 6, 500)
            call SetResearchTypeGoldCost(d, 7, 530)
            call SetResearchTypeGoldCost(d, 8, 560)
            call SetResearchTypeGoldCost(d, 9, 590)
            set iteration = iteration - 1
        endloop
        call InitResearchType( RESEARCH_ID )

        set BONUS_ATTACK_RATE[1] = 0.1
        set BONUS_ATTACK_RATE[2] = 0.1
        set BONUS_ATTACK_RATE[3] = 0.1
        set BONUS_ATTACK_RATE[4] = 0.1
        set BONUS_ATTACK_RATE[5] = 0.1
        set BONUS_ATTACK_RATE[6] = 0.1
        set BONUS_ATTACK_RATE[7] = 0.1
        set BONUS_ATTACK_RATE[8] = 0.1
        set BONUS_ATTACK_RATE[9] = 0.1
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradeAttackRate.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradeDamage.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("UpgradeDamage")
    globals
        private constant integer HUMAN_RESEARCH_ID = 'R000'
        private constant integer NAGA_RESEARCH_ID = 'R00J'
        private constant integer NIGHTELF_RESEARCH_ID = 'R00B'
        private constant integer ORC_RESEARCH_ID = 'R002'
        public constant integer RESEARCH_ID = 'R00V'
        private integer array RESEARCH_TYPES_ID
        private integer RESEARCH_TYPES_ID_COUNT = -1
        private constant integer UNDEAD_RESEARCH_ID = 'R004'

        private real array BONUS_RELATIVE_DAMAGE
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( FILTER_UNIT.owner != TEMP_PLAYER ) then
            return false
        endif
        if ( IsUnitTypeUsingResearchTypeId( FILTER_UNIT.type, RESEARCH_ID ) == false ) then
            return false
        endif
        return true
    endfunction

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusRelativeDamage = BONUS_RELATIVE_DAMAGE[researchLevel]
        local Unit enumUnit
        local unit enumUnitSelf
        local integer iteration = CountResearchTypeIdUnitTypes( RESEARCH_ID )
        local UnitType specificUnitType
        set TEMP_PLAYER = researchingUnitOwner
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call AddUnitDamage( enumUnit, GetUnitTypeDamage( enumUnit.type ) * bonusRelativeDamage )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        loop
            exitwhen ( iteration < 0 )
            set specificUnitType = GetResearchTypeIdUnitType( RESEARCH_ID, iteration )
            call AddUnitTypeDamageForPlayer( specificUnitType, researchingUnitOwner, GetUnitTypeDamage( specificUnitType ) * bonusRelativeDamage )
            set iteration = iteration - 1
        endloop
        set iteration = RESEARCH_TYPES_ID_COUNT
        loop
            exitwhen ( iteration < 0 )
            call SetPlayerTechResearched( researchingUnitOwner, RESEARCH_TYPES_ID[iteration], researchLevel )
            set iteration = iteration - 1
        endloop
        call SetPlayerTechResearched( researchingUnitOwner, RESEARCH_ID, researchLevel )
    endfunction

    public function ResearchFinish_Conditions takes integer thisResearchTypeId returns boolean
        local integer iteration = RESEARCH_TYPES_ID_COUNT
        loop
            if (RESEARCH_TYPES_ID[iteration] == thisResearchTypeId) then
                return true
            endif
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        return false
    endfunction

    private function InitResearchTypeId takes integer whichResearchTypeId returns nothing
        set RESEARCH_TYPES_ID_COUNT = RESEARCH_TYPES_ID_COUNT + 1
        set RESEARCH_TYPES_ID[RESEARCH_TYPES_ID_COUNT] = whichResearchTypeId
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d
        local integer iteration

        call InitResearchTypeId(HUMAN_RESEARCH_ID)
        call InitResearchTypeId(ORC_RESEARCH_ID)
        call InitResearchTypeId(UNDEAD_RESEARCH_ID)
        call InitResearchTypeId(NIGHTELF_RESEARCH_ID)
        call InitResearchTypeId(NAGA_RESEARCH_ID)
        set iteration = RESEARCH_TYPES_ID_COUNT
        loop
            exitwhen ( iteration < 0 )
            set d = InitResearchType(RESEARCH_TYPES_ID[iteration])
            call SetResearchTypeGoldCost(d, 1, 200)
            call SetResearchTypeGoldCost(d, 2, 225)
            call SetResearchTypeGoldCost(d, 3, 265)
            call SetResearchTypeGoldCost(d, 4, 300)
            call SetResearchTypeGoldCost(d, 5, 340)
            call SetResearchTypeGoldCost(d, 6, 285)
            call SetResearchTypeGoldCost(d, 7, 335)
            call SetResearchTypeGoldCost(d, 8, 390)
            call SetResearchTypeGoldCost(d, 9, 450)
            set iteration = iteration - 1
        endloop
        call InitResearchType( RESEARCH_ID )

        set BONUS_RELATIVE_DAMAGE[1] = 0.15
        set BONUS_RELATIVE_DAMAGE[2] = 0.15
        set BONUS_RELATIVE_DAMAGE[3] = 0.15
        set BONUS_RELATIVE_DAMAGE[4] = 0.15
        set BONUS_RELATIVE_DAMAGE[5] = 0.15
        set BONUS_RELATIVE_DAMAGE[6] = 0.15
        set BONUS_RELATIVE_DAMAGE[7] = 0.15
        set BONUS_RELATIVE_DAMAGE[8] = 0.15
        set BONUS_RELATIVE_DAMAGE[9] = 0.15
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradeDamage.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradePower.j
//TESH.scrollpos=92
//TESH.alwaysfold=0
//! runtextmacro Scope("UpgradePower")
    globals
        private constant integer HUMAN_RESEARCH_ID = 'R00F'
        private constant integer NAGA_RESEARCH_ID = 'R00L'
        private constant integer NIGHTELF_RESEARCH_ID = 'R00I'
        private constant integer ORC_RESEARCH_ID = 'R00G'
        public constant integer RESEARCH_ID = 'R00Y'
        private integer array RESEARCH_TYPES_ID
        private integer RESEARCH_TYPES_ID_COUNT = -1
        private constant integer UNDEAD_RESEARCH_ID = 'R00H'

        private real array BONUS_RELATIVE_LIFE
        private real array BONUS_RELATIVE_MANA
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( FILTER_UNIT.owner != TEMP_PLAYER ) then
            return false
        endif
        if ( IsUnitTypeUsingResearchTypeId( FILTER_UNIT.type, RESEARCH_ID ) == false ) then
            return false
        endif
        return true
    endfunction

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusRelativeLife = BONUS_RELATIVE_LIFE[researchLevel]
        local real bonusRelativeMana = BONUS_RELATIVE_MANA[researchLevel]
        local Unit enumUnit
        local unit enumUnitSelf
        local integer iteration = CountResearchTypeIdUnitTypes( RESEARCH_ID )
        local real mana
        local UnitType specificUnitType
        set TEMP_PLAYER = researchingUnitOwner
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                set mana = GetUnitMaxMana(enumUnit)
                set specificUnitType = enumUnit.type
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call AddUnitMaxLife( enumUnit, GetUnitTypeMaxLife( specificUnitType ) * bonusRelativeLife )
                if (mana > 0) then
                    call AddUnitMaxMana( enumUnit, mana * bonusRelativeMana )
                endif
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        loop
            exitwhen ( iteration < 0 )
            set specificUnitType = GetResearchTypeIdUnitType( RESEARCH_ID, iteration )
            set mana = GetUnitTypeMaxMana(specificUnitType)
            call AddUnitTypeMaxLifeForPlayer( specificUnitType, researchingUnitOwner, GetUnitTypeMaxLife( specificUnitType ) * bonusRelativeLife )
            if (mana > 0) then
                call AddUnitTypeMaxManaForPlayer( specificUnitType, researchingUnitOwner, mana * bonusRelativeMana )
            endif
            set iteration = iteration - 1
        endloop
        set iteration = RESEARCH_TYPES_ID_COUNT
        loop
            exitwhen ( iteration < 0 )
            call SetPlayerTechResearched( researchingUnitOwner, RESEARCH_TYPES_ID[iteration], researchLevel )
            set iteration = iteration - 1
        endloop
        call SetPlayerTechResearched( researchingUnitOwner, RESEARCH_ID, researchLevel )
    endfunction

    public function ResearchFinish_Conditions takes integer thisResearchTypeId returns boolean
        local integer iteration = RESEARCH_TYPES_ID_COUNT
        loop
            if (RESEARCH_TYPES_ID[iteration] == thisResearchTypeId) then
                return true
            endif
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        return false
    endfunction

    private function InitResearchTypeId takes integer whichResearchTypeId returns nothing
        set RESEARCH_TYPES_ID_COUNT = RESEARCH_TYPES_ID_COUNT + 1
        set RESEARCH_TYPES_ID[RESEARCH_TYPES_ID_COUNT] = whichResearchTypeId
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d
        local integer iteration

        call InitResearchTypeId(HUMAN_RESEARCH_ID)
        call InitResearchTypeId(ORC_RESEARCH_ID)
        call InitResearchTypeId(UNDEAD_RESEARCH_ID)
        call InitResearchTypeId(NIGHTELF_RESEARCH_ID)
        call InitResearchTypeId(NAGA_RESEARCH_ID)
        set iteration = RESEARCH_TYPES_ID_COUNT
        loop
            exitwhen ( iteration < 0 )
            set d = InitResearchType(RESEARCH_TYPES_ID[iteration])
            call SetResearchTypeGoldCost(d, 1, 350)
            call SetResearchTypeGoldCost(d, 2, 400)
            call SetResearchTypeGoldCost(d, 3, 450)
            call SetResearchTypeGoldCost(d, 4, 500)
            call SetResearchTypeGoldCost(d, 5, 550)
            call SetResearchTypeGoldCost(d, 6, 600)
            call SetResearchTypeGoldCost(d, 7, 650)
            call SetResearchTypeGoldCost(d, 8, 700)
            call SetResearchTypeGoldCost(d, 9, 750)
            set iteration = iteration - 1
        endloop
        call InitResearchType( RESEARCH_ID )

        set BONUS_RELATIVE_LIFE[1] = 0.1
        set BONUS_RELATIVE_LIFE[2] = 0.1
        set BONUS_RELATIVE_LIFE[3] = 0.1
        set BONUS_RELATIVE_LIFE[4] = 0.1
        set BONUS_RELATIVE_LIFE[5] = 0.1
        set BONUS_RELATIVE_LIFE[6] = 0.1
        set BONUS_RELATIVE_LIFE[7] = 0.1
        set BONUS_RELATIVE_LIFE[8] = 0.1
        set BONUS_RELATIVE_LIFE[9] = 0.1
        set BONUS_RELATIVE_MANA[1] = 0.1
        set BONUS_RELATIVE_MANA[2] = 0.1
        set BONUS_RELATIVE_MANA[3] = 0.1
        set BONUS_RELATIVE_MANA[4] = 0.1
        set BONUS_RELATIVE_MANA[5] = 0.1
        set BONUS_RELATIVE_MANA[6] = 0.1
        set BONUS_RELATIVE_MANA[7] = 0.1
        set BONUS_RELATIVE_MANA[8] = 0.1
        set BONUS_RELATIVE_MANA[9] = 0.1
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradePower.j

//file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradeSpeed.j
//TESH.scrollpos=21
//TESH.alwaysfold=0
//! runtextmacro Scope("UpgradeSpeed")
    globals
        public constant integer RESEARCH_ID = 'R00C'

        private real array BONUS_RELATIVE_SPEED
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( FILTER_UNIT.owner != TEMP_PLAYER ) then
            return false
        endif
        if ( IsUnitTypeUsingResearchTypeId( FILTER_UNIT.type, RESEARCH_ID ) == false ) then
            return false
        endif
        return true
    endfunction

    public function ResearchFinish takes integer researchLevel, player researchingUnitOwner returns nothing
        local real bonusRelativeSpeed = BONUS_RELATIVE_SPEED[researchLevel]
        local Unit enumUnit
        local unit enumUnitSelf
        local integer iteration = CountResearchTypeIdUnitTypes( RESEARCH_ID )
        local UnitType specificUnitType
        set TEMP_PLAYER = researchingUnitOwner
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call AddUnitSpeed( enumUnit, GetUnitTypeSpeed( GetUnit(enumUnitSelf).type ) * bonusRelativeSpeed )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        loop
            exitwhen ( iteration < 0 )
            set specificUnitType = GetResearchTypeIdUnitType(RESEARCH_ID, iteration )
            call AddUnitTypeSpeedForPlayer( specificUnitType, researchingUnitOwner, GetUnitTypeSpeed( specificUnitType ) * bonusRelativeSpeed )
            set iteration = iteration - 1
        endloop
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType(RESEARCH_ID)
        call SetResearchTypeGoldCost(d, 1, 800)
        call SetResearchTypeGoldCost(d, 2, 800)

        set ENUM_GROUP = CreateGroupWJ()
        set BONUS_RELATIVE_SPEED[1] = 0.2
        set BONUS_RELATIVE_SPEED[2] = 0.4
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Researches\UpgradeSpeed.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\AcidStrike.j
//TESH.scrollpos=15
//TESH.alwaysfold=0
//! runtextmacro Scope("AcidStrike")
    globals
        private constant integer ORDER_ID = 852527//OrderId( "shadowstrike" )
        public constant integer SPELL_ID = 'A00V'

        private real array BONUS_ARMOR
        private real array BONUS_SPEED
        private real array DAMAGE
        private real array DAMAGE_PER_INTERVAL
        private real array DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT
        private real array DURATION
        private real array HERO_DURATION
        private real array INTERVAL
        private constant integer LEVELS_AMOUNT = 5
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\NightElf\\shadowstrike\\shadowstrike.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "overhead"
        private constant string TARGET_EFFECT2_PATH = "Objects\\Spawnmodels\\Undead\\UndeadBlood\\UndeadBloodCryptFiend.mdl"
        private constant string TARGET_EFFECT2_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        integer abilityLevel
        real array bonusSpeed[LEVELS_AMOUNT]
        Unit array caster[LEVELS_AMOUNT]
        real array damageAmount[LEVELS_AMOUNT]
        timer array durationTimer[LEVELS_AMOUNT]
        timer intervalTimer
        Unit target
        effect targetEffect
    endstruct

    private function Interval takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, AcidStrike_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local real damageAmount = d.damageAmount[abilityLevel - 1]
        local Unit target = d.target
        local unit targetSelf = target.self
        local real targetX = GetUnitX(targetSelf)
        local real targetY = GetUnitY(targetSelf)
        set intervalTimer = null
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT2_PATH, targetSelf, TARGET_EFFECT2_ATTACHMENT_POINT ) )
        call CreateRisingTextTag( I2S( R2I( damageAmount ) ), 0.023, GetUnitX( targetSelf ), GetUnitY( targetSelf ), GetUnitZ( targetSelf, targetX, targetY ) + GetUnitOutpactZ(target), 80, 200, 0, 155, 255, 1, 4 )
        set targetSelf = null
        call UnitDamageUnitBySpell( d.caster[abilityLevel - 1], target, damageAmount )
    endfunction

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer abilityLevel = d.abilityLevel
        local real bonusSpeed
        local timer intervalTimer
        local integer iteration = abilityLevel - 1
        local effect targetEffect
        local integer targetId
        loop
            exitwhen (durationTimer == d.durationTimer[iteration])
            set iteration = iteration - 1
        endloop
        set d.durationTimer[iteration] = null
        if ( abilityLevel - 1 <= iteration ) then
            set bonusSpeed = d.bonusSpeed[abilityLevel - 1]
            loop
                exitwhen (iteration < 0)
                exitwhen (d.durationTimer[iteration] != null)
                set iteration = iteration - 1
            endloop
            if ( iteration > -1 ) then
                set d.abilityLevel = iteration + 1
                call AddUnitArmorBonus( target, BONUS_ARMOR[iteration] - BONUS_ARMOR[abilityLevel] )
                call AddUnitSpeedBonus( target, BONUS_SPEED[iteration] - BONUS_SPEED[abilityLevel] )
                call TimerStart(d.intervalTimer, INTERVAL[iteration], true, function Interval)
            else
                set intervalTimer = d.intervalTimer
                set targetEffect = d.targetEffect
                set targetId = target.id
                call d.destroy()
                call DestroyTimerWJ(intervalTimer)
                set intervalTimer = null
                call DestroyEffectWJ( targetEffect )
                set targetEffect = null
                call FlushAttachedIntegerById( targetId, AcidStrike_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
                call AddUnitArmorBonus( target, -BONUS_ARMOR[abilityLevel] )
                call AddUnitSpeedBonus( target, -BONUS_SPEED[abilityLevel] )
            endif
        endif
        call FlushAttachedInteger( durationTimer, AcidStrike_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
    endfunction

    public function Death takes Unit target returns nothing
        local integer abilityLevel
        local Data d = GetAttachedIntegerById(target.id, AcidStrike_SCOPE_ID)
        local timer durationTimer
        local integer iteration
        if (d != NULL) then
            set abilityLevel = d.abilityLevel
            set iteration = 0
            loop
                set durationTimer = d.durationTimer[iteration]
                if ( durationTimer != null ) then
                    call Ending( d, durationTimer, target )
                endif
                set iteration = iteration + 1
                exitwhen ( iteration >= abilityLevel )
            endloop
            set durationTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, AcidStrike_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel(casterSelf, SPELL_ID)
        local real damageAmount = DAMAGE[abilityLevel]
        local real duration
        local timer durationTimer
        local timer intervalTimer
        local integer iteration
        local integer oldAbilityLevel
        local real oldBonusSpeed
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, AcidStrike_SCOPE_ID)
        local boolean isNew = (d == NULL)
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        set casterSelf = null
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set intervalTimer = CreateTimerWJ()
            set iteration = LEVELS_AMOUNT - 1
            set d.abilityLevel = abilityLevel
            set d.intervalTimer = intervalTimer
            set d.target = target
            loop
                if (iteration == abilityLevel - 1) then
                    set d.caster[iteration] = caster
                    set d.durationTimer[iteration] = durationTimer
                else
                    set d.caster[iteration] = NULL
                    set d.durationTimer[iteration] = null
                endif
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call AttachInteger(durationTimer, AcidStrike_SCOPE_ID, d)
            call AttachInteger(intervalTimer, AcidStrike_SCOPE_ID, d)
            call AttachIntegerById(targetId, AcidStrike_SCOPE_ID, d)
        else
            set durationTimer = d.durationTimer[abilityLevel - 1]
            set d.caster[abilityLevel - 1] = caster
            if (durationTimer == null) then
                set durationTimer = CreateTimerWJ()
                set d.durationTimer[abilityLevel - 1] = durationTimer
                call AttachInteger(durationTimer, AcidStrike_SCOPE_ID, d)
            endif
            set oldAbilityLevel = d.abilityLevel
            set oldBonusSpeed = d.bonusSpeed[oldAbilityLevel - 1]
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.damageAmount[abilityLevel - 1] = DAMAGE_PER_INTERVAL[abilityLevel] + GetHeroIntelligence(caster) * DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[abilityLevel]
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            call AddUnitArmorBonus( target, BONUS_ARMOR[abilityLevel] )
            call AddUnitSpeedBonus( target, BONUS_SPEED[abilityLevel] )
            call TimerStart(intervalTimer, INTERVAL[abilityLevel], true, function Interval)
        elseif (abilityLevel > oldAbilityLevel) then
            set d.abilityLevel = abilityLevel
            call AddUnitArmorBonus( target, BONUS_ARMOR[abilityLevel] - BONUS_ARMOR[oldAbilityLevel] )
            call AddUnitSpeedBonus( target, BONUS_SPEED[abilityLevel] - BONUS_SPEED[oldAbilityLevel] )
        endif
        if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
            set duration = HERO_DURATION[abilityLevel]
        else
            set duration = DURATION[abilityLevel]
        endif
        call PlaySoundFromTypeOnUnit( ACID_STRIKE_SOUND_TYPE, targetSelf )
        call TimerStart( durationTimer, duration, false, function EndingByTimer )
        set durationTimer = null
        call CreateRisingTextTag( I2S( R2I( damageAmount ) ), 0.025, targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) + GetUnitOutpactZ(target), 80, 200, 0, 155, 255, 1, 4 )
        set targetSelf = null
        call UnitDamageUnitBySpell( caster, target, damageAmount )
    endfunction


    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitMagicImmunity(target) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        set BONUS_ARMOR[1] = -4
        set BONUS_ARMOR[2] = -5
        set BONUS_ARMOR[3] = -7
        set BONUS_ARMOR[4] = -7
        set BONUS_ARMOR[5] = -8
        set BONUS_SPEED[1] = -60
        set BONUS_SPEED[2] = -70
        set BONUS_SPEED[3] = -80
        set BONUS_SPEED[4] = -90
        set BONUS_SPEED[5] = -100
        set DAMAGE[1] = 50
        set DAMAGE[2] = 60
        set DAMAGE[3] = 70
        set DAMAGE[4] = 80
        set DAMAGE[5] = 90
        set DAMAGE_PER_INTERVAL[1] = 11
        set DAMAGE_PER_INTERVAL[2] = 14
        set DAMAGE_PER_INTERVAL[3] = 17
        set DAMAGE_PER_INTERVAL[4] = 20
        set DAMAGE_PER_INTERVAL[5] = 23
        set DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[1] = 0.08
        set DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[2] = 0.08
        set DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[3] = 0.08
        set DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[4] = 0.08
        set DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[5] = 0.08
        set DURATION[1] = 8
        set DURATION[2] = 8
        set DURATION[3] = 9
        set DURATION[4] = 10
        set DURATION[5] = 11
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set HERO_DURATION[1] = 4
        set HERO_DURATION[2] = 4
        set HERO_DURATION[3] = 5
        set HERO_DURATION[4] = 6
        set HERO_DURATION[5] = 6
        set INTERVAL[1] = 0.5
        set INTERVAL[2] = 0.5
        set INTERVAL[3] = 0.5
        set INTERVAL[4] = 0.5
        set INTERVAL[5] = 0.5
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT2_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\AcidStrike.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\AdvancedTraining.j
//TESH.scrollpos=13
//TESH.alwaysfold=0
//! runtextmacro Scope("AdvancedTraining")
    globals
        public constant integer ACTIVATION_ORDER_ID = 852133//OrderId( "autodispelon" )
        public constant integer DEACTIVATION_ORDER_ID = 852134//OrderId( "autodispeloff" )
        public constant integer SPELL_ID = 'A048'

        public constant integer BONUS_SPAWN_GOLD_COST = 40
        public constant real BONUS_TIME_FACTOR = 0.5
        public constant integer BONUS_TIME_GOLD_COST = 20

        public boolean array ON
        public boolean array USED
    endglobals

    public function Order_Activation takes Unit caster returns nothing
        set caster.automaticAbility = SPELL_ID
    endfunction

    private function Order_Activation_Event takes nothing returns nothing
        call AdvancedTraining_Order_Activation( ORDERED_UNIT )
    endfunction

    public function Order_Deactivation takes Unit caster returns nothing
        set caster.automaticAbility = 0
    endfunction

    private function Order_Deactivation_Event takes nothing returns nothing
        call AdvancedTraining_Order_Deactivation( ORDERED_UNIT )
    endfunction

    public function Learn takes Unit caster, UnitType casterType returns nothing
        if ( casterType.automaticAbility == SPELL_ID ) then
            call IssueImmediateOrderById( caster.self, ACTIVATION_ORDER_ID )
        endif
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER, LEARNER.type )
    endfunction

    public function Init takes nothing returns nothing
        call AddOrderAbility( ACTIVATION_ORDER_ID, SPELL_ID )
        call AddOrderAbility( DEACTIVATION_ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, ACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Activation_Event" )
        //! runtextmacro AddNewEventById( "EVENT_DEACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, DEACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Deactivation_Event" )
        //! runtextmacro CreateDummyEvent( "EVENT_ORDER", "UnitGetsOrder_EVENT_KEY", "0" )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\AdvancedTraining.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\AdvertisingGift.j
//TESH.scrollpos=351
//TESH.alwaysfold=0
//! runtextmacro Scope("AdvertisingGift")
    globals
        private constant integer ORDER_ID = 852662//OrderId( "acidbomb" )
        public constant integer SPELL_ID = 'A02Y'

        private constant string AREA_EFFECT_PATH = ""
        private real array AREA_RANGE
        private real array BONUS_SPEED
        private real array BONUS_SPEED_PER_AGILITY_POINT
        private constant real CEILING = 200.
        private real array DAMAGE
        private constant integer DUMMY_UNIT_ID = 'n010'
        private real array DURATION
        private group ENUM_GROUP
        private constant integer LEVELS_AMOUNT = 5
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 0.035
    endglobals

    private struct Data
        integer abilityLevel
        real bonusSpeed
        Unit caster
        unit dummyUnit
        real lengthX
        real lengthY
        real lengthZ
        real lengthZAdd
        timer moveTimer
        real targetX
        real targetY
        real targetZ
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private real array Target_DURATION
            private real array Target_HERO_DURATION
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\slow\\slowtarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            integer abilityLevel
            real array bonusSpeed[LEVELS_AMOUNT]
            timer array durationTimer[LEVELS_AMOUNT]
            Unit target
            effect targetEffect
        endstruct

        private function Target_Ending takes Target_Data d, timer durationTimer, Unit target returns nothing
            local integer abilityLevel = d.abilityLevel
            local real bonusSpeed
            local integer iteration = abilityLevel - 1
            local effect targetEffect
            local integer targetId
            loop
                exitwhen (durationTimer == d.durationTimer[iteration])
                set iteration = iteration - 1
            endloop
            set d.durationTimer[iteration] = null
            if ( iteration > abilityLevel ) then
                set bonusSpeed = d.bonusSpeed[abilityLevel]
                loop
                    exitwhen (iteration < 0)
                    exitwhen (d.durationTimer[iteration] != null)
                    set iteration = iteration - 1
                endloop
                if ( iteration > -1 ) then
                    set d.abilityLevel = iteration + 1
                    call AddUnitSpeedBonus( target, d.bonusSpeed[iteration] - bonusSpeed )
                else
                    set targetEffect = d.targetEffect
                    set targetId = target.id
                    call d.destroy()
                    call DestroyEffectWJ( targetEffect )
                    set targetEffect = null
                    call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
                    //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                    //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DISPEL" )
                    call AddUnitSpeedBonus( target, -bonusSpeed )
                endif
            endif
            call FlushAttachedInteger( durationTimer, Target_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
        endfunction

        public function Target_Dispel takes Unit target returns nothing
            local integer abilityLevel
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            local timer durationTimer
            local integer iteration
            if (d != NULL) then
                set abilityLevel = d.abilityLevel
                set iteration = 0
                loop
                    set durationTimer = d.durationTimer[iteration]
                    if ( durationTimer != null ) then
                        call Target_Ending( d, durationTimer, target )
                    endif
                    set iteration = iteration + 1
                    exitwhen ( iteration >= abilityLevel )
                endloop
                set durationTimer = null
            endif
        endfunction

        private function Target_Dispel_Event takes nothing returns nothing
            call Target_Dispel( TRIGGER_UNIT )
        endfunction

        public function Target_Death takes Unit target returns nothing
            call Target_Dispel( target )
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        private function Target_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Target_Data d = GetAttachedInteger(durationTimer, Target_SCOPE_ID)
            call Target_Ending( d, durationTimer, d.target )
            set durationTimer = null
        endfunction

        public function Target_Start takes integer abilityLevel, real bonusSpeed, Unit target returns nothing
            local real duration
            local timer durationTimer
            local integer oldAbilityLevel
            local real oldBonusSpeed
            local integer iteration
            local integer targetId = target.id
            local Target_Data d = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
            local boolean isNew = (d == NULL)
            local unit targetSelf = target.self
            if ( isNew ) then
                set d = Target_Data.create()
                set durationTimer = CreateTimerWJ()
                set iteration = LEVELS_AMOUNT - 1
                set d.abilityLevel = abilityLevel
                set d.target = target
                loop
                    if (iteration == abilityLevel) then
                        set d.durationTimer[iteration] = durationTimer
                    else
                        set d.durationTimer[iteration] = null
                    endif
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                endloop
                call AttachInteger(durationTimer, Target_SCOPE_ID, d)
                call AttachIntegerById(targetId, Target_SCOPE_ID, d)
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DISPEL" )
            else
                set durationTimer = d.durationTimer[abilityLevel]
                if (durationTimer == null) then
                    set durationTimer = CreateTimerWJ()
                    set d.durationTimer[abilityLevel] = durationTimer
                    call AttachInteger(durationTimer, Target_SCOPE_ID, d)
                endif
                set oldAbilityLevel = d.abilityLevel
                set oldBonusSpeed = d.bonusSpeed[oldAbilityLevel - 1]
                call DestroyEffectWJ( d.targetEffect )
            endif
            set d.bonusSpeed[abilityLevel - 1] = bonusSpeed
            set d.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, targetSelf, Target_TARGET_EFFECT_ATTACHMENT_POINT )
            if ( isNew ) then
                call AddUnitSpeedBonus( target, bonusSpeed )
            elseif (abilityLevel >= oldAbilityLevel) then
                set d.abilityLevel = abilityLevel
                call AddUnitSpeedBonus( target, bonusSpeed - oldBonusSpeed )
            endif
            if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
                set duration = Target_HERO_DURATION[abilityLevel]
            else
                set duration = Target_DURATION[abilityLevel]
            endif
            set targetSelf = null
            call TimerStart( durationTimer, duration, false, function Target_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Target_Init takes nothing returns nothing
            set Target_DURATION[1] = 10
            set Target_DURATION[2] = 10
            set Target_DURATION[3] = 10
            set Target_DURATION[4] = 10
            set Target_DURATION[5] = 10
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            //! runtextmacro CreateEvent( "Target_EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_NEGATIVE", "0", "function Target_Dispel_Event" )
            set Target_HERO_DURATION[1] = 5
            set Target_HERO_DURATION[2] = 5
            set Target_HERO_DURATION[3] = 5
            set Target_HERO_DURATION[4] = 5
            set Target_HERO_DURATION[5] = 5
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Ending takes nothing returns nothing
        local real damageAmount
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, AdvertisingGift_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local real bonusSpeed = d.bonusSpeed
        local Unit enumUnit
        local unit enumUnitSelf
        local timer moveTimer = d.moveTimer
        local Unit caster = d.caster
        local unit dummyUnit = d.dummyUnit
        local real targetX = d.targetX
        local real targetY = d.targetY
        local real targetZ = d.targetZ
        call d.destroy()
        call FlushAttachedReal( durationTimer, AdvertisingGift_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call SetUnitX( dummyUnit, targetX )
        call SetUnitY( dummyUnit, targetY )
        call SetUnitZ( dummyUnit, targetX, targetY, targetZ )
        call SetUnitAnimationByIndex( dummyUnit, 0 )
        call RemoveUnitTimed( dummyUnit, 2 )
        set dummyUnit = null
        call FlushAttachedInteger( moveTimer, AdvertisingGift_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        set moveTimer = null
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, targetX, targetY ) )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            set damageAmount = DAMAGE[abilityLevel]
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call Target_Target_Start(abilityLevel, bonusSpeed, enumUnit)
                call UnitDamageUnitBySpell( caster, enumUnit, damageAmount )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
    endfunction

    private function Move takes nothing returns nothing
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, AdvertisingGift_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local real dummyUnitX = GetUnitX(dummyUnit)
        local real dummyUnitY = GetUnitY(dummyUnit)
        local real lengthZ = d.lengthZ + d.lengthZAdd
        local real newX = dummyUnitX + d.lengthX
        local real newY = dummyUnitY + d.lengthY
        local real newZ = GetUnitZ(dummyUnit, dummyUnitX, dummyUnitY) + lengthZ
        set d.lengthZ = lengthZ
        call SetUnitX( dummyUnit, newX )
        call SetUnitY( dummyUnit, newY )
        call SetUnitZ( dummyUnit, newX, newY, newZ )
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local real angle
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster)
        local real ceiling
        local Data d = Data.create()
        local unit dummyUnit
        local real duration = DURATION[abilityLevel]
        local timer durationTimer = CreateTimerWJ()
        local real length
        local real lengthZ
        local timer moveTimer = CreateTimerWJ()
        local real targetZ = GetFloorHeight( targetX, targetY )
        if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
            set length = DistanceByCoordinates( casterX, casterY, targetX, targetY ) / duration * UPDATE_TIME
        else
            set angle = GetUnitFacingWJ( casterSelf )
            set length = 0
        endif
        set casterSelf = null
        if ( casterZ > targetZ ) then
            set ceiling = CEILING + casterZ
        else
            set ceiling = CEILING + targetZ
        endif
        set lengthZ = ( 2 * ceiling + 2 * SquareRoot( ceiling * ( ceiling + casterZ - targetZ ) ) ) / duration * UPDATE_TIME
        set dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, angle )
        set d.abilityLevel = abilityLevel
        set d.bonusSpeed = BONUS_SPEED[abilityLevel] + GetHeroAgilityTotal( caster ) * BONUS_SPEED_PER_AGILITY_POINT[abilityLevel]
        set d.caster = caster
        set d.dummyUnit = dummyUnit
        set d.lengthX = length * Cos(angle)
        set d.lengthY = length * Sin(angle)
        set d.lengthZ = lengthZ
        set d.lengthZAdd = -0.5 * lengthZ * lengthZ / ceiling
        set d.moveTimer = moveTimer
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
        call AttachInteger( durationTimer, AdvertisingGift_SCOPE_ID, d )
        call AttachInteger( moveTimer, AdvertisingGift_SCOPE_ID, d )
        call SetUnitZ( dummyUnit, casterX, casterY, casterZ )
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
        call TimerStart( durationTimer, duration, false, function Ending )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Order takes Unit caster, real targetX, real targetY returns string
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        set AREA_RANGE[1] = 300
        set AREA_RANGE[2] = 300
        set AREA_RANGE[3] = 300
        set AREA_RANGE[4] = 300
        set AREA_RANGE[5] = 300
        set BONUS_SPEED[1] = -50
        set BONUS_SPEED[2] = -70
        set BONUS_SPEED[3] = -90
        set BONUS_SPEED[4] = -105
        set BONUS_SPEED[5] = -120
        set BONUS_SPEED_PER_AGILITY_POINT[1] = -1
        set BONUS_SPEED_PER_AGILITY_POINT[2] = -1
        set BONUS_SPEED_PER_AGILITY_POINT[3] = -1
        set BONUS_SPEED_PER_AGILITY_POINT[4] = -1
        set BONUS_SPEED_PER_AGILITY_POINT[5] = -1
        set DAMAGE[1] = 30
        set DAMAGE[2] = 40
        set DAMAGE[3] = 50
        set DAMAGE[4] = 60
        set DAMAGE[5] = 70
        set ENUM_GROUP = CreateGroupWJ()
        set DURATION[1] = 1.5
        set DURATION[2] = 1.5
        set DURATION[3] = 1.5
        set DURATION[4] = 1.5
        set DURATION[5] = 1.5
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\AdvertisingGift.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Air.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Air")
    globals
        public constant integer SPELL_ID = 'A07V'

        public constant real DAMAGE_FACTOR = 1.
    endglobals

    public function Damage takes Unit caster, real damageAmount, Unit target returns real
        if ( IsUnitType( caster.self, UNIT_TYPE_MELEE_ATTACKER ) ) then
            if ( IsUnitType(target.self, UNIT_TYPE_FLYING) ) then
                set damageAmount = damageAmount * DAMAGE_FACTOR
            endif
        endif
        return damageAmount
    endfunction

    public function Init takes nothing returns nothing
        call InitAbility( SPELL_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Air.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\AirPassage.j
//TESH.scrollpos=5
//TESH.alwaysfold=0
//! runtextmacro Scope("AirPassage")
    globals
        private constant integer ORDER_ID = 852525//OrderId( "blink" )
        public constant integer RESEARCH_ID = 'R01A'
        public constant integer SPELL_ID = 'A08M'

        private constant real DURATION = 2.
    endglobals

    public function EndCast takes Unit caster, real targetX, real targetY returns nothing
        local unit casterSelf = caster.self
        call SetUnitX(casterSelf, targetX)
        call SetUnitY(casterSelf, targetY)
        set casterSelf = null
        call SetUnitStunTimed(caster, 1, DURATION)
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Order takes real targetX, real targetY returns string
        if (IsPointInPlayRegion(targetX, targetY) == false) then
            return ErrorStrings_INVALID_TARGET
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\AirPassage.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ArtilleryAttack.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("ArtilleryAttack")
    globals
        public constant integer SPELL_ID = 'A03Z'

        private constant real UPDATE_TIME = 0.01
    endglobals

    private struct Data
        Unit caster
        unit dummyUnit
        timer durationTimer
        real lengthX
        real lengthY
        real lengthZ
        real lengthZAdd
        timer moveTimer
        real targetX
        real targetY
        real x
        real y
        real z
    endstruct

    private function Impact takes Unit caster, unit dummyUnit, real targetX, real targetY returns nothing
        call SetUnitX( dummyUnit, targetX )
        call SetUnitY( dummyUnit, targetY )
        call SetUnitAnimation( dummyUnit, "death" )
        call RemoveUnitTimed( dummyUnit, 2 )
        set TARGET_X = targetX
        set TARGET_Y = targetY
        set TRIGGER_UNIT = caster
        call RunTrigger(UnitTakesDamage_ArtilleryAttack_ArtilleryAttack_DUMMY_TRIGGER)
    endfunction

    private function Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, ArtilleryAttack_SCOPE_ID)
        local Unit caster = d.caster
        local unit dummyUnit = d.dummyUnit
        local timer moveTimer = d.moveTimer
        local real targetX = d.targetX
        local real targetY = d.targetY
        call d.destroy()
        call FlushAttachedInteger( durationTimer, ArtilleryAttack_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( moveTimer, ArtilleryAttack_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        set moveTimer = null
        call Impact( caster, dummyUnit, targetX, targetY )
        set dummyUnit = null
        call RemoveUnitRemainingReference( caster )
    endfunction

    private function Move takes nothing returns nothing
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, ArtilleryAttack_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local real lengthZ = d.lengthZ + d.lengthZAdd
        local real x = d.x + d.lengthX
        local real y = d.y + d.lengthY
        local real z = d.z + d.lengthZ
        set moveTimer = null
        set d.lengthZ = lengthZ
        set d.x = x
        set d.y = y
        set d.z = z
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        set dummyUnit = null
    endfunction

    public function Damage takes Unit caster, Unit target returns nothing
        local real angleXYZ
        local unit casterSelf = caster.self
        local real casterTargetAngle
        local UnitType casterType
        local real casterX
        local real casterY
        local real casterZ
        local Data d
        local real distance
        local real distanceX
        local real distanceY
        local unit dummyUnit
        local real duration
        local timer durationTimer
        local real length
        local real lengthX
        local real lengthY
        local real lengthZ
        local real lengthZAdd
        local timer moveTimer
        local unit targetSelf
        local real targetX
        local real targetY
        local integer wavesAmount
        if ( GetUnitAbilityLevel( casterSelf, SPELL_ID ) > 0 ) then
            set casterType = caster.type
            set casterX = GetUnitX( casterSelf )
            set casterY = GetUnitY( casterSelf )
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set distanceX = targetX - casterX
            set targetY = GetUnitY( targetSelf )
            set targetSelf = null
            set distanceY = targetY - casterY
            set casterTargetAngle = Atan2( distanceY, distanceX )
            set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, GetUnitTypeMissileDummyUnitId(casterType), casterX, casterY, casterTargetAngle )
            if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
                set casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster)
                set d = Data.create()
                set distance = SquareRoot( distanceX * distanceX + distanceY * distanceY )
                set durationTimer = CreateTimerWJ()
                set angleXYZ = GetUnitTypeMissileArc(casterType)
                set length = GetUnitTypeMissileSpeed(casterType) * UPDATE_TIME
                set lengthZ = Sin( angleXYZ ) * length
                set moveTimer = CreateTimerWJ()
                set duration = distance / length * UPDATE_TIME / Cos( angleXYZ )
                set lengthZAdd = ( GetFloorHeight( targetX, targetY ) - casterZ - Tan( angleXYZ ) * distance ) * 2 * length * length * Cos( angleXYZ ) * Cos( angleXYZ ) / distance / distance
                set wavesAmount = R2I(duration / UPDATE_TIME)
                set lengthX = distanceX / wavesAmount
                set lengthY = distanceY / wavesAmount
                set d.caster = caster
                set d.dummyUnit = dummyUnit
                set d.lengthX = lengthX
                set d.lengthY = lengthY
                set d.lengthZ = lengthZ
                set d.lengthZAdd = lengthZAdd
                set d.moveTimer = moveTimer
                set d.targetX = targetX
                set d.targetY = targetY
                set d.x = casterX
                set d.y = casterY
                set d.z = casterZ
                call AttachInteger( durationTimer, ArtilleryAttack_SCOPE_ID, d )
                call AttachInteger( moveTimer, ArtilleryAttack_SCOPE_ID, d )
                call AddUnitRemainingReference( caster )
                call SetUnitZ( dummyUnit, casterX, casterY, casterZ )
                call SetUnitAnimation( dummyUnit, "stand" )
                set dummyUnit = null
                call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
                set moveTimer = null
                call TimerStart( durationTimer, duration, false, function Ending )
                set durationTimer = null
            else
                call Impact( caster, dummyUnit, targetX, targetY )
            endif
        endif
        set casterSelf = null
    endfunction

    public function Init takes nothing returns nothing
        call InitAbility( SPELL_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ArtilleryAttack.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\AttackDerivation.j
//TESH.scrollpos=253
//TESH.alwaysfold=0
//! runtextmacro Scope("AttackDerivation")
    globals
        public constant integer RESEARCH_ID = 'R01G'
        public constant integer SPELL_ID = 'A00I'

        private constant real AREA_RANGE = 350.
        private constant integer DUMMY_UNIT_ID = 'h00J'
        private group ENUM_GROUP
        private constant real RELATIVE_DAMAGE = 0.25
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 0.1
        private constant real LENGTH = 1000 * UPDATE_TIME

        private boolean IS_NEXT_ATTACK = false
    endglobals

    private struct Data
        Unit caster
        real damageAmount
        unit dummyUnit
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        real x
        real y
        real z
    endstruct

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId = caster.id
        if (GetAttachedBooleanById(casterId, AttackDerivation_SCOPE_ID)) then
            call FlushAttachedBooleanById(casterId, AttackDerivation_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( DYING_UNIT )
    endfunction

    private function Ending takes Unit caster, Data d, unit dummyUnit, boolean isTargetNotNull, timer moveTimer, Unit target returns nothing
        local integer targetId
        call d.destroy()
        call RemoveUnitRemainingReference( caster )
        call SetUnitAnimationByIndex( dummyUnit, 1 )
        call RemoveUnitTimed( dummyUnit, 2 )
        call FlushAttachedInteger( moveTimer, AttackDerivation_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        if ( isTargetNotNull ) then
            set targetId = target.id
            call RemoveIntegerFromTableById( targetId, AttackDerivation_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, AttackDerivation_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
            endif
        endif
    endfunction

    private function Death_ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        set d.target = NULL
        call RemoveIntegerFromTableById( targetId, AttackDerivation_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, AttackDerivation_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, AttackDerivation_SCOPE_ID )
        if ( iteration > -1 ) then
            loop
                set d = GetIntegerFromTableById( targetId, AttackDerivation_SCOPE_ID, iteration )
                call Death_ResetTarget( d, target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function TargetConditions_Single takes player casterOwner, unit checkingUnit returns boolean
        if ( IsUnitAlly( checkingUnit, casterOwner ) ) then
            return false
        endif
        return true
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local Unit caster
        local player casterOwner
        local real damageAmount
        local real distanceX
        local real distanceY
        local real distanceZ
        local boolean isTargetNotNull
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, AttackDerivation_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local boolean reachesTarget
        local Unit target = d.target
        local boolean isTargetNull = ( target == null )
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        local real x = d.x
        local real y = d.y
        local real z = d.z
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( x, y, z, targetX, targetY, targetZ ) <= LENGTH )
        if ( reachesTarget ) then
            set x = targetX
            set y = targetY
            set z = targetZ
        else
            set distanceZ = targetZ - z
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, targetX, targetY ) )
            set distanceX = targetX - x
            set distanceY = targetY - y
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = LENGTH * Cos( angleLengthXYZ )
            set x = x + lengthXY * Cos( angleXY )
            set y = y + lengthXY * Sin( angleXY )
            set z = z + LENGTH * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        if ( reachesTarget ) then
            set caster = d.caster
            set isTargetNotNull = ( isTargetNull == false )
            if ( isTargetNotNull ) then
                set damageAmount = d.damageAmount
            endif
            call Ending( caster, d, dummyUnit, isTargetNotNull, moveTimer, target )
            if ( isTargetNotNull ) then
                if ( TargetConditions_Single( caster.owner, targetSelf ) ) then
                    set IS_NEXT_ATTACK = true
                    call UnitDamageUnitEx( caster, target, damageAmount, null )
                endif
            endif
        else
            set d.x = x
            set d.y = y
            set d.z = z
        endif
        set moveTimer = null
        set targetSelf = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( FILTER_UNIT_SELF == TEMP_UNIT_SELF ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        return TargetConditions_Single( TEMP_PLAYER, FILTER_UNIT_SELF )
    endfunction

    public function Damage takes Unit caster, real damageAmount, Unit target returns nothing
        local unit casterSelf
        local Data d
        local unit dummyUnit
        local Unit enumUnit
        local integer enumUnitId
        local unit enumUnitSelf
        local timer moveTimer
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        if ( IS_NEXT_ATTACK ) then
            set IS_NEXT_ATTACK = false
        else
            if ( GetAttachedBooleanById( caster.id, AttackDerivation_SCOPE_ID ) ) then
                set targetSelf = target.self
                set targetX = GetUnitX( targetSelf )
                set targetY = GetUnitY( targetSelf )
                set TEMP_PLAYER = caster.owner
                set TEMP_UNIT_SELF = targetSelf
                call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE, TARGET_CONDITIONS )
                set enumUnitSelf = GetNearestUnit( ENUM_GROUP, targetX, targetY )
                if ( enumUnitSelf != null ) then
                    set casterSelf = caster.self
                    set d = Data.create()
                    set dummyUnit = CreateUnitWJ(NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, targetX, targetY, Atan2(targetY - GetUnitY(casterSelf), targetX - GetUnitX(casterSelf)))
                    set casterSelf = null
                    set enumUnit = GetUnit(enumUnitSelf)
                    set enumUnitId = enumUnit.id
                    set enumUnitSelf = null
                    set moveTimer = CreateTimerWJ()
                    set targetZ = GetUnitZ(targetSelf, targetX, targetY) + GetUnitOutpactZ(target)
                    set d.caster = caster
                    set d.damageAmount = damageAmount * RELATIVE_DAMAGE
                    set d.dummyUnit = dummyUnit
                    set d.moveTimer = moveTimer
                    set d.target = enumUnit
                    set d.x = targetX
                    set d.y = targetY
                    set d.z = targetZ
                    call AddUnitRemainingReference( caster )
                    call AttachInteger( moveTimer, AttackDerivation_SCOPE_ID, d )
                    call AddIntegerToTableById( enumUnitId, AttackDerivation_SCOPE_ID, d )
                    if ( CountIntegersInTableById( enumUnitId, AttackDerivation_SCOPE_ID ) == TABLE_STARTED ) then
                        //! runtextmacro AddEventById( "enumUnitId", "EVENT_DEATH" )
                    endif
                    call SetUnitZ(dummyUnit, targetX, targetY, targetZ)
                    set dummyUnit = null
                    call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
                    set moveTimer = null
                endif
                set targetSelf = null
            endif
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, AttackDerivation_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call SetAbilityRequiredResearch( SPELL_ID, RESEARCH_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\AttackDerivation.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\AxeMaster.j
//TESH.scrollpos=31
//TESH.alwaysfold=0
//! runtextmacro Scope("AxeMaster")
    globals
        public constant integer SPELL_ID = 'A00H'

        private real array BONUS_CRITICAL_STRIKE
        private real array BONUS_DAMAGE
    endglobals

    private struct Data
        integer abilityLevel
    endstruct

    public function Learn takes Unit caster returns nothing
        local integer abilityLevel = GetUnitAbilityLevel(caster.self, SPELL_ID)
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, AxeMaster_SCOPE_ID)
        local boolean isNew = (d == NULL)
        local integer oldAbilityLevel
        if (isNew) then
            set d = Data.create()
            call AttachIntegerById(casterId, AxeMaster_SCOPE_ID, d)
        else
            set oldAbilityLevel = d.abilityLevel
        endif
        set d.abilityLevel = abilityLevel
        if (isNew) then
            call AddUnitCriticalStrike( caster, BONUS_CRITICAL_STRIKE[abilityLevel] )
            call AddUnitDamageBonus( caster, BONUS_DAMAGE[abilityLevel] )
        else
            call AddUnitCriticalStrike( caster, BONUS_CRITICAL_STRIKE[abilityLevel] - BONUS_CRITICAL_STRIKE[oldAbilityLevel] )
            call AddUnitDamageBonus( caster, BONUS_DAMAGE[abilityLevel] - BONUS_DAMAGE[oldAbilityLevel] )
        endif
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set BONUS_DAMAGE[1] = 3
        set BONUS_DAMAGE[2] = 6
        set BONUS_DAMAGE[3] = 9
        set BONUS_DAMAGE[4] = 12
        set BONUS_DAMAGE[5] = 15
        set BONUS_CRITICAL_STRIKE[1] = 0.2
        set BONUS_CRITICAL_STRIKE[2] = 0.24
        set BONUS_CRITICAL_STRIKE[3] = 0.28
        set BONUS_CRITICAL_STRIKE[4] = 0.32
        set BONUS_CRITICAL_STRIKE[5] = 0.36
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\AxeMaster.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Barrage.j
//TESH.scrollpos=249
//TESH.alwaysfold=0
//! runtextmacro Scope("Barrage")
    globals
        private constant integer ORDER_ID = 852089//OrderId( "blizzard" )
        public constant integer SPELL_ID = 'A01U'

        private real array DAMAGE
        private real array DAMAGE_PER_STRENGTH_POINT
        private real array DURATION
        private real array EXPLOSION_DAMAGE
        private real array INTERVAL
        private constant integer LEVELS_AMOUNT = 5
        private constant real MINIMUM_RANGE = 300.
        private integer array WAVES_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        real damageAmount
        timer durationTimer
        real explosionDamageAmount
        timer intervalTimer
        integer remainingArrowsAmount
        real targetX
        real targetY
    endstruct

    private function Ending takes Unit caster, Data d, timer intervalTimer returns nothing
        local timer durationTimer = d.durationTimer
        call d.destroy()
        call FlushAttachedIntegerById( caster.id, Barrage_SCOPE_ID )
        call FlushAttachedInteger( durationTimer, Barrage_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( intervalTimer, Barrage_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        call SetUnitAnimationByIndex( caster.self, 0 )
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Barrage_SCOPE_ID)
        local timer intervalTimer
        if ( d != NULL ) then
            set intervalTimer = d.intervalTimer
            call PauseTimer( intervalTimer )
            if ( d.remainingArrowsAmount == 0 ) then
                call Ending( caster, d, intervalTimer )
            endif
            set intervalTimer = null
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Barrage_SCOPE_ID)
        set durationTimer = null
        call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
    endfunction

    //! runtextmacro Scope("Explosion")
        globals
            private real array Explosion_AREA_RANGE
            private real array Explosion_DAMAGE_REDUCTION_FACTOR
            private constant string Explosion_SPECIAL_EFFECT_PATH = "Abilities\\Weapons\\SteamTank\\SteamTankImpact.mdl"
            private boolexpr Explosion_TARGET_CONDITIONS

            private Data Explosion_D = NULL
        endglobals

        private function Explosion_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( FILTER_UNIT_SELF == TEMP_UNIT_SELF ) then
                return false
            endif
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
                return false
            endif
            if ( GetUnitInvulnerability( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
                return false
            endif
            return true
        endfunction

        public function Explosion_Ending takes nothing returns nothing
            set Explosion_D = NULL
        endfunction

        public function Explosion_Start takes Data d returns nothing
            set Explosion_D = d
        endfunction

        public function Explosion_BeforeDying takes Unit caster, Unit target returns nothing
            local integer abilityLevel
            local Data d
            local group enumGroup
            local unit enumUnit
            local unit targetSelf
            local real targetX
            local real targetY
            if ( Explosion_D != NULL ) then
                set d = Explosion_D
                set abilityLevel = d.abilityLevel
                set enumGroup = CreateGroupWJ()
                set targetSelf = target.self
                set targetX = GetUnitX( targetSelf )
                set targetY = GetUnitY( targetSelf )
                call DestroyEffectWJ( AddSpecialEffectWJ( Explosion_SPECIAL_EFFECT_PATH, targetX, targetY ) )
                set d.explosionDamageAmount = d.explosionDamageAmount * Explosion_DAMAGE_REDUCTION_FACTOR[abilityLevel]
                call AddUnitExplode( target )
                set TEMP_PLAYER = caster.owner
                set TEMP_UNIT_SELF = targetSelf
                set targetSelf = null
                call GroupEnumUnitsInRangeWithCollision( enumGroup, targetX, targetY, Explosion_AREA_RANGE[abilityLevel], Explosion_TARGET_CONDITIONS )
                set enumUnit = FirstOfGroup( enumGroup )
                if ( enumUnit != null ) then
                    loop
                        call GroupRemoveUnit( enumGroup, enumUnit )
                        call Explosion_Start(d)
                        call UnitDamageUnitEx( caster, GetUnit(enumUnit), d.explosionDamageAmount, null )
                        call Explosion_Ending()
                        set enumUnit = FirstOfGroup( enumGroup )
                        exitwhen ( enumUnit == null )
                    endloop
                endif
                call DestroyGroupWJ(enumGroup)
                set enumGroup = null
            endif
        endfunction

        public function Explosion_Init takes nothing returns nothing
            set Explosion_AREA_RANGE[1] = 150
            set Explosion_AREA_RANGE[2] = 150
            set Explosion_AREA_RANGE[3] = 150
            set Explosion_AREA_RANGE[4] = 150
            set Explosion_AREA_RANGE[5] = 150
            set Explosion_DAMAGE_REDUCTION_FACTOR[1] = 0.8
            set Explosion_DAMAGE_REDUCTION_FACTOR[2] = 0.8
            set Explosion_DAMAGE_REDUCTION_FACTOR[3] = 0.8
            set Explosion_DAMAGE_REDUCTION_FACTOR[4] = 0.8
            set Explosion_DAMAGE_REDUCTION_FACTOR[5] = 0.8
            call InitEffectType( Explosion_SPECIAL_EFFECT_PATH )
            set Explosion_TARGET_CONDITIONS = ConditionWJ( function Explosion_TargetConditions )
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Arrow")
        globals
            private real array Arrow_AREA_RANGE
            private constant integer Arrow_DUMMY_UNIT_ID = 'h00H'
            private group Arrow_ENUM_GROUP
            private constant real HIT_RANGE = 120.
            private boolexpr Arrow_TARGET_CONDITIONS
            private constant string Arrow_TARGET_EFFECT_PATH = "Abilities\\Weapons\\LavaSpawnMissile\\LavaSpawnBirthMissile.mdl"
            private constant string Arrow_TARGET_EFFECT2_PATH = "Abilities\\Spells\\Human\\FlakCannons\\FlakTarget.mdl"
        endglobals

        private struct Arrow_Data
            Data d
            real targetX
            real targetY
        endstruct

        private function Arrow_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( FILTER_UNIT_SELF == WORLD_CASTER ) then
                return false
            endif
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
                return false
            endif
            if ( GetUnitInvulnerability( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
                return false
            endif
            return true
        endfunction

        private function Arrow_ExplosionConditions takes Unit checkingUnit returns boolean
            set TEMP_UNIT_SELF = checkingUnit.self
            if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_HERO ) ) then
                return false
            endif
            if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
                return false
            endif
            if ( IsUnitWard( checkingUnit ) ) then
                return false
            endif
            return true
        endfunction

        private function Arrow_ImpactTrig takes nothing returns nothing
            local integer abilityLevel
            local Unit caster
            local Data d
            local Arrow_Data e
            local real damageAmount
            local unit dummyUnit = GetEventDamageSource()
            local Unit enumUnit
            local unit enumUnitSelf
            local real explosionDamageAmount
            local real explosionDamageAmountStart
            local real explosionDamageReductionFactor
            local integer remainingArrowsAmount
            local real targetX
            local real targetY
            if ( GetUnitTypeId( dummyUnit ) == Arrow_DUMMY_UNIT_ID ) then
                set e = GetAttachedInteger(dummyUnit, Arrow_SCOPE_ID)
                set d = e.d
                set abilityLevel = d.abilityLevel
                set caster = d.caster
                set damageAmount = d.damageAmount
                set explosionDamageAmountStart = d.explosionDamageAmount
                set explosionDamageAmount = explosionDamageAmountStart
                set remainingArrowsAmount = d.remainingArrowsAmount - 1
                set targetX = e.targetX
                set targetY = e.targetY
                call e.destroy()
                call FlushAttachedInteger( dummyUnit, Arrow_SCOPE_ID )
                call RemoveUnitWJ( dummyUnit )
                call DestroyEffectWJ( AddSpecialEffectWJ( Arrow_TARGET_EFFECT_PATH, targetX, targetY ) )
                call DestroyEffectWJ( AddSpecialEffectWJ( Arrow_TARGET_EFFECT2_PATH, targetX, targetY ) )
                set TEMP_PLAYER = caster.owner
                call GroupEnumUnitsInRangeWithCollision( Arrow_ENUM_GROUP, targetX, targetY, HIT_RANGE, Arrow_TARGET_CONDITIONS )
                set enumUnitSelf = FirstOfGroup( Arrow_ENUM_GROUP )
                if (enumUnitSelf != null) then
                    loop
                        set enumUnit = GetUnit(enumUnitSelf)
                        call GroupRemoveUnit( Arrow_ENUM_GROUP, enumUnitSelf )
                        if ( Arrow_ExplosionConditions( enumUnit ) ) then
                            call Explosion_Explosion_Start(d)
                            call UnitDamageUnitEx( caster, enumUnit, damageAmount, null )
                            call Explosion_Explosion_Ending()
                        endif
                        set enumUnitSelf = FirstOfGroup( Arrow_ENUM_GROUP )
                        exitwhen ( enumUnitSelf == null )
                    endloop
                endif
                set enumUnitSelf = null
                if ( remainingArrowsAmount == 0 ) then
                    call Ending( caster, d, d.intervalTimer )
                else
                    set d.remainingArrowsAmount = remainingArrowsAmount
                endif
            endif
        endfunction

        public function Arrow_Start takes integer abilityLevel, Unit caster, Data d, real targetX, real targetY returns nothing
            local real angle = GetRandomReal( 0, 2 * PI )
            local unit casterSelf = caster.self
            local real casterX = GetUnitX( casterSelf )
            local real casterY = GetUnitY( casterSelf )
            local unit dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, Arrow_DUMMY_UNIT_ID, casterX, casterY, angle )
            local Arrow_Data e = Arrow_Data.create()
            local real length = GetRandomReal(0, Arrow_AREA_RANGE[abilityLevel])
            set targetX = targetX + length * Cos( angle )
            set targetY = targetY + length * Sin( angle )
            if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
                set angle = Atan2( targetY - casterY, targetX - casterX )
            else
                set angle = GetUnitFacingWJ( casterSelf )
            endif
            set e.d = d
            set e.targetX = targetX
            set e.targetY = targetY
            call AttachInteger(dummyUnit, Arrow_SCOPE_ID, e)
            call SetUnitZ( dummyUnit, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster) )
            call IssuePointOrderById( dummyUnit, ATTACK_GROUND_ORDER_ID, targetX, targetY )
            set dummyUnit = null
            call SetUnitFacingWJ( casterSelf, angle )
            call SetUnitAnimationByIndex( casterSelf, 5 )
            set casterSelf = null
        endfunction

        public function Arrow_Init takes nothing returns nothing
            local trigger damageTrigger = CreateTriggerWJ()
            set Arrow_AREA_RANGE[1] = 175
            set Arrow_AREA_RANGE[2] = 250
            set Arrow_AREA_RANGE[3] = 250
            set Arrow_AREA_RANGE[4] = 250
            set Arrow_AREA_RANGE[5] = 250
            set Arrow_ENUM_GROUP = CreateGroupWJ()
            set Arrow_TARGET_CONDITIONS = ConditionWJ( function Arrow_TargetConditions )
            call AddTriggerCode( damageTrigger, function Arrow_ImpactTrig )
            call TriggerRegisterUnitEvent( damageTrigger, WORLD_CASTER, EVENT_UNIT_DAMAGED )
            set damageTrigger = null
            call InitUnitType( Arrow_DUMMY_UNIT_ID )
            call InitEffectType( Arrow_TARGET_EFFECT_PATH )
            call InitEffectType( Arrow_TARGET_EFFECT2_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function NewTargetByTimer takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, Barrage_SCOPE_ID)
        set intervalTimer = null
        call Arrow_Arrow_Start( d.abilityLevel, d.caster, d, d.targetX, d.targetY )
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.damageAmount = DAMAGE[abilityLevel] + GetHeroStrengthTotal( caster ) * DAMAGE_PER_STRENGTH_POINT[abilityLevel]
        set d.durationTimer = durationTimer
        set d.explosionDamageAmount = EXPLOSION_DAMAGE[abilityLevel]
        set d.intervalTimer = intervalTimer
        set d.remainingArrowsAmount = WAVES_AMOUNT[abilityLevel]
        set d.targetX = targetX
        set d.targetY = targetY
        call AttachIntegerById( caster.id, Barrage_SCOPE_ID, d )
        call AttachInteger( durationTimer, Barrage_SCOPE_ID, d )
        call AttachInteger( intervalTimer, Barrage_SCOPE_ID, d )
        call TimerStart( intervalTimer, INTERVAL[abilityLevel], true, function NewTargetByTimer )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function EndingByTimer )
        set durationTimer = null
        call Arrow_Arrow_Start( abilityLevel, caster, d, targetX, targetY )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    private function Order_CancelConditions takes Unit caster, real targetX, real targetY returns boolean
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        set casterSelf = null
        if ( DistanceByCoordinates( casterX, casterY, targetX, targetY ) > MINIMUM_RANGE ) then
            return false
        endif
        return true
    endfunction

    public function Order takes Unit caster, real targetX, real targetY returns string
        if ( Order_CancelConditions( caster, targetX, targetY ) ) then
            return ErrorStrings_TARGET_TOO_CLOSE
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set DAMAGE[1] = 10
        set DAMAGE[2] = 14
        set DAMAGE[3] = 18
        set DAMAGE[4] = 22
        set DAMAGE[5] = 25
        set DAMAGE_PER_STRENGTH_POINT[1] = 0.125
        set DAMAGE_PER_STRENGTH_POINT[2] = 0.125
        set DAMAGE_PER_STRENGTH_POINT[3] = 0.125
        set DAMAGE_PER_STRENGTH_POINT[4] = 0.125
        set DAMAGE_PER_STRENGTH_POINT[5] = 0.125
        set EXPLOSION_DAMAGE[1] = 40
        set EXPLOSION_DAMAGE[2] = 40
        set EXPLOSION_DAMAGE[3] = 40
        set EXPLOSION_DAMAGE[4] = 40
        set EXPLOSION_DAMAGE[5] = 40
        set INTERVAL[1] = 0.1
        set INTERVAL[2] = 0.1
        set INTERVAL[3] = 0.1
        set INTERVAL[4] = 0.1
        set INTERVAL[5] = 0.1
        set WAVES_AMOUNT[1] = 28
        set WAVES_AMOUNT[2] = 32
        set WAVES_AMOUNT[3] = 35
        set WAVES_AMOUNT[4] = 38
        set WAVES_AMOUNT[5] = 40
        loop
            set DURATION[iteration] = (WAVES_AMOUNT[iteration] - 1) * INTERVAL[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Arrow_Arrow_Init()
        call Explosion_Explosion_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Barrage.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Bash.j
//TESH.scrollpos=123
//TESH.alwaysfold=0
//! runtextmacro Scope("Bash")
    //! runtextmacro Scope("Zombie")
        globals
            public constant integer Zombie_SPELL_ID = 'A00X'

            private constant real Zombie_CHANCE = 0.25
            private constant real Zombie_DURATION = 2.
            private constant real Zombie_HERO_DURATION = 1.
        endglobals

        public function Zombie_Death takes Unit caster returns nothing
            local integer casterId
            if ( GetUnitAbilityLevel( caster.self, Zombie_SPELL_ID ) > 0 ) then
                set casterId = caster.id
                //! runtextmacro RemoveEventById( "casterId", "Zombie_EVENT_DEATH" )
                //! runtextmacro RemoveEventById( "casterId", "Zombie_EVENT_DAMAGE" )
            endif
        endfunction

        private function Zombie_Death_Event takes nothing returns nothing
            call Zombie_Death( DYING_UNIT )
        endfunction

        private function Zombie_Damage_Conditions takes unit caster, Unit target returns boolean
            if ( GetUnitAbilityLevel( caster, Zombie_SPELL_ID ) <= 0 ) then
                return false
            endif
            if ( IsUnitType( target.self, UNIT_TYPE_STRUCTURE ) ) then
                return false
            endif
            if ( IsUnitWard( target ) ) then
                return false
            endif
            if ( GetRandomReal( 0.01, 1 ) > Zombie_CHANCE ) then
                return false
            endif
            return true
        endfunction

        public function Zombie_Damage takes Unit caster, Unit target returns nothing
            local real duration
            if ( Zombie_Damage_Conditions( caster.self, target ) ) then
                if ( IsUnitType( target.self, UNIT_TYPE_HERO ) ) then
                    set duration = Zombie_HERO_DURATION
                else
                    set duration = Zombie_DURATION
                endif
                call SetUnitStunTimed( target, 1, duration )
            endif
        endfunction

        private function Zombie_Damage_Event takes nothing returns nothing
            call Zombie_Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
        endfunction

        public function Zombie_Learn takes Unit caster returns nothing
            local integer casterId = caster.id
            //! runtextmacro AddEventById( "casterId", "Zombie_EVENT_DAMAGE" )
            //! runtextmacro AddEventById( "casterId", "Zombie_EVENT_DEATH" )
        endfunction

        private function Zombie_Learn_Event takes nothing returns nothing
            call Zombie_Learn( LEARNER )
        endfunction

        public function Zombie_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Zombie_EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Zombie_Damage_Event" )
            //! runtextmacro CreateEvent( "Zombie_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Zombie_Death_Event" )
            call InitAbility( Zombie_SPELL_ID )
            call AddNewEventById( Zombie_SPELL_ID, UnitLearnsSkill_EVENT_KEY, 0, function Zombie_Learn_Event )
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("OgreBrat")
        globals
            public constant integer OgreBrat_SPELL_ID = 'A02D'

            private constant real OgreBrat_CHANCE = 0.25
            private constant real OgreBrat_DURATION = 2.5
            private constant real OgreBrat_HERO_DURATION = 1.5
        endglobals

        public function OgreBrat_Death takes Unit caster returns nothing
            local integer casterId
            if ( GetUnitAbilityLevel( caster.self, OgreBrat_SPELL_ID ) > 0 ) then
                set casterId = caster.id
                //! runtextmacro RemoveEventById( "casterId", "OgreBrat_EVENT_DAMAGE" )
                //! runtextmacro RemoveEventById( "casterId", "OgreBrat_EVENT_DEATH" )
            endif
        endfunction

        private function OgreBrat_Death_Event takes nothing returns nothing
            call OgreBrat_Death( DYING_UNIT )
        endfunction

        private function OgreBrat_Damage_Conditions takes unit caster, Unit target returns boolean
            if ( GetUnitAbilityLevel( caster, OgreBrat_SPELL_ID ) <= 0 ) then
                return false
            endif
            if ( IsUnitType( target.self, UNIT_TYPE_STRUCTURE ) ) then
                return false
            endif
            if ( IsUnitWard( target ) ) then
                return false
            endif
            if ( GetRandomReal( 0.01, 1 ) > OgreBrat_CHANCE ) then
                return false
            endif
            return true
        endfunction

        public function OgreBrat_Damage takes Unit caster, Unit target returns nothing
            local real duration
            if ( OgreBrat_Damage_Conditions( caster.self, target ) ) then
                if ( IsUnitType( target.self, UNIT_TYPE_HERO ) ) then
                    set duration = OgreBrat_HERO_DURATION
                else
                    set duration = OgreBrat_DURATION
                endif
                call SetUnitStunTimed( target, 1, duration )
            endif
        endfunction

        private function OgreBrat_Damage_Event takes nothing returns nothing
            call OgreBrat_Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
        endfunction

        public function OgreBrat_Learn takes Unit caster returns nothing
            local integer casterId = caster.id
            //! runtextmacro AddEventById( "casterId", "OgreBrat_EVENT_DAMAGE" )
            //! runtextmacro AddEventById( "casterId", "OgreBrat_EVENT_DEATH" )
        endfunction

        private function OgreBrat_Learn_Event takes nothing returns nothing
            call OgreBrat_Learn( LEARNER )
        endfunction

        public function OgreBrat_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "OgreBrat_EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function OgreBrat_Damage_Event" )
            //! runtextmacro CreateEvent( "OgreBrat_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function OgreBrat_Death_Event" )
            call InitAbility( OgreBrat_SPELL_ID )
            //! runtextmacro AddNewEventById( "OgreBrat_EVENT_LEARN", "OgreBrat_SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function OgreBrat_Learn_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        call OgreBrat_OgreBrat_Init()
        call Zombie_Zombie_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Bash.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\BattleGolem.j
//TESH.scrollpos=15
//TESH.alwaysfold=0
//! runtextmacro Scope("BattleGolem")
    globals
        private constant integer ORDER_ID = 852658//OrderId( "summonfactory" )
        public constant integer SPELL_ID = 'A032'
    endglobals

    private function Release takes nothing returns nothing
        local integer ReleaseTimer = GetExpiredTimerWJ()
        local integer Golem = GetAttachedInteger( ReleaseTimer, "Golem" )
        call FlushAttachedInteger( ReleaseTimer, "Golem" )
        call DestroyTimerWJ( ReleaseTimer )
        call SetUnitPauseWJ( Golem, false )
        call SetUnitInvulnerabilityWJ( Golem, false )
        call SetUnitBlendTimeWJ( Golem, 0.15 )
        call SetUnitAnimationByIndexWJ( Golem, 0 )
        call UnitApplyTimedLifeWJ( Golem, GetAttachedReal( BattleGolem_Id(), "Duration" ) )
    endfunction

    public function SpellEffect takes integer Caster returns nothing
        local integer AbilityLevel = GetUnitAbilityLevelWJ( Caster, BattleGolem_Id() )
        local real CasterAngle = GetUnitFacingWJ( Caster )
        local real CasterX = GetUnitXWJ( Caster )
        local real CasterY = GetUnitYWJ( Caster )
        local integer Golem = CreateUnitEx( GetOwningPlayerWJ( Caster ), GetAttachedInteger( BattleGolem_Id(), "UnitTypeId" + I2S( AbilityLevel ) ), CasterX, CasterY, CasterAngle )
        local integer ReleaseTimer = CreateTimerWJ()
        call DestroyEffectWJ( AddSpecialEffectWJ( GetAttachedString( BattleGolem_Id(), "GraphicSpecial" ), GetUnitXWJ( Golem ), GetUnitYWJ( Golem ) ) )
        call SetUnitBlendTimeWJ( Golem, 0 )
        call SetUnitAnimationByIndexWJ( Golem, 9 )
        call SetUnitPauseWJ( Golem, true )
        call SetUnitInvulnerabilityWJ( Golem, true )
        call AttachInteger( ReleaseTimer, "Golem", Golem )
        call TimerStartWJ( ReleaseTimer, GetAttachedReal( BattleGolem_Id(), "ReleaseTime" ), false, function BattleGolem_Release )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call BattleGolem_SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local string GraphicSpecial = "Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl"
        call AttachReal( BattleGolem_Id(), "Duration", 120 )
        call AttachString( BattleGolem_Id(), "GraphicSpecial", GraphicSpecial )
        call AttachReal( BattleGolem_Id(), "ReleaseTime", 1.634 )
        call AttachInteger( BattleGolem_Id(), "UnitTypeId1", 'n018' )
        call AttachInteger( BattleGolem_Id(), "UnitTypeId2", 'n019' )
        call AttachInteger( BattleGolem_Id(), "UnitTypeId3", 'n01A' )
        call InitEffectType( GraphicSpecial )
        call AddOrderAbility( BattleGolem_OrderId(), BattleGolem_Id() )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\BattleGolem.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Berserk.j
//TESH.scrollpos=104
//TESH.alwaysfold=0
//! runtextmacro Scope("Berserk")
    globals
        private constant integer ORDER_ID = 852100//OrderId( "berserk" )
        public constant integer RESEARCH_ID = 'R017'
        public constant integer SPELL_ID = 'A084'

        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Orc\\TrollBerserk\\HeadhunterWEAPONSLeft.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "hand left"
        private constant string CASTER_EFFECT2_PATH = "Abilities\\Spells\\Orc\\TrollBerserk\\HeadhunterWEAPONSRight.mdl"
        private constant string CASTER_EFFECT2_ATTACHMENT_POINT = "hand right"
        private constant real DAMAGE_FACTOR = 1.5
        private constant real DURATION = 20.
        private constant real RELATIVE_BONUS_ATTACK_RATE = 0.75
    endglobals

    private struct Data
        Unit caster
        effect casterEffect
        effect casterEffect2
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local effect casterEffect = d.casterEffect
        local effect casterEffect2 = d.casterEffect2
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById( casterId, Berserk_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DISPEL" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call DestroyEffectWJ( casterEffect2 )
        set casterEffect2 = null
        call FlushAttachedInteger( durationTimer, Berserk_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call AddUnitAttackRate( caster, -RELATIVE_BONUS_ATTACK_RATE )
    endfunction

    public function Dispel takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Berserk_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit caster returns nothing
        call Dispel( caster )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Berserk_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    public function Damage takes Unit caster, real damageAmount returns real
        if ((GetAttachedIntegerById(caster.id, Berserk_SCOPE_ID) != NULL)) then
            return (damageAmount * DAMAGE_FACTOR)
        endif
        return damageAmount
    endfunction

    private function Damage_Event takes nothing returns nothing
        set DAMAGE_AMOUNT = Damage(TRIGGER_UNIT, DAMAGE_AMOUNT)
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local Data d = GetAttachedIntegerById(casterId, Berserk_SCOPE_ID)
        local timer durationTimer
        local boolean isNew = (d == NULL)
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById(casterId, Berserk_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_DISPEL" )
            call AttachInteger(durationTimer, Berserk_SCOPE_ID, d)
        else
            set durationTimer = d.durationTimer
            call DestroyEffectWJ( d.casterEffect )
            call DestroyEffectWJ( d.casterEffect2 )
        endif
        set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
        set d.casterEffect2 = AddSpecialEffectTargetWJ( CASTER_EFFECT2_PATH, casterSelf, CASTER_EFFECT2_ATTACHMENT_POINT )
        set casterSelf = null
        if (isNew) then
            call AddUnitAttackRate( caster, RELATIVE_BONUS_ATTACK_RATE )
        endif
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_FOR_DAMAGE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitEffectType( CASTER_EFFECT2_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Berserk.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\BlastFurnace.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("BlastFurnace")
    globals
        private constant integer ORDER_ID = 852066//OrderId( "innerfire" )
        public constant integer SPELL_ID = 'A033'
    endglobals

    //! runtextmacro Scope("Extension")
        private function Ending takes integer IntervalTimer returns nothing
            call FlushAttachedReal( IntervalTimer, "MissileX" )
            call FlushAttachedReal( IntervalTimer, "MissileY" )
            call FlushAttachedReal( IntervalTimer, "MissileZ" )
        endfunction

        public function Extension_Abort takes integer IntervalTimer returns nothing
            local integer Caster = GetAttachedInteger( IntervalTimer, "Caster" )
            local integer Target = GetAttachedInteger( IntervalTimer, "Target" )
            call FlushAttachedInteger( Caster, "BlastFurnace_DrawTarget_IntervalTimer" )
            call FlushAttachedInteger( IntervalTimer, "AbilityLevel" )
            call FlushAttachedInteger( IntervalTimer, "Caster" )
            call FlushAttachedInteger( IntervalTimer, "Target" )
            call BlastFurnace_Extension_Ending( IntervalTimer )
            call DestroyTimerWJ( IntervalTimer )
            call RemoveIntegerFromTable( Target, "BlastFurnace_DrawTarget_Casters", Caster )
        endfunction

        public function Extension takes nothing returns nothing
            local real AngleRadianXY
            local real AngleRadianMoveLengthXYZ
            local real DistanceX
            local real DistanceY
            local real DistanceZ
            local real ChainLengthPartX
            local real ChainLengthPartY
            local real ChainLengthPartZ
            local integer ChainPart
            local integer IntervalTimer = GetExpiredTimerWJ()
            local integer AbilityLevel = GetAttachedInteger( IntervalTimer, "AbilityLevel" )
            local integer Caster = GetAttachedInteger( IntervalTimer, "Caster" )
            local real CasterX = GetUnitXWJ( Caster )
            local real CasterY = GetUnitXWJ( Caster )
            local real CasterZ = GetUnitXWJ( Caster ) + GetAttachedReal( Caster, "ImpactZ" )
            local integer ChainPartsAmount = GetAttachedInteger( BlastFurnace_Id(), "ChainPartsAmount" + I2S( AbilityLevel ) )
            local integer Iteration = 1
            local integer LoadAbility
            local real MissileX = GetAttachedReal( IntervalTimer, "MissileX" )
            local real MissileY = GetAttachedReal( IntervalTimer, "MissileY" )
            local real MissileZ = GetAttachedReal( IntervalTimer, "MissileZ" )
            local real MoveLengthXY
            local integer Target = GetAttachedInteger( IntervalTimer, "Target" )
            local real TargetX = GetUnitXWJ( Target )
            local real TargetY = GetUnitYWJ( Target )
            local real TargetZ = GetUnitZ( Target ) + GetAttachedReal( Target, "ImpactZ" )
            local real MoveLength = GetAttachedReal( BlastFurnace_Id(), "MoveLength" + I2S( AbilityLevel ) )
            local boolean ReachesTarget = ( DistanceByCoordinatesWithZ( TargetX, TargetY, TargetZ, CasterX, CasterY, CasterZ ) <= MoveLength )
            if ( ReachesTarget ) then
                set MissileX = TargetX
                set MissileY = TargetY
                set MissileZ = TargetZ
            else
                set DistanceX = TargetX - MissileX
                set DistanceY = TargetY - MissileY
                set DistanceZ = TargetZ - MissileZ
                set AngleRadianMoveLengthXYZ = Atan2( DistanceZ, DistanceByCoordinates( MissileX, MissileY, TargetX, TargetY ) )
                set AngleRadianXY = Atan2( DistanceY, DistanceX )
                set MoveLengthXY = MoveLength * Cos( AngleRadianMoveLengthXYZ )
                set MissileX = MissileX + MoveLengthXY * Cos( AngleRadianXY )
                set MissileY = MissileY + MoveLengthXY * Sin( AngleRadianXY )
                set MissileZ = MissileZ + MoveLength * Sin( AngleRadianMoveLengthXYZ )
                call AttachReal( IntervalTimer, "MissileX", MissileX )
                call AttachReal( IntervalTimer, "MissileY", MissileY )
                call AttachReal( IntervalTimer, "MissileZ", MissileZ )
            endif
            set ChainLengthPartX = ( MissileX - CasterX ) / ChainPartsAmount
            set ChainLengthPartY = ( MissileY - CasterY ) / ChainPartsAmount
            set ChainLengthPartZ = ( MissileZ - CasterZ ) / ChainPartsAmount
            loop
                exitwhen ( Iteration > ChainPartsAmount )
                set ChainPart = GetIntegerFromTable( IntervalTimer, "ChainParts", Iteration )
                call SetUnitXWJ( ChainPart, CasterX + Iteration * ChainLengthPartX )
                call SetUnitXWJ( ChainPart, CasterY + Iteration * ChainLengthPartY )
                call SetUnitXWJ( ChainPart, CasterZ + Iteration * ChainLengthPartZ )
                set Iteration = Iteration + 1
            endloop
            if ( ReachesTarget ) then
                call BlastFurnace_Extension_Ending( IntervalTimer )
        //        call TimerStartWJ( IntervalTimer, GetAttachedReal( BlastFurnace_Id(), "Interval" ), true, function BlastFurnace_DrawTarget_MoveTarget )
            endif
        endfunction
    //! runtextmacro Endscope()

    public function SpellEffect takes integer Caster, integer Target returns nothing
        local integer AbilityLevel = GetUnitAbilityLevelWJ( Caster, BlastFurnace_Id() )
        local real CasterTargetAngle
        local real CasterX = GetUnitXWJ( Caster )
        local real CasterY = GetUnitYWJ( Caster )
        local real CasterZ = GetUnitXWJ( Caster ) + GetAttachedReal( Caster, "ImpactZ" )
        local integer ChainPartUnitTypeId = GetAttachedInteger( BlastFurnace_Id(), "ChainPartUnitTypeId" )
        local integer IntervalTimer = CreateTimerWJ()
        local integer newChainPart
        local real TargetX = GetUnitXWJ( Target )
        local real TargetY = GetUnitYWJ( Target )
        if ( ( CasterX != TargetX ) or ( CasterX != TargetX ) ) then
            set CasterTargetAngle = Atan2( TargetY - CasterY, TargetX - CasterX )
        else
            set CasterTargetAngle = GetUnitFacingWJ( Caster )
        endif
        call AttachInteger( Caster, "BlastFurnace_DrawTarget_IntervalTimer", IntervalTimer )
        call AttachInteger( IntervalTimer, "AbilityLevel", AbilityLevel )
        call AttachInteger( IntervalTimer, "Caster", Caster )
        call AddIntegerToTable( Target, "BlastFurnace_DrawTarget_Casters", Caster )
        loop
            set newChainPart = CreateUnitWJ( PlayerWJ( PLAYER_NEUTRAL_PASSIVE ), ChainPartUnitTypeId, CasterX, CasterY, CasterTargetAngle )
            call SetUnitZWJ( newChainPart, CasterZ )
            call AddIntegerToTable( IntervalTimer, "ChainParts", newChainPart )
        endloop
        call TimerStartWJ( IntervalTimer, GetAttachedReal( BlastFurnace_Id(), "Interval" ), true, function Extension )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\BlastFurnace.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\BloodyClaws.j
//TESH.scrollpos=50
//TESH.alwaysfold=0
//! runtextmacro Scope("BloodyClaws")
    globals
        public constant integer SPELL_ID = 'A00C'

        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Undead\\VampiricAura\\VampiricAuraTarget.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real REFRESHED_LIFE_FACTOR = 0.25
    endglobals

    public function Death takes Unit caster returns nothing
        local integer casterId
        if (GetUnitAbilityLevel(caster.self, SPELL_ID) > 0) then
            set casterId = caster.id
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function Conditions takes unit caster, Unit target returns boolean
        if ( GetUnitAbilityLevel( caster, SPELL_ID ) <= 0 ) then
            return false
        endif
        if ( IsUnitType( target.self, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( target.self, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitIllusionWJ( target ) ) then
            return false
        endif
        if ( IsUnitWard( target ) ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, real damageAmount, Unit target returns nothing
        local unit casterSelf = caster.self
        if ( Conditions( casterSelf, target ) ) then
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT ) )
            call HealUnitBySpell( caster, damageAmount * REFRESHED_LIFE_FACTOR )
        endif
        set casterSelf = null
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_UNBLOCKED_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\BloodyClaws.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\BondOfSouls.j
//TESH.scrollpos=213
//TESH.alwaysfold=0
//! runtextmacro Scope("BondOfSouls")
    globals
        private constant integer ORDER_ID = 852480//OrderId( "magicleash" )
        public constant integer SPELL_ID = 'A00P'

        private real array BONUS_EVADE_CHANCE
        private real array DAMAGE
        private real array DURATION
        private real array DURATION_PER_AGILITY_POINT
        private constant string EFFECT_LIGHTNING_PATH = "CHIM"
        private real array HERO_DURATION
        private real array HERO_DURATION_PER_AGILITY_POINT
        private constant real INTERVAL = 0.25
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\VampiricPotion\\VampPotionCaster.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real UPDATE_TIME = 0.1
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        timer damageTimer
        timer durationTimer
        lightning effectLightning
        sound effectSound
        Unit target
        effect targetEffect
        timer updateTimer
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local integer abilityLevel = d.abilityLevel
        local timer damageTimer = d.damageTimer
        local timer durationTimer = d.durationTimer
        local lightning effectLightning = d.effectLightning
        local sound effectSound = d.effectSound
        local Unit target = d.target
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        local timer updateTimer = d.updateTimer
        call d.destroy()
        call FlushAttachedIntegerById( caster.id, BondOfSouls_SCOPE_ID_BASIC )
        call FlushAttachedInteger( damageTimer, BondOfSouls_SCOPE_ID )
        call DestroyTimerWJ( damageTimer )
        set damageTimer = null
        call FlushAttachedInteger( durationTimer, BondOfSouls_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call DestroyLightningWJ( effectLightning )
        set effectLightning = null
        call StopSoundWJ( effectSound, false )
        set effectSound = null
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call RemoveIntegerFromTableById( targetId, BondOfSouls_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, BondOfSouls_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        call FlushAttachedInteger( updateTimer, BondOfSouls_SCOPE_ID )
        call DestroyTimerWJ(updateTimer)
        set updateTimer = null
        call AddUnitEvasionChance( target, -BONUS_EVADE_CHANCE[abilityLevel] )
        call RemoveUnitStun( target, 0 )
    endfunction

    public function Death takes Unit target returns nothing
        local Unit caster
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, BondOfSouls_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( targetId, BondOfSouls_SCOPE_ID, iteration )
                set caster = d.caster
                call SoulVessel_TryGeneratingVessel( caster, caster.owner )
                call IssueImmediateOrderById( caster.self, STOP_ORDER_ID )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, BondOfSouls_SCOPE_ID_BASIC )
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, BondOfSouls_SCOPE_ID)
        set durationTimer = null
        call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
    endfunction

    private function DealDamage takes nothing returns nothing
        local timer damageTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(damageTimer, BondOfSouls_SCOPE_ID)
        local Unit target = d.target
        set damageTimer = null
        if ( IsUnitIllusionWJ( target ) ) then
            call KillUnit( target.self )
        else
            call UnitDamageUnitBySpell( d.caster, target, DAMAGE[d.abilityLevel] )
        endif
    endfunction

    private function ResetLightning takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, BondOfSouls_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Unit target = d.target
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        set updateTimer = null
        call MoveLightningEx( d.effectLightning, true, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster), targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target) )
        set casterSelf = null
        set targetSelf = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local timer damageTimer = CreateTimerWJ()
        local real duration
        local timer durationTimer = CreateTimerWJ()
        local sound effectSound = CreateSoundFromType( BOND_OF_SOULS_SOUND_TYPE )
        local integer targetId = target.id
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        local timer updateTimer = CreateTimerWJ()
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.damageTimer = damageTimer
        set d.durationTimer = durationTimer
        set d.effectLightning = AddLightningWJ( EFFECT_LIGHTNING_PATH, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster), targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target) )
        set casterSelf = null
        set d.effectSound = effectSound
        set d.target = target
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        set d.updateTimer = updateTimer
        call AttachIntegerById( caster.id, BondOfSouls_SCOPE_ID_BASIC, d )
        call AttachInteger( damageTimer, BondOfSouls_SCOPE_ID, d )
        call AttachInteger( durationTimer, BondOfSouls_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, BondOfSouls_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, BondOfSouls_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call AttachInteger( updateTimer, BondOfSouls_SCOPE_ID, d )
        call AttachSoundToUnit( effectSound, targetSelf )
        call StartSound( effectSound )
        set effectSound = null
        call AddUnitEvasionChance( target, BONUS_EVADE_CHANCE[abilityLevel] )
        call AddUnitStun( target, 0 )
        call TimerStart( damageTimer, INTERVAL, true, function DealDamage )
        set damageTimer = null
        call TimerStart( updateTimer, UPDATE_TIME, true, function ResetLightning )
        set updateTimer = null
        if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
            set duration = HERO_DURATION[abilityLevel] + GetHeroAgility(caster) * HERO_DURATION_PER_AGILITY_POINT[abilityLevel]
        else
            set duration = DURATION[abilityLevel] + GetHeroAgility(caster) * DURATION_PER_AGILITY_POINT[abilityLevel]
        endif
        set targetSelf = null
        call TimerStart( durationTimer, duration, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit caster, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitMagicImmunity( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        set BONUS_EVADE_CHANCE[1] = 0.5
        set BONUS_EVADE_CHANCE[2] = 0.5
        set BONUS_EVADE_CHANCE[3] = 0.5
        set BONUS_EVADE_CHANCE[4] = 0.5
        set BONUS_EVADE_CHANCE[5] = 0.5
        set DAMAGE[1] = 10 * INTERVAL
        set DAMAGE[2] = 15 * INTERVAL
        set DAMAGE[3] = 20 * INTERVAL
        set DAMAGE[4] = 25 * INTERVAL
        set DAMAGE[5] = 28 * INTERVAL
        set DURATION[1] = 6
        set DURATION[2] = 7
        set DURATION[3] = 7.5
        set DURATION[4] = 7.75
        set DURATION[5] = 8
        set DURATION_PER_AGILITY_POINT[1] = 0.05
        set DURATION_PER_AGILITY_POINT[2] = 0.05
        set DURATION_PER_AGILITY_POINT[3] = 0.05
        set DURATION_PER_AGILITY_POINT[4] = 0.05
        set DURATION_PER_AGILITY_POINT[5] = 0.05
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set HERO_DURATION[1] = 3
        set HERO_DURATION[2] = 3
        set HERO_DURATION[3] = 3
        set HERO_DURATION[4] = 3
        set HERO_DURATION[5] = 3
        set HERO_DURATION_PER_AGILITY_POINT[1] = 0.02
        set HERO_DURATION_PER_AGILITY_POINT[2] = 0.02
        set HERO_DURATION_PER_AGILITY_POINT[3] = 0.02
        set HERO_DURATION_PER_AGILITY_POINT[4] = 0.02
        set HERO_DURATION_PER_AGILITY_POINT[5] = 0.02
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\BondOfSouls.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\BubbleArmor.j
//TESH.scrollpos=165
//TESH.alwaysfold=0
//! runtextmacro Scope("BubbleArmor")
    globals
        public constant integer ORDER_ID = 852132//OrderId( "autodispel" )
        public constant integer SPELL_ID = 'A02J'

        private constant real DURATION = 20.
        private constant integer MAX_BLOCKS_AMOUNT = 2
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Undead\\FrostArmor\\FrostArmorTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
    endglobals

    private struct Data
        integer blocksAmount
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, BubbleArmor_SCOPE_ID )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DAMAGE" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById( target.id, BubbleArmor_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, BubbleArmor_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    public function Damage takes Unit target returns boolean
        local integer blocksAmount
        local Data d = GetAttachedIntegerById(target.id, BubbleArmor_SCOPE_ID)
        if ( d != NULL ) then
            set blocksAmount = d.blocksAmount + 1
            if ( blocksAmount >= MAX_BLOCKS_AMOUNT ) then
                call Ending( d, d.durationTimer, target )
            else
                set d.blocksAmount = blocksAmount
            endif
            return true
        endif
        return false
    endfunction

    private function Damage_Event takes nothing returns nothing
        set DAMAGE_BLOCKED = Damage( TRIGGER_UNIT )
    endfunction

    public function SpellEffect takes Unit target returns nothing
        local timer durationTimer
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, BubbleArmor_SCOPE_ID)
        if ( d == NULL ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.blocksAmount = 0
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger( durationTimer, BubbleArmor_SCOPE_ID, d )
            call AttachIntegerById( targetId, BubbleArmor_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DAMAGE" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        else
            set durationTimer = d.durationTimer
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT )
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( TARGET_UNIT )
    endfunction

    private function TargetConditions_Single_String takes player casterOwner, Unit checkingUnit returns string
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) == false ) then
            return ErrorStrings_ONLY_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        return TargetConditions_Single_String( casterOwner, target )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    //! runtextmacro Scope("Automatic")
        globals
            public constant integer Automatic_ACTIVATION_ORDER_ID = 852133//OrderId( "autodispelon" )
            public constant integer Automatic_DEACTIVATION_ORDER_ID = 852134//OrderId( "autodispeloff" )

            private constant real Automatic_AREA_RANGE = 700.
            private group Automatic_ENUM_GROUP
            private boolexpr Automatic_TARGET_CONDITIONS
        endglobals

        private function Automatic_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( TargetConditions_Single_String( TEMP_PLAYER, GetUnit(FILTER_UNIT_SELF) ) != null ) then
                return false
            endif
            if ( GetAttachedIntegerById( GetUnit(FILTER_UNIT_SELF).id, BubbleArmor_SCOPE_ID ) != NULL ) then
                return false
            endif
            return true
        endfunction

        public function Automatic_TargetInRange takes Unit caster, player casterOwner returns nothing
            local unit enumUnit
            local unit casterSelf = caster.self
            local real casterX
            local real casterY
            if ( GetUnitAutomaticAbility(caster) == SPELL_ID ) then
                set casterX = GetUnitX( casterSelf )
                set casterY = GetUnitY( casterSelf )
                set TEMP_PLAYER = casterOwner
                call GroupEnumUnitsInRangeWithCollision( Automatic_ENUM_GROUP, casterX, casterY, Automatic_AREA_RANGE, Automatic_TARGET_CONDITIONS )
                set enumUnit = GetRandomUnit( Automatic_ENUM_GROUP )
                if ( enumUnit != null ) then
                    call IssueTargetOrderByIdTimed( caster, ORDER_ID, GetUnit(enumUnit), 0 )
                    set enumUnit = null
                endif
            endif
            set casterSelf = null
        endfunction

        private function Automatic_TargetInRange_Event takes nothing returns nothing
            call Automatic_TargetInRange( TRIGGER_UNIT, TRIGGER_UNIT.owner )
        endfunction

        public function Automatic_Activation_Order takes Unit caster returns nothing
            //! runtextmacro AddEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, SPELL_ID)
        endfunction

        private function Automatic_Activation_Order_Event takes nothing returns nothing
            call Automatic_Activation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Deactivation_Order takes Unit caster returns nothing
            //! runtextmacro RemoveEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, 0)
        endfunction

        private function Automatic_Deactivation_Order_Event takes nothing returns nothing
            call Automatic_Deactivation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Init takes nothing returns nothing
            set Automatic_ENUM_GROUP = CreateGroupWJ()
            set Automatic_TARGET_CONDITIONS = ConditionWJ( function Automatic_TargetConditions )
            call AddOrderAbility( Automatic_ACTIVATION_ORDER_ID, SPELL_ID )
            call AddOrderAbility( Automatic_DEACTIVATION_ORDER_ID, SPELL_ID )
            //! runtextmacro CreateEvent( "Automatic_EVENT_ACQUIRE", "UnitAcquiresTarget_EVENT_KEY", "0", "function Automatic_TargetInRange_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_ACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_ACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Activation_Order_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_DEACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_DEACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Deactivation_Order_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_FOR_BLOCKING", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Automatic_Automatic_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\BubbleArmor.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Burrow.j
//TESH.scrollpos=102
//TESH.alwaysfold=0
//! runtextmacro Scope("Burrow")
    globals
        public constant integer ORDER_ID = 852533//OrderId("burrow")
        public constant integer RESEARCH_ID = 'R01C'
        public constant integer SPELL_ID = 'A08D'

        private constant real HEAL_INTERVAL = 1.
        private constant real HEAL_REFRESHED_LIFE_PER_INTERVAL = 3.

        private boolean IGNORE_NEXT_FORM_CHANGE = false
    endglobals

    private struct Data
        Unit caster
        UnitType oldUnitType
        boolean on = false
        timer healTimer
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local integer casterId = caster.id
        local timer healTimer = d.healTimer
        local UnitType oldUnitType = d.oldUnitType
        call d.destroy()
        call FlushAttachedIntegerById(casterId, Burrow_SCOPE_ID)
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        call FlushAttachedInteger(healTimer, Burrow_SCOPE_ID)
        call DestroyTimerWJ(healTimer)
        set healTimer = null
        call SetUnitAnimation(caster.self, "stand")
        call UnitChangeForm(caster, oldUnitType)
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Burrow_SCOPE_ID)
        if (d != NULL) then
            call Ending(caster, d)
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function Heal takes nothing returns nothing
        local timer healTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(healTimer, Burrow_SCOPE_ID)
        call HealUnitBySpell( d.caster, HEAL_REFRESHED_LIFE_PER_INTERVAL )
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Burrow_SCOPE_ID)
        local UnitType oldUnitType
        if (d.on) then
            call Ending(caster, d)
        else
            set oldUnitType = d.oldUnitType
            set d.oldUnitType = caster.type
            set d.on = true
            call TimerStart(d.healTimer, HEAL_INTERVAL, true, function Heal)
            set IGNORE_NEXT_FORM_CHANGE = true
            call UnitChangeForm(caster, GetUnitType(CRYPT_FIEND_BURROWED_UNIT_ID))
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    public function FormChange takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Burrow_SCOPE_ID)
        if (d != NULL) then
            if (IGNORE_NEXT_FORM_CHANGE) then
                set IGNORE_NEXT_FORM_CHANGE = false
            else
                call Ending(caster, d)
            endif
        endif
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local player casterOwner
        local unit casterSelf
        local Data d = GetAttachedIntegerById(casterId, Burrow_SCOPE_ID)
        local timer healTimer
        if (d == NULL) then
            set casterOwner = caster.owner
            set casterSelf = caster.self
            set healTimer = CreateTimerWJ()
            set d = Data.create()
            set d.caster = caster
            set d.healTimer = healTimer
            set d.oldUnitType = caster.type
            call AttachIntegerById(casterId, Burrow_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger(healTimer, Burrow_SCOPE_ID, d)
            set healTimer = null
            if (IsUnitSelected(casterSelf, casterOwner)) then
                if (GetLocalPlayer() == casterOwner) then
                    call SelectUnit(casterSelf, false)
                    call SelectUnit(casterSelf, true)
                endif
            endif
            set casterOwner = null
            set casterSelf = null
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Burrow.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Cannibalism.j
//TESH.scrollpos=59
//TESH.alwaysfold=0
//! runtextmacro Scope("Cannibalism")
    globals
        public constant integer RESEARCH_ID = 'A08O'
        public constant integer SPELL_ID = 'A08O'

        private constant real AREA_RANGE = 400.
        private group ENUM_GROUP
        private constant real REFRESHED_LIFE_FACTOR = 10.
        private constant real REFRESHED_LIFE_LOWER_CAP = 50.
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Undead\\DeathPact\\DeathPactTarget.mdl"
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Undead\\DeathPact\\DeathPactCaster.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if (IsUnitAlly(FILTER_UNIT_SELF, TEMP_PLAYER) == false) then
            return false
        endif
        if (IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_UNDEAD ) == false) then
            return false
        endif
        return true
    endfunction

    public function Death takes Unit caster, real casterX, real casterY returns nothing
        local integer casterId = caster.id
        local unit enumUnit
        local real refreshedLife
        if ( GetAttachedBooleanById( casterId, Cannibalism_SCOPE_ID ) ) then
            call FlushAttachedBooleanById(casterId, Cannibalism_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            set TEMP_PLAYER = caster.owner
            call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
            set enumUnit = FirstOfGroup(ENUM_GROUP)
            if (enumUnit != null) then
                set refreshedLife = Max(REFRESHED_LIFE_LOWER_CAP, GetUnitArmorTotal( caster ) * REFRESHED_LIFE_FACTOR)
                call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, casterX, casterY ) )
                loop
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnit, TARGET_EFFECT_ATTACHMENT_POINT ) )
                    call HealUnitBySpell( GetUnit(enumUnit), refreshedLife )
                    set enumUnit = FirstOfGroup(ENUM_GROUP)
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        call Death( DYING_UNIT, GetUnitX(dyingUnitSelf), GetUnitY(dyingUnitSelf) )
        set dyingUnitSelf = null
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, Cannibalism_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Cannibalism.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\CashDiscount.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("CashDiscount")
    globals
        private constant integer ORDER_ID = 852514//OrderId( "phaseshift" )
        public constant integer SPELL_ID = 'A03B'

        private constant real DURATION = 40.
        public constant integer GOLD_COST_PERCENT = 60
        public constant real GOLD_COST_FACTOR = GOLD_COST_PERCENT / 100.

        public boolean array ON
    endglobals

    private struct Data
        integer casterTeam
        timer durationTimer
    endstruct

    private function Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, CashDiscount_SCOPE_ID)
        local integer casterTeam = d.casterTeam
        call d.destroy()
        call FlushAttachedInteger(durationTimer, CashDiscount_SCOPE_ID)
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        set ON[casterTeam] = false
        if ( GetPlayerTeam( GetLocalPlayer() ) == casterTeam ) then
            call DisplayTextTimedWJ( ColorStrings_YELLOW + "'Cash Discount' has expired." + ColorStrings_RESET, 10, GetLocalPlayer() )
        endif
    endfunction

    public function SpellEffect takes player casterOwner returns nothing
        local integer casterTeam = GetPlayerTeam( casterOwner )
        local integer count = Infoboard_COUNT
        local Data d
        local timer durationTimer
        local sound effectSound = CreateSoundFromType( CASH_DISCOUNT_SOUND_TYPE )
        if ( ON[casterTeam] == false ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set ON[casterTeam] = true
            set d.casterTeam = casterTeam
            call AttachInteger( durationTimer, CashDiscount_SCOPE_ID, d )
        else
            set durationTimer = d.durationTimer
        endif
        if ( GetPlayerTeam( GetLocalPlayer() ) == casterTeam ) then
            call DisplayTextTimedWJ( ColorStrings_GREEN + "Someone of your team just activated 'Cash Discount'. All prices are lowered by " + I2S( GOLD_COST_PERCENT ) + " percent.\n(Start: " + GetTimeString( count ) + " End: " + GetTimeString( count + R2I( DURATION ) ) + ")" + ColorStrings_RESET, 10, GetLocalPlayer() )
            call PingMasterWizard( casterTeam )
        endif
        if (GetPlayerTeam(GetLocalPlayer()) != casterTeam) then
            call SetSoundVolume(effectSound, 0)
        endif
        call StartSound( effectSound )
        call KillSound(effectSound, true)
        set effectSound = null
        call TimerStart( durationTimer, DURATION, false, function Ending )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER.owner )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = GetTeams() - 1
        loop
            set ON[iteration] = false
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\CashDiscount.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChainLightning.j
//TESH.scrollpos=192
//TESH.alwaysfold=0
//! runtextmacro Scope("ChainLightning")
    private struct Data
        Unit caster
        timer delayTimer
        integer jumpsAmount
        Unit target
        group targetGroup
    endstruct

    globals
        private constant integer ORDER_ID = 852119//OrderId( "chainlightning" )
        public constant integer SPELL_ID = 'A071'

        private constant real AREA_RANGE = 700.
        private constant real DAMAGE_START = 200.
        private constant real DAMAGE_REDUCTION_PER_JUMP_FACTOR = 0.1
        private trigger CHOOSE_TRIGGER
        private constant real EFFECT_LIGHTNING_DURATION = 0.3
        private constant string EFFECT_LIGHTNING_PATH = "CLPB"
        private constant string EFFECT_LIGHTNING2_PATH = "CLSB"
        private group ENUM_GROUP
        private constant real JUMP_DELAY = 0.175
        private constant integer MAX_TARGETS_AMOUNT = 8
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Weapons\\Bolt\\BoltImpact.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"

        private Data CHOOSE_TRIGGER_D
        private Unit CHOOSE_TRIGGER_SOURCE
    endglobals

    private function Ending_Target takes Data d, Unit target returns nothing
        local integer targetId = target.id
        call RemoveIntegerFromTableById(targetId, ChainLightning_SCOPE_ID, d)
        if (CountIntegersInTableById(targetId, ChainLightning_SCOPE_ID) == TABLE_EMPTY) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DECAY" )
        endif
    endfunction

    private function Ending takes Unit caster, Data d, timer delayTimer, boolean isTargetNotNull, Unit target, group targetGroup returns nothing
        call d.destroy()
        call RemoveUnitRemainingReference( caster )
        call FlushAttachedInteger( delayTimer, ChainLightning_SCOPE_ID )
        call DestroyTimerWJ( delayTimer )
        if ( isTargetNotNull ) then
            call Ending_Target(d, target)
        endif
        call DestroyGroupWJ( targetGroup )
    endfunction

    private function TargetConditions_Single takes player casterOwner, Unit checkingUnit returns boolean
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitMagicImmunity( checkingUnit ) > 0 ) then
            return false
        endif
        if ( GetUnitInvulnerability( checkingUnit ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return false
        endif
        return true
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( IsUnitInGroup( FILTER_UNIT_SELF, TEMP_GROUP ) ) then
            return false
        endif
        if ( TargetConditions_Single( TEMP_PLAYER, GetUnit(FILTER_UNIT_SELF) ) == false ) then
            return false
        endif
        return true
    endfunction

    private function Impact takes nothing returns nothing
        local timer delayTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(delayTimer, ChainLightning_SCOPE_ID)
        local Unit caster = d.caster
        local integer jumpsAmount
        local Unit target = d.target
        call Ending_Target(d, target)
        if ( target == NULL ) then
            call Ending( caster, d, delayTimer, false, NULL, d.targetGroup )
        else
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT ) )
            if ( TargetConditions_Single( caster.owner, target ) ) then
                set jumpsAmount = d.jumpsAmount + 1
                if ( jumpsAmount < MAX_TARGETS_AMOUNT ) then
                    set CHOOSE_TRIGGER_D = d
                    set CHOOSE_TRIGGER_SOURCE = target
                    set d.jumpsAmount = jumpsAmount
                    call RunTrigger(CHOOSE_TRIGGER)
                else
                    call Ending( caster, d, delayTimer, true, target, d.targetGroup )
                endif
                call UnitDamageUnitBySpell( caster, target, DAMAGE_START * ( 1 - ( jumpsAmount - 1 ) * DAMAGE_REDUCTION_PER_JUMP_FACTOR ) )
            else
                call Ending( caster, d, delayTimer, true, target, d.targetGroup )
            endif
        endif
        set delayTimer = null
    endfunction

    public function Decay takes Unit target returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById(targetId, ChainLightning_SCOPE_ID)
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById(targetId, ChainLightning_SCOPE_ID, iteration)
                call Ending_Target(d, target)
                set d.target = NULL
                set iteration = iteration - 1
                exitwhen (iteration < TABLE_STARTED)
            endloop
        endif
    endfunction

    private function Decay_Event takes nothing returns nothing
        call Decay(TRIGGER_UNIT)
    endfunction

    public function Jump takes Data d, timer delayTimer, Unit source, Unit target, group targetGroup, string whichLightningTypeId returns nothing
        local integer targetId = target.id
        call DestroyLightningTimedEx( AddLightningBetweenUnits( whichLightningTypeId, source, target ), EFFECT_LIGHTNING_DURATION )
        set d.target = target
        call AddIntegerToTableById(targetId, ChainLightning_SCOPE_ID, d)
        if (CountIntegersInTableById(targetId, ChainLightning_SCOPE_ID) == TABLE_STARTED) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DECAY" )
        endif
        call GroupAddUnit( targetGroup, target.self )
        call TimerStart( delayTimer, JUMP_DELAY, false, function Impact )
    endfunction

    private function ChooseTrig takes nothing returns nothing
        local Data d = CHOOSE_TRIGGER_D
        local Unit caster = d.caster
        local unit enumUnit
        local Unit source = CHOOSE_TRIGGER_SOURCE
        local unit sourceSelf = source.self
        local real sourceX = GetUnitX( sourceSelf )
        local real sourceY = GetUnitY( sourceSelf )
        local group targetGroup = d.targetGroup
        set sourceSelf = null
        set TEMP_GROUP = targetGroup
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, sourceX, sourceY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = GetNearestUnit( ENUM_GROUP, sourceX, sourceY )
        if ( enumUnit == null ) then
            call Ending( caster, d, d.delayTimer, false, GetUnit(enumUnit), targetGroup )
        else
            call Jump( d, d.delayTimer, source, GetUnit(enumUnit), targetGroup, EFFECT_LIGHTNING2_PATH )
            set enumUnit = null
        endif
        set targetGroup = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local Data d = Data.create()
        local timer delayTimer = CreateTimerWJ()
        local group targetGroup = CreateGroupWJ()
        set d.caster = caster
        set d.delayTimer = delayTimer
        set d.jumpsAmount = 0
        set d.targetGroup = targetGroup
        call AddUnitRemainingReference( caster )
        call AttachInteger( delayTimer, ChainLightning_SCOPE_ID, d )
        call Jump( d, delayTimer, caster, target, targetGroup, EFFECT_LIGHTNING_PATH )
        set delayTimer = null
        set targetGroup = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return ErrorStrings_NOT_HERO
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_ONLY_ORGANIC
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitMagicImmunity( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        set CHOOSE_TRIGGER = CreateTriggerWJ()
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DECAY", "UnitFinishesDecaying_EVENT_KEY", "0", "function Decay_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call AddTriggerCode(CHOOSE_TRIGGER, function ChooseTrig)
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChainLightning.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChillyPresence.j
//TESH.scrollpos=349
//TESH.alwaysfold=0
//! runtextmacro Scope("ChillyPresence")
    globals
        public constant integer SPELL_ID = 'A006'

        private real array AREA_RANGE
        private real array AREA_RANGE_PER_AGILITY_POINT
        private real array BONUS_MANA_REGENERATION_RELATIVE
        private real array BONUS_SPEED_RELATIVE
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Other\\Drain\\ManaDrainCaster.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        effect casterEffect
        group targetGroup
        timer updateTimer
    endstruct

    private function GetCasterData takes Unit caster returns Data
        return GetAttachedIntegerById(caster.id, ChillyPresence_SCOPE_ID)
    endfunction

    //! runtextmacro Scope("Target")
        globals
            private group Target_ENUM_GROUP
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            real bonusManaRegeneration
            real bonusSpeed
            group casterGroup
            Data d
            effect targetEffect
        endstruct

        private function Target_Ending takes Unit caster, group casterGroup, Data d, Target_Data e, integer oldAbilityLevel, Unit target, group targetGroup returns nothing
            local real bonusManaRegeneration
            local real bonusSpeed
            local Unit enumUnit
            local unit enumUnitSelf
            local integer enumUnitAbilityLevel
            local integer iteration
            local integer newLevel
            local real oldBonusManaRegeneration
            local real oldBonusSpeed
            local effect targetEffect
            local integer targetId
            call GroupRemoveUnit( casterGroup, caster.self )
            call GroupRemoveUnit( targetGroup, target.self )
            if (e.d == d) then
                set iteration = oldAbilityLevel - 1
                set oldBonusManaRegeneration = e.bonusManaRegeneration
                set oldBonusSpeed = e.bonusSpeed
                set enumUnitSelf = FirstOfGroup(casterGroup)
                if (enumUnitSelf == null) then
                    set targetEffect = e.targetEffect
                    set targetId = target.id
                    call e.destroy()
                    call DestroyGroupWJ(casterGroup)
                    call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
                    //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                    call DestroyEffectWJ( targetEffect )
                    set targetEffect = null
                    call AddUnitManaRegenerationBonus( target, -oldBonusManaRegeneration )
                    call AddUnitSpeedBonus( target, -oldBonusSpeed )
                else
                    set newLevel = 0
                    loop
                        set enumUnit = GetUnit(enumUnitSelf)
                        set enumUnitAbilityLevel = GetCasterData(enumUnit).abilityLevel
                        call GroupRemoveUnit(casterGroup, enumUnitSelf)
                        if (enumUnitAbilityLevel > newLevel) then
                            set caster = enumUnit
                            set newLevel = enumUnitAbilityLevel
                        endif
                        call GroupAddUnit(Target_ENUM_GROUP, enumUnitSelf)
                        set enumUnitSelf = FirstOfGroup(casterGroup)
                        exitwhen (enumUnitSelf == null)
                    endloop
                    set enumUnitSelf = FirstOfGroup(Target_ENUM_GROUP)
                    loop
                        call GroupRemoveUnit(Target_ENUM_GROUP, enumUnitSelf)
                        call GroupAddUnit(casterGroup, enumUnitSelf)
                        set enumUnitSelf = FirstOfGroup(Target_ENUM_GROUP)
                        exitwhen (enumUnitSelf == null)
                    endloop
                    set bonusManaRegeneration = GetUnitManaRegeneration( target ) * BONUS_MANA_REGENERATION_RELATIVE[newLevel]
                    set bonusSpeed = GetUnitSpeedTotal( target ) * BONUS_SPEED_RELATIVE[newLevel]
                    set e.bonusManaRegeneration = bonusManaRegeneration
                    set e.bonusSpeed = bonusSpeed
                    set e.d = GetCasterData(caster)
                    call AddUnitManaRegenerationBonus( target, bonusManaRegeneration - oldBonusManaRegeneration )
                    call AddUnitSpeedBonus( target, bonusSpeed - oldBonusSpeed )
                endif
            endif
        endfunction

        public function Target_EndingByEnding takes integer abilityLevel, Unit caster, Data d, Unit target, group targetGroup returns nothing
            local Target_Data e = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            call Target_Ending(caster, e.casterGroup, d, e, abilityLevel, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local integer abilityLevel
            local Data d
            local Target_Data e = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            local group casterGroup = e.casterGroup
            local integer iteration
            if (e != NULL) then
                set iteration = CountUnits(casterGroup)
                loop
                    set d = e.d
                    set abilityLevel = d.abilityLevel
                    call Target_Ending( GetUnit(FirstOfGroup(casterGroup)), casterGroup, d, e, abilityLevel, target, d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen (iteration < 1)
                endloop
            endif
            set casterGroup = null
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes integer abilityLevel, real bonusManaRegenerationRelative, real bonusSpeedRelative, Unit caster, Data d, Unit target returns nothing
            local real bonusManaRegeneration = GetUnitManaRegeneration( target ) * bonusManaRegenerationRelative
            local real bonusSpeed = GetUnitSpeedTotal( target ) * bonusSpeedRelative
            local group casterGroup
            local integer oldAbilityLevel
            local real oldBonusManaRegeneration
            local real oldBonusSpeed
            local integer targetId = target.id
            local Target_Data e = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
            local boolean isNew = (e == NULL)
            if (isNew) then
                set casterGroup = CreateGroupWJ()
                set e = Target_Data.create()
                set e.casterGroup = casterGroup
                set e.d = d
                set e.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
                call AttachIntegerById(targetId, Target_SCOPE_ID, e)
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            else
                set casterGroup = e.casterGroup
                set oldAbilityLevel = e.d.abilityLevel
                set oldBonusManaRegeneration = e.bonusManaRegeneration
                set oldBonusSpeed = e.bonusSpeed
            endif
            set e.bonusManaRegeneration = bonusManaRegeneration
            set e.bonusSpeed = bonusSpeed
            call GroupAddUnit(casterGroup, caster.self)
            set casterGroup = null
            if (isNew) then
                call AddUnitManaRegenerationBonus( target, bonusManaRegeneration )
                call AddUnitSpeedBonus( target, bonusSpeed )
            elseif (abilityLevel >= oldAbilityLevel) then
                set e.d = d
                call AddUnitManaRegenerationBonus( target, bonusManaRegeneration - oldBonusManaRegeneration )
                call AddUnitSpeedBonus( target, bonusSpeed - oldBonusSpeed )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            set Target_ENUM_GROUP = CreateGroupWJ()
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local integer abilityLevel
        local unit enumUnit
        local group targetGroup
        local Data d = GetAttachedIntegerById( caster.id, ChillyPresence_SCOPE_ID )
        if ( d != NULL ) then
            set abilityLevel = d.abilityLevel
            set targetGroup = d.targetGroup
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( abilityLevel, caster, d, GetUnit(enumUnit), targetGroup )
            endloop
            set targetGroup = null
            call PauseTimer( d.updateTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes integer abilityLevel, Unit caster, Data d, group targetGroup returns nothing
        local real bonusManaRegenerationRelative
        local real bonusSpeedRelative
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit enumUnit
        local real enumUnitX
        local real enumUnitY
        set casterSelf = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE[abilityLevel] + GetHeroAgilityTotal( caster ) * AREA_RANGE_PER_AGILITY_POINT[abilityLevel], TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( abilityLevel, caster, d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set bonusManaRegenerationRelative = BONUS_MANA_REGENERATION_RELATIVE[abilityLevel]
            set bonusSpeedRelative = BONUS_SPEED_RELATIVE[abilityLevel]
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                call Target_Target_Start(abilityLevel, bonusManaRegenerationRelative, bonusSpeedRelative, caster, d, GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, ChillyPresence_SCOPE_ID)
        set updateTimer = null
        call Update( d.abilityLevel, d.caster, d, d.targetGroup )
    endfunction

    public function Revive takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, ChillyPresence_SCOPE_ID)
        if ( d != NULL ) then
            call TimerStart( d.updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            call Update( d.abilityLevel, caster, d, d.targetGroup )
        endif
    endfunction

    private function Revive_Event takes nothing returns nothing
        call Revive( REVIVING_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel(casterSelf, SPELL_ID)
        local Data d = GetAttachedIntegerById(casterId, ChillyPresence_SCOPE_ID)
        local unit enumUnit
        local boolean isNew = ( d == NULL )
        local real lastBonusSpeed
        local group targetGroup
        local timer updateTimer
        if ( isNew ) then
            set d = Data.create()
            set targetGroup = CreateGroupWJ()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
            set d.targetGroup = targetGroup
            set d.updateTimer = updateTimer
            call AttachIntegerById( casterId, ChillyPresence_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_REVIVE" )
            call AttachInteger( updateTimer, ChillyPresence_SCOPE_ID, d )
        else
            set targetGroup = d.targetGroup
        endif
        set casterSelf = null
        set d.abilityLevel = abilityLevel
        if ( isNew ) then
            call TimerStart( updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            set updateTimer = null
        else
            set enumUnit = FirstOfGroup( targetGroup )
            if ( enumUnit != null ) then
                loop
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call Target_Target_EndingByEnding(abilityLevel, caster, d, GetUnit(enumUnit), targetGroup)
                    set enumUnit = FirstOfGroup( targetGroup )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endif
        call Update( abilityLevel, caster, d, targetGroup )
        set targetGroup = null
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set AREA_RANGE[1] = 500
        set AREA_RANGE[2] = 500
        set AREA_RANGE[3] = 500
        set AREA_RANGE[4] = 500
        set AREA_RANGE[5] = 500
        set AREA_RANGE_PER_AGILITY_POINT[1] = 6
        set AREA_RANGE_PER_AGILITY_POINT[2] = 6
        set AREA_RANGE_PER_AGILITY_POINT[3] = 6
        set AREA_RANGE_PER_AGILITY_POINT[4] = 6
        set AREA_RANGE_PER_AGILITY_POINT[5] = 6
        set BONUS_MANA_REGENERATION_RELATIVE[1] = -0.3
        set BONUS_MANA_REGENERATION_RELATIVE[2] = -0.35
        set BONUS_MANA_REGENERATION_RELATIVE[3] = -0.4
        set BONUS_MANA_REGENERATION_RELATIVE[4] = -0.45
        set BONUS_MANA_REGENERATION_RELATIVE[5] = -0.5
        set BONUS_SPEED_RELATIVE[1] = -0.15
        set BONUS_SPEED_RELATIVE[2] = -0.19
        set BONUS_SPEED_RELATIVE[3] = -0.23
        set BONUS_SPEED_RELATIVE[4] = -0.27
        set BONUS_SPEED_RELATIVE[5] = -0.31
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_REVIVE", "UnitFinishesReviving_EVENT_KEY", "0", "function Revive_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChillyPresence.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChooseHero.j
//TESH.scrollpos=7
//TESH.alwaysfold=0
//! runtextmacro Scope("ChooseHero")
    globals
        private constant integer ORDER_ID = 851981//OrderId( "getitem" )
        public constant integer SPELL_ID = 'A03E'

        private constant integer GOLD_COST = 500
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        local player casterOwner = caster.owner
        local integer casterOwnerId = GetPlayerId(casterOwner)
        local real x = START_POSITION_X[casterOwnerId]
        local real y = START_POSITION_Y[casterOwnerId]
        local Unit newUnit = Miscellaneous_Altar_Altar_ChooseHero(caster, casterOwner, x, y)
        call Miscellaneous_Altar_Altar_Ending( caster )
        call PanCameraTimedAfter( casterOwner, x, y, 2 )
        set casterOwner = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChooseHero.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChooseRandomHero.j
//TESH.scrollpos=10
//TESH.alwaysfold=0
//! runtextmacro Scope("ChooseRandomHero")
    globals
        private constant integer ORDER_ID = 852583//OrderId( "doom" )
        public constant integer SPELL_ID = 'A03N'

        private constant integer GOLD_COST = 500
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        local player casterOwner = caster.owner
        local integer casterOwnerId = GetPlayerId(casterOwner)
        local real x = START_POSITION_X[casterOwnerId]
        local real y = START_POSITION_Y[casterOwnerId]
        local Unit newUnit = Miscellaneous_Altar_Altar_ChooseRandomHero(casterOwner, x, y)
        local unit newUnitSelf = newUnit.self
        call UnitAddItem( newUnitSelf, CreateItemEx( Lollipop_ITEM_ID, 0, 0 ).self )
        set newUnitSelf = null
        call Miscellaneous_Altar_Altar_Ending( caster )
        call PanCameraTimedAfter( casterOwner, x, y, 2 )
        set casterOwner = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChooseRandomHero.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChooseRandomHeroFromSelection.j
//TESH.scrollpos=10
//TESH.alwaysfold=0
//! runtextmacro Scope("ChooseRandomHeroFromSelection")
    globals
        private constant integer ORDER_ID = 852101//OrderId( "bloodlust" )
        public constant integer SPELL_ID = 'A03M'

        private constant integer GOLD_COST = 500
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        local player casterOwner = caster.owner
        local integer casterOwnerId = GetPlayerId(casterOwner)
        local real x = START_POSITION_X[casterOwnerId]
        local real y = START_POSITION_Y[casterOwnerId]
        local Unit newUnit = Miscellaneous_Altar_Altar_ChooseRandomHeroFromSelection(caster, casterOwner, x, y)
        local unit newUnitSelf = newUnit.self
        call UnitAddItem( newUnitSelf, CreateItemEx( Lollipop_ITEM_ID, 0, 0 ).self )
        set newUnitSelf = null
        call Miscellaneous_Altar_Altar_Ending( caster )
        call PanCameraTimedAfter( casterOwner, x, y, 2 )
        set casterOwner = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ChooseRandomHeroFromSelection.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\CourageAndHonor.j
//TESH.scrollpos=214
//TESH.alwaysfold=0
//! runtextmacro Scope("CourageAndHonor")
    globals
        public constant integer SPELL_ID = 'A06M'

        private constant real AREA_RANGE = 500.
        private constant real BONUS_RELATIVE_ATTACK_RATE = 0.01
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        Unit caster
        group targetGroup
        timer updateTimer
    endstruct

    //! runtextmacro Scope("Target")
        private struct Target_Data
            Data d
        endstruct

        private function Target_Ending takes Unit caster, Target_Data d, Unit target, group targetGroup returns nothing
            local integer targetId = target.id
            call d.destroy()
            call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            endif
            call GroupRemoveUnit( targetGroup, target.self )
            call AddUnitAttackRate( caster, -BONUS_RELATIVE_ATTACK_RATE )
        endfunction

        public function Target_EndingByEnding takes Unit caster, Data d, Unit target, group targetGroup returns nothing
            local Target_Data e
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            loop
                set e = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                exitwhen (e.d == d)
                set iteration = iteration - 1
            endloop
            call Target_Ending(caster, e, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Data d
            local Target_Data e
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set e = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                    set d = e.d
                    call Target_Ending( d.caster, e, target, d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes Data d, Unit target returns nothing
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            set e.d = d
            call AddIntegerToTableById( targetId, Target_SCOPE_ID, e )
            if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_STARTED ) then
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, CourageAndHonor_SCOPE_ID)
        local unit enumUnit
        local group targetGroup
        if ( d != NULL ) then
            set targetGroup = d.targetGroup
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( caster, d, GetUnit(enumUnit), targetGroup )
            endloop
            set targetGroup = null
            call PauseTimer( d.updateTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitEnemy( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( IsUnitIllusionWJ( FILTER_UNIT ) ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes Unit caster, Data d, group targetGroup returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit enumUnit
        local real enumUnitX
        local real enumUnitY
        set casterSelf = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( caster, d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if (enumUnit != null) then
            loop
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                call Target_Target_Start(d, GetUnit(enumUnit))
                call AddUnitAttackRate( caster, BONUS_RELATIVE_ATTACK_RATE )
            endloop
        endif
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, CourageAndHonor_SCOPE_ID)
        set updateTimer = null
        call Update( d.caster, d, d.targetGroup )
    endfunction

    public function Revive takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, CourageAndHonor_SCOPE_ID)
        if ( d != NULL ) then
            call TimerStart( d.updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            call Update( caster, d, d.targetGroup )
        endif
    endfunction

    private function Revive_Event takes nothing returns nothing
        call Revive( REVIVING_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, CourageAndHonor_SCOPE_ID)
        local unit enumUnit
        local boolean isNew = ( d == NULL )
        local group targetGroup
        local timer updateTimer
        if ( isNew ) then
            set d = Data.create()
            set targetGroup = CreateGroupWJ()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.targetGroup = targetGroup
            set d.updateTimer = updateTimer
            call AttachIntegerById( casterId, CourageAndHonor_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_REVIVE" )
            call AttachInteger( updateTimer, CourageAndHonor_SCOPE_ID, d )
            call TimerStart( updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            set updateTimer = null
        else
            set targetGroup = d.targetGroup
            set enumUnit = FirstOfGroup( targetGroup )
            if ( enumUnit != null ) then
                loop
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call Target_Target_EndingByEnding(caster, d, GetUnit(enumUnit), targetGroup)
                    set enumUnit = FirstOfGroup( targetGroup )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endif
        call Update( caster, d, targetGroup )
        set targetGroup = null
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_REVIVE", "UnitFinishesReviving_EVENT_KEY", "0", "function Revive_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\CourageAndHonor.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\CripplingWave.j
//TESH.scrollpos=284
//TESH.alwaysfold=0
//! runtextmacro Scope("CripplingWave")
    private struct Data
        Unit caster
        timer delayTimer
        integer jumpsAmount
        Unit target
        group targetGroup
    endstruct

    globals
        private constant integer ORDER_ID = 852189//OrderId( "cripple" )
        public constant integer SPELL_ID = 'A039'

        private constant real AREA_RANGE = 700.
        private trigger CHOOSE_TRIGGER
        private constant real EFFECT_LIGHTNING_DURATION = 0.3
        private constant string EFFECT_LIGHTNING_PATH = "AFOD"
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private group ENUM_GROUP3
        private constant real JUMP_DELAY = 0.175
        private constant integer MAX_TARGETS_AMOUNT = 4
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "CripplingWaveTargetImpact.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"

        private Data chooseTriggerD
        private Unit chooseTriggerSource
    endglobals

    //! runtextmacro Scope("Target")
        globals
            private constant real Target_BONUS_MISS_CHANCE = 0.25
            private constant real Target_DAMAGE_LOSS_FACTOR = 0.4
            private constant real Target_DURATION = 20.
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Orc\\StasisTrap\\StasisTotemTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "overhead"
        endglobals

        private struct Target_Data
            real bonusDamage
            timer durationTimer
            Unit target
            effect targetEffect
        endstruct

        public function Target_IsNotTarget takes Unit target returns boolean
            return (GetAttachedIntegerById(target.id, Target_SCOPE_ID) == NULL)
        endfunction

        private function Target_Ending takes Target_Data d, timer durationTimer, Unit target returns nothing
            local real bonusDamage = d.bonusDamage
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call FlushAttachedInteger( durationTimer, Target_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
            //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            call AddUnitDamageBonus( target, -bonusDamage )
            call AddUnitMissChance( target, -Target_BONUS_MISS_CHANCE )
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            if ( d != NULL ) then
                call Target_Ending( d, d.durationTimer, target )
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        private function Target_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Target_Data d = GetAttachedInteger(durationTimer, Target_SCOPE_ID)
            call Target_Ending( d, durationTimer, d.target )
            set durationTimer = null
        endfunction

        public function Target_Start takes Unit target returns nothing
            local real bonusDamage
            local timer durationTimer
            local integer targetId = target.id
            local Target_Data d = GetAttachedIntegerById( targetId, Target_SCOPE_ID )
            if ( d == NULL ) then
                set bonusDamage = -GetUnitDamage( target ) * Target_DAMAGE_LOSS_FACTOR
                set d = Target_Data.create()
                set durationTimer = CreateTimerWJ()
                set d.bonusDamage = bonusDamage
                set d.durationTimer = durationTimer
                set d.target = target
                call AttachInteger( durationTimer, Target_SCOPE_ID, d )
                call AttachIntegerById( targetId, Target_SCOPE_ID, d )
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
                call AddUnitDamageBonus( target, bonusDamage )
                call AddUnitMissChance( target, Target_BONUS_MISS_CHANCE )
            else
                set durationTimer = d.durationTimer
            endif
            set d.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
            call TimerStart( durationTimer, Target_DURATION, false, function Target_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function TargetConditions_Single takes player casterOwner, Unit checkingUnit returns boolean
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitMagicImmunity( checkingUnit ) > 0 ) then
            return false
        endif
        if ( GetUnitInvulnerability( checkingUnit ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return false
        endif
        return true
    endfunction

    private function Ending_Target takes Data d, Unit target returns nothing
        local integer targetId = target.id
        call RemoveIntegerFromTableById(targetId, CripplingWave_SCOPE_ID, d)
        if (CountIntegersInTableById(targetId, CripplingWave_SCOPE_ID) == TABLE_EMPTY) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DECAY" )
        endif
    endfunction

    private function Ending takes Unit caster, Data d, timer delayTimer, boolean isTargetNotNull, Unit target, group targetGroup returns nothing
        call d.destroy()
        call RemoveUnitRemainingReference( caster )
        call FlushAttachedInteger( delayTimer, CripplingWave_SCOPE_ID )
        call DestroyTimerWJ( delayTimer )
        if ( isTargetNotNull ) then
            call Ending_Target(d, target)
        endif
        call DestroyGroupWJ( targetGroup )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( IsUnitInGroup( FILTER_UNIT_SELF, TEMP_GROUP ) ) then
            return false
        endif
        if ( TargetConditions_Single( TEMP_PLAYER, GetUnit(FILTER_UNIT_SELF) ) == false ) then
            return false
        endif
        return true
    endfunction

    private function Impact takes nothing returns nothing
        local timer delayTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(delayTimer, CripplingWave_SCOPE_ID)
        local Unit caster = d.caster
        local integer jumpsAmount
        local Unit target = d.target
        call Ending_Target(d, target)
        if ( target == NULL ) then
            call Ending( caster, d, delayTimer, false, NULL, d.targetGroup )
        else
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT ) )
            if ( TargetConditions_Single( caster.owner, target ) ) then
                set jumpsAmount = d.jumpsAmount + 1
                if ( jumpsAmount < MAX_TARGETS_AMOUNT ) then
                    set chooseTriggerD = d
                    set chooseTriggerSource = target
                    set d.jumpsAmount = jumpsAmount
                    call RunTrigger(CHOOSE_TRIGGER)
                else
                    call Ending( caster, d, delayTimer, true, target, d.targetGroup )
                endif
                call Target_Target_Start(target)
            else
                call Ending( caster, d, delayTimer, true, target, d.targetGroup )
            endif
        endif
        set delayTimer = null
    endfunction

    public function Decay takes Unit target returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById(targetId, CripplingWave_SCOPE_ID)
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById(targetId, CripplingWave_SCOPE_ID, iteration)
                call Ending_Target(d, target)
                set d.target = NULL
                set iteration = iteration - 1
                exitwhen (iteration < TABLE_STARTED)
            endloop
        endif
    endfunction

    private function Decay_Event takes nothing returns nothing
        call Decay(TRIGGER_UNIT)
    endfunction

    public function Jump takes Data d, timer delayTimer, Unit source, Unit target, group targetGroup returns nothing
        local integer targetId = target.id
        call DestroyLightningTimedEx( AddLightningBetweenUnits( EFFECT_LIGHTNING_PATH, source, target ), EFFECT_LIGHTNING_DURATION )
        set d.target = target
        call AddIntegerToTableById(targetId, CripplingWave_SCOPE_ID, d)
        if (CountIntegersInTableById(targetId, CripplingWave_SCOPE_ID) == TABLE_STARTED) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DECAY" )
        endif
        call GroupAddUnit( targetGroup, target.self )
        call TimerStart( delayTimer, JUMP_DELAY, false, function Impact )
    endfunction

    private function ChooseTrig takes nothing returns nothing
        local Data d = chooseTriggerD
        local Unit caster = d.caster
        local unit enumUnit
        local Unit source = chooseTriggerSource
        local unit sourceSelf = source.self
        local real sourceX = GetUnitX( sourceSelf )
        local real sourceY = GetUnitY( sourceSelf )
        local group targetGroup = d.targetGroup
        set sourceSelf = null
        set TEMP_GROUP = targetGroup
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, sourceX, sourceY, AREA_RANGE, TARGET_CONDITIONS )
        loop
            set enumUnit = FirstOfGroup( ENUM_GROUP )
            exitwhen ( enumUnit == null )
            call GroupRemoveUnit( ENUM_GROUP, enumUnit )
            if ( Target_Target_IsNotTarget(GetUnit(enumUnit)) ) then
                call GroupAddUnit( ENUM_GROUP2, enumUnit )
            else
                call GroupAddUnit( ENUM_GROUP3, enumUnit )
            endif
        endloop
        set enumUnit = GetNearestUnit( ENUM_GROUP2, sourceX, sourceY )
        if ( enumUnit == null ) then
            set enumUnit = GetNearestUnit( ENUM_GROUP3, sourceX, sourceY )
        else
            call GroupClear( ENUM_GROUP2 )
        endif
        if ( enumUnit == null ) then
            call Ending( caster, d, d.delayTimer, false, GetUnit(enumUnit), targetGroup )
        else
            call GroupClear( ENUM_GROUP3 )
            call Jump( d, d.delayTimer, source, GetUnit(enumUnit), targetGroup )
            set enumUnit = null
        endif
        set targetGroup = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local Data d = Data.create()
        local timer delayTimer = CreateTimerWJ()
        local group targetGroup = CreateGroupWJ()
        set d.caster = caster
        set d.delayTimer = delayTimer
        set d.jumpsAmount = 0
        set d.targetGroup = targetGroup
        call AddUnitRemainingReference( caster )
        call AttachInteger( delayTimer, CripplingWave_SCOPE_ID, d )
        call Jump( d, delayTimer, caster, target, targetGroup )
        set delayTimer = null
        set targetGroup = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect(CASTER, TARGET_UNIT)
    endfunction

    public function Order takes player casterOwner, unit target returns string
        if ( IsUnitAlly( target, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( target, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT.self )
    endfunction

    public function Init takes nothing returns nothing
        set CHOOSE_TRIGGER = CreateTriggerWJ()
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        set ENUM_GROUP3 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DECAY", "UnitFinishesDecaying_EVENT_KEY", "0", "function Decay_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call AddTriggerCode(CHOOSE_TRIGGER, function ChooseTrig)
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\CripplingWave.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\CriticalStrike.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("CriticalStrike")
    //! runtextmacro Scope("Myrmidon")
        globals
            public constant integer Myrmidon_SPELL_ID = 'A04G'

            private constant real Myrmidon_CHANCE = 0.2
        endglobals

        public function Myrmidon_Learn takes Unit caster returns nothing
            call AddUnitCriticalStrike( caster, Myrmidon_CHANCE )
        endfunction

        private function Myrmidon_Learn_Event takes nothing returns nothing
            call Myrmidon_Learn( LEARNER )
        endfunction

        public function Myrmidon_Init takes nothing returns nothing
            call InitAbility( Myrmidon_SPELL_ID )
            //! runtextmacro AddNewEventById( "Myrmidon_EVENT_LEARN", "Myrmidon_SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Myrmidon_Learn_Event" )
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("TerrorWolf")
        globals
            public constant integer TerrorWolf_SPELL_ID = 'A03I'

            private constant real TerrorWolf_CHANCE = 0.2
        endglobals

        public function TerrorWolf_Learn takes Unit caster returns nothing
            call AddUnitCriticalStrike( caster, TerrorWolf_CHANCE )
        endfunction

        private function TerrorWolf_Learn_Event takes nothing returns nothing
            call TerrorWolf_Learn( LEARNER )
        endfunction

        public function TerrorWolf_Init takes nothing returns nothing
            call InitAbility( TerrorWolf_SPELL_ID )
            //! runtextmacro AddNewEventById( "TerrorWolf_EVENT_LEARN", "TerrorWolf_SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function TerrorWolf_Learn_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        call Myrmidon_Myrmidon_Init()
        call TerrorWolf_TerrorWolf_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\CriticalStrike.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\CrowdPuller.j
//TESH.scrollpos=332
//TESH.alwaysfold=0
//! runtextmacro Scope("CrowdPuller")
    globals
        private constant integer CROWD_PULLER_ID = 'n02I'
        private constant integer ORDER_ID = 852114//OrderId( "stasistrap" )
        public constant integer SPELL_ID = 'A04C'

        private real array AREA_RANGE
        private real array BONUS_SPEED_RELATIVE
        private real array DRAINED_LIFE_RELATIVE_PER_INTERVAL
        private real array DURATION
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private real array HERO_REFRESHED_MANA_RELATIVE_PER_INTERVAL
        private constant real INTERVAL = 0.25
        private real array LENGTH
        private constant integer LEVELS_AMOUNT = 5
        private real array LIFE_PER_STRENGTH_POINT
        private integer array MAX_TARGETS_AMOUNT
        private real array REFRESHED_MANA_RELATIVE_PER_INTERVAL
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        group targetGroup
        timer updateTimer
        Unit ward
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private constant string Target_EFFECT_LIGHTNING_PATH = "LEAS"
        endglobals

        private struct Target_Data
            real bonusSpeed
            Data d
            lightning effectLightning
            Unit target
        endstruct

        private function Target_Ending takes Target_Data d, Unit target, group targetGroup returns nothing
            local real bonusSpeed = -d.bonusSpeed
            local lightning effectLightning = d.effectLightning
            local integer targetId = target.id
            call d.destroy()
            call DestroyLightningWJ( effectLightning )
            set effectLightning = null
            call GroupRemoveUnit( targetGroup, target.self )
            call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            endif
            call AddUnitSpeedBonus( target, bonusSpeed )
        endfunction

        public function Target_EndingByEnding takes Data d, Unit target, group targetGroup returns nothing
            local Target_Data e
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            loop
                set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                exitwhen (e.d == d)
                set iteration = iteration - 1
            endloop
            call Target_Ending( e, target, d.targetGroup )
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Data d
            local Target_Data e
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                    set d = e.d
                    call Target_Ending( e, target, d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Interval takes Unit caster, Data d, real drainedLifeRelative, real length, real refreshedManaRelativeHero, real refreshedManaRelativeNormal, Unit target, real wardX, real wardY, real wardZ returns nothing
            local Target_Data e
            local real refreshedManaRelative
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById(targetId, Target_SCOPE_ID)
            local unit targetSelf = target.self
            local real targetX = GetUnitX(targetSelf)
            local real targetY = GetUnitY(targetSelf)
            local real targetZ = GetUnitZ(targetSelf, targetX, targetY)
            local real angle = Atan2( wardY - targetY, wardX - targetX )
            loop
                set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                exitwhen (e.d == d)
                set iteration = iteration - 1
            endloop
            call MoveLightningEx( e.effectLightning, true, wardX, wardY, wardZ, targetX, targetY, targetZ )
            call SetUnitXYIfNotBlocked( targetSelf, targetX, targetY, targetX + length * Cos( angle ), targetY + length * Sin( angle ) )
            if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
                set refreshedManaRelative = refreshedManaRelativeHero
            else
                set refreshedManaRelative = refreshedManaRelativeNormal
            endif
            call AddUnitState( targetSelf, UNIT_STATE_MANA, GetUnitState( targetSelf, UNIT_STATE_MAX_MANA ) * refreshedManaRelative )
            call UnitDamageUnitBySpell( caster, target, GetUnitState( targetSelf, UNIT_STATE_MAX_LIFE ) * drainedLifeRelative )
            set targetSelf = null
        endfunction

        public function Target_Start takes real bonusSpeedRelative, Unit caster, Data d, Unit target, real wardX, real wardY, real wardZ returns nothing
            local real bonusSpeed = GetUnitSpeedTotal( target ) * bonusSpeedRelative
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            local unit targetSelf = target.self
            local real targetX = GetUnitX(targetSelf)
            local real targetY = GetUnitY(targetSelf)
            set e.bonusSpeed = bonusSpeed
            set e.d = d
            set e.effectLightning = AddLightningWJ( Target_EFFECT_LIGHTNING_PATH, wardX, wardY, wardZ, targetX, targetY, GetUnitZ(targetSelf, targetX, targetY) + GetUnitImpactZ(target) )
            set targetSelf = null
            call AddIntegerToTableById(targetId, Target_SCOPE_ID, e)
            if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_STARTED ) then
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            endif
            call AddUnitSpeedBonus( target, bonusSpeed )
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit ward returns nothing
        local unit enumUnit
        local group targetGroup
        local timer updateTimer
        local integer wardId = ward.id
        local Data d = GetAttachedIntegerById(wardId, CrowdPuller_SCOPE_ID)
        if ( d != NULL ) then
            set targetGroup = d.targetGroup
            set updateTimer = d.updateTimer
            call d.destroy()
            call FlushAttachedIntegerById( wardId, CrowdPuller_SCOPE_ID )
            //! runtextmacro RemoveEventById( "wardId", "EVENT_DEATH" )
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
            endloop
            call DestroyGroupWJ( targetGroup )
            set targetGroup = null
            call FlushAttachedInteger( updateTimer, CrowdPuller_SCOPE_ID )
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes integer abilityLevel, Unit caster, Data d, group targetGroup, real wardX, real wardY, real wardZ returns nothing
        local real bonusSpeed
        local real bonusSpeedRelative
        local real drainedLifeRelative
        local unit enumUnit
        local real length
        local real refreshedManaRelative
        local real refreshedManaRelativeHero
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, wardX, wardY, AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            set drainedLifeRelative = DRAINED_LIFE_RELATIVE_PER_INTERVAL[abilityLevel]
            set length = LENGTH[abilityLevel]
            set refreshedManaRelative = REFRESHED_MANA_RELATIVE_PER_INTERVAL[abilityLevel]
            set refreshedManaRelativeHero = HERO_REFRESHED_MANA_RELATIVE_PER_INTERVAL[abilityLevel]
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup)
                else
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                call Target_Target_Interval( caster, d, drainedLifeRelative, length, refreshedManaRelativeHero, refreshedManaRelative, GetUnit(enumUnit), wardX, wardY, wardZ )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        if ( CountUnits( targetGroup ) < MAX_TARGETS_AMOUNT[abilityLevel] ) then
            set enumUnit = FirstOfGroup( ENUM_GROUP )
            if ( enumUnit != null ) then
                set bonusSpeedRelative = BONUS_SPEED_RELATIVE[abilityLevel]
                loop
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call GroupAddUnit( targetGroup, enumUnit )
                    call Target_Target_Start(bonusSpeedRelative, caster, d, GetUnit(enumUnit), wardX, wardY, wardZ)
                    set enumUnit = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endif
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, CrowdPuller_SCOPE_ID)
        local Unit ward = d.ward
        local unit wardSelf = ward.self
        local real wardX = GetUnitX( wardSelf )
        local real wardY = GetUnitY( wardSelf )
        local real wardZ = GetUnitZ( wardSelf, wardX, wardY ) + GetUnitOutpactZ(ward)
        set wardSelf = null
        call Update( d.abilityLevel, d.caster, d, d.targetGroup, wardX, wardY, wardZ )
        set updateTimer = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local Data d = Data.create()
        local group targetGroup = CreateGroupWJ()
        local timer updateTimer = CreateTimerWJ()
        local Unit ward = CreateUnitEx( caster.owner, CROWD_PULLER_UNIT_ID, targetX, targetY, STANDARD_ANGLE )
        local integer wardId = ward.id
        local unit wardSelf = ward.self
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.targetGroup = targetGroup
        set d.updateTimer = updateTimer
        set d.ward = ward
        call AttachInteger( updateTimer, CrowdPuller_SCOPE_ID, d )
        call AttachIntegerById( wardId, CrowdPuller_SCOPE_ID, d )
        //! runtextmacro AddEventById( "wardId", "EVENT_DEATH" )
        call SetUnitAnimationByIndex( wardSelf, 0 )
        call AddUnitMaxLife( ward, GetHeroStrengthTotal( caster ) * LIFE_PER_STRENGTH_POINT[abilityLevel] )
        call TimerStart( updateTimer, INTERVAL, true, function UpdateByTimer )
        set updateTimer = null
        call Update( abilityLevel, caster, d, targetGroup, targetX, targetY, GetUnitZ(wardSelf, targetX, targetY) + GetUnitOutpactZ(ward) )
        set targetGroup = null
        call UnitApplyTimedLifeWJ( wardSelf, DURATION[abilityLevel] )
        set wardSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set AREA_RANGE[1] = 400
        set AREA_RANGE[2] = 425
        set AREA_RANGE[3] = 450
        set AREA_RANGE[4] = 475
        set AREA_RANGE[5] = 500
        set BONUS_SPEED_RELATIVE[1] = -0.3
        set BONUS_SPEED_RELATIVE[2] = -0.3
        set BONUS_SPEED_RELATIVE[3] = -0.3
        set BONUS_SPEED_RELATIVE[4] = -0.3
        set BONUS_SPEED_RELATIVE[5] = -0.3
        set DRAINED_LIFE_RELATIVE_PER_INTERVAL[1] = 0.02
        set DRAINED_LIFE_RELATIVE_PER_INTERVAL[2] = 0.02
        set DRAINED_LIFE_RELATIVE_PER_INTERVAL[3] = 0.02
        set DRAINED_LIFE_RELATIVE_PER_INTERVAL[4] = 0.02
        set DRAINED_LIFE_RELATIVE_PER_INTERVAL[5] = 0.02
        set DURATION[1] = 15
        set DURATION[2] = 15
        set DURATION[3] = 15
        set DURATION[4] = 15
        set DURATION[5] = 15
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set HERO_REFRESHED_MANA_RELATIVE_PER_INTERVAL[1] = -0.02
        set HERO_REFRESHED_MANA_RELATIVE_PER_INTERVAL[2] = -0.02
        set HERO_REFRESHED_MANA_RELATIVE_PER_INTERVAL[3] = -0.03
        set HERO_REFRESHED_MANA_RELATIVE_PER_INTERVAL[4] = -0.04
        set HERO_REFRESHED_MANA_RELATIVE_PER_INTERVAL[5] = -0.04
        set LENGTH[1] = 30
        set LENGTH[2] = 36
        set LENGTH[3] = 42
        set LENGTH[4] = 48
        set LENGTH[5] = 54
        set LIFE_PER_STRENGTH_POINT[1] = 5
        set LIFE_PER_STRENGTH_POINT[2] = 5
        set LIFE_PER_STRENGTH_POINT[3] = 5
        set LIFE_PER_STRENGTH_POINT[4] = 5
        set LIFE_PER_STRENGTH_POINT[5] = 5
        set MAX_TARGETS_AMOUNT[1] = 5
        set MAX_TARGETS_AMOUNT[2] = 6
        set MAX_TARGETS_AMOUNT[3] = 7
        set MAX_TARGETS_AMOUNT[4] = 8
        set MAX_TARGETS_AMOUNT[5] = 9
        set REFRESHED_MANA_RELATIVE_PER_INTERVAL[1] = -0.05
        set REFRESHED_MANA_RELATIVE_PER_INTERVAL[2] = -0.06
        set REFRESHED_MANA_RELATIVE_PER_INTERVAL[3] = -0.07
        set REFRESHED_MANA_RELATIVE_PER_INTERVAL[4] = -0.08
        set REFRESHED_MANA_RELATIVE_PER_INTERVAL[5] = -0.09
        loop
            set DRAINED_LIFE_RELATIVE_PER_INTERVAL[iteration] = DRAINED_LIFE_RELATIVE_PER_INTERVAL[iteration] * INTERVAL
            set HERO_REFRESHED_MANA_RELATIVE_PER_INTERVAL[iteration] = HERO_REFRESHED_MANA_RELATIVE_PER_INTERVAL[iteration] * INTERVAL
            set LENGTH[iteration] = LENGTH[iteration] * INTERVAL
            set REFRESHED_MANA_RELATIVE_PER_INTERVAL[iteration] = REFRESHED_MANA_RELATIVE_PER_INTERVAL[iteration] * INTERVAL
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\CrowdPuller.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\CurseOfTheBloodline.j
//TESH.scrollpos=250
//TESH.alwaysfold=0
//! runtextmacro Scope("CurseOfTheBloodline")
    globals
        private constant integer ORDER_ID = 852190//OrderId( "curse" )
        public constant integer SPELL_ID = 'A011'

        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\NightElf\\BattleRoar\\RoarCaster.mdl"
        private real array AREA_RANGE
        private real array BONUS_CRITICAL_STRIKE_DEFENSE
        private real array DURATION
        private group ENUM_GROUP
        private real array HERO_DURATION
        private constant integer LEVELS_AMOUNT = 5
        private real array RELATIVE_DAMAGE
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\SoulBurn\\SoulBurnbuff.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "overhead"
        private constant string TARGET_EFFECT2_PATH = "Abilities\\Spells\\Undead\\DeathandDecay\\DeathandDecayTarget.mdl"
        private constant string TARGET_EFFECT2_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        integer abilityLevel
        Unit array caster[LEVELS_AMOUNT]
        timer array durationTimer[LEVELS_AMOUNT]
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer abilityLevel
        local integer oldAbilityLevel = d.abilityLevel
        local integer iteration = oldAbilityLevel - 1
        local effect targetEffect
        local integer targetId
        loop
            exitwhen (durationTimer == d.durationTimer[iteration])
            set iteration = iteration - 1
        endloop
        call FlushAttachedInteger( durationTimer, CurseOfTheBloodline_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set d.durationTimer[iteration] = null
        if ( iteration > oldAbilityLevel ) then
            loop
                exitwhen (iteration < 0)
                exitwhen (d.durationTimer[iteration] != null)
                set iteration = iteration - 1
            endloop
            if ( iteration > -1 ) then
                set abilityLevel = iteration + 1
                set d.abilityLevel = abilityLevel
                call AddUnitCriticalStrikeDefense(target, BONUS_CRITICAL_STRIKE_DEFENSE[abilityLevel] - BONUS_CRITICAL_STRIKE_DEFENSE[oldAbilityLevel] )
            else
                set targetEffect = d.targetEffect
                set targetId = target.id
                call d.destroy()
                call DestroyEffectWJ( targetEffect )
                set targetEffect = null
                call FlushAttachedIntegerById( targetId, CurseOfTheBloodline_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DAMAGE" )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
                call AddUnitCriticalStrikeDefense(target, -BONUS_CRITICAL_STRIKE_DEFENSE[oldAbilityLevel] )
            endif
        endif
    endfunction

    public function Dispel takes Unit target returns nothing
        local integer abilityLevel
        local Data d = GetAttachedIntegerById(target.id, CurseOfTheBloodline_SCOPE_ID)
        local timer durationTimer
        local integer iteration
        if (d != NULL) then
            set abilityLevel = d.abilityLevel
            set iteration = 0
            loop
                set durationTimer = d.durationTimer[iteration]
                if ( durationTimer != null ) then
                    call Ending( d, durationTimer, target )
                endif
                set iteration = iteration + 1
                exitwhen ( iteration >= abilityLevel )
            endloop
            set durationTimer = null
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, CurseOfTheBloodline_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    public function Damage takes real damageAmount, Unit target, Unit victim returns nothing
        local integer abilityLevel
        local texttag newTextTag
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, CurseOfTheBloodline_SCOPE_ID)
        local player targetOwner
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        if (d != NULL) then
            set targetOwner = target.owner
            if ( IsUnitAlly( victim.self, targetOwner ) == false ) then
                set abilityLevel = d.abilityLevel
                set damageAmount = damageAmount * RELATIVE_DAMAGE[abilityLevel - 1]
                set targetX = GetUnitX( targetSelf )
                set targetY = GetUnitY( targetSelf )
                set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
                set targetSelf = null
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT2_PATH, targetSelf, TARGET_EFFECT2_ATTACHMENT_POINT ) )
                set targetSelf = target.self
                call UnitDamageUnitBySpell( d.caster[abilityLevel - 1], target, damageAmount )
                set newTextTag = CreateRisingTextTag( I2S( R2I( damageAmount ) ), 0.022, targetX, targetY, targetZ, 70, 255, 128, 128, 255, 0.75, 3 )
                if ( newTextTag != null ) then
                    call LimitTextTagVisibilityToPlayer( newTextTag, targetOwner )
                    set newTextTag = null
                endif
            endif
            set targetOwner = null
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_AMOUNT, DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function StartTarget takes integer abilityLevel, Unit caster, Unit target returns nothing
        local real duration
        local timer durationTimer
        local integer iteration
        local integer oldAbilityLevel
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, CurseOfTheBloodline_SCOPE_ID)
        local boolean isNew = (d == NULL)
        local unit targetSelf = target.self
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set iteration = LEVELS_AMOUNT - 1
            set d.abilityLevel = abilityLevel
            set d.target = target
            loop
                if (iteration == abilityLevel) then
                    set d.caster[iteration] = caster
                    set d.durationTimer[iteration] = durationTimer
                else
                    set d.caster[iteration] = NULL
                    set d.durationTimer[iteration] = null
                endif
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call AttachInteger(durationTimer, CurseOfTheBloodline_SCOPE_ID, d)
            call AttachIntegerById(targetId, CurseOfTheBloodline_SCOPE_ID, d)
            //! runtextmacro AddEventById( "targetId", "EVENT_DAMAGE" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        else
            set durationTimer = d.durationTimer[abilityLevel]
            set d.caster[abilityLevel - 1] = caster
            if (durationTimer == null) then
                set durationTimer = CreateTimerWJ()
                set d.durationTimer[abilityLevel - 1] = durationTimer
                call AttachInteger(durationTimer, CurseOfTheBloodline_SCOPE_ID, d)
            endif
            set oldAbilityLevel = d.abilityLevel
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            call AddUnitCriticalStrikeDefense( target, BONUS_CRITICAL_STRIKE_DEFENSE[abilityLevel] )
        elseif (abilityLevel > oldAbilityLevel) then
            set d.abilityLevel = abilityLevel
            call AddUnitCriticalStrikeDefense( target, BONUS_CRITICAL_STRIKE_DEFENSE[abilityLevel] - BONUS_CRITICAL_STRIKE_DEFENSE[oldAbilityLevel] )
        endif
        if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
            set duration = HERO_DURATION[abilityLevel]
        else
            set duration = DURATION[abilityLevel]
        endif
        set targetSelf = null
        call TimerStart( durationTimer, duration, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local unit enumUnit
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, targetX, targetY ) )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call StartTarget(abilityLevel, caster, GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        set AREA_RANGE[1] = 275
        set AREA_RANGE[2] = 275
        set AREA_RANGE[3] = 275
        set AREA_RANGE[4] = 275
        set AREA_RANGE[5] = 275
        set BONUS_CRITICAL_STRIKE_DEFENSE[1] = -0.15
        set BONUS_CRITICAL_STRIKE_DEFENSE[2] = -0.18
        set BONUS_CRITICAL_STRIKE_DEFENSE[3] = -0.21
        set BONUS_CRITICAL_STRIKE_DEFENSE[4] = -0.24
        set BONUS_CRITICAL_STRIKE_DEFENSE[5] = -0.27
        set DURATION[1] = 15
        set DURATION[2] = 15
        set DURATION[3] = 15
        set DURATION[4] = 15
        set DURATION[5] = 15
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_NEGATIVE", "0", "function Dispel_Event" )
        set HERO_DURATION[1] = 6
        set HERO_DURATION[2] = 6
        set HERO_DURATION[3] = 6
        set HERO_DURATION[4] = 6
        set HERO_DURATION[5] = 6
        set RELATIVE_DAMAGE[1] = 0.6
        set RELATIVE_DAMAGE[2] = 0.8
        set RELATIVE_DAMAGE[3] = 01
        set RELATIVE_DAMAGE[4] = 1.2
        set RELATIVE_DAMAGE[5] = 1.4
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT2_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\CurseOfTheBloodline.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\DarkCloud.j
//TESH.scrollpos=365
//TESH.alwaysfold=0
//! runtextmacro Scope("DarkCloud")
    globals
        private constant integer ORDER_ID = 852222//OrderId( "deathcoil" )
        public constant integer SPELL_ID = 'A00Q'

        private real array BONUS_MISS_CHANCE
        private real array BONUS_MISS_CHANCE_PER_AGILITY_POINT
        private real array DAMAGE_PER_INTERVAL
        private real array DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT
        private real array DURATION
        private group ENUM_GROUP
        private real array INTERVAL
        private constant integer LEVELS_AMOUNT = 5
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant string TARGET_EFFECT2_PATH = "Abilities\\Spells\\Other\\Monsoon\\MonsoonRain.mdl"
        private constant string TARGET_EFFECT2_ATTACHMENT_POINT = "origin"
        private integer array WAVES_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        real array bonusMissChance[LEVELS_AMOUNT]
        Unit array caster[LEVELS_AMOUNT]
        real array damagePerIntervalAmount[LEVELS_AMOUNT]
        timer array durationTimer[LEVELS_AMOUNT]
        timer intervalTimer
        Unit target
        effect targetEffect
        effect targetEffect2
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer abilityLevel = d.abilityLevel
        local real bonusMissChance
        local timer intervalTimer
        local integer iteration = abilityLevel - 1
        local effect targetEffect
        local effect targetEffect2
        local integer targetId
        loop
            exitwhen (durationTimer == d.durationTimer[iteration])
            set iteration = iteration - 1
        endloop
        set d.durationTimer[iteration] = null
        if ( abilityLevel - 1 <= iteration ) then
            set bonusMissChance = d.bonusMissChance[abilityLevel - 1]
            loop
                exitwhen (iteration < 0)
                exitwhen (d.durationTimer[iteration] != null)
                set iteration = iteration - 1
            endloop
            if ( iteration > -1 ) then
                set d.abilityLevel = iteration + 1
                call AddUnitMissChance( target, d.bonusMissChance[iteration] - bonusMissChance )
            else
                set intervalTimer = d.intervalTimer
                set targetEffect = d.targetEffect
                set targetEffect2 = d.targetEffect2
                set targetId = target.id
                call d.destroy()
                call FlushAttachedInteger(intervalTimer, DarkCloud_SCOPE_ID)
                call DestroyTimerWJ(intervalTimer)
                set intervalTimer = null
                call DestroyEffectWJ( targetEffect )
                call DestroyEffectWJ( targetEffect2 )
                set targetEffect = null
                call FlushAttachedIntegerById( targetId, DarkCloud_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
                call AddUnitMissChance( target, -bonusMissChance )
            endif
        endif
        call FlushAttachedInteger( durationTimer, DarkCloud_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
    endfunction

    public function Dispel takes Unit target returns nothing
        local integer abilityLevel
        local Data d = GetAttachedIntegerById(target.id, DarkCloud_SCOPE_ID)
        local timer durationTimer
        local integer iteration
        if (d != NULL) then
            set abilityLevel = d.abilityLevel
            set iteration = 0
            loop
                set durationTimer = d.durationTimer[iteration]
                if ( durationTimer != null ) then
                    call Ending( d, durationTimer, target )
                endif
                set iteration = iteration + 1
                exitwhen ( iteration == abilityLevel )
            endloop
            set durationTimer = null
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, DarkCloud_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    //! runtextmacro Scope("Lightning")
        globals
            private real array Lightning_AREA_RANGE
            private constant real Lightning_DELAY = 0.5
            private constant string Lightning_SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl"
            private constant string Lightning_SPECIAL_EFFECT2_PATH = "Abilities\\Spells\\Human\\Thunderclap\\ThunderClapCaster.mdl"
            private real array Lightning_STUN_AREA_RANGE
            private real array Lightning_STUN_DURATION
            private real array Lightning_STUN_HERO_DURATION
            private boolexpr Lightning_TARGET_CONDITIONS
        endglobals

        private struct Lightning_Data
            integer abilityLevel
            Unit caster
            real damageAmount
            Unit target
            real targetX
            real targetY
        endstruct

        private function Lightning_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( FILTER_UNIT_SELF == TEMP_UNIT_SELF ) then
                return false
            endif
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
                return false
            endif
            set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
            if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
                return false
            endif
            if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
                return false
            endif
            return true
        endfunction

        private function Lightning_Ending takes nothing returns nothing
            local real areaRangeStun
            local real duration
            local Unit enumUnit
            local unit enumUnitSelf
            local timer delayTimer = GetExpiredTimer()
            local Lightning_Data d = GetAttachedInteger(delayTimer, Lightning_SCOPE_ID)
            local integer abilityLevel = d.abilityLevel
            local Unit caster = d.caster
            local real damageAmount = d.damageAmount
            local real heroDuration
            local real stunTime
            local Unit target = d.target
            local real targetX = d.targetX
            local real targetY = d.targetY
            call d.destroy()
            call FlushAttachedInteger( delayTimer, Lightning_SCOPE_ID )
            call DestroyTimerWJ( delayTimer )
            set delayTimer = null
            call DestroyEffectWJ( AddSpecialEffectWJ( Lightning_SPECIAL_EFFECT2_PATH, targetX, targetY ) )
            set TEMP_PLAYER = caster.owner
            set TEMP_UNIT_SELF = target.self
            call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, Lightning_AREA_RANGE[abilityLevel], Lightning_TARGET_CONDITIONS )
            set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
            if ( enumUnitSelf != null ) then
                set areaRangeStun = Lightning_STUN_AREA_RANGE[abilityLevel]
                set duration = Lightning_STUN_DURATION[abilityLevel]
                set heroDuration = Lightning_STUN_HERO_DURATION[abilityLevel]
                loop
                    set enumUnit = GetUnit(enumUnitSelf)
                    call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                    if ( DistanceByCoordinates( targetX, targetY, GetUnitX( enumUnitSelf ), GetUnitY( enumUnitSelf ) ) <= areaRangeStun ) then
                        if ( IsUnitType( enumUnitSelf, UNIT_TYPE_HERO ) ) then
                            set stunTime = heroDuration
                        else
                            set stunTime = duration
                        endif
                        call SetUnitStunTimed( enumUnit, 1, stunTime )
                    endif
                    call UnitDamageUnitBySpell( caster, enumUnit, damageAmount )
                    set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnitSelf == null )
                endloop
            endif
        endfunction

        public function Lightning_Start takes integer abilityLevel, Unit caster, real damageAmount, Unit target returns nothing
            local Lightning_Data d = Lightning_Data.create()
            local timer delayTimer = CreateTimerWJ()
            local unit targetSelf = target.self
            local real targetX = GetUnitX( targetSelf )
            local real targetY = GetUnitY( targetSelf )
            set targetSelf = null
            set d.abilityLevel = abilityLevel
            set d.caster = caster
            set d.damageAmount = damageAmount
            set d.target = target
            set d.targetX = targetX
            set d.targetY = targetY
            call AttachInteger( delayTimer, Lightning_SCOPE_ID, d )
            call DestroyEffectWJ( AddSpecialEffectWJ( Lightning_SPECIAL_EFFECT_PATH, targetX, targetY ) )
            call TimerStart( delayTimer, Lightning_DELAY, false, function Lightning_Ending )
            set delayTimer = null
        endfunction

        public function Lightning_Init takes nothing returns nothing
            set Lightning_AREA_RANGE[1] = 350
            set Lightning_AREA_RANGE[2] = 350
            set Lightning_AREA_RANGE[3] = 350
            set Lightning_AREA_RANGE[4] = 350
            set Lightning_AREA_RANGE[5] = 350
            set Lightning_STUN_AREA_RANGE[1] = 100
            set Lightning_STUN_AREA_RANGE[2] = 100
            set Lightning_STUN_AREA_RANGE[3] = 100
            set Lightning_STUN_AREA_RANGE[4] = 100
            set Lightning_STUN_AREA_RANGE[5] = 100
            set Lightning_STUN_DURATION[1] = 0.5
            set Lightning_STUN_DURATION[2] = 0.5
            set Lightning_STUN_DURATION[3] = 0.5
            set Lightning_STUN_DURATION[4] = 0.5
            set Lightning_STUN_DURATION[5] = 0.5
            set Lightning_STUN_HERO_DURATION[1] = 0.5
            set Lightning_STUN_HERO_DURATION[2] = 0.5
            set Lightning_STUN_HERO_DURATION[3] = 0.5
            set Lightning_STUN_HERO_DURATION[4] = 0.5
            set Lightning_STUN_HERO_DURATION[5] = 0.5
            set Lightning_TARGET_CONDITIONS = ConditionWJ( function Lightning_TargetConditions )
            call InitEffectType( Lightning_SPECIAL_EFFECT_PATH )
            call InitEffectType( Lightning_SPECIAL_EFFECT2_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function Interval takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, DarkCloud_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        set intervalTimer = null
        call Lightning_Lightning_Start( abilityLevel, d.caster[abilityLevel - 1], d.damagePerIntervalAmount[abilityLevel - 1], d.target )
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local real bonusMissChance = BONUS_MISS_CHANCE[abilityLevel]
        local real damagePerIntervalAmount = DAMAGE_PER_INTERVAL[abilityLevel] + GetHeroStrengthTotal(caster) * DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[abilityLevel]
        local timer durationTimer
        local timer intervalTimer
        local integer iteration
        local integer oldAbilityLevel
        local real oldBonusMissChance
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, DarkCloud_SCOPE_ID)
        local boolean isNew = (d == NULL)
        local unit targetSelf = target.self
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set intervalTimer = CreateTimerWJ()
            set iteration = abilityLevel - 1
            set d.abilityLevel = abilityLevel
            set d.intervalTimer = intervalTimer
            set d.target = target
            loop
                if (iteration == abilityLevel - 1) then
                    set d.caster[iteration] = caster
                    set d.durationTimer[iteration] = durationTimer
                else
                    set d.caster[iteration] = NULL
                    set d.durationTimer[iteration] = null
                endif
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call AttachInteger(durationTimer, DarkCloud_SCOPE_ID, d)
            call AttachInteger(intervalTimer, DarkCloud_SCOPE_ID, d)
            call AttachIntegerById(targetId, DarkCloud_SCOPE_ID, d)
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        else
            set durationTimer = d.durationTimer[abilityLevel - 1]
            set d.caster[abilityLevel - 1] = caster
            if (durationTimer == null) then
                set durationTimer = CreateTimerWJ()
                set d.durationTimer[abilityLevel - 1] = durationTimer
                call AttachInteger(durationTimer, DarkCloud_SCOPE_ID, d)
            endif
            set oldAbilityLevel = d.abilityLevel
            set oldBonusMissChance = d.bonusMissChance[oldAbilityLevel - 1]
            call DestroyEffectWJ( d.targetEffect )
            call DestroyEffectWJ( d.targetEffect2 )
        endif
        set d.bonusMissChance[abilityLevel - 1] = bonusMissChance
        set d.damagePerIntervalAmount[abilityLevel - 1] = damagePerIntervalAmount
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        set d.targetEffect2 = AddSpecialEffectTargetWJ( TARGET_EFFECT2_PATH, targetSelf, TARGET_EFFECT2_ATTACHMENT_POINT )
        set targetSelf = null
        if ( isNew ) then
            call AddUnitMissChance( target, bonusMissChance )
            call TimerStart(intervalTimer, INTERVAL[abilityLevel], true, function Interval)
            set intervalTimer = null
        elseif (abilityLevel >= oldAbilityLevel) then
            set d.abilityLevel = abilityLevel
            call AddUnitMissChance( target, bonusMissChance - oldBonusMissChance )
            call TimerStart(d.intervalTimer, INTERVAL[abilityLevel], true, function Interval)
        endif
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit caster, unit target returns string
        if ( IsUnitType( target, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT, TARGET_UNIT.self )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set BONUS_MISS_CHANCE[1] = 0.34
        set BONUS_MISS_CHANCE[2] = 0.41
        set BONUS_MISS_CHANCE[3] = 0.48
        set BONUS_MISS_CHANCE[4] = 0.55
        set BONUS_MISS_CHANCE[5] = 0.62
        set BONUS_MISS_CHANCE_PER_AGILITY_POINT[1] = 0.005
        set BONUS_MISS_CHANCE_PER_AGILITY_POINT[2] = 0.005
        set BONUS_MISS_CHANCE_PER_AGILITY_POINT[3] = 0.005
        set BONUS_MISS_CHANCE_PER_AGILITY_POINT[4] = 0.005
        set BONUS_MISS_CHANCE_PER_AGILITY_POINT[5] = 0.005
        set DAMAGE_PER_INTERVAL[1] = 20
        set DAMAGE_PER_INTERVAL[2] = 35
        set DAMAGE_PER_INTERVAL[3] = 50
        set DAMAGE_PER_INTERVAL[4] = 65
        set DAMAGE_PER_INTERVAL[5] = 80
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[1] = 0.5
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[2] = 0.5
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[3] = 0.5
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[4] = 0.5
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[5] = 0.5
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_NEGATIVE", "0", "function Dispel_Event" )
        set INTERVAL[1] = 2.25
        set INTERVAL[2] = 2.25
        set INTERVAL[3] = 2.25
        set INTERVAL[4] = 2.25
        set INTERVAL[5] = 2.25
        set WAVES_AMOUNT[1] = 4
        set WAVES_AMOUNT[2] = 5
        set WAVES_AMOUNT[3] = 6
        set WAVES_AMOUNT[4] = 7
        set WAVES_AMOUNT[5] = 8
        loop
            set DURATION[iteration] = WAVES_AMOUNT[iteration] * INTERVAL[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT2_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Lightning_Lightning_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\DarkCloud.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Defend.j
//TESH.scrollpos=62
//TESH.alwaysfold=0
//! runtextmacro Scope("Defend")
    globals
        private constant integer ACTIVATION_ORDER_ID = 852055//OrderId( "defend" )
        private constant integer DEACTIVATION_ORDER_ID = 852056//OrderId( "undefend" )
        public constant integer RESEARCH_ID = 'R013'
        public constant integer SPELL_ID = 'A083'

        private constant real BONUS_SPEED = -150.
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Human\\Defend\\DefendCaster.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real DAMAGE_FACTOR = 0.3
    endglobals

    private struct Data
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById( casterId, Defend_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        call AddUnitSpeedBonus( caster, -BONUS_SPEED )
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Defend_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    public function Damage takes Unit caster, real damageAmount, Unit damageSource returns real
        if ((GetAttachedIntegerById(caster.id, Defend_SCOPE_ID) != NULL)) then
            if (GetUnitTypeDamageType(damageSource.type) == DMG_TYPE_PIERCE) then
                return (damageAmount * DAMAGE_FACTOR)
            endif
        endif
        return damageAmount
    endfunction

    private function Damage_Event takes nothing returns nothing
        set DAMAGE_AMOUNT = Damage(TRIGGER_UNIT, DAMAGE_AMOUNT, DAMAGE_SOURCE)
    endfunction

    public function Deactivation_OrderExecute takes Unit caster returns nothing
        local integer casterId
        local unit casterSelf = caster.self
        local Data d
        if (IsUnitType(casterSelf, UNIT_TYPE_DEAD) == false) then
            set casterId = caster.id
            set d = GetAttachedIntegerById(casterId, Defend_SCOPE_ID)
            if ( d != NULL ) then
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT ) )
                call Ending(caster, d)
            endif
        endif
        set casterSelf = null
    endfunction

    private function Deactivation_OrderExecute_Event takes nothing returns nothing
        call Deactivation_OrderExecute( ORDERED_UNIT )
    endfunction

    public function Activation_OrderExecute takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, Defend_SCOPE_ID)
        if ( d == NULL ) then
            set d = Data.create()
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT ) )
            call AttachIntegerById(casterId, Defend_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AddUnitSpeedBonus( caster, BONUS_SPEED )
        endif
    endfunction

    private function Activation_OrderExecute_Event takes nothing returns nothing
        call Activation_OrderExecute( ORDERED_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro AddNewEventById( "EVENT_ACTIVATION_ORDER_EXECUTE", "GetAbilityOrderId( SPELL_ID, ACTIVATION_ORDER_ID )", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function Activation_OrderExecute_Event" )
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_FOR_DAMAGE", "0", "function Damage_Event" )
        //! runtextmacro AddNewEventById( "EVENT_DEACTIVATION_ORDER_EXECUTE", "GetAbilityOrderId( SPELL_ID, DEACTIVATION_ORDER_ID )", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function Deactivation_OrderExecute_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateDummyEvent( "EVENT_ORDER_EXECUTE", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0" )
        call AddOrderAbility( ACTIVATION_ORDER_ID, SPELL_ID )
        call InitEffectType( CASTER_EFFECT_PATH )
        call AddOrderAbility( DEACTIVATION_ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Defend.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Disarm.j
//TESH.scrollpos=132
//TESH.alwaysfold=0
//! runtextmacro Scope("Disarm")
    globals
        public constant integer RESEARCH_ID = 'R019'
        public constant integer SPELL_ID = 'A089'

        private constant real DURATION = 10.
        private constant real RELATIVE_BONUS_DAMAGE = -0.4
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\NightElf\\Barkskin\\BarkSkinTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "hand right"
    endglobals

    private struct Data
        real bonusDamage
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId = caster.id
        if (GetAttachedBooleanById( casterId, Disarm_SCOPE_ID )) then
            call FlushAttachedBooleanById( casterId, Disarm_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( TRIGGER_UNIT )
    endfunction

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local real bonusDamage = d.bonusDamage
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, Disarm_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, Disarm_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call AddUnitDamageBonus( target, -bonusDamage )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById( target.id, Disarm_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( DYING_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel(target)
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Disarm_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function Damage_TargetConditions takes Unit caster, player casterOwner, unit target returns boolean
        if ( GetAttachedBooleanById( caster.id, Disarm_SCOPE_ID ) == false ) then
            return false
        endif
        if ( IsUnitAlly( target, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, Unit target returns nothing
        local real bonusDamage
        local Data d
        local timer durationTimer
        local boolean isNew
        local real oldBonusDamage
        local integer targetId
        local unit targetSelf = target.self
        if ( Damage_TargetConditions( caster, caster.owner, targetSelf ) ) then
            set bonusDamage = RELATIVE_BONUS_DAMAGE * GetUnitDamage(target)
            set targetId = target.id
            set d = GetAttachedIntegerById( targetId, Disarm_SCOPE_ID )
            set isNew = ( d == NULL )
            if ( isNew ) then
                set d = Data.create()
                set durationTimer = CreateTimerWJ()
                set d.bonusDamage = bonusDamage
                set d.durationTimer = durationTimer
                set d.target = target
                call AttachInteger( durationTimer, Disarm_SCOPE_ID, d )
                call AttachIntegerById( targetId, Disarm_SCOPE_ID, d )
                //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            else
                set durationTimer = d.durationTimer
                call DestroyEffectWJ( d.targetEffect )
            endif
            set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
            set targetSelf = null
            if (isNew) then
                call AddUnitDamageBonus( target, bonusDamage )
            else
                set oldBonusDamage = d.bonusDamage
                if (bonusDamage != oldBonusDamage) then
                    set d.bonusDamage = bonusDamage
                    call AddUnitDamageBonus( target, bonusDamage - oldBonusDamage )
                endif
            endif
            call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
            set durationTimer = null
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, Disarm_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call SetAbilityRequiredResearch( SPELL_ID, RESEARCH_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Disarm.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\DiversionaryTactics.j
//TESH.scrollpos=57
//TESH.alwaysfold=0
//! runtextmacro Scope("DiversionaryTactics")
    globals
        private constant integer ORDER_ID = 852662//OrderId( "acidbomb" )
        public constant integer SPELL_ID = 'A02C'

        private constant real AREA_RANGE = 700.
        private group ENUM_GROUP
        private integer HINTS_AMOUNT = 0
        private string array HINTS
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( IsUnitChanneling( FILTER_UNIT ) ) then
            return false
        endif
        if ( IsUnitEnemy( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitIllusionWJ( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY )
        local unit enumUnit
        call CreateRisingTextTag( HINTS[GetRandomInt(0, HINTS_AMOUNT - 1)], 0.026, casterX, casterY, casterZ + 175, 60, 255, 255, 255, 255, 1.5, 3 )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if (enumUnit != null) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call IssueTargetOrderById( enumUnit, ATTACK_ORDER_ID, casterSelf )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set casterSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    private function InitHint takes string text returns nothing
        set HINTS[HINTS_AMOUNT] = text
        set HINTS_AMOUNT = HINTS_AMOUNT + 1
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        call InitHint( "I love you!" )
        call InitHint( "Baka!" )
        call InitHint( "I have eaten all of your cookies!" )
        call InitHint( "Losers!" )
        call InitHint( "All signs point to me!" )
        call InitHint( "Come to mama!" )
        call InitHint( "Meet your maker!" )
        call InitHint( "!!! (need more content) !!!" )
        call InitHint( "Look in front of you, a one-headed monkey!" )
        call InitHint( "You cannot even do a kickflip!" )
        call InitHint( "How many of you are needed to change a bulb?!" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\DiversionaryTactics.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\DiversionShot.j
//TESH.scrollpos=134
//TESH.alwaysfold=0
//! runtextmacro Scope("DiversionShot")
    globals
        public constant integer SPELL_ID = 'A043'

        private constant real AREA_RANGE = 260.
        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Other\\Volcano\\VolcanoDeath.mdl"
        private group ENUM_GROUP
        private constant real INTERVAL = 0.035
        private constant real DURATION = 0.5
        private constant real DAMAGE = 100. / DURATION * INTERVAL
        private constant real SPEED = 550.
        private constant real LENGTH = SPEED * INTERVAL
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        Unit caster
        timer durationTimer
        timer intervalTimer
        real targetX
        real targetY
    endstruct

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId = caster.id
        if (GetAttachedBooleanById( casterId, DiversionShot_SCOPE_ID )) then
            call FlushAttachedBooleanById( casterId, DiversionShot_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( TRIGGER_UNIT )
    endfunction

    private function Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, DiversionShot_SCOPE_ID)
        local Unit caster = d.caster
        local timer intervalTimer = d.intervalTimer
        call d.destroy()
        call RemoveUnitRemainingReference( caster )
        call FlushAttachedInteger( durationTimer, DiversionShot_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( intervalTimer, DiversionShot_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitInvulnerability( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function Interval takes nothing returns nothing
        local Unit enumUnit
        local unit enumUnitSelf
        local real enumUnitX
        local real enumUnitY
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, DiversionShot_SCOPE_ID)
        local Unit caster = d.caster
        local real targetEnumUnitAngle
        local real targetX = d.targetX
        local real targetY = d.targetY
        set intervalTimer = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                set enumUnitX = GetUnitX( enumUnitSelf )
                set enumUnitY = GetUnitY( enumUnitSelf )
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                if ( ( enumUnitX != targetX ) or ( enumUnitY != targetY ) ) then
                    set targetEnumUnitAngle = Atan2( enumUnitY - targetY, enumUnitX - targetX )
                else
                    set targetEnumUnitAngle = GetUnitFacingWJ( enumUnitSelf ) + PI
                endif
                call SetUnitXYIfNotBlocked( enumUnitSelf, enumUnitX, enumUnitY, enumUnitX + LENGTH * Cos( targetEnumUnitAngle ), enumUnitY + LENGTH * Sin( targetEnumUnitAngle ) )
                call UnitDamageUnitEx( caster, enumUnit, ( 1 - DistanceByCoordinates( enumUnitX, enumUnitY, targetX, targetY ) / AREA_RANGE ) * DAMAGE, null )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
    endfunction

    public function Damage takes Unit caster, real targetX, real targetY returns nothing
        local Data d
        local timer durationTimer
        local timer intervalTimer
        if ( GetAttachedBooleanById( caster.id, DiversionShot_SCOPE_ID ) ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set intervalTimer = CreateTimerWJ()
            set d.caster = caster
            set d.durationTimer = durationTimer
            set d.intervalTimer = intervalTimer
            set d.targetX = targetX
            set d.targetY = targetY
            call AttachInteger( durationTimer, DiversionShot_SCOPE_ID, d )
            call AttachInteger( intervalTimer, DiversionShot_SCOPE_ID, d )
            call AddUnitRemainingReference(caster)
            call DestroyEffectTimed( AddSpecialEffectWJ( AREA_EFFECT_PATH, targetX, targetY ), DURATION )
            call TimerStart( intervalTimer, INTERVAL, true, function Interval )
            set intervalTimer = null
            call TimerStart( durationTimer, DURATION, false, function Ending )
            set durationTimer = null
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, TARGET_X, TARGET_Y )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, DiversionShot_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\DiversionShot.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\DivineArmor.j
//TESH.scrollpos=66
//TESH.alwaysfold=0
//! runtextmacro Scope("DivineArmor")
    globals
        public constant integer SPELL_ID = 'A041'

        private constant integer DUMMY_UNIT_ID = 'h00F'
        private real array CHANCE
        private real array DURATION
        private real array HERO_DURATION
    endglobals

    private function Damage_Conditions takes player casterOwner, unit target returns boolean
        if ( IsUnitAlly( target, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_MELEE_ATTACKER ) == false ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, Unit target returns nothing
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX
        local real casterY
        local unit dummyUnit
        local real duration
        local unit targetSelf
        if (abilityLevel > 0) then
            set targetSelf = target.self
            if ( Damage_Conditions( caster.owner, targetSelf ) ) then
                if ( GetRandomReal( 0.01, 1 ) < CHANCE[abilityLevel] ) then
                    set casterX = GetUnitX( casterSelf )
                    set casterY = GetUnitY( casterSelf )
                    set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, casterX, casterY, GetUnitFacingWJ( casterSelf ) + PI )
                    call SetUnitAnimationByIndex( dummyUnit, 1 )
                    call RemoveUnitTimed( dummyUnit, 2 )
                    set dummyUnit = null
                    if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
                        set duration = HERO_DURATION[abilityLevel]
                    else
                        set duration = DURATION[abilityLevel]
                    endif
                    call SetUnitStunTimed( target, 1, duration )
                endif
            endif
            set targetSelf = null
        endif
        set casterSelf = null
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( TRIGGER_UNIT, DAMAGE_SOURCE )
    endfunction

    public function Learn takes Unit caster returns nothing
        //! runtextmacro AddEventById( "caster.id", "EVENT_DAMAGE" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set CHANCE[1] = 0.25
        set CHANCE[2] = 0.25
        set CHANCE[3] = 0.28
        set CHANCE[4] = 0.30
        set CHANCE[5] = 0.32
        set DURATION[1] = 1.8
        set DURATION[2] = 2
        set DURATION[3] = 2.2
        set DURATION[4] = 2.4
        set DURATION[5] = 2.6
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY", "0", "function Damage_Event" )
        set HERO_DURATION[1] = 1
        set HERO_DURATION[2] = 1.3
        set HERO_DURATION[3] = 1.6
        set HERO_DURATION[4] = 1.9
        set HERO_DURATION[5] = 2.2
        call InitUnitType( DUMMY_UNIT_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\DivineArmor.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\DivineShield.j
//TESH.scrollpos=141
//TESH.alwaysfold=0
//! runtextmacro Scope("DivineShield")
    globals
        private constant integer ORDER_ID = 852090//OrderId( "divineshield" )
        public constant integer SPELL_ID = 'A03A'

        private constant real DURATION = 10.
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        integer casterTeam
        timer durationTimer
        group targetGroup
    endstruct

    //! runtextmacro Scope("Target")
        private struct Target_Data
            Data d
        endstruct

        private function Target_Ending takes Target_Data d, Unit target, group targetGroup returns nothing
            local integer targetId = target.id
            call d.destroy()
            call FlushAttachedIntegerById(targetId, Target_SCOPE_ID)
            //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            call GroupRemoveUnit( targetGroup, target.self )
            call RemoveUnitInvulnerabilityWithEffect( target )
        endfunction

        public function Target_EndingByEnding takes Unit target, group targetGroup returns nothing
            call Target_Ending(GetAttachedIntegerById(target.id, Target_SCOPE_ID), target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Data d
            local Target_Data e = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            if ( e != NULL ) then
                set d = e.d
                call Target_Ending( e, target, d.targetGroup )
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( TRIGGER_UNIT )
        endfunction

        public function Target_Start takes Data d, Unit target, group targetGroup returns nothing
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            call GroupAddUnit( targetGroup, target.self )
            set e.d = d
            call AttachIntegerById(targetId, Target_SCOPE_ID, e)
            //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            call AddUnitInvulnerabilityWithEffect( target )
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    private function Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, DivineShield_SCOPE_ID)
        local integer casterTeam = d.casterTeam
        local string casterTeamString = GetTeamString(casterTeam)
        local unit enumUnit
        local group targetGroup = d.targetGroup
        call d.destroy()
        call FlushSavedInteger( casterTeamString, SCOPE_PREFIX )
        call FlushAttachedInteger( durationTimer, DivineShield_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        //! runtextmacro RemoveSavedEvent( "casterTeamString", "EVENT_ACTIVATE" )
        loop
            set enumUnit = FirstOfGroup( targetGroup )
            exitwhen ( enumUnit == null )
            call Target_Target_EndingByEnding( GetUnit(enumUnit), targetGroup )
        endloop
        call DestroyGroupWJ( targetGroup )
        set targetGroup = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetPlayerTeam( GetUnit( FILTER_UNIT_SELF ).owner ) != TEMP_INTEGER ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    public function Activate takes Unit target, integer targetTeam returns nothing
        local Data d = GetSavedInteger(GetTeamString(targetTeam), SCOPE_PREFIX)
        local group targetGroup
        if ( d != NULL ) then
            call Target_Target_Start(d, target, d.targetGroup)
        endif
    endfunction

    private function Activate_Event takes nothing returns nothing
        call Activate( TRIGGER_UNIT, GetPlayerTeam(TRIGGER_UNIT.owner) )
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterTeam = GetPlayerTeam( caster.owner )
        local string casterTeamString = GetTeamString(casterTeam)
        local Data d = GetSavedInteger(casterTeamString, SCOPE_PREFIX)
        local timer durationTimer
        local unit enumUnit
        local group targetGroup
        if ( d == NULL ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set targetGroup = CreateGroupWJ()
            set d.casterTeam = casterTeam
            set d.durationTimer = durationTimer
            set d.targetGroup = targetGroup
            call SaveIntegerWJ( casterTeamString, SCOPE_PREFIX, d )
            //! runtextmacro AddSavedEvent( "casterTeamString", "EVENT_ACTIVATE" )
            call AttachInteger(durationTimer, DivineShield_SCOPE_ID, d)
            set TEMP_INTEGER = casterTeam
            call GroupEnumUnitsInRectWithCollision( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
            set enumUnit = FirstOfGroup( ENUM_GROUP )
            if ( enumUnit != null ) then
                loop
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call Target_Target_Start(d, GetUnit(enumUnit), targetGroup)
                    set enumUnit = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        else
            set durationTimer = d.durationTimer
        endif
        call PingMasterWizard( casterTeam )
        call TimerStart( durationTimer, DURATION, false, function Ending )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateSavedEvent( "EVENT_ACTIVATE", "UnitIsActivated_EVENT_STRING_KEY", "0", "function Activate_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\DivineShield.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Downgrade.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Downgrade")
    globals
        private constant integer ORDER_ID = 852534//OrderId( "unburrow" )
        public constant integer SPELL_ID = 'A036'

        private constant real RESTORED_GOLD_FACTOR = 0.65
    endglobals

    public function SpellEffect2 takes Unit caster returns nothing
        local player casterOwner = caster.owner
        local Unit townHall = GetPlayerTownHall(casterOwner)
        local unit townHallSelf = townHall.self
        local real townHallRelativeLife = GetUnitState( townHallSelf, UNIT_STATE_LIFE ) / GetUnitState( townHallSelf, UNIT_STATE_MAX_LIFE )
        local integer goldSpent = R2I( GetUnitGoldSpentInUpgrades(townHall) * RESTORED_GOLD_FACTOR )
        call RemoveUnitEx( GetPlayerResearchCenter(townHall.owner) )
        call ClearUnitRequestQueue( townHall )
        call RemoveUnitEx( townHall )
        set townHall = CreateUnitEx( casterOwner, FLAG_UNIT_ID, GetStartLocationX( GetPlayerStartLocation( casterOwner ) ), GetStartLocationY( GetPlayerStartLocation( casterOwner ) ), STANDARD_ANGLE )
        set townHallSelf = townHall.self
        call SetPlayerRaceWJ(casterOwner, NULL)
        call SetPlayerTownHall(casterOwner, townHall)
        call PlaySoundFromTypeForPlayer( DOWNGRADE_SOUND_TYPE, casterOwner )
        call SetUnitState( townHallSelf, UNIT_STATE_LIFE, townHallRelativeLife * GetUnitState( townHallSelf, UNIT_STATE_MAX_LIFE ) )
        set townHallSelf = null
        call AddPlayerState( casterOwner, PLAYER_STATE_RESOURCE_GOLD, goldSpent )
        set casterOwner = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        call SpellEffect2(caster)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        if ( IsUnitType( target.self, UNIT_TYPE_TOWNHALL ) == false ) then
            return ErrorStrings_ONLY_TOWN_HALL
        endif
        if ( casterOwner != target.owner ) then
            return ErrorStrings_ONLY_YOUR_TOWN_HALL
        endif
        if (GetPlayerRaceWJ(casterOwner) == NULL) then
            return ErrorStrings_WHAT_ABOUT_RACE_FIRST
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Downgrade.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\DreadCall.j
//TESH.scrollpos=125
//TESH.alwaysfold=0
//! runtextmacro Scope("DreadCall")
    globals
        private constant integer ORDER_ID = 852105//OrderId( "evileye" )
        public constant integer SPELL_ID = 'A075'

        private constant real AREA_RANGE = 300.
        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Other\\HowlOfTerror\\HowlCaster.mdl"
        private constant real DURATION = 8.
        private group ENUM_GROUP
        private constant real HERO_DURATION = 5.
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, DreadCall_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, DreadCall_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call RemoveUnitAttackSilence( target )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, DreadCall_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, DreadCall_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit( FILTER_UNIT_SELF )
        if ( IsUnitIllusionWJ( FILTER_UNIT ) ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        return true
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d
        local real duration
        local timer durationTimer
        local Unit enumUnit
        local integer enumUnitId
        local unit enumUnitSelf
        set casterSelf = null
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, casterX, casterY ) )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                set enumUnitId = enumUnit.id
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                set d = GetAttachedIntegerById( enumUnitId, DreadCall_SCOPE_ID )
                if ( d == NULL ) then
                    set d = Data.create()
                    set durationTimer = CreateTimerWJ()
                    set d.durationTimer = durationTimer
                    set d.target = enumUnit
                    call AttachInteger( durationTimer, DreadCall_SCOPE_ID, d )
                    call AttachIntegerById( enumUnitId, DreadCall_SCOPE_ID, d )
                    //! runtextmacro AddEventById( "enumUnitId", "EVENT_DEATH" )
                    //! runtextmacro AddEventById( "enumUnitId", "EVENT_DISPEL" )
                    call AddUnitAttackSilence( enumUnit )
                else
                    set durationTimer = d.durationTimer
                    call DestroyEffectWJ( d.targetEffect )
                endif
                set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnitSelf, TARGET_EFFECT_ATTACHMENT_POINT )
                if ( IsUnitType( enumUnitSelf, UNIT_TYPE_HERO ) ) then
                    set duration = HERO_DURATION
                else
                    set duration = DURATION
                endif
                call TimerStart( durationTimer, duration, false, function EndingByTimer )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
            set durationTimer = null
        endif
    endfunction

    public function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_NEGATIVE", "0", "function Dispel_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function DreadCall_SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\DreadCall.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\EarlyPromotion.j
//TESH.scrollpos=33
//TESH.alwaysfold=0
//! runtextmacro Scope("EarlyPromotion")
    globals
        private constant integer ORDER_ID = 852072//OrderId( "militia" )
        public constant integer SPELL_ID = 'A08G'

        private constant real AREA_RANGE = 250.
        private group ENUM_GROUP
        private constant integer MAX_TARGETS_AMOUNT = 3
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl"
        private boolexpr TARGET_CONDITIONS
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if (IsUnitIllusionWJ(FILTER_UNIT)) then
            return false
        endif
        if ( GetUnitRevaluation(FILTER_UNIT) > 0 ) then
            return false
        endif
        if ( IsUnitTypeSpawn(FILTER_UNIT.type) == false ) then
            return false
        endif
        return true
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local unit enumUnit
        local integer iteration = MAX_TARGETS_AMOUNT
        call DestroyEffect( AddSpecialEffect( SPECIAL_EFFECT_PATH, targetX, targetY ) )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE, TARGET_CONDITIONS )
        loop
            set enumUnit = GetNearestUnit( ENUM_GROUP, targetX, targetY )
            exitwhen ( enumUnit == null )
            call GroupRemoveUnit( ENUM_GROUP, enumUnit )
            call SetUnitRevaluation(GetUnit(enumUnit), 1)
            call SetUnitState(enumUnit, UNIT_STATE_LIFE, GetUnitState(enumUnit, UNIT_STATE_MAX_LIFE))
            set iteration = iteration - 1
            exitwhen ( iteration < 1 )
        endloop
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Order takes player casterOwner, real targetX, real targetY returns string
        set TEMP_PLAYER = casterOwner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE, TARGET_CONDITIONS )
        if ( FirstOfGroup( ENUM_GROUP ) == null ) then
            return ErrorStrings_EARLY_PROMOTION
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\EarlyPromotion.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\EasyPrey.j
//TESH.scrollpos=141
//TESH.alwaysfold=0
//! runtextmacro Scope("EasyPrey")
    globals
        private constant integer ORDER_ID = 852583//OrderId( "doom" )
        public constant integer SPELL_ID = 'A01V'

        public constant integer ARROW_SPELL_ID = 'A049'

        private integer array BONUS_DROP
        private real array BONUS_RELATIVE_ARMOR
        private real array DAMAGE
        private real array DURATION
        private real array HERO_DURATION
        private constant integer LEVELS_AMOUNT = 5
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Undead\\Curse\\CurseTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "overhead"
    endglobals

    private struct Data
        integer abilityLevel
        timer array durationTimer[LEVELS_AMOUNT]
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer abilityLevel = d.abilityLevel
        local integer iteration = abilityLevel - 1
        local effect targetEffect
        local integer targetId = target.id
        loop
            exitwhen (durationTimer == d.durationTimer[iteration])
            set iteration = iteration - 1
        endloop
        set d.durationTimer[iteration] = null
        if ( abilityLevel - 1 <= iteration ) then
            loop
                exitwhen (iteration < 0)
                exitwhen (d.durationTimer[iteration] != null)
                set iteration = iteration - 1
            endloop
            if ( iteration > -1 ) then
                set d.abilityLevel = iteration + 1
                call AddUnitArmorRelativeBonus( target, BONUS_RELATIVE_ARMOR[iteration] - BONUS_RELATIVE_ARMOR[abilityLevel] )
                call AddUnitDropBonus( target, BONUS_DROP[iteration] - BONUS_DROP[abilityLevel] )
            else
                set targetEffect = d.targetEffect
                set targetId = target.id
                call d.destroy()
                call DestroyEffectWJ( targetEffect )
                set targetEffect = null
                call FlushAttachedIntegerById( targetId, EasyPrey_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
                call AddUnitArmorRelativeBonus( target,  -BONUS_RELATIVE_ARMOR[abilityLevel] )
                call AddUnitDropBonus( target, -BONUS_DROP[abilityLevel] )
            endif
        endif
        call FlushAttachedInteger( durationTimer, EasyPrey_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
    endfunction

    public function Dispel takes Unit target returns nothing
        local integer abilityLevel
        local Data d = GetAttachedIntegerById(target.id, EasyPrey_SCOPE_ID)
        local timer durationTimer
        local integer iteration
        if (d != NULL) then
            set abilityLevel = d.abilityLevel
            set iteration = 0
            loop
                set durationTimer = d.durationTimer[iteration]
                if ( durationTimer != null ) then
                    call Ending( d, durationTimer, target )
                endif
                set iteration = iteration + 1
                exitwhen ( iteration >= abilityLevel )
            endloop
            set durationTimer = null
        endif
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel(target)
    endfunction

    private function Death_Event takes nothing returns nothing
        call Dispel( DYING_UNIT )
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, EasyPrey_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    //! runtextmacro Scope("ManaRestoration")
        globals
            private real array MANA_COST
            private real array MANA_COST_RESTORATION_FACTOR_PER_INTELLIGENCE_POINT
        endglobals

        private struct ManaRestoration_Data
            real array manaCost[LEVELS_AMOUNT]
        endstruct

        public function ManaRestoration_Start takes integer abilityLevel, Unit caster, integer spellId returns nothing
            local ManaRestoration_Data d = GetAttachedIntegerById(spellId, ManaRestoration_SCOPE_ID)
            local real manaCost = d.manaCost[abilityLevel]
            call AddUnitState( caster.self, UNIT_STATE_MANA, ( 1 - Pow( MANA_COST_RESTORATION_FACTOR_PER_INTELLIGENCE_POINT[abilityLevel], GetHeroIntelligenceTotal( caster ) ) ) * manaCost )
        endfunction

        public function ManaRestoration_Init takes nothing returns nothing
            local ManaRestoration_Data d = ManaRestoration_Data.create()
            set d.manaCost[0] = 60
            set d.manaCost[1] = 55
            set d.manaCost[2] = 50
            set d.manaCost[3] = 50
            set d.manaCost[4] = 50
            call AttachIntegerById(SPELL_ID, ManaRestoration_SCOPE_ID, d)
            set d = ManaRestoration_Data.create()
            set d.manaCost[0] = 17
            set d.manaCost[1] = 17
            set d.manaCost[2] = 17
            set d.manaCost[3] = 17
            set d.manaCost[4] = 17
            call AttachIntegerById(ARROW_SPELL_ID, ManaRestoration_SCOPE_ID, d)
            set MANA_COST_RESTORATION_FACTOR_PER_INTELLIGENCE_POINT[1] = 0.99
            set MANA_COST_RESTORATION_FACTOR_PER_INTELLIGENCE_POINT[2] = 0.99
            set MANA_COST_RESTORATION_FACTOR_PER_INTELLIGENCE_POINT[3] = 0.99
            set MANA_COST_RESTORATION_FACTOR_PER_INTELLIGENCE_POINT[4] = 0.99
            set MANA_COST_RESTORATION_FACTOR_PER_INTELLIGENCE_POINT[5] = 0.99
        endfunction
    //! runtextmacro Endscope()

    private function Start takes integer abilityLevel, Unit caster, integer spellId, Unit target returns nothing
        local real duration
        local timer durationTimer
        local integer iteration
        local integer oldAbilityLevel
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, EasyPrey_SCOPE_ID)
        local boolean isNew = (d == NULL)
        local unit targetSelf = target.self
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set iteration = LEVELS_AMOUNT - 1
            set d.abilityLevel = abilityLevel
            set d.target = target
            loop
                if (iteration == abilityLevel - 1) then
                    set d.durationTimer[iteration] = durationTimer
                else
                    set d.durationTimer[iteration] = null
                endif
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call AttachInteger(durationTimer, EasyPrey_SCOPE_ID, d)
            call AttachIntegerById(targetId, EasyPrey_SCOPE_ID, d)
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        else
            set durationTimer = d.durationTimer[abilityLevel - 1]
            if (durationTimer == null) then
                set durationTimer = CreateTimerWJ()
                set d.durationTimer[abilityLevel - 1] = durationTimer
                call AttachInteger(durationTimer, EasyPrey_SCOPE_ID, d)
            endif
            set oldAbilityLevel = d.abilityLevel
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            call AddUnitArmorRelativeBonus( target, BONUS_RELATIVE_ARMOR[abilityLevel] )
            call AddUnitDropBonus( target, BONUS_DROP[abilityLevel] )
        elseif (abilityLevel >= oldAbilityLevel) then
            set d.abilityLevel = abilityLevel
            call AddUnitArmorRelativeBonus( target, BONUS_RELATIVE_ARMOR[abilityLevel] - BONUS_RELATIVE_ARMOR[oldAbilityLevel] )
            call AddUnitDropBonus( target, BONUS_DROP[abilityLevel] - BONUS_DROP[oldAbilityLevel] )
        endif
        if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
            set duration = HERO_DURATION[abilityLevel]
        else
            set duration = DURATION[abilityLevel]
        endif
        set targetSelf = null
        call TimerStart( durationTimer, duration, false, function EndingByTimer )
        set durationTimer = null
        call ManaRestoration_ManaRestoration_Start(abilityLevel, caster, spellId)
    endfunction

    public function SpellEffect takes integer abilityLevel, Unit caster, integer spellId, Unit target returns nothing
        call Start(abilityLevel, caster, spellId, target)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( GetUnitAbilityLevel(CASTER.self, SPELL_ID), CASTER, SPELL_ID, TARGET_UNIT )
    endfunction

    public function Order takes unit target returns string
        if ( IsUnitType( target, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_UNIT.self )
    endfunction

    //! runtextmacro Scope("Arrow")
        globals
            private integer array Arrow_BUFF_ID
            private constant integer Arrow_ORDER_ID = 852243//OrderId( "coldarrowstarg" )
        endglobals

        private struct Arrow_Data
        endstruct

        public function Arrow_Damage takes Unit caster, real damageAmount, Unit target returns real
            local integer currentBuffId
            local integer iteration = LEVELS_AMOUNT - 1
            local unit targetSelf = target.self
            loop
                set currentBuffId = Arrow_BUFF_ID[iteration]
                exitwhen ( GetUnitAbilityLevel( targetSelf, currentBuffId ) > 0 )
                set iteration = iteration - 1
                exitwhen ( iteration < 1 )
            endloop
            if ( iteration > 0 ) then
                set damageAmount = damageAmount + DAMAGE[iteration]
                call UnitRemoveAbility( targetSelf, currentBuffId )
                call Start( iteration, caster, ARROW_SPELL_ID, target )
            endif
            set targetSelf = null
            return damageAmount
        endfunction

        private function Arrow_Damage_Event takes nothing returns nothing
            set DAMAGE_AMOUNT = Arrow_Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
        endfunction

        public function Arrow_Order takes unit target returns string
            return Order( target )
        endfunction

        private function Arrow_Order_Event takes nothing returns nothing
            set ERROR_MSG = Arrow_Order( TARGET_UNIT.self )
        endfunction

        public function Arrow_Learn takes Unit caster returns nothing
            local integer casterId = caster.id
            local Arrow_Data d = GetAttachedIntegerById(casterId, Arrow_SCOPE_ID)
            if ( d == NULL ) then
                call AttachIntegerById(casterId, Arrow_SCOPE_ID, Arrow_Data.create())
                //! runtextmacro AddEventById( "casterId", "Arrow_EVENT_DAMAGE" )
            endif
        endfunction

        private function Arrow_Learn_Event takes nothing returns nothing
            call Arrow_Learn( LEARNER )
        endfunction

        public function Arrow_Init takes nothing returns nothing
            set Arrow_BUFF_ID[1] = 'B00L'
            set Arrow_BUFF_ID[2] = 'B00M'
            set Arrow_BUFF_ID[3] = 'B00N'
            set Arrow_BUFF_ID[4] = 'B00O'
            set Arrow_BUFF_ID[5] = 'B00P'
            //! runtextmacro CreateEvent( "Arrow_EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_FOR_DAMAGE_AS_DAMAGE_SOURCE", "0", "function Arrow_Damage_Event" )
            call AddOrderAbility( Arrow_ORDER_ID, ARROW_SPELL_ID )
            call InitAbility( ARROW_SPELL_ID )
            //! runtextmacro AddNewEventById( "Arrow_EVENT_ORDER", "GetAbilityOrderId( ARROW_SPELL_ID, Arrow_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Arrow_Order_Event" )
            //! runtextmacro AddNewEventById( "Arrow_EVENT_LEARN", "ARROW_SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Arrow_Learn_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        set BONUS_DROP[1] = 20
        set BONUS_DROP[2] = 24
        set BONUS_DROP[3] = 28
        set BONUS_DROP[4] = 32
        set BONUS_DROP[5] = 36
        set BONUS_RELATIVE_ARMOR[1] = -0.15
        set BONUS_RELATIVE_ARMOR[2] = -0.2
        set BONUS_RELATIVE_ARMOR[3] = -0.25
        set BONUS_RELATIVE_ARMOR[4] = -0.3
        set BONUS_RELATIVE_ARMOR[5] = -0.35
        set DAMAGE[1] = 3
        set DAMAGE[2] = 4
        set DAMAGE[3] = 5
        set DAMAGE[4] = 6
        set DAMAGE[5] = 7
        set DURATION[1] = 7
        set DURATION[2] = 8
        set DURATION[3] = 9
        set DURATION[4] = 10
        set DURATION[5] = 11
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_NEGATIVE", "0", "function Dispel_Event" )
        set HERO_DURATION[1] = 4
        set HERO_DURATION[2] = 4
        set HERO_DURATION[3] = 4
        set HERO_DURATION[4] = 4
        set HERO_DURATION[5] = 4
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call Arrow_Arrow_Init()
        call ManaRestoration_ManaRestoration_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\EasyPrey.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\EmployHenchman.j
//TESH.scrollpos=122
//TESH.alwaysfold=0
//! runtextmacro Scope("EmployHenchman")
    globals
        private constant integer ORDER_ID = 852072//OrderId( "militia" )
        public constant integer SPELL_ID = 'A06Z'

        private constant real BONUS_RELATIVE_ATTACK_RATE = 0.1
        private constant real DURATION = 30.
        private constant real RELATIVE_RESTORED_LIFE = 0.5
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\Silence\\SilenceTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "overhead"
    endglobals

    private struct Data
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    //! runtextmacro Scope("Cooldown")
        globals
            private constant real Cooldown_DURATION = 30.
            private constant real Cooldown_DURATION_PER_INTELLIGENCE_POINT = -0.2
        endglobals

        private struct Cooldown_Data
            Unit caster
        endstruct

        private function Cooldown_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Cooldown_Data d = GetAttachedInteger(durationTimer, Cooldown_SCOPE_ID)
            local Unit caster = d.caster
            local player casterOwner = caster.owner
            local unit casterSelf = caster.self
            call d.destroy()
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            if ( IsUnitSelected( casterSelf, casterOwner ) ) then
                call PlaySoundFromTypeForPlayer( COOLDOWN_SOUND_TYPE, casterOwner )
            endif
            set casterOwner = null
            call UnitAddAbility(casterSelf, SPELL_ID)
            set casterSelf = null
        endfunction

        private function Cooldown_PreEnding takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Cooldown_Data d = GetAttachedInteger(durationTimer, Cooldown_SCOPE_ID)
            local Unit caster = d.caster
            local unit casterSelf = caster.self
            call UnitRemoveAbility( casterSelf, SPELL_ID )
            set casterSelf = null
            call TimerStart( durationTimer, 0.5, false, function Cooldown_Ending )
            set durationTimer = null
        endfunction

        public function Cooldown_Start takes Unit caster returns nothing
            local timer durationTimer = CreateTimerWJ()
            local Cooldown_Data d = Cooldown_Data.create()
            set d.caster = caster
            call AttachInteger( durationTimer, Cooldown_SCOPE_ID, d )
            call TimerStart( durationTimer, Cooldown_DURATION + GetHeroIntelligenceTotal( caster ) * Cooldown_DURATION_PER_INTELLIGENCE_POINT - 0.5, false, function Cooldown_PreEnding )
            set durationTimer = null
        endfunction
    //! runtextmacro Endscope()

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, EmployHenchman_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, EmployHenchman_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call SetUnitRevaluation(target, 0)
    endfunction

    public function Death takes Unit target returns nothing
        local Data d = GetAttachedIntegerById( target.id, EmployHenchman_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, EmployHenchman_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local timer durationTimer
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, EmployHenchman_SCOPE_ID)
        local boolean isNew = ( d == NULL )
        local unit targetSelf = target.self
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger( durationTimer, EmployHenchman_SCOPE_ID, d )
            call AttachIntegerById( targetId, EmployHenchman_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        else
            set durationTimer = d.durationTimer
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            call AddUnitAttackRate( target, BONUS_RELATIVE_ATTACK_RATE )
            call SetUnitRevaluation(target, 2)
        endif
        call HealUnitBySpell( target, GetUnitState( targetSelf, UNIT_STATE_MAX_LIFE ) * RELATIVE_RESTORED_LIFE )
        set targetSelf = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
        call Cooldown_Cooldown_Start(caster)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        local UnitType targetType
        if ( IsUnitAlly( target.self, casterOwner ) == false ) then
            return ErrorStrings_ONLY_ALLY
        endif
        set targetType = target.type
        if ( ( IsUnitTypeSpawn(targetType) == false ) and ( targetType.id != RESERVE_UNIT_ID ) ) then
            return ErrorStrings_ONLY_SPAWNS_OR_RESERVE
        endif
        if ( IsUnitIllusionWJ( target ) ) then
            return ErrorStrings_NOT_ILLUSION
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\EmployHenchman.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Enchant.j
//TESH.scrollpos=77
//TESH.alwaysfold=0
//! runtextmacro Scope("Enchant")
    globals
        private constant integer ORDER_ID = 852096//OrderId( "thunderclap" )
        public constant integer SPELL_ID = 'A06P'

        private constant real AREA_RANGE = 250.
        private constant real BONUS_DAMAGE = 5.
        private constant real DAMAGE_FACTOR = 0.55
        private constant string DAMAGE_SPECIAL_EFFECT_PATH = "Abilities\\Weapons\\GyroCopter\\GyroCopterMissile.mdl"
        private constant string DAMAGE_SPECIAL_EFFECT_ATTACHMENT_POINT = "origin"
        private constant string DAMAGE_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\Volcano\\VolcanoMissile.mdl"
        private constant string DAMAGE_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private boolexpr DAMAGE_TARGET_CONDITIONS
        private constant real DURATION = 15.
        private group ENUM_GROUP
        private constant string TARGET_EFFECT_PATH = "Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile_mini.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "weapon"
    endglobals

    private struct Data
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, Enchant_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, Enchant_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DAMAGE" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call AddUnitDamageBonus( target, -BONUS_DAMAGE )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, Enchant_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Enchant_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function Damage_TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_GROUND ) != TEMP_BOOLEAN ) then
            return false
        endif
        if ( GetUnitInvulnerability( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes real damageAmount, Unit target, Unit victim returns nothing
        local Data d = GetAttachedIntegerById(target.id, Enchant_SCOPE_ID)
        local unit enumUnit
        local unit victimSelf
        if ( d != NULL ) then
            set victimSelf = victim.self
            set TEMP_BOOLEAN = IsUnitType( victimSelf, UNIT_TYPE_GROUND )
            set TEMP_PLAYER = target.owner
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( DAMAGE_TARGET_EFFECT_PATH, victimSelf, DAMAGE_TARGET_EFFECT_ATTACHMENT_POINT ) )
            call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, GetUnitX( victimSelf ), GetUnitY( victimSelf ), AREA_RANGE, DAMAGE_TARGET_CONDITIONS )
            set victimSelf = null
            set enumUnit = FirstOfGroup( ENUM_GROUP )
            if ( enumUnit != null ) then
                set damageAmount = damageAmount * DAMAGE_FACTOR
                loop
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call DestroyEffectWJ( AddSpecialEffectTargetWJ( DAMAGE_SPECIAL_EFFECT_PATH, enumUnit, DAMAGE_SPECIAL_EFFECT_ATTACHMENT_POINT ) )
                    call UnitDamageUnitBySpell( target, GetUnit(enumUnit), damageAmount )
                    set enumUnit = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_AMOUNT, DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function SpellEffect takes Unit target returns nothing
        local timer durationTimer
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, Enchant_SCOPE_ID)
        local unit targetSelf = target.self
        local real targetX = GetUnitX(targetSelf)
        local real targetY = GetUnitY(targetSelf)
        if ( d == NULL ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger(durationTimer, Enchant_SCOPE_ID, d)
            call AttachIntegerById(targetId, Enchant_SCOPE_ID, d)
            //! runtextmacro AddEventById( "targetId", "EVENT_DAMAGE" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
            call AddUnitDamageBonus( target, BONUS_DAMAGE )
        else
            set durationTimer = d.durationTimer
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        call PlaySoundFromTypeAtPosition( ENCHANT_SOUND_TYPE, targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) )
        set targetSelf = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) == false ) then
            return ErrorStrings_ONLY_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitIllusionWJ( target ) ) then
            return ErrorStrings_NOT_ILLUSION
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        set DAMAGE_TARGET_CONDITIONS = ConditionWJ( function Damage_TargetConditions )
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( DAMAGE_SPECIAL_EFFECT_PATH )
        call InitEffectType( DAMAGE_TARGET_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Enchant.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\EnergyGap.j
//TESH.scrollpos=290
//TESH.alwaysfold=0
//! runtextmacro Scope("EnergyGap")
    globals
        public constant integer SPELL_ID = 'A00A'

        private constant integer LEVELS_AMOUNT = 5
    endglobals

    //! runtextmacro Scope("Heal")
        globals
            private constant real Heal_AREA_RANGE = 500.
            private real array Heal_CHANCE
            private constant integer Heal_DUMMY_UNIT_ID = 'n00S'
            private group Heal_ENUM_GROUP
            private group Heal_ENUM_GROUP2
            private real array Heal_LENGTH
            private real array Heal_REFRESHED_LIFE_PER_DAMAGE_POINT
            private real array Heal_REFRESHED_LIFE_PER_DAMAGE_POINT_PER_STRENGTH_POINT
            private integer array Heal_SHOTS_AMOUNT
            private real array Heal_SPEED
            private boolexpr Heal_TARGET_CONDITIONS
            private constant string Heal_TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"
            private constant string Heal_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
            private constant real Heal_UPDATE_TIME = 0.035
        endglobals

        private struct Heal_Data
            integer abilityLevel
            Unit caster
            unit dummyUnit
            real refreshedLife
            Unit target
            real targetX
            real targetY
            real targetZ
            real x
            real y
            real z
        endstruct

        private function Heal_Ending takes Heal_Data d, unit dummyUnit, boolean isTargetNotNull, timer moveTimer, Unit target returns nothing
            local integer targetId
            call d.destroy()
            call SetUnitAnimationByIndex( dummyUnit, 2 )
            call RemoveUnitTimed( dummyUnit, 1 )
            if ( isTargetNotNull ) then
                set targetId = target.id
                call RemoveIntegerFromTableById( targetId, Heal_SCOPE_ID, d )
                if ( CountIntegersInTableById( targetId, Heal_SCOPE_ID ) == TABLE_EMPTY ) then
                    //! runtextmacro RemoveEventById( "targetId", "Heal_EVENT_DEATH" )
                endif
            endif
            call FlushAttachedInteger( moveTimer, Heal_SCOPE_ID )
            call DestroyTimerWJ( moveTimer )
        endfunction

        private function Heal_Death_ResetTarget takes Heal_Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
            local integer targetId = target.id
            set d.target = NULL
            call RemoveIntegerFromTableById( targetId, Heal_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, Heal_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "Heal_EVENT_DEATH" )
            endif
            set d.targetX = targetX
            set d.targetY = targetY
            set d.targetZ = targetZ
        endfunction

        public function Heal_Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
            local Heal_Data d
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Heal_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set d = GetIntegerFromTableById( targetId, Heal_SCOPE_ID, iteration )
                    call Heal_Death_ResetTarget( d, target, targetX, targetY, targetZ )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Heal_Death_Event takes nothing returns nothing
            local unit dyingUnitSelf = DYING_UNIT.self
            local real dyingUnitX = GetUnitX(dyingUnitSelf)
            local real dyingUnitY = GetUnitY(dyingUnitSelf)
            call Heal_Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
            set dyingUnitSelf = null
        endfunction

        private function Heal_TargetConditionsSingle takes unit caster, player casterOwner, unit checkingUnit returns boolean
            if ( checkingUnit == caster ) then
                return false
            endif
            if ( GetUnitState( checkingUnit, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( GetUnitState( checkingUnit, UNIT_STATE_LIFE ) >= GetUnitState( checkingUnit, UNIT_STATE_MAX_LIFE ) ) then
                return false
            endif
            if ( IsUnitAlly( checkingUnit, casterOwner ) == false ) then
                return false
            endif
            if ( IsUnitType( checkingUnit, UNIT_TYPE_MECHANICAL ) ) then
                return false
            endif
            if ( IsUnitType( checkingUnit, UNIT_TYPE_STRUCTURE ) ) then
                return false
            endif
            return true
        endfunction

        private function Heal_TargetConditions takes nothing returns boolean
            return Heal_TargetConditionsSingle( TEMP_UNIT_SELF, TEMP_PLAYER, GetFilterUnit() )
        endfunction

        private function Heal_Move takes nothing returns nothing
            local real angleLengthXYZ
            local real angleXY
            local Unit caster
            local real distanceX
            local real distanceY
            local real distanceZ
            local boolean isTargetNotNull
            local real lengthXY
            local timer moveTimer = GetExpiredTimer()
            local Heal_Data d = GetAttachedInteger(moveTimer, Heal_SCOPE_ID)
            local integer abilityLevel = d.abilityLevel
            local unit dummyUnit = d.dummyUnit
            local real length = Heal_LENGTH[abilityLevel]
            local boolean reachesTarget
            local real refreshedLife
            local Unit target = d.target
            local boolean isTargetNull = ( target == NULL )
            local unit targetSelf
            local real targetX
            local real targetY
            local real targetZ
            local real x = d.x
            local real y = d.y
            local real z = d.z
            if ( isTargetNull ) then
                set targetX = d.targetX
                set targetY = d.targetY
                set targetZ = d.targetZ
            else
                set targetSelf = target.self
                set targetX = GetUnitX( targetSelf )
                set targetY = GetUnitY( targetSelf )
                set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
            endif
            set reachesTarget = ( DistanceByCoordinatesWithZ( x, y, z, targetX, targetY, targetZ ) <= length )
            if ( reachesTarget ) then
                set x = targetX
                set y = targetY
                set z = targetZ
            else
                set distanceZ = targetZ - z
                set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, targetX, targetY ) )
                set distanceX = targetX - x
                set distanceY = targetY - y
                set angleXY = Atan2( distanceY, distanceX )
                set lengthXY = length * Cos( angleLengthXYZ )
                set x = x + lengthXY * Cos( angleXY )
                set y = y + lengthXY * Sin( angleXY )
                set z = z + length * Sin( angleLengthXYZ )
                call SetUnitFacingWJ( dummyUnit, angleXY )
            endif
            call SetUnitX( dummyUnit, x )
            call SetUnitY( dummyUnit, y )
            call SetUnitZ( dummyUnit, x, y, z )
            if ( reachesTarget ) then
                set caster = d.caster
                set isTargetNotNull = (isTargetNull == false)
                set refreshedLife = d.refreshedLife
                call Heal_Ending(d, dummyUnit, isTargetNotNull, moveTimer, target)
                if ( isTargetNotNull ) then
                    if ( Heal_TargetConditionsSingle( caster.self, caster.owner, targetSelf ) ) then
                        call DestroyEffectWJ( AddSpecialEffectTargetWJ( Heal_TARGET_EFFECT_PATH, targetSelf, Heal_TARGET_EFFECT_ATTACHMENT_POINT ) )
                        call HealUnitBySpell( target, refreshedLife )
                    endif
                endif
            else
                set d.x = x
                set d.y = y
                set d.z = z
            endif
            set dummyUnit = null
            set moveTimer = null
            set targetSelf = null
        endfunction

        private function Heal_Damage_Conditions takes integer abilityLevel, Unit caster, player casterOwner, Unit target returns boolean
            if ( abilityLevel <= 0 ) then
                return false
            endif
            if ( IsUnitAlly( target.self, casterOwner ) ) then
                return false
            endif
            if ( GetRandomReal( 0.01, 1 ) > Heal_CHANCE[abilityLevel] ) then
                return false
            endif
            if ( IsUnitWard( target ) ) then
                return false
            endif
            return true
        endfunction

        public function Heal_Damage takes Unit caster, real damageAmount, Unit target returns nothing
            local player casterOwner = caster.owner
            local unit casterSelf = caster.self
            local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
            local real currentLife
            local Heal_Data d
            local unit dummyUnit
            local Unit enumUnit
            local integer enumUnitId
            local unit enumUnitSelf
            local real enumUnitLife
            local real enumUnitX
            local real enumUnitY
            local boolean found
            local integer iteration
            local timer moveTimer
            local real refreshedLife
            local integer shotsAmount
            local unit targetSelf
            local real targetX
            local real targetY
            local real targetZ
            if ( Heal_Damage_Conditions( abilityLevel, caster, casterOwner, target ) ) then
                set targetSelf = target.self
                set targetX = GetUnitX( targetSelf )
                set targetY = GetUnitY( targetSelf )
                set targetSelf = null
                set TEMP_PLAYER = casterOwner
                set TEMP_UNIT_SELF = casterSelf
                call GroupEnumUnitsInRangeWithCollision( Heal_ENUM_GROUP, targetX, targetY, Heal_AREA_RANGE, Heal_TARGET_CONDITIONS )
                set enumUnitSelf = FirstOfGroup( Heal_ENUM_GROUP )
                if ( enumUnitSelf != null ) then
                    set iteration = 1
                    set refreshedLife = damageAmount * Heal_REFRESHED_LIFE_PER_DAMAGE_POINT[abilityLevel] + GetHeroStrengthTotal( caster ) * Heal_REFRESHED_LIFE_PER_DAMAGE_POINT_PER_STRENGTH_POINT[abilityLevel]
                    set shotsAmount = Heal_SHOTS_AMOUNT[abilityLevel]
                    set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitOutpactZ(target)
                    loop
                        exitwhen ( iteration > shotsAmount )
                        set found = false
                        loop
                            call GroupRemoveUnit( Heal_ENUM_GROUP, enumUnitSelf )
                            call GroupAddUnit( Heal_ENUM_GROUP2, enumUnitSelf )
                            set enumUnitLife = GetUnitState( enumUnitSelf, UNIT_STATE_LIFE )
                            if ( found == false ) then
                                set currentLife = enumUnitLife
                                set found = true
                            elseif ( enumUnitLife < currentLife ) then
                                set currentLife = enumUnitLife
                            endif
                            set enumUnitSelf = FirstOfGroup( Heal_ENUM_GROUP )
                            exitwhen ( enumUnitSelf == null )
                        endloop
                        loop
                            set enumUnitSelf = FirstOfGroup( Heal_ENUM_GROUP2 )
                            exitwhen ( enumUnitSelf == null )
                            call GroupRemoveUnit( Heal_ENUM_GROUP2, enumUnitSelf )
                            if ( GetUnitState( enumUnitSelf, UNIT_STATE_LIFE ) == currentLife ) then
                                set d = Heal_Data.create()
                                set enumUnit = GetUnit(enumUnitSelf)
                                set enumUnitId = enumUnit.id
                                set enumUnitX = GetUnitX( enumUnitSelf )
                                set enumUnitY = GetUnitY( enumUnitSelf )
                                set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, Heal_DUMMY_UNIT_ID, targetX, targetY, Atan2( enumUnitY - targetY, enumUnitX - targetX ) )
                                set moveTimer = CreateTimerWJ()
                                set d.abilityLevel = abilityLevel
                                set d.caster = caster
                                set d.dummyUnit = dummyUnit
                                set d.refreshedLife = refreshedLife
                                set d.target = enumUnit
                                set d.x = targetX
                                set d.y = targetY
                                set d.z = targetZ
                                call AddIntegerToTableById( enumUnitId, Heal_SCOPE_ID, d )
                                if ( CountIntegersInTableById( enumUnitId, Heal_SCOPE_ID ) == TABLE_STARTED ) then
                                    //! runtextmacro AddEventById( "enumUnitId", "Heal_EVENT_DEATH" )
                                endif
                                call AttachInteger( moveTimer, Heal_SCOPE_ID, d )
                                call SetUnitZ(dummyUnit, targetX, targetY, targetZ)
                                call TimerStart( moveTimer, Heal_UPDATE_TIME, true, function Heal_Move )
                                set iteration = iteration + 1
                            else
                                call GroupAddUnit( Heal_ENUM_GROUP, enumUnitSelf )
                            endif
                        endloop
                        set enumUnitSelf = FirstOfGroup( Heal_ENUM_GROUP )
                        exitwhen ( enumUnitSelf == null )
                    endloop
                    set dummyUnit = null
                    set moveTimer = null
                endif
            endif
            set casterSelf = null
        endfunction

        private function Heal_Damage_Event takes nothing returns nothing
            call Heal_Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
        endfunction

        public function Heal_Learn takes Unit caster returns nothing
            local integer casterId = caster.id
            local Heal_Data d = GetAttachedIntegerById(casterId, Heal_SCOPE_ID)
            if ( d == NULL ) then
                set d = Heal_Data.create()
                set d.abilityLevel = GetUnitAbilityLevel(caster.self, SPELL_ID)
                call AttachIntegerById(casterId, Heal_SCOPE_ID, d)
                //! runtextmacro AddEventById( "casterId", "Heal_EVENT_DAMAGE" )
            endif
        endfunction

        private function Heal_Learn_Event takes nothing returns nothing
            call Heal_Learn( LEARNER )
        endfunction

        public function Heal_Init takes nothing returns nothing
            local integer iteration = LEVELS_AMOUNT
            set Heal_CHANCE[1] = 0.3
            set Heal_CHANCE[2] = 0.35
            set Heal_CHANCE[3] = 0.4
            set Heal_CHANCE[4] = 0.45
            set Heal_CHANCE[5] = 0.5
            set Heal_ENUM_GROUP = CreateGroupWJ()
            set Heal_ENUM_GROUP2 = CreateGroupWJ()
            //! runtextmacro CreateEvent( "Heal_EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Heal_Damage_Event" )
            //! runtextmacro CreateEvent( "Heal_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Heal_Death_Event" )
            set Heal_SHOTS_AMOUNT[1] = 3
            set Heal_SHOTS_AMOUNT[2] = 3
            set Heal_SHOTS_AMOUNT[3] = 3
            set Heal_SHOTS_AMOUNT[4] = 3
            set Heal_SHOTS_AMOUNT[5] = 3
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT[1] = 0.6
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT[2] = 0.75
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT[3] = 0.9
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT[4] = 1.05
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT[5] = 1.2
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT_PER_STRENGTH_POINT[1] = 0.005
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT_PER_STRENGTH_POINT[2] = 0.005
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT_PER_STRENGTH_POINT[3] = 0.005
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT_PER_STRENGTH_POINT[4] = 0.005
            set Heal_REFRESHED_LIFE_PER_DAMAGE_POINT_PER_STRENGTH_POINT[5] = 0.005
            set Heal_SPEED[1] = 800
            set Heal_SPEED[2] = 800
            set Heal_SPEED[3] = 800
            set Heal_SPEED[4] = 1000
            set Heal_SPEED[5] = 1000
            loop
                set Heal_LENGTH[iteration] = Heal_SPEED[iteration] * Heal_UPDATE_TIME
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
            set Heal_TARGET_CONDITIONS = ConditionWJ( function Heal_TargetConditions )
            call InitUnitType( Heal_DUMMY_UNIT_ID )
            call InitEffectType( Heal_TARGET_EFFECT_PATH )
            //! runtextmacro AddNewEventById( "Heal_EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Heal_Learn_Event" )
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Aura")
        globals
            private real array Aura_AREA_RANGE
            private real array Aura_BONUS_DAMAGE_RELATIVE
            private group Aura_ENUM_GROUP
            private group Aura_ENUM_GROUP2
            private boolexpr Aura_TARGET_CONDITIONS
            private constant real Aura_UPDATE_TIME = 1
        endglobals

        private struct Aura_Data
            integer abilityLevel
            Unit caster
            group targetGroup
            timer updateTimer
        endstruct

        //! runtextmacro Scope("Target")
            private struct Target_Data
                Aura_Data d
            endstruct

            private function Target_Ending takes real bonusDamage, Unit caster, Target_Data d, Unit target, group targetGroup returns nothing
                local integer targetId = target.id
                call d.destroy()
                call GroupRemoveUnit( targetGroup, target.self )
                call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
                if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_EMPTY ) then
                    //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                endif
                call AddUnitDamageBonus( caster, bonusDamage )
            endfunction

            public function Target_EndingByEnding takes real bonusDamage, Unit caster, Aura_Data d, Unit target, group targetGroup returns nothing
                local Target_Data e
                local integer targetId = target.id
                local integer iteration = CountIntegersInTableById(targetId, Target_SCOPE_ID)
                loop
                    set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                    exitwhen (e.d == d)
                    set iteration = iteration - 1
                endloop
                call Target_Ending(bonusDamage, caster, e, target, targetGroup)
            endfunction

            public function Target_Death takes Unit target returns nothing
                local Unit caster
                local Aura_Data d
                local Target_Data e
                local integer targetId = target.id
                local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
                if (iteration > TABLE_EMPTY) then
                    loop
                        set e = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                        set d = e.d
                        set caster = d.caster
                        call Target_Ending( -Aura_BONUS_DAMAGE_RELATIVE[d.abilityLevel] * GetUnitDamage( caster ), caster, e, target, d.targetGroup )
                        set iteration = iteration - 1
                        exitwhen ( iteration < TABLE_STARTED )
                    endloop
                endif
            endfunction

            private function Target_Death_Event takes nothing returns nothing
                call Target_Death( DYING_UNIT )
            endfunction

            public function Target_Start takes Aura_Data d, Unit target returns nothing
                local Target_Data e = Target_Data.create()
                local integer targetId = target.id
                set e.d = d
                call AddIntegerToTableById( targetId, Target_SCOPE_ID, e )
                if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_STARTED ) then
                    //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
                endif
            endfunction

            public function Target_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        public function Aura_Death takes Unit caster returns nothing
            local real bonusDamage
            local Aura_Data d = GetAttachedIntegerById(caster.id, Aura_SCOPE_ID)
            local unit enumUnit
            local group targetGroup
            if ( d != NULL ) then
                set bonusDamage = -Aura_BONUS_DAMAGE_RELATIVE[d.abilityLevel] * GetUnitDamage( caster )
                set targetGroup = d.targetGroup
                loop
                    set enumUnit = FirstOfGroup( targetGroup )
                    exitwhen ( enumUnit == null )
                    call Target_Target_EndingByEnding( bonusDamage, caster, d, GetUnit(enumUnit), targetGroup )
                endloop
                set targetGroup = null
                call PauseTimer( d.updateTimer )
            endif
        endfunction

        private function Aura_Death_Event takes nothing returns nothing
            call Aura_Death( DYING_UNIT )
        endfunction

        private function Aura_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if (FILTER_UNIT_SELF == TEMP_UNIT_SELF) then
                return false
            endif
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
                return false
            endif
            if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
                return false
            endif
            return true
        endfunction

        private function Aura_Update takes integer abilityLevel, Unit caster, Aura_Data d, group targetGroup returns nothing
            local real areaRange = Aura_AREA_RANGE[abilityLevel]
            local real bonusDamage = Aura_BONUS_DAMAGE_RELATIVE[abilityLevel] * GetUnitDamage( caster )
            local unit casterSelf = caster.self
            local real casterX = GetUnitX( casterSelf )
            local real casterY = GetUnitY( casterSelf )
            local unit enumUnit
            local real enumUnitX
            local real enumUnitY
            set TEMP_PLAYER = caster.owner
            set TEMP_UNIT_SELF = casterSelf
            set casterSelf = null
            call GroupEnumUnitsInRangeWithCollision( Aura_ENUM_GROUP, casterX, casterY, areaRange, Aura_TARGET_CONDITIONS )
            set enumUnit = FirstOfGroup( targetGroup )
            if ( enumUnit != null ) then
                loop
                    if ( IsUnitInGroup( enumUnit, Aura_ENUM_GROUP ) ) then
                        call GroupRemoveUnit( Aura_ENUM_GROUP, enumUnit )
                        call GroupRemoveUnit( targetGroup, enumUnit )
                        call GroupAddUnit( Aura_ENUM_GROUP2, enumUnit )
                    else
                        call Target_Target_EndingByEnding( -bonusDamage, caster, d, GetUnit(enumUnit), targetGroup )
                    endif
                    set enumUnit = FirstOfGroup( targetGroup )
                    exitwhen ( enumUnit == null )
                endloop
                set enumUnit = FirstOfGroup( Aura_ENUM_GROUP2 )
                loop
                    call GroupRemoveUnit( Aura_ENUM_GROUP2, enumUnit )
                    call GroupAddUnit( targetGroup, enumUnit )
                    set enumUnit = FirstOfGroup( Aura_ENUM_GROUP2 )
                    exitwhen ( enumUnit == null )
                endloop
            endif
            loop
                set enumUnit = FirstOfGroup( Aura_ENUM_GROUP )
                exitwhen ( enumUnit == null )
                call GroupRemoveUnit( Aura_ENUM_GROUP, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                call Target_Target_Start(d, GetUnit(enumUnit))
                call AddUnitDamageBonus( caster, bonusDamage )
            endloop
        endfunction

        private function Aura_UpdateByTimer takes nothing returns nothing
            local timer updateTimer = GetExpiredTimer()
            local Aura_Data d = GetAttachedInteger(updateTimer, Aura_SCOPE_ID)
            call Aura_Update( d.abilityLevel, d.caster, d, d.targetGroup )
            set updateTimer = null
        endfunction

        public function Aura_LevelGain_Before takes Unit caster returns nothing
            local real bonusDamage
            local Aura_Data d = GetAttachedIntegerById(caster.id, Aura_SCOPE_ID)
            local unit enumUnit
            local group targetGroup
            if ( d != NULL ) then
                set bonusDamage = -Aura_BONUS_DAMAGE_RELATIVE[d.abilityLevel] * GetUnitDamage( caster )
                set targetGroup = d.targetGroup
                set enumUnit = FirstOfGroup( targetGroup )
                if (enumUnit != null) then
                    loop
                        call Target_Target_EndingByEnding( bonusDamage, caster, d, GetUnit(enumUnit), targetGroup )
                        set enumUnit = FirstOfGroup( targetGroup )
                        exitwhen ( enumUnit == null )
                    endloop
                endif
                call Aura_Update(d.abilityLevel, caster, d, targetGroup)
                set targetGroup = null
            endif
        endfunction

        public function Aura_Revive takes Unit caster returns nothing
            local Aura_Data d = GetAttachedIntegerById(caster.id, Aura_SCOPE_ID)
            local timer updateTimer
            if ( d != NULL ) then
                set updateTimer = d.updateTimer
                call TimerStart( updateTimer, Aura_UPDATE_TIME, true, function Aura_UpdateByTimer )
                set updateTimer = null
                call Aura_Update( d.abilityLevel, caster, d, d.targetGroup )
            endif
        endfunction

        private function Aura_Revive_Event takes nothing returns nothing
            call Aura_Revive( REVIVING_UNIT )
        endfunction

        public function Aura_Learn takes Unit caster returns nothing
            local integer abilityLevel = GetUnitAbilityLevel(caster.self, SPELL_ID)
            local real bonusDamage
            local unit enumUnit
            local real newBonusDamage
            local real oldBonusDamage
            local group targetGroup
            local integer casterId = caster.id
            local Aura_Data d = GetAttachedIntegerById(casterId, Aura_SCOPE_ID)
            local boolean isNew = ( d == NULL )
            local timer updateTimer
            if ( isNew ) then
                set d = Aura_Data.create()
                set updateTimer = CreateTimerWJ()
                set d.caster = caster
                set d.targetGroup = CreateGroupWJ()
                set d.updateTimer = updateTimer
                call AttachIntegerById(casterId, Aura_SCOPE_ID, d)
                //! runtextmacro AddEventById( "casterId", "Aura_EVENT_DEATH" )
                //! runtextmacro AddEventById( "casterId", "Aura_EVENT_REVIVE" )
                call AttachInteger(updateTimer, Aura_SCOPE_ID, d)
            else
                set targetGroup = d.targetGroup
            endif
            set d.abilityLevel = abilityLevel
            if ( isNew ) then
                call TimerStart( updateTimer, Aura_UPDATE_TIME, true, function Aura_UpdateByTimer )
                set updateTimer = null
            else
                set targetGroup = d.targetGroup
                set enumUnit = FirstOfGroup( targetGroup )
                if ( enumUnit != null ) then
                    set bonusDamage = -Aura_BONUS_DAMAGE_RELATIVE[d.abilityLevel] * GetUnitDamage( caster )
                    loop
                        call Target_Target_EndingByEnding(bonusDamage, caster, d, GetUnit(enumUnit), targetGroup)
                        set enumUnit = FirstOfGroup( targetGroup )
                        exitwhen (enumUnit == null)
                    endloop
                endif
            endif
            call Aura_Update( abilityLevel, caster, d, targetGroup )
            set targetGroup = null
        endfunction

        private function Aura_Learn_Event takes nothing returns nothing
            call Aura_Learn( LEARNER )
        endfunction

        public function Aura_Init takes nothing returns nothing
            set Aura_AREA_RANGE[1] = 500
            set Aura_AREA_RANGE[2] = 500
            set Aura_AREA_RANGE[3] = 500
            set Aura_AREA_RANGE[4] = 500
            set Aura_AREA_RANGE[5] = 500
            set Aura_BONUS_DAMAGE_RELATIVE[1] = 0.02
            set Aura_BONUS_DAMAGE_RELATIVE[2] = 0.02
            set Aura_BONUS_DAMAGE_RELATIVE[3] = 0.02
            set Aura_BONUS_DAMAGE_RELATIVE[4] = 0.02
            set Aura_BONUS_DAMAGE_RELATIVE[5] = 0.02
            set Aura_ENUM_GROUP = CreateGroupWJ()
            set Aura_ENUM_GROUP2 = CreateGroupWJ()
            //! runtextmacro CreateEvent( "Aura_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Aura_Death_Event" )
            //! runtextmacro CreateEvent( "Aura_EVENT_REVIVE", "UnitFinishesReviving_EVENT_KEY", "0", "function Aura_Revive_Event" )
            set Aura_TARGET_CONDITIONS = ConditionWJ( function Aura_TargetConditions )
            //! runtextmacro AddNewEventById( "Aura_EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Aura_Learn_Event" )
            call Target_Target_Init()
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        call InitAbility( SPELL_ID )
        call Aura_Aura_Init()
        call Heal_Heal_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\EnergyGap.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\EsteemInCoins.j
//TESH.scrollpos=32
//TESH.alwaysfold=0
//! runtextmacro Scope("EsteemInCoins")
    globals
        private constant integer ORDER_ID = 852233//OrderId( "gold2lumber" )
        public constant integer SPELL_ID = 'A070'

        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private constant integer GOLD_COST = 300
        private constant real RESTORED_MANA = 200.
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Items\\AIil\\AIilTarget.mdl"
        private constant string SPECIAL_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private function Conditions takes integer resultGold returns string
        if ( resultGold < 0 ) then
            return ErrorStrings_TOO_LESS_GOLD
        endif
        return null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local player casterOwner = caster.owner
        local integer casterTeam
        local texttag newTextTag
        local integer resultGold = GetPlayerState( casterOwner, PLAYER_STATE_RESOURCE_GOLD ) - GOLD_COST
        local Unit wizard
        local unit wizardSelf
        local real wizardX
        local real wizardY
        if ( Conditions( resultGold ) == null ) then
            set casterTeam = GetPlayerTeam( casterOwner )
            set wizard = MASTER_WIZARDS[casterTeam]
            set wizardSelf = wizard.self
            set wizardX = GetUnitX(wizardSelf)
            set wizardY = GetUnitY(wizardSelf)
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT ) )
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( SPECIAL_EFFECT_PATH, wizardSelf, SPECIAL_EFFECT_ATTACHMENT_POINT ) )
            call SetPlayerState( casterOwner, PLAYER_STATE_RESOURCE_GOLD, resultGold )
            set newTextTag = CreateRisingTextTag( "+" + I2S( R2I( RESTORED_MANA ) ), 0.024, wizardX, wizardY, GetUnitZ( wizardSelf, wizardX, wizardY ) + GetUnitOutpactZ(wizard), 80, 0, 0, 255, 255, 0, 3 )
            if ( newTextTag != null ) then
                call LimitTextTagVisibilityToTeam( newTextTag, casterTeam )
            endif
            set newTextTag = null
            call AddUnitState( wizardSelf, UNIT_STATE_MANA, RESTORED_MANA )
            set wizardSelf = null
        endif
        set casterOwner = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Order takes player casterOwner returns string
        return Conditions( GetPlayerState( casterOwner, PLAYER_STATE_RESOURCE_GOLD ) - GOLD_COST )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner )
    endfunction

    public function Init takes nothing returns nothing
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\EsteemInCoins.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Evasion.j
//TESH.scrollpos=3
//TESH.alwaysfold=0
//! runtextmacro Scope("Evasion")
    globals
        public constant integer BERSERKER_SPELL_ID = 'A06L'
        public constant integer RAIDER_RESEARCH_ID = 'R018'
        public constant integer RAIDER_SPELL_ID = 'A008'
        public constant integer SILVER_TAIL_SPELL_ID = 'A03G'
    endglobals

    private struct Data
        real BONUS_CHANCE
    endstruct

    public function Learn takes Unit caster, integer spellId returns nothing
        local Data d = GetAttachedIntegerById(spellId, Evasion_SCOPE_ID)
        call AddUnitEvasionChance( caster, d.BONUS_CHANCE )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER, SKILL )
    endfunction

    private function Init_AddEvents takes nothing returns nothing
        //! runtextmacro AddEventById( "BERSERKER_SPELL_ID", "EVENT_LEARN" )
        //! runtextmacro AddEventById( "RAIDER_SPELL_ID", "EVENT_LEARN" )
        //! runtextmacro AddEventById( "SILVER_TAIL_SPELL_ID", "EVENT_LEARN" )
    endfunction

    public function Init takes nothing returns nothing
        local Data d = Data.create()
        local ResearchType e
        //! runtextmacro CreateEvent( "EVENT_LEARN", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        set d.BONUS_CHANCE = 0.15
        call AttachIntegerById( BERSERKER_SPELL_ID, Evasion_SCOPE_ID, d )
        call InitAbility( BERSERKER_SPELL_ID )

        set e = InitResearchType( RAIDER_RESEARCH_ID )
        call SetResearchTypeGoldCost(e, 1, 300)

        set d = Data.create()
        set d.BONUS_CHANCE = 0.2
        call AttachIntegerById( RAIDER_SPELL_ID, Evasion_SCOPE_ID, d )
        call InitAbility( RAIDER_SPELL_ID )
        call SetAbilityRequiredResearch( RAIDER_SPELL_ID, RAIDER_RESEARCH_ID )

        set d = Data.create()
        set d.BONUS_CHANCE = 0.7
        call AttachIntegerById( SILVER_TAIL_SPELL_ID, Evasion_SCOPE_ID, d )
        call InitAbility( SILVER_TAIL_SPELL_ID )

        call Init_AddEvents()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Evasion.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Feedback.j
//TESH.scrollpos=70
//TESH.alwaysfold=0
//! runtextmacro Scope("Feedback")
    globals
        public constant integer RESEARCH_ID = 'R01I'
        public constant integer SPELL_ID = 'A086'

        private constant real BURNED_MANA = 10.
        private constant real DAMAGE_FACTOR = 1.
        private constant real HERO_BURNED_MANA = 5.
        private string TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\Feedback\\ArcaneTowerAttack.mdl"
        private string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId = caster.id
        if (GetAttachedBooleanById( casterId, Feedback_SCOPE_ID )) then
            call FlushAttachedBooleanById( casterId, Feedback_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( TRIGGER_UNIT )
    endfunction

    private function Damage_Conditions takes Unit target returns boolean
        set TEMP_UNIT_SELF = target.self
        if (IsUnitType(TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL)) then
            return false
        endif
        if (IsUnitType(TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE)) then
            return false
        endif
        if (GetUnitState(TEMP_UNIT_SELF, UNIT_STATE_MANA) <= 0) then
            return false
        endif
        if (GetUnitMagicImmunity(target) > 0) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, real damageAmount, Unit target returns real
        local real burnedMana
        local real maxBurnedMana
        local real targetMana
        local unit targetSelf
        if ( GetAttachedBooleanById( caster.id, Feedback_SCOPE_ID ) ) then
            if (Damage_Conditions(target)) then
                set targetSelf = target.self
                set targetMana = GetUnitState(targetSelf, UNIT_STATE_MANA)
                if (IsUnitType( targetSelf, UNIT_TYPE_HERO )) then
                    set maxBurnedMana = HERO_BURNED_MANA
                else
                    set maxBurnedMana = BURNED_MANA
                endif
                set burnedMana = Min( maxBurnedMana, targetMana )
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
                call SetUnitState( targetSelf, UNIT_STATE_MANA, targetMana - burnedMana )
                set targetSelf = null
                return (damageAmount + burnedMana * DAMAGE_FACTOR)
            endif
        endif
        return damageAmount
    endfunction

    private function Damage_Event takes nothing returns nothing
        set DAMAGE_AMOUNT = Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, Feedback_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_UNBLOCKABLE_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call SetAbilityRequiredResearch( SPELL_ID, RESEARCH_ID )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Feedback.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\FeelingOfSecurity.j
//TESH.scrollpos=170
//TESH.alwaysfold=0
//! runtextmacro Scope("FeelingOfSecurity")
    globals
        private constant integer ORDER_ID = 852160//OrderId( "rejuvination" )
        public constant integer RESEARCH_ID = 'R00W'
        public constant integer SPELL_ID = 'A081'
        public constant integer UPGRADED_SPELL_ID = 'A082'

        private constant real DURATION = 15.
        private constant real INTERVAL = 0.25
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\ScrollOfRejuvenation\\ScrollManaHealth.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
        private constant integer WAVES_AMOUNT = R2I(DURATION / INTERVAL)
        private constant real RELATIVE_REFRESHED_LIFE_PER_INTERVAL = 0.5 / WAVES_AMOUNT
        private constant real RELATIVE_REFRESHED_MANA_PER_INTERVAL = 0.5 / WAVES_AMOUNT
    endglobals

    private struct Data
        timer durationTimer
        timer intervalTimer
        Unit target
        effect targetEffect
    endstruct

    //! runtextmacro Scope("Cooldown")
        globals
            private constant real Cooldown_DURATION = 100.
        endglobals

        private struct Cooldown_Data
            Unit caster
            timer durationTimer
        endstruct

        private function Cooldown_Ending takes Unit caster, Cooldown_Data d, timer durationTimer returns nothing
            local integer casterId = caster.id
            local unit casterSelf
            call d.destroy()
            call FlushAttachedIntegerById( casterId, Cooldown_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "Cooldown_EVENT_DEATH" )
            call DestroyTimerWJ( durationTimer )
            if (GetPlayerTechCount(caster.owner, RESEARCH_ID, true) > 0) then
                set casterSelf = caster.self
                call UnitRemoveAbility(casterSelf, SPELL_ID)
                call UnitAddAbility(casterSelf, UPGRADED_SPELL_ID)
                set casterSelf = null
            endif
        endfunction

        private function Cooldown_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Cooldown_Data d = GetAttachedInteger(durationTimer, Cooldown_SCOPE_ID)
            call Cooldown_Ending(d.caster, d, durationTimer)
            set durationTimer = null
        endfunction

        public function Cooldown_Death takes Unit caster returns nothing
            local Cooldown_Data d = GetAttachedIntegerById( caster.id, Cooldown_SCOPE_ID )
            if (d != NULL) then
                call Cooldown_Ending( caster, d, d.durationTimer )
            endif
        endfunction

        private function Cooldown_Death_Event takes nothing returns nothing
            call Cooldown_Death( DYING_UNIT )
        endfunction

        public function Cooldown_ResearchFinish takes player researchingUnitOwner returns nothing
            local Unit townHall = GetPlayerTownHall( researchingUnitOwner )
            local unit townHallSelf
            if (GetAttachedIntegerById(townHall.id, Cooldown_SCOPE_ID) == NULL) then
                set townHallSelf = townHall.self
                call UnitRemoveAbility(townHallSelf, SPELL_ID)
                call UnitAddAbility(townHallSelf, UPGRADED_SPELL_ID)
                set townHallSelf = null
            endif
        endfunction

        public function Cooldown_Start takes Unit caster returns nothing
            local integer casterId = caster.id
            local timer durationTimer = CreateTimerWJ()
            local Cooldown_Data d = Cooldown_Data.create()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById( casterId, Cooldown_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "Cooldown_EVENT_DEATH" )
            call AttachInteger( durationTimer, Cooldown_SCOPE_ID, d )
            call TimerStart( durationTimer, Cooldown_DURATION, false, function Cooldown_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Cooldown_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Cooldown_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Cooldown_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local timer intervalTimer = d.intervalTimer
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, FeelingOfSecurity_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( intervalTimer, FeelingOfSecurity_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
        call FlushAttachedIntegerById( targetId, FeelingOfSecurity_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DAMAGE" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call RemoveUnitMagicImmunity(target)
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, FeelingOfSecurity_SCOPE_ID)
        call Ending(d, durationTimer, d.target)
        set durationTimer = null
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, FeelingOfSecurity_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Damage takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function Heal takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, FeelingOfSecurity_SCOPE_ID)
        local Unit target = d.target
        local unit targetSelf = target.self
        set intervalTimer = null
        call HealUnitBySpell( target, RELATIVE_REFRESHED_LIFE_PER_INTERVAL * GetUnitState( targetSelf, UNIT_STATE_MAX_LIFE ) )
        call AddUnitState( targetSelf, UNIT_STATE_MANA, RELATIVE_REFRESHED_MANA_PER_INTERVAL * GetUnitState( targetSelf, UNIT_STATE_MAX_MANA ) )
        set targetSelf = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        local integer targetId = target.id
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        set d.target = target
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT )
        call AttachInteger( durationTimer, FeelingOfSecurity_SCOPE_ID, d )
        call AttachInteger( intervalTimer, FeelingOfSecurity_SCOPE_ID, d )
        call AttachIntegerById( targetId, FeelingOfSecurity_SCOPE_ID, d )
        //! runtextmacro AddEventById( "targetId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        call TimerStart( intervalTimer, INTERVAL, true, function Heal )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
        if (GetPlayerTechCount(caster.owner, RESEARCH_ID, true) == 0) then
            call Cooldown_Cooldown_Start(caster)
        endif
        call AddUnitMagicImmunity(target)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    private function Init_AddEvents takes nothing returns nothing
        //! runtextmacro AddEventById( "SPELL_ID", "EVENT_CAST" )
        //! runtextmacro AddEventById( "UPGRADED_SPELL_ID", "EVENT_CAST" )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d

        set d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 350)

        //! runtextmacro CreateEvent( "EVENT_CAST", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )

        call InitEffectType( TARGET_EFFECT_PATH )

        call Init_AddEvents()

        call Cooldown_Cooldown_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\FeelingOfSecurity.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Fertilizer.j
//TESH.scrollpos=30
//TESH.alwaysfold=0
//! runtextmacro Scope("Fertilizer")
    globals
        public constant integer SPELL_ID = 'A01S'

        private real array BONUS_ARMOR
        private real array BONUS_SPEED
    endglobals

    private struct Data
        integer abilityLevel
    endstruct

    public function Learn takes Unit caster returns nothing
        local integer abilityLevel = GetUnitAbilityLevel(caster.self, SPELL_ID)
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, Fertilizer_SCOPE_ID)
        local boolean isNew = (d == NULL)
        local integer oldAbilityLevel
        if (isNew) then
            call AttachIntegerById(casterId, Fertilizer_SCOPE_ID, d)
        else
            set oldAbilityLevel = d.abilityLevel
        endif
        set d.abilityLevel = abilityLevel
        if (isNew) then
            call AddUnitArmorBonus( caster, BONUS_ARMOR[abilityLevel] )
            call AddUnitSpeedBonus( caster, BONUS_SPEED[abilityLevel] )
        else
            call AddUnitArmorBonus( caster, BONUS_ARMOR[abilityLevel] - BONUS_ARMOR[oldAbilityLevel] )
            call AddUnitSpeedBonus( caster, BONUS_SPEED[abilityLevel] - BONUS_SPEED[oldAbilityLevel] )
        endif
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set BONUS_ARMOR[1] = 2
        set BONUS_ARMOR[2] = 3
        set BONUS_ARMOR[3] = 4
        set BONUS_ARMOR[4] = 5
        set BONUS_ARMOR[5] = 6
        set BONUS_SPEED[1] = 30
        set BONUS_SPEED[2] = 30
        set BONUS_SPEED[3] = 30
        set BONUS_SPEED[4] = 30
        set BONUS_SPEED[5] = 30
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Fertilizer.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\FieryBoots.j
//TESH.scrollpos=268
//TESH.alwaysfold=0
//! runtextmacro Scope("FieryBoots")
    globals
        private constant integer ACTIVATION_ORDER_ID = 852129//OrderId("windwalk")
        private constant integer ACTIVATION_SPELL_BOOK_SPELL_ID = 'A03V'
        public constant integer ACTIVATION_SPELL_ID = 'A02X'
        private constant integer DEACTIVATION_SPELL_BOOK_SPELL_ID = 'A03W'
        public constant integer DEACTIVATION_SPELL_ID = 'A015'
        private constant integer DEACTIVATION_ORDER_ID = 852129//OrderId("windwalk")

        private constant real BONUS_SPEED = 500.
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Items\\AIsp\\SpeedTarget.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real DRAIN_INTERVAL = 0.5
        private real array DRAINED_MANA
        private real array DRAINED_MANA_PER_INTELLIGENCE_POINT
        private constant real FIRE_SPAWN_INTERVAL = 0.15
        private constant integer LEVELS_AMOUNT = 5
        private constant real MANA_PUFFER = 5.
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        effect casterEffect
        timer drainTimer
        timer fireTimer
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local effect casterEffect = d.casterEffect
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, DEACTIVATION_SPELL_ID )
        local timer drainTimer = d.drainTimer
        local timer fireTimer = d.fireTimer
        call FlushAttachedIntegerById( casterId, FieryBoots_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call FlushAttachedInteger( drainTimer, FieryBoots_SCOPE_ID )
        call DestroyTimerWJ( drainTimer )
        set drainTimer = null
        call FlushAttachedInteger( fireTimer, FieryBoots_SCOPE_ID )
        call DestroyTimerWJ( fireTimer )
        set fireTimer = null
        call AddUnitPathing( caster )
        call AddUnitSpeedBonus( caster, -BONUS_SPEED )
        call UnitRemoveAbility( casterSelf, ACTIVATION_SPELL_BOOK_SPELL_ID )
        call UnitRemoveAbility( casterSelf, DEACTIVATION_SPELL_ID )
        //call UnitAddAbility( casterSelf, ACTIVATION_SPELL_BOOK_SPELL_ID )
        //call UnitAddAbility(casterSelf, DEACTIVATION_SPELL_ID)
        //call SetUnitAbilityLevel( casterSelf, DEACTIVATION_SPELL_ID, LEVELS_AMOUNT )
        call UnitAddAbility(casterSelf, ACTIVATION_SPELL_ID)
        call SetUnitAbilityLevel( casterSelf, ACTIVATION_SPELL_ID, abilityLevel )
        set casterSelf = null
    endfunction

    public function Deactivation_EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, FieryBoots_SCOPE_ID)
        call Ending( caster, d )
    endfunction

    private function Deactivation_EndCast_Event takes nothing returns nothing
        call Deactivation_EndCast( CASTER )
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, FieryBoots_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByMana takes nothing returns nothing
        local Unit caster = GetUnit(GetTriggerUnit())
        local Data d = GetAttachedIntegerById(caster.id, FieryBoots_SCOPE_ID)
        if (d != NULL) then
            call Ending( caster, d )
        endif
    endfunction

    //! runtextmacro Scope("Fire")
        globals
            private real array Fire_AREA_RANGE
            private real array Fire_DAMAGE_PER_INTERVAL
            private real array Fire_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT
            private constant integer Fire_DUMMY_UNIT_ID = 'n02D'
            private constant real Fire_DURATION = 2.
            private group Fire_ENUM_GROUP
            private constant real Fire_INTERVAL = 0.25
            private boolexpr Fire_TARGET_CONDITIONS
        endglobals

        private struct Fire_Data
            real areaRange
            Unit caster
            real damagePerIntervalAmount
            unit dummyUnit
            sound effectSound
            timer intervalTimer
            real targetX
            real targetY
        endstruct

        private function Fire_Ending takes Fire_Data d, timer durationTimer returns nothing
            local unit dummyUnit = d.dummyUnit
            local sound effectSound = d.effectSound
            local timer intervalTimer = d.intervalTimer
            call d.destroy()
            call SetUnitAnimationByIndex( dummyUnit, 1 )
            call RemoveUnitTimed( dummyUnit, 7.767 )
            set dummyUnit = null
            call FlushAttachedInteger( durationTimer, Fire_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call StopSound( effectSound, true, true )
            set effectSound = null
            call FlushAttachedInteger( intervalTimer, Fire_SCOPE_ID )
            call DestroyTimerWJ( intervalTimer )
            set intervalTimer = null
        endfunction

        private function Fire_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Fire_Data d = GetAttachedInteger(durationTimer, Fire_SCOPE_ID)
            call Fire_Ending( d, durationTimer )
            set durationTimer = null
        endfunction

        private function Fire_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
                return false
            endif
            set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
            if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
                return false
            endif
            if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
                return false
            endif
            return true
        endfunction

        private function Fire_Interval takes real areaRange, Unit caster, Fire_Data d, real targetX, real targetY returns nothing
            local real damageAmount
            local unit enumUnit
            set TEMP_PLAYER = caster.owner
            call GroupEnumUnitsInRangeWithCollision( Fire_ENUM_GROUP, targetX, targetY, areaRange, Fire_TARGET_CONDITIONS )
            set enumUnit = FirstOfGroup( Fire_ENUM_GROUP )
            if ( enumUnit != null ) then
                set damageAmount = d.damagePerIntervalAmount
                loop
                    call GroupRemoveUnit( Fire_ENUM_GROUP, enumUnit )
                    call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), damageAmount * ( 1 - DistanceByCoordinates( GetUnitX( enumUnit ), GetUnitY( enumUnit ), targetX, targetY ) / areaRange ) )
                    set enumUnit = FirstOfGroup( Fire_ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endfunction

        private function Fire_IntervalByTimer takes nothing returns nothing
            local timer intervalTimer = GetExpiredTimer()
            local Fire_Data d = GetAttachedInteger(intervalTimer, Fire_SCOPE_ID)
            set intervalTimer = null
            call Fire_Interval( d.areaRange, d.caster, d, d.targetX, d.targetY )
        endfunction

        public function Fire_Start takes integer abilityLevel, Unit caster returns nothing
            local unit casterSelf = caster.self
            local Fire_Data d = Fire_Data.create()
            local timer durationTimer = CreateTimerWJ()
            local sound effectSound = CreateSoundFromType( FIERY_BOOTS_FIRE_SOUND_TYPE )
            local unit enumUnit
            local real areaRange = Fire_AREA_RANGE[abilityLevel]
            local real casterX = GetUnitX( casterSelf )
            local real casterY = GetUnitY( casterSelf )
            local unit dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, Fire_DUMMY_UNIT_ID, casterX, casterY, GetRandomReal( 0, 2 * PI ) )
            local timer intervalTimer = CreateTimerWJ()
            set casterSelf = null
            set d.areaRange = areaRange
            set d.caster = caster
            set d.damagePerIntervalAmount = Fire_DAMAGE_PER_INTERVAL[abilityLevel] + GetHeroAgilityTotal( caster ) * Fire_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[abilityLevel]
            set d.dummyUnit = dummyUnit
            set d.effectSound = effectSound
            set d.intervalTimer = intervalTimer
            set d.targetX = casterX
            set d.targetY = casterY
            call AttachInteger(durationTimer, Fire_SCOPE_ID, d)
            call AttachInteger(intervalTimer, Fire_SCOPE_ID, d)
            call AttachSoundToUnit( effectSound, dummyUnit )
            call StartSound( effectSound )
            set effectSound = null
            call TimerStart( intervalTimer, Fire_INTERVAL, true, function Fire_IntervalByTimer )
            set intervalTimer = null
            call TimerStart( durationTimer, Fire_DURATION, false, function Fire_EndingByTimer )
            set durationTimer = null
            call Fire_Interval( areaRange, caster, d, casterX, casterY )
        endfunction

        public function Fire_Init takes nothing returns nothing
            local integer iteration = LEVELS_AMOUNT
            set Fire_AREA_RANGE[1] = 150
            set Fire_AREA_RANGE[2] = 150
            set Fire_AREA_RANGE[3] = 150
            set Fire_AREA_RANGE[4] = 150
            set Fire_AREA_RANGE[5] = 150
            set Fire_DAMAGE_PER_INTERVAL[1] = 20
            set Fire_DAMAGE_PER_INTERVAL[2] = 27
            set Fire_DAMAGE_PER_INTERVAL[3] = 34
            set Fire_DAMAGE_PER_INTERVAL[4] = 41
            set Fire_DAMAGE_PER_INTERVAL[5] = 48
            set Fire_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[1] = 0.55
            set Fire_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[2] = 0.55
            set Fire_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[3] = 0.55
            set Fire_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[4] = 0.55
            set Fire_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[5] = 0.55
            loop
                set Fire_DAMAGE_PER_INTERVAL[iteration] = Fire_DAMAGE_PER_INTERVAL[iteration] * Fire_INTERVAL
                set Fire_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[iteration] = Fire_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[iteration] * Fire_INTERVAL
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
            set Fire_ENUM_GROUP = CreateGroupWJ()
            set Fire_TARGET_CONDITIONS = ConditionWJ( function Fire_TargetConditions )
            call InitUnitType( Fire_DUMMY_UNIT_ID )
        endfunction
    //! runtextmacro Endscope()

    private function CreateFire takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, FieryBoots_SCOPE_ID)
        set intervalTimer = null
        call Fire_Fire_Start(d.abilityLevel, d.caster)
    endfunction

    private function DrainMana takes nothing returns nothing
        local timer drainTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(drainTimer, FieryBoots_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit caster = d.caster
        set drainTimer = null
        call AddUnitState( caster.self, UNIT_STATE_MANA, Min( -DRAINED_MANA[abilityLevel] - GetHeroIntelligenceTotal( caster ) * DRAINED_MANA_PER_INTELLIGENCE_POINT[abilityLevel], 0 ) )
    endfunction

    public function Activation_EndCast takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local Data d = GetAttachedIntegerById(caster.id, FieryBoots_SCOPE_ID)
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, ACTIVATION_SPELL_ID )
        //call UnitRemoveAbility( casterSelf, DEACTIVATION_SPELL_BOOK_SPELL_ID )
        call UnitRemoveAbility( casterSelf, ACTIVATION_SPELL_ID )
        call UnitAddAbility( casterSelf, ACTIVATION_SPELL_BOOK_SPELL_ID )
        call UnitAddAbility( casterSelf, ACTIVATION_SPELL_ID )
        call SetUnitAbilityLevel( casterSelf, ACTIVATION_SPELL_ID, LEVELS_AMOUNT )
        call UnitAddAbility( casterSelf, DEACTIVATION_SPELL_ID )
        call SetUnitAbilityLevel( casterSelf, DEACTIVATION_SPELL_ID, abilityLevel )
        if ( GetUnitState( casterSelf, UNIT_STATE_MANA ) < MANA_PUFFER ) then
            call Ending( caster, d )
        endif
        set casterSelf = null
    endfunction

    private function Activation_EndCast_Event takes nothing returns nothing
        call Activation_EndCast( CASTER )
    endfunction

    public function OrderExecute takes Unit caster returns nothing
        local integer abilityLevel
        local integer casterId = caster.id
        local unit casterSelf
        local Data d = GetAttachedIntegerById(casterId, FieryBoots_SCOPE_ID)
        local timer drainTimer
        local timer fireTimer
        if ( d == NULL ) then
            set casterSelf = caster.self
            set abilityLevel = GetUnitAbilityLevel( casterSelf, ACTIVATION_SPELL_ID )
            set d = Data.create()
            set drainTimer = CreateTimerWJ()
            set fireTimer = CreateTimerWJ()
            set d.abilityLevel = abilityLevel
            set d.caster = caster
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
            set casterSelf = null
            set d.drainTimer = drainTimer
            set d.fireTimer = fireTimer
            call AttachIntegerById(casterId, FieryBoots_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger(drainTimer, FieryBoots_SCOPE_ID, d)
            call AttachInteger(fireTimer, FieryBoots_SCOPE_ID, d)
            call RemoveUnitPathing( caster )
            call AddUnitSpeedBonus( caster, BONUS_SPEED )
            call TimerStart( drainTimer, DRAIN_INTERVAL, true, function DrainMana )
            set drainTimer = null
            call TimerStart( fireTimer, FIRE_SPAWN_INTERVAL, true, function CreateFire )
            set fireTimer = null
        endif
    endfunction

    private function OrderExecute_Event takes nothing returns nothing
        call OrderExecute( ORDERED_UNIT )
    endfunction

    //! runtextmacro Scope("LowManaTrigger")
        public struct LowManaTrigger_Data
            trigger dummyTrigger
        endstruct

        public function Learn takes Unit caster returns nothing
            local integer casterId = caster.id
            local LowManaTrigger_Data d = GetAttachedIntegerById(casterId, LowManaTrigger_SCOPE_ID)
            local trigger dummyTrigger
            if (d == NULL) then
                set d = LowManaTrigger_Data.create()
                set dummyTrigger = CreateTriggerWJ()
                set d.dummyTrigger = dummyTrigger
                call AttachIntegerById(casterId, LowManaTrigger_SCOPE_ID, d)
                call AddTriggerCode( dummyTrigger, function EndingByMana )
                call TriggerRegisterUnitStateEvent( dummyTrigger, caster.self, UNIT_STATE_MANA, LESS_THAN, MANA_PUFFER )
                set dummyTrigger = null
            endif
        endfunction

        private function Learn_Event takes nothing returns nothing
            call Learn(LEARNER)
        endfunction
    //! runtextmacro Endscope()

    private function Init_AddEvents takes nothing returns nothing
        //! runtextmacro AddEventById( "GetAbilityOrderId( ACTIVATION_SPELL_ID, ACTIVATION_ORDER_ID )", "EVENT_ORDER_EXECUTE" )
        //! runtextmacro AddEventById( "GetAbilityOrderId( DEACTIVATION_SPELL_ID, DEACTIVATION_ORDER_ID )", "EVENT_ORDER_EXECUTE" )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = MAX_PLAYER_INDEX
        local player specificPlayer
        set DRAINED_MANA[1] = 15
        set DRAINED_MANA[2] = 15
        set DRAINED_MANA[3] = 15
        set DRAINED_MANA[4] = 15
        set DRAINED_MANA[5] = 15
        set DRAINED_MANA_PER_INTELLIGENCE_POINT[1] = 0
        set DRAINED_MANA_PER_INTELLIGENCE_POINT[2] = 0
        set DRAINED_MANA_PER_INTELLIGENCE_POINT[3] = 0
        set DRAINED_MANA_PER_INTELLIGENCE_POINT[4] = 0
        set DRAINED_MANA_PER_INTELLIGENCE_POINT[5] = 0
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call AddOrderAbility( ACTIVATION_ORDER_ID, ACTIVATION_SPELL_ID )
        call InitAbility( ACTIVATION_SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ACTIVATION_ENDCAST", "ACTIVATION_SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function Activation_EndCast_Event" )
        //! runtextmacro CreateEvent( "EVENT_ORDER_EXECUTE", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function OrderExecute_Event" )
        call InitAbility( ACTIVATION_SPELL_BOOK_SPELL_ID )
        call InitEffectType( CASTER_EFFECT_PATH )
        call AddOrderAbility( DEACTIVATION_ORDER_ID, DEACTIVATION_SPELL_ID )
        call InitAbility( DEACTIVATION_SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_DEACTIVATION_ENDCAST", "DEACTIVATION_SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function Deactivation_EndCast_Event" )
        call InitAbility( DEACTIVATION_SPELL_BOOK_SPELL_ID )
        loop
            set specificPlayer = PlayerWJ( iteration )
            call SetPlayerAbilityAvailable( specificPlayer, ACTIVATION_SPELL_BOOK_SPELL_ID, false )
            call SetPlayerAbilityAvailable( specificPlayer, DEACTIVATION_SPELL_BOOK_SPELL_ID, false )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set specificPlayer = null

        call Init_AddEvents()

        call Fire_Fire_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\FieryBoots.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Fireball.j
//TESH.scrollpos=252
//TESH.alwaysfold=0
//! runtextmacro Scope("Fireball")
    globals
        public constant integer ORDER_ID = 852132//OrderId( "autodispel" )
        public constant integer SPELL_ID = 'A08J'

        private real array DAMAGE
        private constant integer DUMMY_UNIT_ID = 'h014'
        private real array DURATION
        private constant real SPEED = 600.
        private constant real UPDATE_TIME = 0.035
        private SoundType array LAUNCH_EFFECT_SOUND_TYPES
        private constant real LENGTH = SPEED * UPDATE_TIME
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        unit dummyUnit
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        real x
        real y
        real z
    endstruct

    private function Ending takes Data d, boolean isTargetNotNull, unit dummyUnit, timer moveTimer, Unit target returns nothing
        local integer targetId
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 1 )
        call RemoveUnitTimed( dummyUnit, 2 )
        call FlushAttachedInteger( moveTimer, Fireball_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        if ( isTargetNotNull ) then
            set targetId = target.id
            call RemoveIntegerFromTableById( targetId, Fireball_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, Fireball_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
            endif
        endif
    endfunction

    private function Death_ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        call RemoveIntegerFromTableById( targetId, Fireball_SCOPE_ID, d )
        set d.target = NULL
        if ( CountIntegersInTableById( targetId, Fireball_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, Fireball_SCOPE_ID )
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById( targetId, Fireball_SCOPE_ID, iteration )
                call Death_ResetTarget( d, target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function TargetConditions takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return ErrorStrings_NOT_HERO
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_ONLY_ORGANIC
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitInvulnerability( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_INVULNERABLE
        endif
        if ( GetUnitMagicImmunity( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        return null
    endfunction

    private function Move takes nothing returns nothing
        local integer abilityLevel
        local real angleLengthXYZ
        local real angleXY
        local Unit caster
        local real distanceX
        local real distanceY
        local real distanceZ
        local boolean isTargetNotNull
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, Fireball_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local real dummyUnitX = d.x
        local real dummyUnitY = d.y
        local real dummyUnitZ = d.z
        local boolean reachesTarget
        local Unit target = d.target
        local boolean isTargetNull = ( target == null )
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
            set targetSelf = null
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( dummyUnitX, dummyUnitY, dummyUnitZ, targetX, targetY, targetZ ) <= LENGTH )
        if ( reachesTarget ) then
            set dummyUnitX = targetX
            set dummyUnitY = targetY
            set dummyUnitZ = targetZ
        else
            set distanceZ = targetZ - dummyUnitZ
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( dummyUnitX, dummyUnitY, targetX, targetY ) )
            set distanceX = targetX - dummyUnitX
            set distanceY = targetY - dummyUnitY
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = LENGTH * Cos( angleLengthXYZ )
            set dummyUnitX = dummyUnitX + lengthXY * Cos( angleXY )
            set dummyUnitY = dummyUnitY + lengthXY * Sin( angleXY )
            set dummyUnitZ = dummyUnitZ + LENGTH * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, dummyUnitX )
        call SetUnitY( dummyUnit, dummyUnitY )
        call SetUnitZ( dummyUnit, dummyUnitX, dummyUnitY, dummyUnitZ )
        if ( reachesTarget ) then
            set isTargetNotNull = ( isTargetNull == false )
            if ( isTargetNotNull ) then
                set abilityLevel = d.abilityLevel
                set caster = d.caster
            endif
            call Ending( d, isTargetNotNull, dummyUnit, moveTimer, target )
            call PlaySoundFromTypeAtPosition( FIREBALL_IMPACT_SOUND_TYPE, dummyUnitX, dummyUnitY, dummyUnitZ )
            if ( isTargetNotNull ) then
                if ( TargetConditions( caster.owner, target ) == null ) then
                    call SetUnitStunTimed( target, 1, DURATION[abilityLevel] )
                    call UnitDamageUnitBySpell( caster, target, DAMAGE[abilityLevel] )
                endif
            endif
        else
            set d.x = dummyUnitX
            set d.y = dummyUnitY
            set d.z = dummyUnitZ
        endif
        set moveTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local integer abilityLevel = 1 + GetPlayerTechCount( caster.owner, GreaterFireball_RESEARCH_ID, true )
        local unit casterSelf = caster.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster)
        local Data d = Data.create()
        local unit dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, GetUnitFacingWJ( casterSelf ) )
        local timer moveTimer = CreateTimer()
        local integer targetId = target.id
        set casterSelf = null
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.dummyUnit = dummyUnit
        set d.moveTimer = moveTimer
        set d.target = target
        set d.x = casterX
        set d.y = casterY
        set d.z = casterZ
        call AttachInteger( moveTimer, Fireball_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, Fireball_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, Fireball_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call SetUnitZ( dummyUnit, casterX, casterY, casterZ )
        set dummyUnit = null
        call PlaySoundFromTypeAtPosition( LAUNCH_EFFECT_SOUND_TYPES[GetRandomInt(0, 2)], casterX, casterY, casterZ )
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        return TargetConditions( casterOwner, target )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    //! runtextmacro Scope("Automatic")
        globals
            public constant integer Automatic_ACTIVATION_ORDER_ID = 852133//OrderId( "autodispelon" )
            public constant integer Automatic_DEACTIVATION_ORDER_ID = 852134//OrderId( "autodispeloff" )

            private constant real Automatic_AREA_RANGE = 500.
            private group Automatic_ENUM_GROUP
            private boolexpr Automatic_TARGET_CONDITIONS
        endglobals

        private function Automatic_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
            if ( TargetConditions( TEMP_PLAYER, FILTER_UNIT ) != null ) then
                return false
            endif
            return true
        endfunction

        public function Automatic_TargetInRange takes Unit caster, player casterOwner returns nothing
            local unit enumUnit
            local unit casterSelf
            local real casterX
            local real casterY
            if ( GetUnitAutomaticAbility(caster) == SPELL_ID ) then
                set casterSelf = caster.self
                set casterX = GetUnitX( casterSelf )
                set casterY = GetUnitY( casterSelf )
                set casterSelf = null
                set TEMP_PLAYER = casterOwner
                call GroupEnumUnitsInRangeWithCollision( Automatic_ENUM_GROUP, casterX, casterY, Automatic_AREA_RANGE, Automatic_TARGET_CONDITIONS )
                set enumUnit = GetRandomUnit( Automatic_ENUM_GROUP )
                if ( enumUnit != null ) then
                    call IssueTargetOrderByIdTimed( caster, ORDER_ID, GetUnit(enumUnit), 0 )
                endif
            endif
        endfunction

        private function Automatic_TargetInRange_Event takes nothing returns nothing
            call Automatic_TargetInRange( TRIGGER_UNIT, TRIGGER_UNIT.owner )
        endfunction

        public function Automatic_Activation_Order takes Unit caster returns nothing
            //! runtextmacro AddEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, SPELL_ID)
        endfunction

        private function Automatic_Activation_Order_Event takes nothing returns nothing
            call Automatic_Activation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Deactivation_Order takes Unit caster returns nothing
            //! runtextmacro RemoveEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, 0)
        endfunction

        private function Automatic_Deactivation_Order_Event takes nothing returns nothing
            call Automatic_Deactivation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Init takes nothing returns nothing
            set Automatic_ENUM_GROUP = CreateGroupWJ()
            set Automatic_TARGET_CONDITIONS = ConditionWJ( function Automatic_TargetConditions )
            call AddOrderAbility( Automatic_ACTIVATION_ORDER_ID, SPELL_ID )
            call AddOrderAbility( Automatic_DEACTIVATION_ORDER_ID, SPELL_ID )
            //! runtextmacro CreateEvent( "Automatic_EVENT_ACQUIRE", "UnitAcquiresTarget_EVENT_KEY", "0", "function Automatic_TargetInRange_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_ACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_ACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Activation_Order_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_DEACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_DEACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Deactivation_Order_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        set DAMAGE[1] = 20
        set DAMAGE[2] = 30
        set DAMAGE[3] = 40
        set DURATION[1] = 3
        set DURATION[2] = 3.5
        set DURATION[3] = 4
        set LAUNCH_EFFECT_SOUND_TYPES[0] = FIREBALL_LAUNCH_SOUND_TYPE
        set LAUNCH_EFFECT_SOUND_TYPES[1] = FIREBALL_LAUNCH2_SOUND_TYPE
        set LAUNCH_EFFECT_SOUND_TYPES[2] = FIREBALL_LAUNCH3_SOUND_TYPE
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Automatic_Automatic_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Fireball.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\FireBurst.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("FireBurst")
    globals
        private constant integer ORDER_ID = 852540//OrderId( "flamingattack" )
        public constant integer SPELL_ID = 'A004'

        private real array AREA_RANGE
        private real array DAMAGE
        private real array DAMAGE_PER_INTELLIGENCE_POINT
        private constant integer DUMMY_UNIT_ID = 'n004'
        private group ENUM_GROUP
        private real array EXPLOSION_AREA_RANGE
        private real array EXPLOSION_DAMAGE
        private real array EXPLOSION_DAMAGE_PER_STRENGTH_POINT
        private constant real MAX_LENGTH = 700.
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Weapons\\PhoenixMissile\\Phoenix_Missile.mdl"
        private constant string SPECIAL_EFFECT2_PATH = "Objects\\Spawnmodels\\Other\\NeutralBuildingExplosion\\NeutralBuildingExplosion.mdl"
        private constant integer SPECIAL_EFFECTS_AMOUNT = 2
        private constant real SPEED = 1000.
        private constant real DURATION = MAX_LENGTH / SPEED
        private constant real SPECIAL_EFFECT_INTERVAL = DURATION / (SPECIAL_EFFECTS_AMOUNT + 1)
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\FlameStrike\\FlameStrikeEmbers.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "head"
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        real damageAmount
        unit dummyUnit
        timer durationTimer
        timer effectTimer
        real explosionDamageAmount
        real lengthX
        real lengthY
        group targetGroup
        timer updateTimer
        real x
        real y
    endstruct

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function Ending takes Unit caster, Data d, unit dummyUnit, real x, real y, timer durationTimer, group targetGroup, timer updateTimer returns nothing
        local integer abilityLevel = d.abilityLevel
        local timer effectTimer = d.effectTimer
        local unit enumUnit
        local real explosionDamageAmount = d.explosionDamageAmount
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 9 )
        call RemoveUnitTimed( dummyUnit, 2 )
        call FlushAttachedInteger( durationTimer, FireBurst_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( effectTimer, FireBurst_SCOPE_ID )
        call DestroyTimerWJ( effectTimer )
        set effectTimer = null
        call DestroyGroupWJ( targetGroup )
        call FlushAttachedInteger( updateTimer, FireBurst_SCOPE_ID )
        call DestroyTimerWJ( updateTimer )
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT2_PATH, x, y ) )
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, x, y, EXPLOSION_AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        loop
            set enumUnit = FirstOfGroup( ENUM_GROUP )
            exitwhen ( enumUnit == null )
            call GroupRemoveUnit( ENUM_GROUP, enumUnit )
            call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), explosionDamageAmount )
        endloop
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, FireBurst_SCOPE_ID)
        call Ending( d.caster, d, d.dummyUnit, d.x, d.y, durationTimer, d.targetGroup, d.updateTimer )
        set durationTimer = null
    endfunction

    private function SpawnEffect takes nothing returns nothing
        local timer effectTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(effectTimer, FireBurst_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        set effectTimer = null
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, GetUnitX( dummyUnit ), GetUnitY( dummyUnit ) ) )
    endfunction

    private function Move takes nothing returns nothing
        local real damageAmount
        local unit enumUnit
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, FireBurst_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit caster = d.caster
        local unit dummyUnit = d.dummyUnit
        local real dummyUnitX = GetUnitX(dummyUnit)
        local real dummyUnitY = GetUnitY(dummyUnit)
        local real newX = d.x + d.lengthX
        local real newY = d.y + d.lengthY
        local boolean isEnding = IsTerrainPathable( newX, newY, PATHING_TYPE_WALKABILITY )
        local group targetGroup = d.targetGroup
        if ( isEnding == false ) then
            set d.x = newX
            set d.y = newY
            call SetUnitXWJ( dummyUnit, newX )
            call SetUnitYWJ( dummyUnit, newY )
        endif
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, newX, newY, AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set damageAmount = d.damageAmount
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if (IsUnitInGroup(enumUnit, targetGroup) == false) then
                    call GroupAddUnit( targetGroup, enumUnit )
                    call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnit, TARGET_EFFECT_ATTACHMENT_POINT ) )
                    call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), damageAmount )
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        if ( isEnding ) then
            call Ending( caster, d, dummyUnit, dummyUnitX, dummyUnitY, d.durationTimer, targetGroup, updateTimer )
        endif
        set dummyUnit = null
        set targetGroup = null
        set updateTimer = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local real angle
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local timer effectTimer = CreateTimerWJ()
        local timer updateTimer = CreateTimerWJ()
        if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
        else
            set angle = GetUnitFacingWJ( casterSelf )
        endif
        set casterSelf = null
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.damageAmount = DAMAGE[abilityLevel] + GetHeroIntelligenceTotal( caster ) * DAMAGE_PER_INTELLIGENCE_POINT[abilityLevel]
        set d.dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, angle )
        set d.durationTimer = durationTimer
        set d.explosionDamageAmount = EXPLOSION_DAMAGE[abilityLevel] + GetHeroStrengthTotal( caster ) * EXPLOSION_DAMAGE_PER_STRENGTH_POINT[abilityLevel]
        set d.effectTimer = effectTimer
        set d.lengthX = LENGTH * Cos( angle )
        set d.lengthY = LENGTH * Sin( angle )
        set d.targetGroup = CreateGroupWJ()
        set d.updateTimer = updateTimer
        set d.x = casterX
        set d.y = casterY
        call AttachInteger( durationTimer, FireBurst_SCOPE_ID, d )
        call AttachInteger( effectTimer, FireBurst_SCOPE_ID, d )
        call AttachInteger( updateTimer, FireBurst_SCOPE_ID, d )
        call TimerStart( updateTimer, UPDATE_TIME, true, function Move )
        set updateTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
        call TimerStart( effectTimer, SPECIAL_EFFECT_INTERVAL, true, function SpawnEffect )
        set effectTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        set AREA_RANGE[1] = 150
        set AREA_RANGE[2] = 150
        set AREA_RANGE[3] = 150
        set AREA_RANGE[4] = 150
        set AREA_RANGE[5] = 150
        set DAMAGE[1] = 35
        set DAMAGE[2] = 45
        set DAMAGE[3] = 53
        set DAMAGE[4] = 61
        set DAMAGE[5] = 67
        set DAMAGE_PER_INTELLIGENCE_POINT[1] = 1
        set DAMAGE_PER_INTELLIGENCE_POINT[2] = 1
        set DAMAGE_PER_INTELLIGENCE_POINT[3] = 1
        set DAMAGE_PER_INTELLIGENCE_POINT[4] = 1
        set DAMAGE_PER_INTELLIGENCE_POINT[5] = 1
        set EXPLOSION_AREA_RANGE[1] = 250
        set EXPLOSION_AREA_RANGE[2] = 250
        set EXPLOSION_AREA_RANGE[3] = 250
        set EXPLOSION_AREA_RANGE[4] = 250
        set EXPLOSION_AREA_RANGE[5] = 250
        set EXPLOSION_DAMAGE[1] = 50
        set EXPLOSION_DAMAGE[2] = 65
        set EXPLOSION_DAMAGE[3] = 80
        set EXPLOSION_DAMAGE[4] = 90
        set EXPLOSION_DAMAGE[5] = 100
        set EXPLOSION_DAMAGE_PER_STRENGTH_POINT[1] = 2
        set EXPLOSION_DAMAGE_PER_STRENGTH_POINT[2] = 2
        set EXPLOSION_DAMAGE_PER_STRENGTH_POINT[3] = 2
        set EXPLOSION_DAMAGE_PER_STRENGTH_POINT[4] = 2
        set EXPLOSION_DAMAGE_PER_STRENGTH_POINT[5] = 2
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitEffectType( SPECIAL_EFFECT2_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\FireBurst.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\FleshBomb.j
//TESH.scrollpos=173
//TESH.alwaysfold=0
//! runtextmacro Scope("FleshBomb")
    globals
        private constant integer ORDER_ID = 852223//OrderId( "deathpact" )
        public constant integer SPELL_ID = 'A00W'

        private real array AREA_RANGE
        private real array AREA_RANGE_PER_AGILITY_POINT
        private real array DAMAGE_HIGH_FACTOR
        private real array DAMAGE_LOW_FACTOR
        private constant real DURATION = 3.
        private group ENUM_GROUP
        private constant real INTERVAL_START = 0.5
        private constant real INTERVAL_END = 0.1
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Weapons\\Mortar\\MortarMissile.mdl"
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\Incinerate\\IncinerateBuff.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
    endglobals

    private struct Data
        integer abilityLevel
        real areaRange
        Unit caster
        timer durationTimer
        timer effectTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local timer effectTimer = d.effectTimer
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, FleshBomb_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( effectTimer, FleshBomb_SCOPE_ID )
        call DestroyTimerWJ( effectTimer )
        set effectTimer = null
        call FlushAttachedIntegerById( targetId, FleshBomb_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call AddUnitVertexColorTimed( target, 40, 255, 255, 0, null, DURATION )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, FleshBomb_SCOPE_ID)
        if ( d != NULL ) then
            call Ending(d, d.durationTimer, target)
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function BeforeDying takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local real damageHighFactor
        local real damageLowFactor
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger( durationTimer, FleshBomb_SCOPE_ID )
        local integer abilityLevel = d.abilityLevel
        local real areaRange = d.areaRange
        local Unit caster = d.caster
        local unit enumUnit
        local real enumUnitX
        local real enumUnitY
        local Unit target = d.target
        local unit targetSelf = target.self
        local real targetLifeMax = GetUnitState( targetSelf, UNIT_STATE_MAX_LIFE )
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        call Ending( d, durationTimer, target )
        set durationTimer = null
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, targetX, targetY ) )
        call AddUnitDecay(target)
        call SetUnitDecayTime(target, 0)
        call AddUnitExplode( target )
        call KillUnit( targetSelf )
        set targetSelf = null
        set TEMP_PLAYER = target.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, areaRange, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set damageHighFactor = DAMAGE_HIGH_FACTOR[abilityLevel]
            set damageLowFactor = DAMAGE_LOW_FACTOR[abilityLevel]
            loop
                set enumUnitX = GetUnitX( enumUnit )
                set enumUnitY = GetUnitY( enumUnit )
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call UnitDamageUnitEx( caster, GetUnit(enumUnit), ( damageLowFactor + ( damageHighFactor - damageLowFactor ) / areaRange * ( areaRange - DistanceByCoordinates( enumUnitX, enumUnitY, targetX, targetY ) ) ) * targetLifeMax, null )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function Graphic takes nothing returns nothing
        local timer effectTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger( effectTimer, FleshBomb_SCOPE_ID )
        local integer abilityLevel = d.abilityLevel
        local Unit target = d.target
        call TimerStart( effectTimer, INTERVAL_END + TimerGetRemaining( d.durationTimer ) / DURATION * ( INTERVAL_START - INTERVAL_END ), false, function Graphic )
        set effectTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local integer abilityLevel
        local real areaRange
        local timer durationTimer
        local timer effectTimer
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, FleshBomb_SCOPE_ID)
        if (d != NULL) then
            return
        endif
        set abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        set areaRange = AREA_RANGE[abilityLevel] + GetHeroAgilityTotal( caster ) * AREA_RANGE_PER_AGILITY_POINT[abilityLevel]
        set d = Data.create()
        set durationTimer = CreateTimerWJ()
        set effectTimer = CreateTimerWJ()
        set d.abilityLevel = abilityLevel
        set d.areaRange = areaRange
        set d.caster = caster
        set d.durationTimer = durationTimer
        set d.effectTimer = effectTimer
        set d.target = target
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT )
        call AttachInteger( durationTimer, FleshBomb_SCOPE_ID, d )
        call AttachInteger( effectTimer, FleshBomb_SCOPE_ID, d )
        call AttachIntegerById( targetId, FleshBomb_SCOPE_ID, d )
        //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        call AddUnitVertexColorTimed( target, -40, -255, -255, 0, null, DURATION )
        call TimerStart( effectTimer, INTERVAL_START, false, function Graphic )
        set effectTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitIllusionWJ( target ) ) then
            return ErrorStrings_NOT_ILLUSION
        endif
        if ( GetUnitMagicImmunity( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        if ( GetAttachedIntegerById( target.id, FleshBomb_SCOPE_ID ) != NULL ) then
            return ErrorStrings_ALREADY_BOMB
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        set AREA_RANGE[1] = 260
        set AREA_RANGE[2] = 270
        set AREA_RANGE[3] = 280
        set AREA_RANGE[4] = 290
        set AREA_RANGE[5] = 300
        set AREA_RANGE_PER_AGILITY_POINT[1] = 2
        set AREA_RANGE_PER_AGILITY_POINT[2] = 2
        set AREA_RANGE_PER_AGILITY_POINT[3] = 2
        set AREA_RANGE_PER_AGILITY_POINT[4] = 2
        set AREA_RANGE_PER_AGILITY_POINT[5] = 2
        set DAMAGE_HIGH_FACTOR[1] = 0.4
        set DAMAGE_HIGH_FACTOR[2] = 0.45
        set DAMAGE_HIGH_FACTOR[3] = 0.5
        set DAMAGE_HIGH_FACTOR[4] = 0.55
        set DAMAGE_HIGH_FACTOR[5] = 0.6
        set DAMAGE_LOW_FACTOR[1] = 0.2
        set DAMAGE_LOW_FACTOR[2] = 0.25
        set DAMAGE_LOW_FACTOR[3] = 0.3
        set DAMAGE_LOW_FACTOR[4] = 0.35
        set DAMAGE_LOW_FACTOR[5] = 0.4
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\FleshBomb.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\FreeRoad.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("FreeRoad")
    globals
        public constant integer SPELL_ID = 'A08E'
    endglobals

    public function Learn takes Unit caster returns nothing
        call RemoveUnitPathing(caster)
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\FreeRoad.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Frenzy.j
//TESH.scrollpos=139
//TESH.alwaysfold=0
//! runtextmacro Scope("Frenzy")
    globals
        private constant integer ORDER_ID = 852100//OrderId( "berserk" )
        public constant integer SPELL_ID = 'A00G'

        private real array BONUS_SCALE
        private real array BONUS_SPEED_RELATIVE
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Orc\\Bloodlust\\BloodlustTarget.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "hand left"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT2 = "hand right"
        private real array DURATION
        private real array DURATION_PER_AGILITY_POINT
        private real array RELATIVE_BONUS_ATTACK_RATE
        private constant real SCALE_TIME = 1.
    endglobals

    private struct Data
        integer abilityLevel
        real bonusSpeed
        Unit caster
        effect casterEffect
        effect casterEffect2
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local integer abilityLevel = d.abilityLevel
        local real bonusSpeed = -d.bonusSpeed
        local effect casterEffect = d.casterEffect
        local effect casterEffect2 = d.casterEffect2
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById( casterId, Frenzy_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DISPEL" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call DestroyEffectWJ( casterEffect2 )
        set casterEffect2 = null
        call FlushAttachedInteger( durationTimer, Frenzy_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call AddUnitAttackRate( caster, -RELATIVE_BONUS_ATTACK_RATE[abilityLevel] )
        call AddUnitScaleTimed( caster, -BONUS_SCALE[abilityLevel], SCALE_TIME )
        call AddUnitSpeedBonus( caster, bonusSpeed )
    endfunction

    public function Dispel takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Frenzy_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit caster returns nothing
        call Dispel( caster )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Frenzy_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = GetAttachedIntegerById(casterId, Frenzy_SCOPE_ID)
        local timer durationTimer
        local boolean isNew = (d == NULL)
        local real duration = DURATION[abilityLevel] + GetHeroAgilityTotal( caster ) * DURATION_PER_AGILITY_POINT[abilityLevel]
        local real newBonusSpeed = GetUnitSpeed( caster ) * BONUS_SPEED_RELATIVE[abilityLevel]
        local integer oldAbilityLevel
        local real oldBonusSpeed
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById(casterId, Frenzy_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_DISPEL" )
            call AttachInteger(durationTimer, Frenzy_SCOPE_ID, d)
        else
            set durationTimer = d.durationTimer
            set oldAbilityLevel = d.abilityLevel
            set oldBonusSpeed = d.bonusSpeed
            call DestroyEffectWJ( d.casterEffect )
            call DestroyEffectWJ( d.casterEffect2 )
        endif
        set d.abilityLevel = abilityLevel
        set d.bonusSpeed = newBonusSpeed
        set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
        set d.casterEffect2 = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT2 )
        if (isNew) then
            call AddUnitAttackRate( caster, RELATIVE_BONUS_ATTACK_RATE[abilityLevel] )
            call AddUnitScaleTimed( caster, BONUS_SCALE[abilityLevel], SCALE_TIME )
            call AddUnitSpeedBonus( caster, newBonusSpeed )
        else
            call AddUnitAttackRate( caster, RELATIVE_BONUS_ATTACK_RATE[abilityLevel] - RELATIVE_BONUS_ATTACK_RATE[oldAbilityLevel] )
            call AddUnitScaleTimed( caster, BONUS_SCALE[abilityLevel] - BONUS_SCALE[oldAbilityLevel], SCALE_TIME )
            call AddUnitSpeedBonus( caster, newBonusSpeed - oldBonusSpeed )
        endif
        call PlaySoundFromTypeAtPosition( FRENZY_SOUND_TYPE, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) )
        set casterSelf = null
        if ( duration > TimerGetRemaining( durationTimer ) ) then
            call TimerStart( durationTimer, duration, false, function EndingByTimer )
        endif
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        set BONUS_SCALE[1] = 0.25
        set BONUS_SCALE[2] = 0.25
        set BONUS_SCALE[3] = 0.25
        set BONUS_SCALE[4] = 0.25
        set BONUS_SCALE[5] = 0.25
        set BONUS_SPEED_RELATIVE[1] = 0.2
        set BONUS_SPEED_RELATIVE[2] = 0.26
        set BONUS_SPEED_RELATIVE[3] = 0.3
        set BONUS_SPEED_RELATIVE[4] = 0.34
        set BONUS_SPEED_RELATIVE[5] = 0.37
        set DURATION[1] = 8
        set DURATION[2] = 10
        set DURATION[3] = 12
        set DURATION[4] = 14
        set DURATION[5] = 15
        set DURATION_PER_AGILITY_POINT[1] = 0.1
        set DURATION_PER_AGILITY_POINT[2] = 0.1
        set DURATION_PER_AGILITY_POINT[3] = 0.1
        set DURATION_PER_AGILITY_POINT[4] = 0.1
        set DURATION_PER_AGILITY_POINT[5] = 0.1
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        set RELATIVE_BONUS_ATTACK_RATE[1] = 0.3
        set RELATIVE_BONUS_ATTACK_RATE[2] = 0.37
        set RELATIVE_BONUS_ATTACK_RATE[3] = 0.43
        set RELATIVE_BONUS_ATTACK_RATE[4] = 0.48
        set RELATIVE_BONUS_ATTACK_RATE[5] = 0.52
        call InitEffectType( CASTER_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Frenzy.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\FrostBolt.j
//TESH.scrollpos=186
//TESH.alwaysfold=0
//! runtextmacro Scope("FrostBolt")
    globals
        private constant integer ORDER_ID = 852600//OrderId("channel")
        public constant integer SPELL_ID = 'A07K'

        private constant real DAMAGE = 250.
        private constant integer DUMMY_UNIT_ID = 'h00X'
        private constant real DURATION = 5.
        private constant real HERO_DAMAGE = 75.
        private constant real HERO_DURATION = 2.
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = 600 * UPDATE_TIME
    endglobals

    private struct Data
        Unit caster
        unit dummyUnit
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        real x
        real y
        real z
    endstruct

    private function Ending takes Data d, unit dummyUnit, boolean isTargetNotNull, timer moveTimer, Unit target returns nothing
        local integer targetId = target.id
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 2 )
        call RemoveUnitTimed( dummyUnit, 2 )
        call FlushAttachedInteger( moveTimer, FrostBolt_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        if ( isTargetNotNull ) then
            call RemoveIntegerFromTableById( targetId, FrostBolt_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, FrostBolt_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
            endif
        endif
    endfunction

    private function Death_ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        set d.target = NULL
        call RemoveIntegerFromTableById( targetId, FrostBolt_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, FrostBolt_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, FrostBolt_SCOPE_ID )
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById( targetId, FrostBolt_SCOPE_ID, iteration )
                call Death_ResetTarget( d, target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function TargetConditions takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_ONLY_ORGANIC
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitInvulnerability( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_INVULNERABLE
        endif
        if ( GetUnitMagicImmunity( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        return null
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local real damageAmount
        local real distanceX
        local real distanceY
        local real distanceZ
        local boolean isTargetNotNull
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Unit caster
        local Data d = GetAttachedInteger(moveTimer, FrostBolt_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local boolean reachesTarget
        local real stunTime
        local Unit target = d.target
        local unit targetSelf
        local boolean isTargetNull = ( target == null )
        local real targetX
        local real targetY
        local real targetZ
        local real x = d.x
        local real y = d.y
        local real z = d.z
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( x, y, z, targetX, targetY, targetZ ) <= LENGTH )
        if ( reachesTarget ) then
            set x = targetX
            set y = targetY
            set z = targetZ
        else
            set distanceZ = targetZ - z
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, targetX, targetY ) )
            set distanceX = targetX - x
            set distanceY = targetY - y
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = LENGTH * Cos( angleLengthXYZ )
            set x = x + lengthXY * Cos( angleXY )
            set y = y + lengthXY * Sin( angleXY )
            set z = z + LENGTH * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        if ( reachesTarget ) then
            set caster = d.caster
            set isTargetNotNull = ( isTargetNull == false )
            call Ending( d, dummyUnit, isTargetNotNull, moveTimer, target )
            if ( isTargetNotNull ) then
                if ( TargetConditions( caster.owner, target ) == null ) then
                    if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
                        set damageAmount = HERO_DAMAGE
                        set stunTime = HERO_DURATION
                    else
                        set damageAmount = DAMAGE
                        set stunTime = DURATION
                    endif
                    call SetUnitStunTimed( target, 1, stunTime )
                    call UnitDamageUnitBySpell( caster, target, damageAmount )
                endif
            endif
        else
            set d.x = x
            set d.y = y
            set d.z = z
        endif
        set dummyUnit = null
        set moveTimer = null
        set targetSelf = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local Data d = Data.create()
        local unit dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, GetUnitFacingWJ( casterSelf ) )
        local timer moveTimer = CreateTimerWJ()
        local integer targetId = target.id
        set d.caster = caster
        set d.dummyUnit = dummyUnit
        set d.moveTimer = moveTimer
        set d.target = target
        set d.x = casterX
        set d.y = casterY
        call AttachInteger( moveTimer, FrostBolt_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, FrostBolt_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, FrostBolt_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call SetUnitZ( dummyUnit, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster) )
        set casterSelf = null
        set dummyUnit = null
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        return TargetConditions( casterOwner, target )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order(ORDERED_UNIT.owner, TARGET_UNIT)
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\FrostBolt.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\FrostNova.j
//TESH.scrollpos=205
//TESH.alwaysfold=0
//! runtextmacro Scope("FrostNova")
    globals
        private constant integer ORDER_ID = 852226//OrderId( "frostnova" )
        public constant integer SPELL_ID = 'A02R'

        private real array AREA_RANGE
        private integer array BLOCKS_AMOUNT
        private real array DAMAGE
        private constant integer DUMMY_UNIT_ID = 'n029'
        private real array DURATION
        private group ENUM_GROUP
        private constant real HIT_RANGE = 128.
        private constant integer LEVELS_AMOUNT = 5
        private constant integer MAX_BLOCKS_AMOUNT = 8
        private constant real SPEED = 300
        private real array STUN_DURATION
        private real array STUN_HERO_DURATION
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
    endglobals

    private struct Data
        integer abilityLevel
        unit array blocks[MAX_BLOCKS_AMOUNT]
        Unit caster
        real array lengthX[MAX_BLOCKS_AMOUNT]
        real array lengthY[MAX_BLOCKS_AMOUNT]
        timer moveTimer
        group targetGroup
        real array x[MAX_BLOCKS_AMOUNT]
        real array y[MAX_BLOCKS_AMOUNT]
    endstruct

    private function Ending takes nothing returns nothing
        local unit array blocks
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, FrostNova_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local integer iteration = BLOCKS_AMOUNT[abilityLevel] - 1
        local timer moveTimer = d.moveTimer
        loop
            set blocks[iteration] = d.blocks[iteration]
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set iteration = BLOCKS_AMOUNT[abilityLevel] - 1
        call d.destroy()
        loop
            call RemoveUnitTimed( blocks[iteration], 1 )
            set blocks[iteration] = null
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        call FlushAttachedInteger( durationTimer, FrostNova_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( moveTimer, FrostNova_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        set moveTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitInGroup( FILTER_UNIT_SELF, TEMP_GROUP ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Move takes nothing returns nothing
        local unit block
        local Unit enumUnit
        local unit enumUnitSelf
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, FrostNova_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit caster = d.caster
        local player casterOwner = caster.owner
        local real damageAmount = DAMAGE[abilityLevel]
        local real stunTime
        local group targetGroup = d.targetGroup
        local integer iteration = BLOCKS_AMOUNT[abilityLevel] - 1
        local real x
        local real y
        set moveTimer = null
        loop
            set block = d.blocks[iteration]
            set x = d.x[iteration] + d.lengthX[iteration]
            set y = d.y[iteration] + d.lengthY[iteration]
            set d.x[iteration] = x
            set d.y[iteration] = y
            call SetUnitXWJ( block, x )
            call SetUnitYWJ( block, y )
            set TEMP_GROUP = targetGroup
            set TEMP_PLAYER = casterOwner
            call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, x, y, HIT_RANGE, TARGET_CONDITIONS )
            set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
            if (enumUnitSelf != null) then
                loop
                    set enumUnit = GetUnit(enumUnitSelf)
                    call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                    call GroupAddUnit( targetGroup, enumUnitSelf )
                    if ( IsUnitType( enumUnitSelf, UNIT_TYPE_HERO ) ) then
                        set stunTime = STUN_HERO_DURATION[abilityLevel]
                    else
                        set stunTime = STUN_DURATION[abilityLevel]
                    endif
                    call SetUnitStunTimed( enumUnit, 2, stunTime )
                    call UnitDamageUnitBySpell( caster, enumUnit, damageAmount )
                    set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnitSelf == null )
                endloop
            endif
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set block = null
        set casterOwner = null
        set targetGroup = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local unit block
        local player casterOwner = caster.owner
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real angle = GetUnitFacingWJ( casterSelf ) + PI / 4
        local integer blocksAmount = BLOCKS_AMOUNT[abilityLevel]
        local real angleAdd = 2 * PI / blocksAmount
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local integer iteration = 0
        local timer moveTimer = CreateTimerWJ()
        set casterSelf = null
        set d.abilityLevel = abilityLevel
        loop
            set block = CreateUnitWJ( casterOwner, DUMMY_UNIT_ID, casterX, casterY, angle )
            set d.blocks[iteration] = block
            set d.lengthX[iteration] = LENGTH * Cos( angle )
            set d.lengthY[iteration] = LENGTH * Sin( angle )
            set d.x[iteration] = casterX
            set d.y[iteration] = casterY
            call SetUnitVertexColor( block, 255, 255, 255, 127 )
            set iteration = iteration + 1
            exitwhen ( iteration >= blocksAmount )
        endloop
        set casterOwner = null
        set d.caster = caster
        set d.moveTimer = moveTimer
        set d.targetGroup = CreateGroupWJ()
        call AttachInteger( durationTimer, FrostNova_SCOPE_ID, d )
        call AttachInteger( moveTimer, FrostNova_SCOPE_ID, d )
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function Ending )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set AREA_RANGE[1] = 450
        set AREA_RANGE[2] = 450
        set AREA_RANGE[3] = 450
        set AREA_RANGE[4] = 450
        set AREA_RANGE[5] = 450
        set BLOCKS_AMOUNT[1] = 5
        set BLOCKS_AMOUNT[2] = 6
        set BLOCKS_AMOUNT[3] = 7
        set BLOCKS_AMOUNT[4] = 8
        set BLOCKS_AMOUNT[5] = 8
        set DAMAGE[1] = 20
        set DAMAGE[2] = 20
        set DAMAGE[3] = 40
        set DAMAGE[4] = 60
        set DAMAGE[5] = 80
        loop
            set DURATION[iteration] = AREA_RANGE[iteration] / SPEED
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        set ENUM_GROUP = CreateGroupWJ()
        set STUN_DURATION[1] = 4
        set STUN_DURATION[2] = 6
        set STUN_DURATION[3] = 8
        set STUN_DURATION[4] = 9
        set STUN_DURATION[5] = 10
        set STUN_HERO_DURATION[1] = 1
        set STUN_HERO_DURATION[2] = 1
        set STUN_HERO_DURATION[3] = 1.5
        set STUN_HERO_DURATION[4] = 1.5
        set STUN_HERO_DURATION[5] = 2
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\FrostNova.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\FuneralFeast.j
//TESH.scrollpos=74
//TESH.alwaysfold=0
//! runtextmacro Scope("FuneralFeast")
    globals
        public constant integer SPELL_ID = 'A06U'

        private constant real AREA_RANGE = 500.
        private boolexpr CASTER_CONDITIONS
        private constant integer DUMMY_UNIT_ID = 'n02N'
        private group ENUM_GROUP
        private constant real RELATIVE_BONUS_ATTRIBUTES = 0.05
        private constant real RELATIVE_BONUS_ATTRIBUTES_PER_INTELLIGENCE_POINT = 0.0005
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = 800 * UPDATE_TIME
    endglobals

    private struct Data
        real bonusRelativeAttributes
        Unit caster
        real casterX
        real casterY
        real casterZ
        unit dummyUnit
        timer moveTimer
        real x
        real y
        real z
    endstruct

    private function Ending takes Unit caster, Data d, unit dummyUnit, boolean isCasterNotNull, timer moveTimer returns nothing
        local integer casterId = caster.id
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 2 )
        call RemoveUnitTimed( dummyUnit, 1 )
        call FlushAttachedInteger( moveTimer, FuneralFeast_SCOPE_ID )
        if ( isCasterNotNull ) then
            call RemoveIntegerFromTableById( casterId, FuneralFeast_SCOPE_ID, d )
            if ( CountIntegersInTableById( casterId, FuneralFeast_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "casterId", "EVENT_CASTER_DEATH" )
            endif
        endif
        call DestroyTimerWJ( moveTimer )
    endfunction

    private function CasterConditions_Single takes unit checkingUnit returns boolean
        if ( GetUnitState( checkingUnit, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        return true
    endfunction

    //! runtextmacro Scope("Buff")
        globals
            private constant string Buff_CASTER_EFFECT_PATH = "Abilities\\Weapons\\ProcMissile\\ProcMissile.mdl"
            private constant string Buff_CASTER_EFFECT_ATTACHMENT_POINT = "origin"
            private constant string Buff_CASTER_EFFECT2_PATH = "Abilities\\Spells\\Items\\OrbSlow\\OrbSlow.mdl"
            private constant string Buff_CASTER_EFFECT2_ATTACHMENT_POINT = "chest"
            private constant real Buff_DURATION = 10.
            private constant integer Buff_MAX_LEVEL = 4
        endglobals

        private struct Buff_Data
            real bonusAgility
            real bonusIntelligence
            real bonusStrength
            Unit caster
            effect array casterEffects[Buff_MAX_LEVEL]
            timer durationTimer
            integer level
        endstruct

        private function Buff_Ending takes Unit caster, Buff_Data d, timer durationTimer returns nothing
            local real bonusAgility = -d.bonusAgility
            local real bonusIntelligence = -d.bonusIntelligence
            local real bonusStrength = -d.bonusStrength
            local effect array casterEffects
            local integer casterId = caster.id
            local UnitType casterType = caster.type
            local integer level = d.level
            local integer iteration = level
            loop
                set casterEffects[iteration] = d.casterEffects[iteration]
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            set iteration = level
            call d.destroy()
            call FlushAttachedIntegerById( casterId, Buff_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "Buff_EVENT_DEATH" )
            call FlushAttachedInteger( durationTimer, Buff_SCOPE_ID )
            loop
                call DestroyEffectWJ( casterEffects[iteration] )
                set casterEffects[iteration] = null
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            call DestroyTimerWJ( durationTimer )
            call AddHeroAgilityBonus( caster, casterType, bonusAgility )
            call AddHeroIntelligenceBonus( caster, casterType, bonusIntelligence )
            call AddHeroStrengthBonus( caster, casterType, bonusStrength )
        endfunction

        public function Buff_Death takes Unit caster returns nothing
            local Buff_Data d = GetAttachedIntegerById(caster.id, Buff_SCOPE_ID)
            if ( d != NULL ) then
                call Buff_Ending( caster, d, d.durationTimer )
            endif
        endfunction

        private function Buff_Death_Event takes nothing returns nothing
            call Buff_Death( DYING_UNIT )
        endfunction

        private function Buff_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Buff_Data d = GetAttachedInteger(durationTimer, Buff_SCOPE_ID)
            call Buff_Ending( d.caster, d, durationTimer )
            set durationTimer = null
        endfunction

        public function Buff_Start takes real bonusRelativeAttributes, Unit caster returns nothing
            local real bonusAgility
            local real bonusIntelligence
            local real bonusStrength
            local integer casterId
            local unit casterSelf = caster.self
            local UnitType casterType
            local Buff_Data d
            local timer durationTimer
            local boolean isNew
            local integer level
            if ( CasterConditions_Single( casterSelf ) ) then
                set casterId = caster.id
                set d = GetAttachedIntegerById( casterId, Buff_SCOPE_ID )
                set isNew = (d == NULL)
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( Buff_CASTER_EFFECT_PATH, casterSelf, Buff_CASTER_EFFECT_ATTACHMENT_POINT ) )
                if ( isNew ) then
                    set level = 0
                else
                    set durationTimer = d.durationTimer
                    set level = d.level
                endif
                if ( level < Buff_MAX_LEVEL ) then
                    set bonusAgility = RoundTo( GetHeroAgility( caster ) * bonusRelativeAttributes, 0.1 )
                    set bonusIntelligence = RoundTo( GetHeroIntelligence( caster ) * bonusRelativeAttributes, 0.1 )
                    set bonusStrength = RoundTo( GetHeroStrength( caster ) * bonusRelativeAttributes, 0.1 )
                    set casterType = caster.type
                    if ( isNew ) then
                        set d = Buff_Data.create()
                        set durationTimer = CreateTimerWJ()
                        set d.bonusAgility = bonusAgility
                        set d.bonusIntelligence = bonusIntelligence
                        set d.bonusStrength = bonusStrength
                        set d.caster = caster
                        set d.durationTimer = durationTimer
                        call AttachIntegerById( casterId, Buff_SCOPE_ID, d )
                        //! runtextmacro AddEventById( "casterId", "Buff_EVENT_DEATH" )
                        call AttachInteger( durationTimer, Buff_SCOPE_ID, d )
                    else
                        set d.bonusAgility = d.bonusAgility + bonusAgility
                        set d.bonusIntelligence = d.bonusIntelligence + bonusIntelligence
                        set d.bonusStrength = d.bonusStrength + bonusStrength
                    endif
                    set level = level + 1
                    set d.casterEffects[level] = AddSpecialEffectTargetWJ( Buff_CASTER_EFFECT2_PATH, casterSelf, Buff_CASTER_EFFECT2_ATTACHMENT_POINT )
                    set d.level = level
                    call AddHeroAgilityBonus( caster, casterType, bonusAgility )
                    call AddHeroIntelligenceBonus( caster, casterType, bonusIntelligence )
                    call AddHeroStrengthBonus( caster, casterType, bonusStrength )
                endif
                call TimerStart( durationTimer, Buff_DURATION, false, function Buff_EndingByTimer )
                set durationTimer = null
            endif
            set casterSelf = null
        endfunction

        public function Buff_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Buff_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Buff_Death_Event" )
            call InitEffectType( Buff_CASTER_EFFECT_PATH )
            call InitEffectType( Buff_CASTER_EFFECT2_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function Caster_Death_ResetCaster takes Unit caster, real casterX, real casterY, real casterZ, Data d returns nothing
        local integer casterId = caster.id
        set d.caster = NULL
        call RemoveIntegerFromTableById( casterId, FuneralFeast_SCOPE_ID, d )
        if ( CountIntegersInTableById( casterId, FuneralFeast_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "casterId", "EVENT_CASTER_DEATH" )
        endif
        set d.casterX = casterX
        set d.casterY = casterY
        set d.casterZ = casterZ
    endfunction

    public function Caster_Death takes Unit caster, real casterX, real casterY, real casterZ returns nothing
        local integer casterId = caster.id
        local Data d
        local integer iteration = CountIntegersInTableById( casterId, FuneralFeast_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( casterId, FuneralFeast_SCOPE_ID, iteration )
                call Caster_Death_ResetCaster( caster, casterX, casterY, casterZ, d )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Caster_Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Caster_Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local real bonusRelativeAttributes
        local unit casterSelf
        local real casterX
        local real casterY
        local real casterZ
        local real distanceX
        local real distanceY
        local real distanceZ
        local boolean isCasterNotNull
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, FuneralFeast_SCOPE_ID)
        local Unit caster = d.caster
        local unit dummyUnit = d.dummyUnit
        local boolean isCasterNull = ( caster == NULL )
        local boolean reachesCaster
        local real x = d.x
        local real y = d.y
        local real z = d.z
        if ( isCasterNull ) then
            set casterX = d.casterX
            set casterY = d.casterY
            set casterZ = d.casterZ
        else
            set casterSelf = caster.self
            set casterX = GetUnitX( casterSelf )
            set casterY = GetUnitY( casterSelf )
            set casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitImpactZ(caster)
            set casterSelf = null
        endif
        set reachesCaster = ( DistanceByCoordinatesWithZ( x, y, z, casterX, casterY, casterZ ) <= LENGTH )
        if ( reachesCaster ) then
            set x = casterX
            set y = casterY
            set z = casterZ
        else
            set distanceZ = casterZ - z
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, casterX, casterY ) )
            set distanceX = casterX - x
            set distanceY = casterY - y
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = LENGTH * Cos( angleLengthXYZ )
            set x = x + lengthXY * Cos( angleXY )
            set y = y + lengthXY * Sin( angleXY )
            set z = z + LENGTH * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        if ( reachesCaster ) then
            set bonusRelativeAttributes = d.bonusRelativeAttributes
            set isCasterNotNull = (isCasterNull == false)
            call Ending(caster, d, dummyUnit, isCasterNotNull, moveTimer)
            if ( isCasterNotNull ) then
                call Buff_Buff_Start( bonusRelativeAttributes, caster )
            endif
        else
            set d.x = x
            set d.y = y
            set d.z = z
        endif
        set dummyUnit = null
        set moveTimer = null
    endfunction

    private function CasterConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetAttachedBooleanById( GetUnit(FILTER_UNIT_SELF).id, FuneralFeast_SCOPE_ID ) == false ) then
            return false
        endif
        if ( CasterConditions_Single( FILTER_UNIT_SELF ) == false ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        return true
    endfunction

    private function SourceConditions takes boolean deathCausedByEnemy, Unit source returns boolean
        if (deathCausedByEnemy == false) then
            return false
        endif
        set TEMP_UNIT_SELF = source.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitIllusionWJ( source ) ) then
            return false
        endif
        if ( IsUnitWard( source ) ) then
            return false
        endif
        return true
    endfunction

    public function Source_Death takes boolean deathCausedByEnemy, player killingUnitOwner, Unit source, player sourceOwner, real sourceX, real sourceY, real sourceZ returns nothing
        local Unit caster
        local integer casterId
        local unit casterSelf
        local Data d
        local unit dummyUnit
        local timer moveTimer
        if ( SourceConditions( deathCausedByEnemy, source ) ) then
            set TEMP_PLAYER = killingUnitOwner
            call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, sourceX, sourceY, AREA_RANGE, CASTER_CONDITIONS )
            set casterSelf = GetNearestUnit( ENUM_GROUP, sourceX, sourceY )
            if ( casterSelf != null ) then
                set caster = GetUnit(casterSelf)
                set casterId = caster.id
                set d = Data.create()
                set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, sourceX, sourceY, Atan2( GetUnitY(casterSelf) - sourceY, GetUnitX(casterSelf) - sourceX ) )
                set casterSelf = null
                set moveTimer = CreateTimerWJ()
                set d.bonusRelativeAttributes = RELATIVE_BONUS_ATTRIBUTES + GetHeroIntelligenceTotal( caster ) * RELATIVE_BONUS_ATTRIBUTES_PER_INTELLIGENCE_POINT
                set d.caster = caster
                set d.dummyUnit = dummyUnit
                set d.moveTimer = moveTimer
                set d.x = sourceX
                set d.y = sourceY
                set d.z = sourceZ
                call AddIntegerToTableById( casterId, FuneralFeast_SCOPE_ID, d )
                if ( CountIntegersInTableById( casterId, FuneralFeast_SCOPE_ID ) == TABLE_STARTED ) then
                    //! runtextmacro AddEventById( "casterId", "EVENT_CASTER_DEATH" )
                endif
                call AttachInteger( moveTimer, FuneralFeast_SCOPE_ID, d )
                call SetUnitZ(dummyUnit, sourceX, sourceY, sourceZ)
                set dummyUnit = null
                call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
                set moveTimer = null
            endif
        endif
    endfunction

    private function Source_Death_Event takes nothing returns nothing
        local player dyingUnitOwner = DYING_UNIT.owner
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Source_Death( IsUnitEnemy(KILLING_UNIT.self, dyingUnitOwner), KILLING_UNIT.owner, DYING_UNIT, dyingUnitOwner, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) + GetUnitOutpactZ(DYING_UNIT) )
        set dyingUnitOwner = null
        set dyingUnitSelf = null
    endfunction

    public function Learn takes Unit caster returns nothing
        call AttachBooleanById( caster.id, FuneralFeast_SCOPE_ID, true )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set CASTER_CONDITIONS = ConditionWJ( function CasterConditions )
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_CASTER_DEATH", "UnitDies_EVENT_KEY", "0", "function Caster_Death_Event" )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call SetAbilityRequiredResearch( SPELL_ID, SecondaryTalent_RESEARCH_ID )
    //    call AddNewSavedEvent( "MainIntegers", UnitDies_EVENT_STRING_KEY, 0, function Source_Death_Event )
        call Buff_Buff_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\FuneralFeast.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Fury.j
//TESH.scrollpos=165
//TESH.alwaysfold=0
//! runtextmacro Scope("Fury")
    globals
        public constant integer ORDER_ID = 852132//OrderId( "autodispel" )
        public constant integer SPELL_ID = 'A044'

        private real array BONUS_RELATIVE_ATTACK_RATE
        private constant real DURATION = 30.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Orc\\Bloodlust\\BloodlustTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "left hand"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT2 = "right hand"
    endglobals

    private struct Data
        integer abilityLevel
        timer durationTimer
        Unit target
        effect targetEffect
        effect targetEffect2
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer abilityLevel = d.abilityLevel
        local effect targetEffect = d.targetEffect
        local effect targetEffect2 = d.targetEffect2
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, Fury_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedIntegerById(targetId, Fury_SCOPE_ID)
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call DestroyEffectWJ( targetEffect2 )
        set targetEffect2 = null
        call AddUnitAttackRate( target, -BONUS_RELATIVE_ATTACK_RATE[abilityLevel] )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, Fury_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Fury_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local integer abilityLevel = 1 + GetPlayerTechCount( caster.owner, ImprovedFury_RESEARCH_ID, true )
        local timer durationTimer
        local integer oldAbilityLevel
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, Fury_SCOPE_ID)
        local boolean isNew = ( d == NULL )
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger( durationTimer, Fury_SCOPE_ID, d )
            call AttachIntegerById( targetId, Fury_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        else
            set durationTimer = d.durationTimer
            set oldAbilityLevel = d.abilityLevel
            call DestroyEffectWJ( d.targetEffect )
            call DestroyEffectWJ( d.targetEffect2 )
        endif
        set d.abilityLevel = abilityLevel
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        set d.targetEffect2 = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT2 )
        if ( isNew ) then
            call AddUnitAttackRate( target, BONUS_RELATIVE_ATTACK_RATE[abilityLevel] )
        else
            call AddUnitAttackRate( target, BONUS_RELATIVE_ATTACK_RATE[abilityLevel] - BONUS_RELATIVE_ATTACK_RATE[oldAbilityLevel] )
        endif
        call PlaySoundFromTypeAtPosition( FURY_SOUND_TYPE, targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) )
        set targetSelf = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    private function TargetConditions_Single_String takes player casterOwner, Unit checkingUnit returns string
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) == false ) then
            return ErrorStrings_ONLY_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_ONLY_ORGANIC
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        return TargetConditions_Single_String( casterOwner, target )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    //! runtextmacro Scope("Automatic")
        globals
            public constant integer Automatic_ACTIVATION_ORDER_ID = 852133//OrderId( "autodispelon" )
            public constant integer Automatic_DEACTIVATION_ORDER_ID = 852134//OrderId( "autodispeloff" )

            private constant real Automatic_AREA_RANGE = 500.
            private group Automatic_ENUM_GROUP
            private boolexpr Automatic_TARGET_CONDITIONS
        endglobals

        private function Automatic_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
            if ( TargetConditions_Single_String( TEMP_PLAYER, FILTER_UNIT ) != null ) then
                return false
            endif
            if ( GetAttachedIntegerById( FILTER_UNIT.id, Fury_SCOPE_ID ) != NULL ) then
                return false
            endif
            return true
        endfunction

        public function Automatic_TargetInRange takes Unit caster, player casterOwner returns nothing
            local unit enumUnit
            local unit casterSelf
            local real casterX
            local real casterY
            if ( GetUnitAutomaticAbility(caster) == SPELL_ID ) then
                set casterSelf = caster.self
                set casterX = GetUnitX( casterSelf )
                set casterY = GetUnitY( casterSelf )
                set casterSelf = null
                set TEMP_PLAYER = casterOwner
                call GroupEnumUnitsInRangeWithCollision( Automatic_ENUM_GROUP, casterX, casterY, Automatic_AREA_RANGE, Automatic_TARGET_CONDITIONS )
                set enumUnit = GetRandomUnit( Automatic_ENUM_GROUP )
                if ( enumUnit != null ) then
                    call IssueTargetOrderByIdTimed( caster, ORDER_ID, GetUnit(enumUnit), 0 )
                endif
            endif
        endfunction

        private function Automatic_TargetInRange_Event takes nothing returns nothing
            call Automatic_TargetInRange( TRIGGER_UNIT, TRIGGER_UNIT.owner )
        endfunction

        public function Automatic_Activation_Order takes Unit caster returns nothing
            //! runtextmacro AddEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, SPELL_ID)
        endfunction

        private function Automatic_Activation_Order_Event takes nothing returns nothing
            call Automatic_Activation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Deactivation_Order takes Unit caster returns nothing
            //! runtextmacro RemoveEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, 0)
        endfunction

        private function Automatic_Deactivation_Order_Event takes nothing returns nothing
            call Automatic_Deactivation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Init takes nothing returns nothing
            set Automatic_ENUM_GROUP = CreateGroupWJ()
            set Automatic_TARGET_CONDITIONS = ConditionWJ( function Automatic_TargetConditions )
            call AddOrderAbility( Automatic_ACTIVATION_ORDER_ID, SPELL_ID )
            call AddOrderAbility( Automatic_DEACTIVATION_ORDER_ID, SPELL_ID )
            //! runtextmacro CreateEvent( "Automatic_EVENT_ACQUIRE", "UnitAcquiresTarget_EVENT_KEY", "0", "function Automatic_TargetInRange_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_ACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_ACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Activation_Order_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_DEACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_DEACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Deactivation_Order_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        set BONUS_RELATIVE_ATTACK_RATE[1] = 0.4
        set BONUS_RELATIVE_ATTACK_RATE[2] = 0.6
        set BONUS_RELATIVE_ATTACK_RATE[3] = 0.8
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Automatic_Automatic_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Fury.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\GhostTakeOver.j
//TESH.scrollpos=129
//TESH.alwaysfold=0
//! runtextmacro Scope("GhostTakeOver")
    globals
        private constant integer ORDER_ID = 852581//OrderId( "charm" )
        public constant integer SPELL_ID = 'A00S'

        private real array AREA_RANGE
        private real array DURATION
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Undead\\Possession\\PossessionMissile.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    //! runtextmacro Scope("Cooldown")
        globals
            private real array Cooldown_DURATION
            private real array Cooldown_DURATION_PER_INTELLIGENCE_POINT
        endglobals

        private struct Cooldown_Data
            integer abilityLevel
            Unit caster
        endstruct

        private function Cooldown_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Cooldown_Data d = GetAttachedInteger(durationTimer, Cooldown_SCOPE_ID)
            local integer abilityLevel = d.abilityLevel
            local Unit caster = d.caster
            local unit casterSelf = caster.self
            local player casterOwner = caster.owner
            call d.destroy()
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            if ( IsUnitSelected( casterSelf, casterOwner ) ) then
                call PlaySoundFromTypeForPlayer( COOLDOWN_SOUND_TYPE, casterOwner )
            endif
            set casterOwner = null
            call UnitAddAbility(casterSelf, SPELL_ID)
            call SetUnitAbilityLevel( casterSelf, SPELL_ID, abilityLevel )
            set casterSelf = null
        endfunction

        private function Cooldown_PreEnding takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Cooldown_Data d = GetAttachedInteger(durationTimer, Cooldown_SCOPE_ID)
            local Unit caster = d.caster
            local unit casterSelf = caster.self
            local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
            set d.abilityLevel = abilityLevel
            call UnitRemoveAbility( casterSelf, SPELL_ID )
            set casterSelf = null
            call TimerStart( durationTimer, 0.5, false, function Cooldown_Ending )
            set durationTimer = null
        endfunction

        public function Cooldown_Start takes integer abilityLevel, Unit caster returns nothing
            local timer durationTimer = CreateTimerWJ()
            local Cooldown_Data d = Cooldown_Data.create()
            set d.caster = caster
            call AttachInteger( durationTimer, Cooldown_SCOPE_ID, d )
            call TimerStart( durationTimer, Cooldown_DURATION[abilityLevel] + GetHeroIntelligenceTotal( caster ) * Cooldown_DURATION_PER_INTELLIGENCE_POINT[abilityLevel] - 0.5, false, function Cooldown_PreEnding )
            set durationTimer = null
        endfunction

        public function Cooldown_Init takes nothing returns nothing
            set Cooldown_DURATION[1] = 100
            set Cooldown_DURATION[2] = 80
            set Cooldown_DURATION_PER_INTELLIGENCE_POINT[1] = -0.75
            set Cooldown_DURATION_PER_INTELLIGENCE_POINT[2] = -0.75
        endfunction
    //! runtextmacro Endscope()

    private function TargetConditions takes nothing returns boolean
        local UnitType filterUnitType
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitRevaluation(FILTER_UNIT) > 1 ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        set filterUnitType = FILTER_UNIT.type
        if ( IsUnitTypeCaster(filterUnitType) ) then
            return false
        endif
        if ( IsUnitTypeSpawn(filterUnitType) == false ) then
            return false
        endif
        return true
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local player casterOwner = caster.owner
        local real duration
        local Unit enumUnit
        local unit enumUnitSelf
        set TEMP_PLAYER = casterOwner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            set duration = DURATION[abilityLevel]
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnitSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
                if ( IsUnitIllusionWJ( enumUnit ) ) then
                    call KillUnit( enumUnitSelf )
                else
                    call SetUnitOwnerEx( enumUnit, casterOwner, true )
                    call UnitApplyTimedLifeWJ( enumUnitSelf, duration )
                endif
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        call Cooldown_Cooldown_Start(abilityLevel, caster)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        set AREA_RANGE[1] = 200
        set AREA_RANGE[2] = 200
        set DURATION[1] = 20
        set DURATION[2] = 30
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Cooldown_Cooldown_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\GhostTakeOver.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\GhoulFrenzy.j
//TESH.scrollpos=107
//TESH.alwaysfold=0
//! runtextmacro Scope("GhoulFrenzy")
    globals
        public constant integer RESEARCH_ID = 'R01B'
        public constant integer SPELL_ID = 'A085'

        private constant real BONUS_SPEED = 100.
        private constant string CASTER_EFFECT_PATH = "Abilities\\Weapons\\IllidanMissile\\IllidanMissile.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "hand left"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT2 = "hand right"
        private constant real DURATION = 10.
        private constant real RELATIVE_BONUS_ATTACK_RATE = 1.
    endglobals

    private struct Data
        Unit caster
        effect casterEffect
        effect casterEffect2
        timer durationTimer
    endstruct

    public function Caster_Death takes Unit caster returns nothing
        local integer casterId = caster.id
        if (GetAttachedBooleanById(casterId, GhoulFrenzy_SCOPE_ID)) then
            call FlushAttachedBooleanById(casterId, GhoulFrenzy_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_CASTER_DEATH" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_SOURCE_DEATH" )
        endif
    endfunction

    private function Caster_Death_Event takes nothing returns nothing
        call Caster_Death( DYING_UNIT )
    endfunction

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local effect casterEffect = d.casterEffect
        local effect casterEffect2 = d.casterEffect2
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById( casterId, GhoulFrenzy_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_CASTER_DEATH2" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DISPEL" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call DestroyEffectWJ( casterEffect2 )
        set casterEffect2 = null
        call FlushAttachedInteger( durationTimer, GhoulFrenzy_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call AddUnitAttackRate( caster, -RELATIVE_BONUS_ATTACK_RATE )
        call AddUnitSpeedBonus( caster, -BONUS_SPEED )
    endfunction

    public function Dispel takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, GhoulFrenzy_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Caster_Death2 takes Unit caster returns nothing
        call Dispel( caster )
    endfunction

    private function Caster_Death2_Event takes nothing returns nothing
        call Caster_Death2( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, GhoulFrenzy_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    public function Source_Death takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf
        local Data d
        local timer durationTimer
        local boolean isNew
        if (GetAttachedBooleanById( casterId, GhoulFrenzy_SCOPE_ID )) then
            set casterSelf = caster.self
            set d = GetAttachedIntegerById(casterId, GhoulFrenzy_SCOPE_ID)
            set isNew = (d == NULL)
            if ( isNew ) then
                set d = Data.create()
                set durationTimer = CreateTimerWJ()
                set d.caster = caster
                set d.durationTimer = durationTimer
                call AttachIntegerById(casterId, GhoulFrenzy_SCOPE_ID, d)
                //! runtextmacro AddEventById( "casterId", "EVENT_CASTER_DEATH2" )
                //! runtextmacro AddEventById( "casterId", "EVENT_DISPEL" )
                call AttachInteger(durationTimer, GhoulFrenzy_SCOPE_ID, d)
            else
                set durationTimer = d.durationTimer
                call DestroyEffectWJ( d.casterEffect )
                call DestroyEffectWJ( d.casterEffect2 )
            endif
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
            set d.casterEffect2 = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT2 )
            set casterSelf = null
            if (isNew) then
                call AddUnitAttackRate( caster, RELATIVE_BONUS_ATTACK_RATE )
                call AddUnitSpeedBonus( caster, BONUS_SPEED )
            endif
            call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
            set durationTimer = null
        endif
    endfunction

    private function Source_Death_Event takes nothing returns nothing
        call Source_Death( KILLING_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, GhoulFrenzy_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_CASTER_DEATH" )
        //! runtextmacro AddEventById( "casterId", "EVENT_SOURCE_DEATH" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_CASTER_DEATH", "UnitDies_EVENT_KEY", "0", "function Caster_Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_CASTER_DEATH2", "UnitDies_EVENT_KEY", "0", "function Caster_Death2_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        //! runtextmacro CreateEvent( "EVENT_SOURCE_DEATH", "UnitDies_EVENT_KEY_AS_KILLING_UNIT", "0", "function Source_Death_Event" )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //    call AddNewSavedEvent( "MainIntegers", UnitDies_EVENT_STRING_KEY, 0, function Source_Death_Event )
        call SetAbilityRequiredResearch( SPELL_ID, RESEARCH_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\GhoulFrenzy.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\HammerThrow.j
//TESH.scrollpos=252
//TESH.alwaysfold=0
//! runtextmacro Scope("HammerThrow")
    globals
        private constant integer ORDER_ID = 852095//OrderId( "thunderbolt" )
        public constant integer SPELL_ID = 'A06Y'

        private constant real DAMAGE = 50.
        private constant real DAMAGE_PER_STRENGTH_POINT = 3.
        private constant integer DUMMY_UNIT_ID = 'h00U'
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = 600 * UPDATE_TIME
    endglobals

    private struct Data
        Unit caster
        real damageAmount
        unit dummyUnit
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        real x
        real y
        real z
    endstruct

    private function Ending takes Data d, unit dummyUnit, boolean isTargetNotNull, timer moveTimer, Unit target returns nothing
        local integer targetId
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 1 )
        call RemoveUnitTimed( dummyUnit, 2 )
        if ( isTargetNotNull ) then
            set targetId = target.id
            call RemoveIntegerFromTableById( targetId, HammerThrow_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, HammerThrow_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
            endif
        endif
        call FlushAttachedInteger( moveTimer, HammerThrow_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
    endfunction

    private function ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        set d.target = NULL
        call RemoveIntegerFromTableById( targetId, HammerThrow_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, HammerThrow_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, HammerThrow_SCOPE_ID )
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById( targetId, HammerThrow_SCOPE_ID, iteration )
                call ResetTarget( d, target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function TargetConditions takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( GetUnitInvulnerability( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_INVULNERABLE
        endif
        if ( GetUnitInvulnerability( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        return null
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local Unit caster
        local real damageAmount
        local real distanceX
        local real distanceY
        local real distanceZ
        local boolean isTargetNotNull
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, HammerThrow_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local boolean reachesTarget
        local Unit target = d.target
        local boolean isTargetNull = ( target == NULL )
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        local real x = d.x
        local real y = d.y
        local real z = d.z
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
            set targetSelf = null
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( x, y, z, targetX, targetY, targetZ ) <= LENGTH )
        if ( reachesTarget ) then
            set x = targetX
            set y = targetY
            set z = targetZ
        else
            set distanceZ = targetZ - z
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, targetX, targetY ) )
            set distanceX = targetX - x
            set distanceY = targetY - y
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = LENGTH * Cos( angleLengthXYZ )
            set x = x + lengthXY * Cos( angleXY )
            set y = y + lengthXY * Sin( angleXY )
            set z = z + LENGTH * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        if ( reachesTarget ) then
            set caster = d.caster
            set isTargetNotNull = ( isTargetNull == false )
            if ( isTargetNotNull ) then
                set damageAmount = d.damageAmount
            endif
            call Ending( d, dummyUnit, isTargetNotNull, moveTimer, target )
            if ( isTargetNotNull ) then
                if ( TargetConditions( caster.owner, target ) == null ) then
                    call UnitDamageUnitBySpell( caster, target, damageAmount )
                endif
            endif
        else
            set d.x = x
            set d.y = y
            set d.z = z
        endif
        set moveTimer = null
    endfunction

    //! runtextmacro Scope("Mana")
        globals
            private constant real Mana_DELAY = 2.
            private constant real Mana_RELATIVE_REFRESHED_MANA = 0.1
        endglobals

        private struct Mana_Data
            Unit caster
            timer delayTimer
        endstruct

        private function Mana_Ending takes Unit caster, Mana_Data d, timer delayTimer returns nothing
            local integer casterId = caster.id
            call RemoveIntegerFromTableById( casterId, Mana_SCOPE_ID, d )
            if ( CountIntegersInTableById( casterId, Mana_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "casterId", "Mana_EVENT_DEATH" )
            endif
            call FlushAttachedInteger( delayTimer, Mana_SCOPE_ID )
            call DestroyTimerWJ( delayTimer )
        endfunction

        public function Mana_Death takes Unit caster returns nothing
            local integer casterId = caster.id
            local Mana_Data d
            local integer iteration = CountIntegersInTableById( casterId, Mana_SCOPE_ID )
            if ( iteration > TABLE_EMPTY ) then
                loop
                    set d = GetIntegerFromTableById( casterId, Mana_SCOPE_ID, iteration )
                    call Mana_Ending( caster, d, d.delayTimer )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Mana_Death_Event takes nothing returns nothing
            call Mana_Death( DYING_UNIT )
        endfunction

        private function Mana_EndingByTimer takes nothing returns nothing
            local timer delayTimer = GetExpiredTimer()
            local Mana_Data d = GetAttachedInteger(delayTimer, Mana_SCOPE_ID)
            local Unit caster = d.caster
            local unit casterSelf = caster.self
            local real casterX = GetUnitX( casterSelf )
            local real casterY = GetUnitY( casterSelf )
            local real refreshedMana = GetUnitState( casterSelf, UNIT_STATE_MAX_MANA ) * Mana_RELATIVE_REFRESHED_MANA
            call Mana_Ending( caster, d, delayTimer )
            set delayTimer = null
            call CreateRisingTextTag( "+" + I2S( R2I( refreshedMana ) ), 0.023, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitImpactZ(caster), 80, 0, 0, 255, 255, 1, 4 )
            call AddUnitState( casterSelf, UNIT_STATE_MANA, refreshedMana )
            set casterSelf = null
        endfunction

        public function Mana_Start takes Unit caster returns nothing
            local integer casterId = caster.id
            local Mana_Data d = Mana_Data.create()
            local timer delayTimer = CreateTimerWJ()
            set d.caster = caster
            set d.delayTimer = delayTimer
            call AddIntegerToTableById( casterId, Mana_SCOPE_ID, d )
            if ( CountIntegersInTableById( casterId, Mana_SCOPE_ID ) == TABLE_STARTED ) then
                //! runtextmacro AddEventById( "casterId", "Mana_EVENT_DEATH" )
            endif
            call AttachInteger( delayTimer, Mana_SCOPE_ID, d )
            call TimerStart( delayTimer, Mana_DELAY, false, function Mana_EndingByTimer )
            set delayTimer = null
        endfunction

        public function Mana_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Mana_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Mana_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster)
        local Data d = Data.create()
        local unit dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, GetUnitFacingWJ( casterSelf ) )
        local timer moveTimer = CreateTimerWJ()
        local integer targetId = target.id
        set casterSelf = null
        set d.caster = caster
        set d.damageAmount = DAMAGE + GetHeroStrengthTotal( caster ) * DAMAGE_PER_STRENGTH_POINT
        set d.dummyUnit = dummyUnit
        set d.target = target
        set d.x = casterX
        set d.y = casterY
        set d.z = casterZ
        call AttachInteger( moveTimer, HammerThrow_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, HammerThrow_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, HammerThrow_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call SetUnitZ( dummyUnit, casterX, casterY, casterZ )
        set dummyUnit = null
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
        call Mana_Mana_Start(caster)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        return TargetConditions( casterOwner, target )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Mana_Mana_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\HammerThrow.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Harmagedon.j
//TESH.scrollpos=15
//TESH.alwaysfold=0
//! runtextmacro Scope("Harmagedon")
    globals
        private constant integer ORDER_ID = 852093//OrderId( "massteleport" )
        public constant integer SPELL_ID = 'A035'

        private real array DESTINATION_X
        private real array DESTINATION_Y
        private constant real DURATION = 10.
        private timer DURATION_TIMER
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\MassTeleport\\MassTeleportTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"

        private integer CASTER_TEAM
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        return true
    endfunction

    private function MoveUnits takes nothing returns nothing
        local unit enumUnit
        local real targetX = DESTINATION_X[CASTER_TEAM]
        local real targetY = DESTINATION_Y[CASTER_TEAM]
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call SetUnitPosition( enumUnit, targetX, targetY )
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnit, TARGET_EFFECT_ATTACHMENT_POINT ) )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        set CASTER_TEAM = GetPlayerTeam( caster.owner )
        call DisplayTextTimedWJ( ColorStrings_RED + "Attention: Harmagedon\nAll units are going to be teleported in the base of " + ColorStrings_GOLD + "team " + I2S( CASTER_TEAM + 1 ) + ColorStrings_RESET + " after " + I2S( R2I( DURATION ) ) + " seconds have elapsed." + ColorStrings_RESET, 10, GetLocalPlayer() )
        call PingMasterWizard( CASTER_TEAM )
        call PlaySoundFromType( HARMAGEDON_WARNING_SOUND_TYPE )
        call TimerStart( DURATION_TIMER, DURATION, false, function MoveUnits )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local real differenceX = GetRectCenterX( gg_rct_Harmagedon ) - CENTER_X
        local real differenceY = GetRectCenterY( gg_rct_Harmagedon ) - CENTER_Y
        local real angle = Atan2( differenceY, differenceX )
        local real difference = SquareRoot( differenceX * differenceX + differenceY * differenceY )
        local integer iteration = GetTeams() - 1
        local integer teamsAmount = GetTeams()
        local real angleAdd = 2 * PI / teamsAmount
        set DURATION_TIMER = CreateTimerWJ()
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        loop
            set angle = angle + angleAdd
            set DESTINATION_X[iteration] = CENTER_X + difference * Cos( angle )
            set DESTINATION_Y[iteration] = CENTER_Y + difference * Sin( angle )
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Harmagedon.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Harmagedon2.j
//TESH.scrollpos=18
//TESH.alwaysfold=0
//! runtextmacro Scope("Harmagedon2")
    globals
        private constant integer ORDER_ID = 852093//OrderId( "massteleport" )
        public constant integer SPELL_ID = 'A04J'

        private constant real DELAY = 2.
        private constant real DURATION = 15.
        private constant real EFFECT_INTERVAL = 0.005
        private group ENUM_GROUP
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Human\\MarkOfChaos\\MarkOfChaosTarget.mdl"
        private rect TARGET_RECT
        private boolexpr TARGET_CONDITIONS

        private timer DURATION_TIMER
        private timer EFFECT_TIMER
    endglobals

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        return true
    endfunction

    private function Destroy takes nothing returns nothing
        local Unit enumUnit
        local unit enumUnitSelf
        local UnitType enumUnitType
        local integer iteration = GetTeams() - 1
        call GroupEnumUnitsInRectWJ( ENUM_GROUP, PLAY_RECT, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                set enumUnitType = enumUnit.type
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                if ( GetUnitRevaluation(enumUnit) == 2 ) then
                    call SetUnitRevaluation(enumUnit, 0)
                else
                    if ( (IsUnitTypeSpawn(enumUnitType) or (enumUnitType.id == RESERVE_UNIT_ID)) and ( IsUnitIllusionWJ( enumUnit ) == false ) ) then
                        call KillUnit( enumUnitSelf )
                    endif
                endif
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        call PauseTimer( EFFECT_TIMER )
        call SetCameraSourceNoise( GetLocalPlayer(), 0, 0 )
        call SetCameraTargetNoise( GetLocalPlayer(), 0, 0 )
        loop
            exitwhen ( iteration < 0 )
            call UnitAddAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
            set iteration = iteration - 1
        endloop
    endfunction

    private function CreateEffect takes nothing returns nothing
        call DestroyEffectTimed( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, GetRandomReal( GetRectMinX( TARGET_RECT ), GetRectMaxX( TARGET_RECT ) ), GetRandomReal( GetRectMinY( TARGET_RECT ), GetRectMaxY( TARGET_RECT ) ) ), 2 )
    endfunction

    private function PreDestroy takes nothing returns nothing
        call TimerStart( EFFECT_TIMER, EFFECT_INTERVAL, true, function CreateEffect )
        call TimerStart( DURATION_TIMER, DELAY, false, function Destroy )
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterTeam = GetPlayerTeam( caster.owner )
        local integer count = Infoboard_COUNT
        local integer iteration = GetTeams() - 1
        set DURATION_TIMER = CreateTimerWJ()
        loop
            exitwhen ( iteration < 0 )
            call UnitRemoveAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
            set iteration = iteration - 1
        endloop
        call DisplayTextTimedWJ( ColorStrings_RED + "Attention: Harmagedon " + ColorStrings_RESET + "(" + ColorStrings_GOLD + "team " + I2S( casterTeam + 1 ) + "|r)\nAll spawn units are going to be killed in " + I2S( R2I( DURATION ) ) + " seconds. In addition, the wimpy rest loses silver/gold state.\n(Start: " + GetTimeString( count ) + " End: " + GetTimeString( count + R2I( DURATION ) ) + ")" + ColorStrings_RESET, DURATION, GetLocalPlayer() )
        call PingMasterWizard( casterTeam )
        call PlaySoundFromType( HARMAGEDON_WARNING_SOUND_TYPE )
        call SetCameraSourceNoise( GetLocalPlayer(), 15, 11068 )
        call SetCameraTargetNoise( GetLocalPlayer(), 15, 11068 )
        call TimerStart( DURATION_TIMER, DURATION, false, function PreDestroy )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        set DURATION_TIMER = CreateTimerWJ()
        set EFFECT_TIMER = CreateTimerWJ()
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        set TARGET_RECT = InitRect( gg_rct_Harmagedon2 )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Harmagedon2.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Heal.j
//TESH.scrollpos=11
//TESH.alwaysfold=0
//! runtextmacro Scope("Heal")
    globals
        private constant integer ORDER_ID = 852063//OrderId( "heal" )
        public constant integer SPELL_ID = 'A02B'

        private constant real REFRESHED_LIFE = 40.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    public function SpellEffect takes Unit target returns nothing
        call DestroyEffectTimed( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT ), 5 )
        call HealUnitBySpell( target, REFRESHED_LIFE )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( TARGET_UNIT )
    endfunction

    public function Order takes Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_ONLY_ORGANIC
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitMagicImmunity( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Heal.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\HindranceOfLearning.j
//TESH.scrollpos=36
//TESH.alwaysfold=0
//! runtextmacro Scope("HindranceOfLearning")
    globals
        private constant integer ORDER_ID = 852159//OrderId( "rechargeoff" )
        public constant integer SPELL_ID = 'A02I'

        private constant real DURATION = 30.
        private timer DURATION_TIMER

        private integer CASTER_TEAM
    endglobals

    private function Ending takes nothing returns nothing
        local integer casterTeam = CASTER_TEAM
        local timer durationTimer = GetExpiredTimer()
        local integer iteration = GetTeams() - 1
        set Experience_DISABLED[casterTeam] = false
        loop
            exitwhen ( iteration < 0 )
            if (iteration != casterTeam) then
                set Experience_DISABLED[casterTeam] = false
            endif
            call UnitAddAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
            set iteration = iteration - 1
        endloop
        call DisplayTextTimedWJ( "'Hindrance of Learning' has vanished: Kills grant experience again.", 10, GetLocalPlayer() )
    endfunction

    public function SpellEffect takes player casterOwner returns nothing
        local integer casterTeam = GetPlayerTeam( casterOwner )
        local integer count = Infoboard_COUNT
        local timer durationTimer = CreateTimerWJ()
        local integer iteration = GetTeams() - 1
        loop
            exitwhen ( iteration < 0 )
            if (iteration != casterTeam) then
                set Experience_DISABLED[casterTeam] = true
            endif
            call UnitRemoveAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
            set iteration = iteration - 1
        endloop
        set CASTER_TEAM = casterTeam
        call DisplayTextTimedWJ( ColorStrings_RED + "Go and stand in the hall: " + ColorStrings_GOLD + "Team" + I2S( casterTeam + 1 ) + ColorStrings_RESET + " has abrogated the experience gaining via kills for " + I2S( R2I( DURATION ) ) + " seconds.\n(Start: " + GetTimeString( count ) + " End: " + GetTimeString( count + R2I( DURATION ) ) + ")" + ColorStrings_RESET, 10, GetLocalPlayer() )
        call PingMasterWizard( casterTeam )
        call PlaySoundFromType( HINDRANCE_OF_LEARNING_SOUND_TYPE )
        call TimerStart( DURATION_TIMER, DURATION, false, function Ending )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER.owner )
    endfunction

    public function Init takes nothing returns nothing
        set DURATION_TIMER = CreateTimerWJ()
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\HindranceOfLearning.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Hurricane.j
//TESH.scrollpos=373
//TESH.alwaysfold=0
//! runtextmacro Scope("Hurricane")
    globals
        private constant integer ORDER_ID = 852144//OrderId( "cyclone" )
        public constant integer SPELL_ID = 'A005'

        private constant integer DUMMY_UNIT_ID = 'n00R'
        private real array DURATION
        private constant real EFFECT_INTERVAL = 0.3
        private constant integer EFFECTS_AMOUNT_PER_INTERVAL = 3
        private group ENUM_GROUP
        private real array LENGTH
        private constant integer LEVELS_AMOUNT = 5
        private real array LIFE_APPROXIMATION_LENGTH
        private real array LIFE_APPROXIMATION_LENGTH_PER_AGILITY_POINT
        private real array LIFE_LOSS_RELATIVE_PER_INTERVAL
        private real array LIFE_LOSS_RELATIVE_PER_INTERVAL_PER_AGILITY_POINT
        private constant integer MAX_EFFECTS_AMOUNT = 20
        private real array MAX_LENGTH
        private constant real MOVE_INTERVAL = 0.045
        private boolexpr TARGET_CONDITIONS
        private real array WIDTH
    endglobals

    private struct Data
        integer abilityLevel
        real angle
        Unit caster
        unit array dummyUnits[MAX_EFFECTS_AMOUNT]
        timer durationTimer
        integer effectsCount = -1
        real array effectsLengthX[MAX_EFFECTS_AMOUNT]
        real array effectsLengthY[MAX_EFFECTS_AMOUNT]
        real array effectsX[MAX_EFFECTS_AMOUNT]
        real array effectsY[MAX_EFFECTS_AMOUNT]
        timer effectTimer
        real lengthX
        real lengthY
        real lifeApproximationLength
        real lifeLossRelative
        timer moveTimer
        real sourceX
        real sourceY
        rect targetRect
    endstruct

    private function Ending takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Hurricane_SCOPE_ID)
        local unit dummyUnit
        local timer effectTimer = d.effectTimer
        local unit enumUnit
        local integer iteration = d.effectsCount
        local timer moveTimer = d.moveTimer
        local rect targetRect = d.targetRect
        call d.destroy()
        call FlushAttachedInteger(durationTimer, Hurricane_SCOPE_ID)
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger(effectTimer, Hurricane_SCOPE_ID)
        call DestroyTimerWJ( effectTimer )
        set effectTimer = null
        if (iteration > -1) then
            loop
                set dummyUnit = d.dummyUnits[iteration]
                call SetUnitAnimationByIndex( dummyUnit, 2 )
                call RemoveUnitTimed( dummyUnit, 2 )
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            set dummyUnit = null
        endif
        call FlushAttachedInteger(moveTimer, Hurricane_SCOPE_ID)
        call DestroyTimerWJ( moveTimer )
        set moveTimer = null
        call RemoveRectWJ( targetRect )
        set targetRect = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        local real angle
        local real distance
        local real filterUnitLife
        local real filterUnitX
        local real filterUnitY
        local real sourceX
        local real sourceY
        set FILTER_UNIT_SELF = GetFilterUnit()
        set filterUnitLife = GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE )
        if ( filterUnitLife <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        set filterUnitX = GetUnitX( FILTER_UNIT_SELF )
        set filterUnitY = GetUnitY( FILTER_UNIT_SELF )
        set sourceX = TEMP_REAL
        set sourceY = TEMP_REAL2
        set distance = DistanceByCoordinates( sourceX, sourceY, filterUnitX, filterUnitY )
        set angle = GetAngleDifference( TEMP_REAL3, Atan2( filterUnitY - sourceY, filterUnitX - sourceX ) )
        if ( ( Sin( angle ) * distance > TEMP_REAL4 ) or ( Cos( angle ) * distance > TEMP_REAL5 ) ) then
            return false
        endif
        set TEMP_INTEGER = TEMP_INTEGER + 1
        set TEMP_REAL6 = TEMP_REAL6 + filterUnitLife
        return true
    endfunction

    private function Move takes nothing returns nothing
        local integer bonusLifeSign
        local unit dummyUnit
        local integer effectsCount
        local unit enumUnit
        local real enumUnitLife
        local real enumUnitX
        local real enumUnitY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, Hurricane_SCOPE_ID)
        local Unit caster = d.caster
        local integer abilityLevel = d.abilityLevel
        local real angle = d.angle
        local integer iteration = d.effectsCount
        local real maxLength = MAX_LENGTH[abilityLevel]
        local real lengthX
        local real lengthY
        local real lifeApproximationLength
        local real lifeAverage
        local real newX
        local real newY
        local real sourceX = d.sourceX
        local real sourceY = d.sourceY
        local rect targetRect = d.targetRect
        local real width = WIDTH[abilityLevel]
        set TEMP_INTEGER = 0
        set TEMP_PLAYER = caster.owner
        set TEMP_REAL = sourceX
        set TEMP_REAL2 = sourceY
        set TEMP_REAL3 = angle
        set TEMP_REAL4 = width
        set TEMP_REAL5 = maxLength
        set TEMP_REAL6 = 0
        call GroupEnumUnitsInRectWithCollision( ENUM_GROUP, targetRect, TARGET_CONDITIONS )
        if ( TEMP_INTEGER > 0 ) then
            set lifeApproximationLength = d.lifeApproximationLength
            set lifeAverage = Max( TEMP_REAL6 / TEMP_INTEGER * ( 1 - d.lifeLossRelative ), R2I( LIMIT_OF_DEATH + 1 ) )
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set lengthX = d.lengthX
            set lengthY = d.lengthY
            loop
                set enumUnitX = GetUnitX( enumUnit )
                set enumUnitY = GetUnitY( enumUnit )
                set newX = enumUnitX + lengthX
                set newY = enumUnitY + lengthY
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call SetUnitFacingWJ( enumUnit, GetRandomReal( 0, 2 * PI ) )
                if ( GetUnitTypeId( enumUnit ) == DUMMY_UNIT_ID ) then
                    set newX = newX + 2 * lengthX
                    set newY = newY + 2 * lengthY

                else
                    call SetUnitXYIfNotBlocked( enumUnit, enumUnitX, enumUnitY, newX, newY )
                    set enumUnitLife = GetUnitState( enumUnit, UNIT_STATE_LIFE )
                    if ( enumUnitLife > 0 ) then
                        set bonusLifeSign = Sign( lifeAverage - enumUnitLife )
                        call SetUnitState( enumUnit, UNIT_STATE_LIFE, MinMax( enumUnitLife + bonusLifeSign * lifeApproximationLength, lifeAverage, I2B( bonusLifeSign ) == false ) )
                    endif
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        if (iteration > -1) then
            set effectsCount = iteration
            loop
                set dummyUnit = d.dummyUnits[iteration]
                set newX = d.effectsX[iteration] + d.effectsLengthX[iteration]
                set newY = d.effectsY[iteration] + d.effectsLengthY[iteration]
                call SetUnitXWJ( dummyUnit, newX )
                call SetUnitYWJ( dummyUnit, newY )
                if ( Cos( angle - Atan2( newY - sourceY, newX - sourceX ) ) * DistanceByCoordinates( sourceX, sourceY, newX, newY ) > maxLength ) then
                    set d.dummyUnits[iteration] = d.dummyUnits[effectsCount]
                    set d.effectsX[iteration] = d.effectsX[effectsCount]
                    set d.effectsY[iteration] = d.effectsY[effectsCount]
                    set effectsCount = effectsCount - 1
                    call SetUnitAnimationByIndex( dummyUnit, 2 )
                    call RemoveUnitTimed( dummyUnit, 2 )
                else
                    set d.effectsX[iteration] = newX
                    set d.effectsY[iteration] = newY
                endif
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            set dummyUnit = null
            set d.effectsCount = effectsCount
        endif
    endfunction

    private function NewEffect takes nothing returns nothing
        local timer effectTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(effectTimer, Hurricane_SCOPE_ID)
        local integer abilityLevel
        local real angle
        local real angle2
        local integer count = d.effectsCount
        local integer iteration
        local real lengthHorizontal
        local real lengthVertical
        local real random
        local real sourceX
        local real sourceY
        local real width
        local real x
        local real xHorizontalPart
        local real xVerticalPart
        local real y
        local real yHorizontalPart
        local real yVerticalPart
        set effectTimer = null
        if (count < MAX_EFFECTS_AMOUNT - 1) then
            set abilityLevel = d.abilityLevel
            set angle = d.angle
            set angle2 = angle + PI / 2
            set iteration = 1
            set lengthVertical = LENGTH[abilityLevel]
            set sourceX = d.sourceX
            set sourceY = d.sourceY
            set width = WIDTH[abilityLevel]
            set xHorizontalPart = Cos(angle2)
            set xVerticalPart = Cos(angle)
            set yHorizontalPart = Sin(angle2)
            set yVerticalPart = Sin(angle)
            loop
                set lengthHorizontal = GetRandomReal( -width, width )
                set count = count + 1
                set random = GetRandomReal(2, 4) * lengthVertical
                set x = sourceX + lengthHorizontal * xHorizontalPart
                set y = sourceY + lengthHorizontal * yHorizontalPart
                set d.dummyUnits[count] = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, x, y, angle )
                set d.effectsLengthX[count] = random * xVerticalPart
                set d.effectsLengthY[count] = random * yVerticalPart
                set d.effectsX[count] = x
                set d.effectsY[count] = y
                exitwhen (count == MAX_EFFECTS_AMOUNT)
                set iteration = iteration + 1
                exitwhen ( iteration > EFFECTS_AMOUNT_PER_INTERVAL )
            endloop
            set d.effectsCount = count
        endif
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local real angle
        local real angle2
        local real casterAgility = GetHeroAgilityTotal( caster )
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local timer effectTimer = CreateTimerWJ()
        local real endX
        local real endY
        local real maxLength = MAX_LENGTH[abilityLevel]
        local real length = LENGTH[abilityLevel]
        local timer moveTimer = CreateTimerWJ()
        local real width = WIDTH[abilityLevel]
        local real widthX
        local real widthY
        local real aX
        local real bX
        local real cX
        local real dX
        local real aY
        local real bY
        local real cY
        local real dY
        if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
        else
            set angle = GetUnitFacingWJ( casterSelf )
        endif
        set casterSelf = null
        set angle2 = angle - PI / 2
        set widthX = width * Cos( angle2 )
        set widthY = width * Sin( angle2 )
        set aX = casterX - widthX
        set aY = casterY - widthY
        set bX = casterX + widthX
        set bY = casterY + widthY
        set endX = casterX + maxLength * Cos( angle )
        set cX = endX - widthX
        set dX = endX + widthX
        set endY = casterY + maxLength * Sin( angle )
        set cY = endY - widthY
        set dY = endY + widthY
        set d.abilityLevel = abilityLevel
        set d.angle = angle
        set d.caster = caster
        set d.durationTimer = durationTimer
        set d.effectTimer = effectTimer
        set d.lengthX = length * Cos(angle)
        set d.lengthY = length * Sin(angle)
        set d.lifeApproximationLength = LIFE_APPROXIMATION_LENGTH[abilityLevel] + casterAgility * LIFE_APPROXIMATION_LENGTH_PER_AGILITY_POINT[abilityLevel]
        set d.lifeLossRelative = LIFE_LOSS_RELATIVE_PER_INTERVAL[abilityLevel] + casterAgility * LIFE_LOSS_RELATIVE_PER_INTERVAL_PER_AGILITY_POINT[abilityLevel]
        set d.moveTimer = moveTimer
        set d.sourceX = casterX
        set d.sourceY = casterY
        set d.targetRect = RectWJ( Min( Min( aX, bX ), Min( cX, dX ) ), Min( Min( aY, bY ), Min( cY, dY ) ), Max( Max( aX, bX ), Max( cX, dX ) ), Max( Max( aY, bY ), Max( cY, dY ) ) )
        call AttachInteger(durationTimer, Hurricane_SCOPE_ID, d)
        call AttachInteger(effectTimer, Hurricane_SCOPE_ID, d)
        call AttachInteger(moveTimer, Hurricane_SCOPE_ID, d)
        call TimerStart( effectTimer, EFFECT_INTERVAL, true, function NewEffect )
        set effectTimer = null
        call TimerStart( moveTimer, MOVE_INTERVAL, true, function Move )
        set moveTimer = null
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function Ending )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set DURATION[1] = 3
        set DURATION[2] = 4
        set DURATION[3] = 5
        set DURATION[4] = 5
        set DURATION[5] = 5
        set ENUM_GROUP = CreateGroupWJ()
        set LENGTH[1] = 150
        set LENGTH[2] = 225
        set LENGTH[3] = 300
        set LENGTH[4] = 375
        set LENGTH[5] = 450
        set LIFE_APPROXIMATION_LENGTH[1] = 7.5
        set LIFE_APPROXIMATION_LENGTH[2] = 7.5
        set LIFE_APPROXIMATION_LENGTH[3] = 7.5
        set LIFE_APPROXIMATION_LENGTH[4] = 7.5
        set LIFE_APPROXIMATION_LENGTH[5] = 7.5
        set LIFE_APPROXIMATION_LENGTH_PER_AGILITY_POINT[1] = 0.15
        set LIFE_APPROXIMATION_LENGTH_PER_AGILITY_POINT[2] = 0.15
        set LIFE_APPROXIMATION_LENGTH_PER_AGILITY_POINT[3] = 0.15
        set LIFE_APPROXIMATION_LENGTH_PER_AGILITY_POINT[4] = 0.15
        set LIFE_APPROXIMATION_LENGTH_PER_AGILITY_POINT[5] = 0.15
        set LIFE_LOSS_RELATIVE_PER_INTERVAL[1] = 0.05
        set LIFE_LOSS_RELATIVE_PER_INTERVAL[2] = 0.08
        set LIFE_LOSS_RELATIVE_PER_INTERVAL[3] = 0.11
        set LIFE_LOSS_RELATIVE_PER_INTERVAL[4] = 0.14
        set LIFE_LOSS_RELATIVE_PER_INTERVAL[5] = 0.17
        set LIFE_LOSS_RELATIVE_PER_INTERVAL_PER_AGILITY_POINT[1] = 0.0005
        set LIFE_LOSS_RELATIVE_PER_INTERVAL_PER_AGILITY_POINT[2] = 0.0005
        set LIFE_LOSS_RELATIVE_PER_INTERVAL_PER_AGILITY_POINT[3] = 0.0005
        set LIFE_LOSS_RELATIVE_PER_INTERVAL_PER_AGILITY_POINT[4] = 0.0005
        set LIFE_LOSS_RELATIVE_PER_INTERVAL_PER_AGILITY_POINT[5] = 0.0005
        loop
            set LENGTH[iteration] = LENGTH[iteration] * MOVE_INTERVAL
            set LIFE_APPROXIMATION_LENGTH[iteration] = LIFE_APPROXIMATION_LENGTH[iteration] * MOVE_INTERVAL
            set LIFE_APPROXIMATION_LENGTH_PER_AGILITY_POINT[iteration] = LIFE_APPROXIMATION_LENGTH_PER_AGILITY_POINT[iteration] * MOVE_INTERVAL
            set LIFE_LOSS_RELATIVE_PER_INTERVAL[iteration] = LIFE_LOSS_RELATIVE_PER_INTERVAL[iteration] * MOVE_INTERVAL
            set LIFE_LOSS_RELATIVE_PER_INTERVAL_PER_AGILITY_POINT[iteration] = LIFE_LOSS_RELATIVE_PER_INTERVAL_PER_AGILITY_POINT[iteration] * MOVE_INTERVAL
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        set MAX_LENGTH[1] = 700
        set MAX_LENGTH[2] = 700
        set MAX_LENGTH[3] = 700
        set MAX_LENGTH[4] = 700
        set MAX_LENGTH[5] = 700
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        set WIDTH[1] = 175
        set WIDTH[2] = 200
        set WIDTH[3] = 230
        set WIDTH[4] = 265
        set WIDTH[5] = 305
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Hurricane.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\IceBall.j
//TESH.scrollpos=568
//TESH.alwaysfold=0
//! runtextmacro Scope("IceBall")
    globals
        private constant integer ORDER_ID = 852075//OrderId( "slow" )
        public constant integer SPELL_ID = 'A003'

        private real array AREA_RANGE
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Human\\Feedback\\SpellBreakerAttack.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private real array DAMAGE_LOW
        private real array DAMAGE_LOW_PER_AGILITY_POINT
        private real array DAMAGE_WIDTH
        private real array DAMAGE_WIDTH_PER_AGILITY_POINT
        private constant integer DUMMY_UNIT_ID = 'h00E'
        private group ENUM_GROUP
        private constant real HIT_RANGE = 32.
        private real array LENGTH
        private real array LENGTH_PER_AGILITY_POINT
        private constant integer LEVELS_AMOUNT = 5
        private constant real RISING_TIME = 0.25
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 0.01
        private constant real RISING_LENGTH = 400 * UPDATE_TIME
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        real damageAmountLow
        real damageAmountWidth
        unit dummyUnit
        real length
        timer moveTimer
        timer riseTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        real x
        real y
        real z
    endstruct

    private function TargetConditions takes nothing returns boolean
        local real filterUnitX
        local real filterUnitY
        set FILTER_UNIT_SELF = GetFilterUnit()
        set filterUnitX = GetUnitX( FILTER_UNIT_SELF )
        set filterUnitY = GetUnitY( FILTER_UNIT_SELF )
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( DistanceByCoordinatesWithZ( filterUnitX, filterUnitY, GetUnitZ( FILTER_UNIT_SELF, filterUnitX, filterUnitY ) + GetUnitImpactZ(FILTER_UNIT), TEMP_REAL2, TEMP_REAL3, TEMP_REAL4 ) > TEMP_REAL ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        return true
    endfunction

    //! runtextmacro Scope("Buff")
        globals
            private real array Buff_BONUS_SPEED
            private constant real Buff_DAMAGE_SPEED_CAP_LOW = 250.
            private constant real Buff_DAMAGE_SPEED_CAP_WIDTH = 350 - Buff_DAMAGE_SPEED_CAP_LOW
            private real array Buff_DURATION
            private trigger Buff_EVENT_DISPEL
            private real array Buff_HERO_DURATION
            private constant string Buff_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl"
            private constant string Buff_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Buff_Data
            integer abilityLevel
            timer durationTimer
            Unit target
            effect targetEffect
        endstruct

        private function Buff_Ending takes Buff_Data d, timer durationTimer, Unit target returns nothing
            local integer abilityLevel = d.abilityLevel
            local integer targetId = target.id
            local effect targetEffect = d.targetEffect
            call d.destroy()
            call FlushAttachedInteger( durationTimer, Buff_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call FlushAttachedIntegerById( targetId, Buff_SCOPE_ID )
            //! runtextmacro RemoveEventById( "targetId", "Buff_EVENT_DEATH" )
            call DestroyEffectWJ(targetEffect)
            set targetEffect = null
            call AddUnitSpeedBonus( target, -Buff_BONUS_SPEED[abilityLevel] )
            call RemoveUnitFrostSlow(target)
        endfunction

        public function Buff_Dispel takes Unit target returns nothing
            local Buff_Data d = GetAttachedIntegerById( target.id, Buff_SCOPE_ID )
            if ( d != NULL ) then
                call Buff_Ending( d, d.durationTimer, target )
            endif
        endfunction

        private function Buff_Dispel_Event takes nothing returns nothing
            call Buff_Dispel( TRIGGER_UNIT )
        endfunction

        public function Buff_Death takes Unit target returns nothing
            call Buff_Dispel( target )
        endfunction

        private function Buff_Death_Event takes nothing returns nothing
            call Buff_Death( DYING_UNIT )
        endfunction

        private function Buff_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Buff_Data d = GetAttachedInteger(durationTimer, Buff_SCOPE_ID)
            set durationTimer = null
            call Buff_Ending( d, durationTimer, d.target )
        endfunction

        public function Buff_Start takes integer abilityLevel, Unit caster, player casterOwner, real damageAmountLow, real damageAmountWidth, real targetX, real targetY, real targetZ returns nothing
            local real areaRange = AREA_RANGE[abilityLevel]
            local real bonusSpeed
            local Buff_Data d
            local real damageAmount
            local real duration
            local timer durationTimer
            local Unit enumUnit
            local integer enumUnitId
            local unit enumUnitSelf
            local boolean isNew
            local integer oldAbilityLevel
            set TEMP_PLAYER = casterOwner
            set TEMP_REAL = areaRange
            set TEMP_REAL2 = targetX
            set TEMP_REAL3 = targetY
            set TEMP_REAL4 = targetZ
            call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, areaRange, TARGET_CONDITIONS )
            set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
            if ( enumUnitSelf != null ) then
                set bonusSpeed = Buff_BONUS_SPEED[abilityLevel]
                loop
                    set enumUnit = GetUnit(enumUnitSelf)
                    set damageAmount = damageAmountLow + Min( Max( GetUnitSpeed( enumUnit ) - Buff_DAMAGE_SPEED_CAP_LOW, 0 ), Buff_DAMAGE_SPEED_CAP_WIDTH ) / Buff_DAMAGE_SPEED_CAP_WIDTH * damageAmountWidth
                    set enumUnitId = enumUnit.id
                    set d = GetAttachedIntegerById( enumUnitId, Buff_SCOPE_ID )
                    set isNew = ( d == NULL )
                    call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                    if ( isNew ) then
                        set d = Buff_Data.create()
                        set durationTimer = CreateTimerWJ()
                        set d.durationTimer = durationTimer
                        set d.target = enumUnit
                        call AttachInteger( durationTimer, Buff_SCOPE_ID, d )
                        call AttachIntegerById( enumUnitId, Buff_SCOPE_ID, d )
                        //! runtextmacro AddEventById( "enumUnitId", "Buff_EVENT_DEATH" )
                    else
                        set durationTimer = d.durationTimer
                        set oldAbilityLevel = d.abilityLevel
                        call DestroyEffectWJ( d.targetEffect )
                    endif
                    set d.abilityLevel = abilityLevel
                    set d.targetEffect = AddSpecialEffectTargetWJ( Buff_TARGET_EFFECT_PATH, enumUnitSelf, Buff_TARGET_EFFECT_ATTACHMENT_POINT )
                    if ( isNew ) then
                        call AddUnitSpeedBonus( enumUnit, bonusSpeed )
                        call AddUnitFrostSlow(enumUnit)
                    else
                        call AddUnitSpeedBonus( enumUnit, bonusSpeed - Buff_BONUS_SPEED[oldAbilityLevel] )
                    endif
                    if ( IsUnitType( enumUnitSelf, UNIT_TYPE_HERO ) ) then
                        set duration = Buff_HERO_DURATION[abilityLevel]
                    else
                        set duration = Buff_DURATION[abilityLevel]
                    endif
                    call TimerStart( durationTimer, duration, false, function Buff_EndingByTimer )
                    call UnitDamageUnitBySpell( caster, enumUnit, damageAmount )
                    set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnitSelf == null )
                endloop
                set durationTimer = null
            endif
        endfunction

        public function Buff_Init takes nothing returns nothing
            set Buff_BONUS_SPEED[1] = -100
            set Buff_BONUS_SPEED[2] = -100
            set Buff_BONUS_SPEED[3] = -100
            set Buff_BONUS_SPEED[4] = -100
            set Buff_BONUS_SPEED[5] = -100
            set Buff_DURATION[1] = 5
            set Buff_DURATION[2] = 7
            set Buff_DURATION[3] = 9
            set Buff_DURATION[4] = 10
            set Buff_DURATION[5] = 11
            set Buff_HERO_DURATION[1] = 1.2
            set Buff_HERO_DURATION[2] = 1.4
            set Buff_HERO_DURATION[3] = 1.6
            set Buff_HERO_DURATION[4] = 1.8
            set Buff_HERO_DURATION[5] = 2
            //! runtextmacro CreateEvent( "Buff_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Buff_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("FrostNova")
        globals
            private constant integer FrostNova_DUMMY_UNIT_ID = 'n029'
            private constant integer FrostNova_DUMMY_UNITS_AMOUNT = 4
            private constant real FrostNova_DURATION = 0.75
            private real array FrostNova_LENGTH
            private constant real FrostNova_TIME_SCALE = 2 / FrostNova_DURATION
            private constant real FrostNova_UPDATE_TIME = 0.035
            private constant integer FrostNova_WAVES_AMOUNT = R2I(FrostNova_DURATION / FrostNova_UPDATE_TIME)
        endglobals

        private struct FrostNova_Data
            unit array dummyUnits[FrostNova_DUMMY_UNITS_AMOUNT]
            integer iteration
            real length
            timer updateTimer
            real array x[FrostNova_DUMMY_UNITS_AMOUNT]
            real array y[FrostNova_DUMMY_UNITS_AMOUNT]
            real z
        endstruct

        private function FrostNova_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local FrostNova_Data d = GetAttachedInteger(durationTimer, FrostNova_SCOPE_ID)
            local unit array dummyUnits
            local integer iteration = FrostNova_DUMMY_UNITS_AMOUNT - 1
            local timer updateTimer = d.updateTimer
            loop
                set dummyUnits[iteration] = d.dummyUnits[iteration]
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            set iteration = FrostNova_DUMMY_UNITS_AMOUNT - 1
            call d.destroy()
            call FlushAttachedInteger( durationTimer, FrostNova_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            loop
                call RemoveUnitWJ( dummyUnits[iteration] )
                set dummyUnits[iteration] = null
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            call FlushAttachedInteger(updateTimer, FrostNova_SCOPE_ID)
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endfunction

        private function FrostNova_Move takes nothing returns nothing
            local real currentAngle
            local unit dummyUnit
            local integer iteration = FrostNova_DUMMY_UNITS_AMOUNT - 1
            local timer updateTimer = GetExpiredTimer()
            local FrostNova_Data d = GetAttachedInteger(updateTimer, FrostNova_SCOPE_ID)
            local real length = d.length
            local real x
            local real y
            local real z = d.z
            set d.iteration = d.iteration + 1
            set updateTimer = null
            loop
                set currentAngle = PI / 2 * ( 0.5 + iteration )
                set dummyUnit = d.dummyUnits[iteration]
                set x = d.x[iteration] + length * Cos( currentAngle )
                set y = d.y[iteration] + length * Sin( currentAngle )
                set d.x[iteration] = x
                set d.y[iteration] = y
                call SetUnitX( dummyUnit, x )
                call SetUnitY( dummyUnit, y )
                call SetUnitZ( dummyUnit, x, y, z )
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            set dummyUnit = null
        endfunction

        public function FrostNova_Start takes integer abilityLevel, timer durationTimer, real targetX, real targetY, real targetZ returns nothing
            local FrostNova_Data d = FrostNova_Data.create()
            local unit dummyUnit
            local integer iteration = FrostNova_DUMMY_UNITS_AMOUNT - 1
            local timer updateTimer = CreateTimerWJ()
            set d.iteration = 0
            set d.length = FrostNova_LENGTH[abilityLevel]
            set d.updateTimer = updateTimer
            loop
                set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, FrostNova_DUMMY_UNIT_ID, targetX, targetY, PI / 2 * ( 0.5 + iteration ) )
                set d.dummyUnits[iteration] = dummyUnit
                set d.x[iteration] = targetX
                set d.y[iteration] = targetY
                call SetUnitTimeScale( dummyUnit, FrostNova_TIME_SCALE )
                call SetUnitZ( dummyUnit, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
            set dummyUnit = null
            set d.z = targetZ
            call AttachInteger(durationTimer, FrostNova_SCOPE_ID, d)
            call AttachInteger(updateTimer, FrostNova_SCOPE_ID, d)
            call TimerStart( updateTimer, FrostNova_UPDATE_TIME, true, function FrostNova_Move )
            set updateTimer = null
            call TimerStart( durationTimer, FrostNova_DURATION, false, function FrostNova_Ending )
        endfunction

        public function FrostNova_Init takes nothing returns nothing
            local integer iteration = LEVELS_AMOUNT
            loop
                set FrostNova_LENGTH[iteration] = ( AREA_RANGE[iteration] + 115 ) / FrostNova_WAVES_AMOUNT
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
            call InitUnitType( FrostNova_DUMMY_UNIT_ID )
        endfunction
    //! runtextmacro Endscope()

    private function Ending takes integer abilityLevel, Data d, unit dummyUnit, boolean isTargetNotNull, timer moveTimer, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( moveTimer, IceBall_SCOPE_ID )
        if ( isTargetNotNull ) then
            call RemoveIntegerFromTableById( targetId, IceBall_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, IceBall_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
            endif
        endif
        call SetUnitAnimationByIndex( dummyUnit, 1 )
        call RemoveUnitTimed( dummyUnit, 2 )
        call FrostNova_FrostNova_Start(abilityLevel, moveTimer, targetX, targetY, targetZ)
    endfunction

    private function Death_ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        set d.target = NULL
        call RemoveIntegerFromTableById( targetId, IceBall_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, IceBall_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, IceBall_SCOPE_ID )
        if ( iteration > TABLE_EMPTY ) then
            loop
                call Death_ResetTarget( GetIntegerFromTableById( targetId, IceBall_SCOPE_ID, iteration ), target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local real damageAmountLow
        local real damageAmountWidth
        local real distanceX
        local real distanceY
        local real distanceZ
        local unit enumUnit
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, IceBall_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit caster = d.caster
        local player casterOwner = caster.owner
        local unit dummyUnit = d.dummyUnit
        local real length = d.length
        local boolean reachesTarget
        local Unit target = d.target
        local boolean isTargetNull = ( target == NULL )
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        local real x = d.x
        local real y = d.y
        local real z = d.z
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
            set targetSelf = null
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( x, y, z, targetX, targetY, targetZ ) <= length )
        if ( reachesTarget ) then
            set x = targetX
            set y = targetY
            set z = targetZ
        else
            set distanceZ = targetZ - z
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, targetX, targetY ) )
            set distanceX = targetX - x
            set distanceY = targetY - y
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = length * Cos( angleLengthXYZ )
            set x = x + lengthXY * Cos( angleXY )
            set y = y + lengthXY * Sin( angleXY )
            set z = z + length * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        set TEMP_PLAYER = casterOwner
        set TEMP_REAL = AREA_RANGE[abilityLevel]
        set TEMP_REAL2 = x
        set TEMP_REAL3 = y
        set TEMP_REAL4 = z
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, x, y, HIT_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( ( enumUnit != null ) or ( reachesTarget ) ) then
            set damageAmountLow = d.damageAmountLow
            set damageAmountWidth = d.damageAmountWidth
            if ( enumUnit != null ) then
                set targetX = GetUnitX( enumUnit )
                set targetY = GetUnitY( enumUnit )
                set targetZ = GetUnitZ( enumUnit, targetX, targetY )
                set enumUnit = null
            endif
            call Ending( abilityLevel, d, dummyUnit, isTargetNull == false, moveTimer, target, targetX, targetY, targetZ )
            call Buff_Buff_Start( abilityLevel, caster, casterOwner, damageAmountLow, damageAmountWidth, targetX, targetY, targetZ )
        else
            set d.x = x
            set d.y = y
            set d.z = z
        endif
        set casterOwner = null
        set dummyUnit = null
        set moveTimer = null
    endfunction

    private function Rise_Ending takes nothing returns nothing
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger( moveTimer, IceBall_SCOPE_ID )
        local timer riseTimer = d.riseTimer
        call FlushAttachedInteger( riseTimer, IceBall_SCOPE_ID )
        call DestroyTimerWJ( riseTimer )
        set riseTimer = null
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
    endfunction

    private function Rise takes nothing returns nothing
        local timer riseTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger( riseTimer, IceBall_SCOPE_ID )
        local unit dummyUnit = d.dummyUnit
        local real z = d.z + d.length
        set riseTimer = null
        set d.z = z
        call SetUnitZ( dummyUnit, d.x, d.y, z )
        set dummyUnit = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local real casterAgility = GetHeroAgilityTotal( caster )
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster)
        local Data d = Data.create()
        local unit dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, GetUnitFacingWJ( casterSelf ) )
        local timer moveTimer = CreateTimerWJ()
        local timer riseTimer = CreateTimerWJ()
        local integer targetId = target.id
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT ) )
        set casterSelf = null
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.damageAmountLow = DAMAGE_LOW[abilityLevel] + casterAgility * DAMAGE_LOW_PER_AGILITY_POINT[abilityLevel]
        set d.damageAmountWidth = DAMAGE_WIDTH[abilityLevel] + casterAgility * DAMAGE_WIDTH_PER_AGILITY_POINT[abilityLevel]
        set d.dummyUnit = dummyUnit
        set d.length = LENGTH[abilityLevel] + casterAgility * LENGTH_PER_AGILITY_POINT[abilityLevel]
        set d.moveTimer = moveTimer
        set d.riseTimer = riseTimer
        set d.target = target
        set d.x = casterX
        set d.y = casterY
        set d.z = casterZ
        call AttachInteger(moveTimer, IceBall_SCOPE_ID, d)
        call AttachInteger(riseTimer, IceBall_SCOPE_ID, d)
        call AddIntegerToTableById( targetId, IceBall_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, IceBall_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call SetUnitZ( dummyUnit, casterX, casterY, casterZ )
        set dummyUnit = null
        call TimerStart( riseTimer, UPDATE_TIME, true, function Rise )
        set riseTimer = null
        call TimerStart( moveTimer, RISING_TIME, false, function Rise_Ending )
        set moveTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT)
    endfunction

    public function Order takes Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set AREA_RANGE[1] = 200
        set AREA_RANGE[2] = 225
        set AREA_RANGE[3] = 250
        set AREA_RANGE[4] = 275
        set AREA_RANGE[5] = 300
        set DAMAGE_LOW[1] = 28
        set DAMAGE_LOW[2] = 36
        set DAMAGE_LOW[3] = 44
        set DAMAGE_LOW[4] = 52
        set DAMAGE_LOW[5] = 60
        set DAMAGE_LOW_PER_AGILITY_POINT[1] = 0.24
        set DAMAGE_LOW_PER_AGILITY_POINT[2] = 0.24
        set DAMAGE_LOW_PER_AGILITY_POINT[3] = 0.24
        set DAMAGE_LOW_PER_AGILITY_POINT[4] = 0.24
        set DAMAGE_LOW_PER_AGILITY_POINT[5] = 0.24
        set DAMAGE_WIDTH[1] = 50
        set DAMAGE_WIDTH[2] = 50
        set DAMAGE_WIDTH[3] = 50
        set DAMAGE_WIDTH[4] = 50
        set DAMAGE_WIDTH[5] = 50
        set DAMAGE_WIDTH_PER_AGILITY_POINT[1] = 0.4
        set DAMAGE_WIDTH_PER_AGILITY_POINT[2] = 0.4
        set DAMAGE_WIDTH_PER_AGILITY_POINT[3] = 0.4
        set DAMAGE_WIDTH_PER_AGILITY_POINT[4] = 0.4
        set DAMAGE_WIDTH_PER_AGILITY_POINT[5] = 0.4
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set LENGTH[1] = 450
        set LENGTH[2] = 450
        set LENGTH[3] = 450
        set LENGTH[4] = 450
        set LENGTH[5] = 450
        set LENGTH_PER_AGILITY_POINT[1] = 0
        set LENGTH_PER_AGILITY_POINT[2] = 0
        set LENGTH_PER_AGILITY_POINT[3] = 0
        set LENGTH_PER_AGILITY_POINT[4] = 0
        set LENGTH_PER_AGILITY_POINT[5] = 0
        loop
            set DAMAGE_WIDTH[iteration] = DAMAGE_WIDTH[iteration] - DAMAGE_LOW[iteration]
            set DAMAGE_WIDTH_PER_AGILITY_POINT[iteration] = DAMAGE_WIDTH_PER_AGILITY_POINT[iteration] - DAMAGE_LOW_PER_AGILITY_POINT[iteration]
            set LENGTH[iteration] = LENGTH[iteration] * UPDATE_TIME
            set LENGTH_PER_AGILITY_POINT[iteration] = LENGTH_PER_AGILITY_POINT[iteration] * UPDATE_TIME
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call FrostNova_FrostNova_Init()
        call Buff_Buff_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\IceBall.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Immolation.j
//TESH.scrollpos=97
//TESH.alwaysfold=0
//! runtextmacro Scope("Immolation")
    globals
        public constant integer SPELL_ID = 'A03S'

        private constant real AREA_RANGE = 250.
        private constant real INTERVAL = 2.
        private constant real DAMAGE_PER_INTERVAL = 15 * INTERVAL
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\NightElf\\Immolation\\ImmolationDamage.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "head"
    endglobals

    private struct Data
        Unit caster
        timer intervalTimer
    endstruct

    public function Death takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, Immolation_SCOPE_ID)
        local timer intervalTimer
        if ( d != NULL ) then
            set intervalTimer = d.intervalTimer
            call FlushAttachedIntegerById( casterId, Immolation_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            call FlushAttachedInteger( intervalTimer, Immolation_SCOPE_ID )
            call DestroyTimerWJ( intervalTimer )
            set intervalTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) != TEMP_BOOLEAN ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Interval takes nothing returns nothing
        local unit enumUnit
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, Immolation_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        set intervalTimer = null
        set TEMP_BOOLEAN = IsUnitType( casterSelf, UNIT_TYPE_FLYING )
        set casterSelf = null
        set TEMP_PLAYER = caster.owner
        set TEMP_UNIT_SELF = casterSelf
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnit, TARGET_EFFECT_ATTACHMENT_POINT ) )
                call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), DAMAGE_PER_INTERVAL )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, Immolation_SCOPE_ID)
        local timer intervalTimer
        if ( d == NULL) then
            set d = Data.create()
            set intervalTimer = CreateTimerWJ()
            set d.caster = caster
            set d.intervalTimer = intervalTimer
            call AttachIntegerById( casterId, Immolation_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger( intervalTimer, Immolation_SCOPE_ID, d )
            call TimerStart( intervalTimer, INTERVAL, true, function Interval )
            set intervalTimer = null
        endif
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Immolation.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Inspiration.j
//TESH.scrollpos=152
//TESH.alwaysfold=0
//! runtextmacro Scope("Inspiration")
    globals
        public constant integer ORDER_ID = 852132//OrderId( "autodispel" )
        public constant integer SPELL_ID = 'A00M'

        private constant real BONUS_DAMAGE = 2.
        private real array BONUS_LIFE_REGENERATION
        private real array DURATION
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\InnerFire\\InnerFireTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "overhead"
    endglobals

    private struct Data
        integer abilityLevel
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer abilityLevel = d.abilityLevel
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger(durationTimer, Inspiration_SCOPE_ID)
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedIntegerById(targetId, Inspiration_SCOPE_ID)
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call AddUnitDamageBonus( target, -BONUS_DAMAGE )
        call AddUnitLifeRegenerationBonus( target, -BONUS_LIFE_REGENERATION[abilityLevel] )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, Inspiration_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Inspiration_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local player casterOwner = caster.owner
        local integer abilityLevel = 1 + GetPlayerTechCount( casterOwner, ImprovedInspiration_RESEARCH_ID, true )
        local timer durationTimer
        local integer oldAbilityLevel
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, Inspiration_SCOPE_ID)
        local boolean isNew = ( d == NULL )
        set casterOwner = null
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger( durationTimer, Inspiration_SCOPE_ID, d )
            call AttachIntegerById( targetId, Inspiration_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        else
            set durationTimer = d.durationTimer
            set oldAbilityLevel = d.abilityLevel
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.abilityLevel = abilityLevel
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            call AddUnitDamageBonus( target, BONUS_DAMAGE )
            call AddUnitLifeRegenerationBonus( target, BONUS_LIFE_REGENERATION[abilityLevel] )
        else
            call AddUnitLifeRegenerationBonus( target, BONUS_LIFE_REGENERATION[abilityLevel] - BONUS_LIFE_REGENERATION[oldAbilityLevel] )
        endif
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    private function TargetConditions_Single_String takes player casterOwner, Unit checkingUnit returns string
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) == false ) then
            return ErrorStrings_ONLY_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    public function Order takes Unit caster, Unit target returns string
        return TargetConditions_Single_String( caster.owner, target )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT, TARGET_UNIT )
    endfunction

    //! runtextmacro Scope("Automatic")
        globals
            public constant integer Automatic_ACTIVATION_ORDER_ID = 852133//OrderId( "autodispelon" )
            public constant integer Automatic_DEACTIVATION_ORDER_ID = 852134//OrderId( "autodispeloff" )

            private constant real Automatic_AREA_RANGE = 500.
            private group Automatic_ENUM_GROUP
            private boolexpr Automatic_TARGET_CONDITIONS
        endglobals

        private function Automatic_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
            if ( TargetConditions_Single_String( TEMP_PLAYER, FILTER_UNIT ) != null ) then
                return false
            endif
            if ( GetAttachedIntegerById( FILTER_UNIT.id, Inspiration_SCOPE_ID ) != NULL ) then
                return false
            endif
            return true
        endfunction

        public function Automatic_TargetInRange takes Unit caster, player casterOwner returns nothing
            local unit casterSelf
            local unit enumUnit
            if ( GetUnitAutomaticAbility(caster) == SPELL_ID ) then
                set casterSelf = caster.self
                set TEMP_PLAYER = casterOwner
                call GroupEnumUnitsInRangeWithCollision( Automatic_ENUM_GROUP, GetUnitX( casterSelf ), GetUnitY( casterSelf ), Automatic_AREA_RANGE, Automatic_TARGET_CONDITIONS )
                set enumUnit = GetRandomUnit( Automatic_ENUM_GROUP )
                if ( enumUnit != null ) then
                    call IssueTargetOrderByIdTimed( caster, ORDER_ID, GetUnit(enumUnit), 0 )
                    set enumUnit = null
                endif
                set casterSelf = null
            endif
        endfunction

        private function Automatic_TargetInRange_Event takes nothing returns nothing
            call Automatic_TargetInRange( TRIGGER_UNIT, TRIGGER_UNIT.owner )
        endfunction

        public function Automatic_Activation_Order takes Unit caster returns nothing
            //! runtextmacro AddEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, SPELL_ID)
        endfunction

        private function Automatic_Activation_Order_Event takes nothing returns nothing
            call Automatic_Activation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Deactivation_Order takes Unit caster returns nothing
            //! runtextmacro RemoveEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, 0)
        endfunction

        private function Automatic_Deactivation_Order_Event takes nothing returns nothing
            call Automatic_Deactivation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Init takes nothing returns nothing
            set Automatic_ENUM_GROUP = CreateGroupWJ()
            set Automatic_TARGET_CONDITIONS = ConditionWJ( function Automatic_TargetConditions )
            call AddOrderAbility( Automatic_ACTIVATION_ORDER_ID, SPELL_ID )
            call AddOrderAbility( Automatic_DEACTIVATION_ORDER_ID, SPELL_ID )
            //! runtextmacro CreateEvent( "Automatic_EVENT_ACQUIRE", "UnitAcquiresTarget_EVENT_KEY", "0", "function Automatic_TargetInRange_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_ACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_ACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Activation_Order_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_DEACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_DEACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Deactivation_Order_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        set BONUS_LIFE_REGENERATION[1] = 4
        set BONUS_LIFE_REGENERATION[2] = 6
        set BONUS_LIFE_REGENERATION[3] = 8
        set DURATION[1] = 25
        set DURATION[2] = 35
        set DURATION[3] = 45
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Automatic_Automatic_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Inspiration.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Invulnerability.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Invulnerability")
    globals
        public constant integer SPELL_ID = 'A000'
    endglobals

    public function Learn takes Unit caster returns nothing
        call AddUnitInvulnerability( caster )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Invulnerability.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Kataikaze.j
//TESH.scrollpos=211
//TESH.alwaysfold=0
//! runtextmacro Scope("Kataikaze")
    globals
        public constant integer ORDER_ID = 852132//OrderId( "unstableconcoction" )
        public constant integer RESEARCH_ID = 'R01D'
        public constant integer SPELL_ID = 'A08N'

        private constant real AREA_RANGE = 300.
        private constant real DAMAGE_FACTOR = 7.
        private constant real HERO_DAMAGE_FACTOR = 4.
        private constant real HIT_TOLERANCE = 30.
        private group ENUM_GROUP
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Weapons\\Mortar\\MortarMissile.mdl"
        private constant real SPEED_FACTOR = 1.25
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 0.035
    endglobals

    private struct Data
        Unit caster
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
    endstruct

    private function Ending takes Unit caster, Data d, boolean isTargetNotNull, timer moveTimer, Unit target returns nothing
        local integer casterId = caster.id
        local integer targetId
        call d.destroy()
        call FlushAttachedIntegerById( casterId, Kataikaze_SCOPE_ID_BASIC )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_CASTER_DEATH" )
        call FlushAttachedInteger( moveTimer, Kataikaze_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        if ( isTargetNotNull ) then
            set targetId = target.id
            call RemoveIntegerFromTableById( targetId, Kataikaze_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, Kataikaze_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_TARGET_DEATH" )
            endif
        endif
        call AddUnitPathing(caster)
        call RemoveUnitStun(caster, 5)
    endfunction

    public function Caster_Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Kataikaze_SCOPE_ID_BASIC)
        local Unit target
        if (d != NULL) then
            set target = d.target
            call Ending(caster, d, (target != NULL), d.moveTimer, target)
        endif
    endfunction

    private function Caster_Death_Event takes nothing returns nothing
        call Caster_Death( DYING_UNIT )
    endfunction

    private function Target_Death_ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        call RemoveIntegerFromTableById( targetId, Kataikaze_SCOPE_ID, d )
        set d.target = NULL
        if ( CountIntegersInTableById( targetId, Kataikaze_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_TARGET_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Target_Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, Kataikaze_SCOPE_ID )
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById( targetId, Kataikaze_SCOPE_ID, iteration )
                call Target_Death_ResetTarget( d, target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Target_Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Target_Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function TargetConditions_Single takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_GROUND ) == false ) then
            return ErrorStrings_ONLY_GROUND
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitInvulnerability( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_INVULNERABLE
        endif
        return null
    endfunction

    private function TargetConditions takes nothing returns boolean
        if (TargetConditions_Single(TEMP_PLAYER, GetUnit(GetFilterUnit())) != null) then
            return false
        endif
        return true
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local real casterDamage
        local real damage
        local real distanceX
        local real distanceY
        local real distanceZ
        local unit enumUnit
        local real heroDamage
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, Kataikaze_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY )
        local real length = GetUnitSpeedTotal( caster ) * SPEED_FACTOR * UPDATE_TIME
        local real normalDamage
        local boolean reachesTarget
        local Unit target = d.target
        local boolean isTargetNull = ( target == NULL )
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        set moveTimer = null
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
            set targetSelf = null
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( casterX, casterY, casterZ, targetX, targetY, targetZ ) <= length + HIT_TOLERANCE )
        if ( reachesTarget ) then
            set casterX = targetX
            set casterY = targetY
            set casterZ = targetZ
        else
            set distanceZ = targetZ - casterZ
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( casterX, casterY, targetX, targetY ) )
            set distanceX = targetX - casterX
            set distanceY = targetY - casterY
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = length * Cos( angleLengthXYZ )
            set casterX = casterX + lengthXY * Cos( angleXY )
            set casterY = casterY + lengthXY * Sin( angleXY )
            set casterZ = casterZ + length * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( casterSelf, angleXY )
        endif
        call SetUnitX( casterSelf, casterX )
        call SetUnitY( casterSelf, casterY )
        call SetUnitZ( casterSelf, casterX, casterY, casterZ )
        if ( reachesTarget ) then
            set casterDamage = GetUnitDamage(caster)
            set heroDamage = casterDamage * DAMAGE_FACTOR
            set normalDamage = casterDamage * DAMAGE_FACTOR
            call KillUnit(casterSelf)
            set TEMP_PLAYER = caster.owner
            call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, casterX, casterY ) )
            call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
            set enumUnit = FirstOfGroup(ENUM_GROUP)
            if (enumUnit != null) then
                loop
                    call GroupRemoveUnit(ENUM_GROUP, enumUnit)
                    if (IsUnitType(enumUnit, UNIT_TYPE_HERO)) then
                        set damage = heroDamage
                    else
                        set damage = normalDamage
                    endif
                    call UnitDamageUnitEx(caster, GetUnit(enumUnit), damage, null)
                    set enumUnit = FirstOfGroup(ENUM_GROUP)
                    exitwhen (enumUnit == null)
                endloop
            endif
        endif
        set casterSelf = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local integer casterId = caster.id
        local Data d = Data.create()
        local timer moveTimer = CreateTimer()
        local integer targetId = target.id
        set d.caster = caster
        set d.moveTimer = moveTimer
        set d.target = target
        call AttachIntegerById( casterId, Kataikaze_SCOPE_ID_BASIC, d )
        //! runtextmacro AddEventById( "casterId", "EVENT_CASTER_DEATH" )
        call AttachInteger( moveTimer, Kataikaze_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, Kataikaze_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, Kataikaze_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_TARGET_DEATH" )
        endif
        call RemoveUnitPathing(caster)
        call AddUnitStun(caster, 5)
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        return TargetConditions_Single( casterOwner, target )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_CASTER_DEATH", "UnitDies_EVENT_KEY", "0", "function Caster_Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_TARGET_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Kataikaze.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\KidneyShot.j
//TESH.scrollpos=70
//TESH.alwaysfold=0
//! runtextmacro Scope("KidneyShot")
    globals
        private constant integer ORDER_ID = 852183//OrderId( "starfall" )
        public constant integer SPELL_ID = 'A06W'

        private constant real DAMAGE = 100.
        private constant real DAMAGE_PER_STRENGTH_POINT = 1.
        private constant real DURATION = 3.
        private constant real RETURNED_LIFE = 40.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Weapons\\ChimaeraLightningMissile\\ChimaeraLightningMissile.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
    endglobals

    private struct Data
        timer durationTimer
        Unit target
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger(durationTimer, KidneyShot_SCOPE_ID)
        call DestroyTimerWJ( durationTimer )
        call RemoveIntegerFromTableById( targetId, KidneyShot_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, KidneyShot_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
    endfunction

    public function Death takes Unit target returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, KidneyShot_SCOPE_ID )
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById( targetId, KidneyShot_SCOPE_ID, iteration )
                call Ending( d, d.durationTimer, target )
                set iteration = iteration - 1
                exitwhen (iteration < TABLE_STARTED)
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, KidneyShot_SCOPE_ID)
        local Unit target = d.target
        call Ending( d, durationTimer, target )
        set durationTimer = null
        call AddUnitState( target.self, UNIT_STATE_LIFE, RETURNED_LIFE )
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local integer targetId = target.id
        local unit targetSelf = target.self
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
        set d.durationTimer = durationTimer
        set d.target = target
        call AttachInteger( durationTimer, KidneyShot_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, KidneyShot_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, KidneyShot_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call PlaySoundFromTypeOnUnit( KIDNEY_SHOT_SOUND_TYPE, targetSelf )
        set targetSelf = null
        call SetUnitStunTimed( target, 1, DURATION )
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
        call UnitDamageUnitEx( caster, target, DAMAGE + GetHeroStrengthTotal( caster ) * DAMAGE_PER_STRENGTH_POINT, null )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, unit target returns string
        if ( IsUnitAlly( target, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( target, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_ONLY_ORGANIC
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( CASTER.owner, TARGET_UNIT.self )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\KidneyShot.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\KittyJump.j
//TESH.scrollpos=334
//TESH.alwaysfold=0
//! runtextmacro Scope("KittyJump")
    globals
        private constant integer ORDER_ID = 852525//OrderId( "blink" )
        public constant integer SPELL_ID = 'A01W'

        private real array ACCELERATION_Z
        private real array DAMAGE
        private real array DAMAGE_PER_STRENGTH_POINT
        private real array DAMAGE_PER_INTERVAL
        private real array DAMAGE_PER_INTERVAL_PER_AGILITY_POINT
        private real array DURATION
        private group ENUM_GROUP
        private constant real HEIGHT = 234.375
        private constant real HIT_HEIGHT = 64.
        private constant real HIT_RADIUS = 224.
        private real array LENGTH_Z_ADD
        private real array LENGTH_Z_START
        private constant integer LEVELS_AMOUNT = 5
        private constant real MINIMUM_RANGE = 500.
        private constant string SPECIAL_EFFECT_PATH = "Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl"
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 0.035
        private integer array WAVES_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        real damageAmount
        real damagePerIntervalAmount
        real lengthX
        real lengthY
        real lengthZ
        group targetGroup
        timer updateTimer
    endstruct

    private function Ending takes Unit caster, real casterX, real casterY, real casterZ, Data d returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local group targetGroup = d.targetGroup
        local timer updateTimer = d.updateTimer
        call d.destroy()
        call FlushAttachedIntegerById( casterId, KittyJump_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_ORDER2" )
        call DestroyGroupWJ( targetGroup )
        set targetGroup = null
        call FlushAttachedInteger( updateTimer, KittyJump_SCOPE_ID )
        call DestroyTimerWJ( updateTimer )
        set updateTimer = null
        call AddUnitPathing( caster )
        call RemoveUnitSilence( caster )
        call SetUnitPosition( casterSelf, casterX, casterY )
        call SetUnitZ( casterSelf, casterX, casterY, -99999 )
        set casterSelf = null
        call PlaySoundFromTypeAtPosition( KITTY_JUMP_ENDING_SOUND_TYPE, casterX, casterY, casterZ )
    endfunction

    public function MoveCheck takes Unit caster, real casterX, real casterY, real casterZ returns nothing
        local Data d = GetAttachedIntegerById( caster.id, KittyJump_SCOPE_ID)
        if ( d != NULL ) then
            if ( casterZ <= GetFloorHeight( casterX, casterY ) ) then
                call Ending(caster, casterX, casterY, casterZ, d)
            endif
        endif
    endfunction

    //! runtextmacro Scope("Target")
        globals
            public real array Target_DAMAGE_PER_INTERVAL
            public real array Target_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT
            private real array Target_DURATION
            private constant real Target_INTERVAL = 1.
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "chest"
            private integer array Target_WAVES_AMOUNT
        endglobals

        private struct Target_Data
            integer abilityLevel
            Unit array caster[LEVELS_AMOUNT]
            real array damagePerIntervalAmount[LEVELS_AMOUNT]
            timer array durationTimer[LEVELS_AMOUNT]
            timer intervalTimer
            Unit target
        endstruct

        private function Target_DealDamage takes nothing returns nothing
            local timer intervalTimer = GetExpiredTimer()
            local Target_Data d = GetAttachedInteger(intervalTimer, Target_SCOPE_ID)
            local integer abilityLevel = d.abilityLevel - 1
            local Unit target = d.target
            set intervalTimer = null
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( GetUnitBlood( target ), target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT ) )
            call UnitDamageUnitEx( d.caster[abilityLevel], target, d.damagePerIntervalAmount[abilityLevel], null )
        endfunction

        private function Target_Ending takes Target_Data d, timer durationTimer, Unit target returns nothing
            local integer abilityLevel = d.abilityLevel
            local timer intervalTimer
            local integer iteration = abilityLevel - 1
            local integer targetId
            loop
                exitwhen (durationTimer == d.durationTimer[iteration])
                set iteration = iteration - 1
            endloop
            set d.durationTimer[iteration] = null
            if ( abilityLevel - 1 <= iteration ) then
                loop
                    exitwhen (iteration < 0)
                    exitwhen (d.durationTimer[iteration] != null)
                    set iteration = iteration - 1
                endloop
                if ( iteration > -1 ) then
                    set d.abilityLevel = iteration + 1
                else
                    set intervalTimer = d.intervalTimer
                    set targetId = target.id
                    call d.destroy()
                    call DestroyTimerWJ(intervalTimer)
                    set intervalTimer = null
                    call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
                    //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                endif
            endif
            call FlushAttachedInteger( durationTimer, Target_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            local timer durationTimer
            local integer iteration
            if (d != NULL) then
                set iteration = 0
                loop
                    set durationTimer = d.durationTimer[iteration]
                    if ( durationTimer != null ) then
                        call Target_Ending( d, durationTimer, target )
                    endif
                    set iteration = iteration + 1
                    exitwhen ( iteration >= LEVELS_AMOUNT )
                endloop
                set durationTimer = null
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        private function Target_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Target_Data d = GetAttachedInteger(durationTimer, Target_SCOPE_ID)
            call Target_Ending( d, durationTimer, d.target )
            set durationTimer = null
        endfunction

        public function Target_Start takes integer abilityLevel, Unit caster, real damagePerIntervalAmount, Unit target returns nothing
            local timer durationTimer
            local timer intervalTimer
            local integer iteration
            local integer oldAbilityLevel
            local integer targetId = target.id
            local Target_Data d = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
            local boolean isNew = (d == NULL)
            local unit targetSelf = target.self
            if ( isNew ) then
                set d = Target_Data.create()
                set durationTimer = CreateTimerWJ()
                set intervalTimer = CreateTimerWJ()
                set iteration = LEVELS_AMOUNT - 1
                set d.abilityLevel = abilityLevel
                set d.intervalTimer = intervalTimer
                loop
                    if (iteration == abilityLevel - 1) then
                        set d.caster[iteration] = caster
                        set d.durationTimer[iteration] = durationTimer
                    else
                        set d.caster[iteration] = NULL
                        set d.durationTimer[iteration] = null
                    endif
                    set iteration = iteration - 1
                    exitwhen (iteration < 0)
                endloop
                set d.target = target
                call AttachInteger(durationTimer, Target_SCOPE_ID, d)
                call AttachInteger(intervalTimer, Target_SCOPE_ID, d)
                call AttachIntegerById(targetId, Target_SCOPE_ID, d)
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            else
                set durationTimer = d.durationTimer[abilityLevel - 1]
                set d.caster[abilityLevel - 1] = caster
                if (durationTimer == null) then
                    set durationTimer = CreateTimerWJ()
                    set d.durationTimer[abilityLevel - 1] = durationTimer
                    call AttachInteger(durationTimer, Target_SCOPE_ID, d)
                endif
                set oldAbilityLevel = d.abilityLevel
            endif
            set d.damagePerIntervalAmount[abilityLevel - 1] = damagePerIntervalAmount
            if ( isNew ) then
                call TimerStart(intervalTimer, Target_INTERVAL, true, function Target_DealDamage)
                set intervalTimer = null
            elseif (abilityLevel > oldAbilityLevel) then
                set d.abilityLevel = abilityLevel
            endif
            call DestroyEffectWJ( AddSpecialEffectWJ( GetUnitBloodExplosion( target ), GetUnitX( targetSelf ), GetUnitY( targetSelf ) ) )
            set targetSelf = null
            call TimerStart( durationTimer, Target_DURATION[abilityLevel], false, function Target_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Target_Init takes nothing returns nothing
            local integer iteration = LEVELS_AMOUNT
            set DAMAGE_PER_INTERVAL[1] = 48
            set DAMAGE_PER_INTERVAL[2] = 63
            set DAMAGE_PER_INTERVAL[3] = 80
            set DAMAGE_PER_INTERVAL[4] = 99
            set DAMAGE_PER_INTERVAL[5] = 120
            set DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[1] = 0.5
            set DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[2] = 0.5
            set DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[3] = 0.5
            set DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[4] = 0.5
            set DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[5] = 0.5
            set Target_DURATION[1] = 6
            set Target_DURATION[2] = 7
            set Target_DURATION[3] = 8
            set Target_DURATION[4] = 9
            set Target_DURATION[5] = 10
            loop
                set Target_WAVES_AMOUNT[iteration] = R2I(Target_DURATION[iteration] / Target_INTERVAL)
                set DAMAGE_PER_INTERVAL[iteration] = DAMAGE_PER_INTERVAL[iteration] / Target_WAVES_AMOUNT[iteration]
                set DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[iteration] = DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[iteration] / Target_WAVES_AMOUNT[iteration]
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( Absolute( TEMP_REAL - GetUnitZ( FILTER_UNIT_SELF, GetUnitX( FILTER_UNIT_SELF ), GetUnitY( FILTER_UNIT_SELF ) ) ) > HIT_RADIUS ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitInGroup( FILTER_UNIT_SELF, TEMP_GROUP ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitInvulnerability( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function Move takes nothing returns nothing
        local real damageAmount
        local real damagePerIntervalAmount
        local Unit enumUnit
        local unit enumUnitSelf
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, KittyJump_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY )
        local real lengthZ = d.lengthZ + LENGTH_Z_ADD[abilityLevel]
        local real newX = casterX + d.lengthX
        local real newY = casterY + d.lengthY
        local real floorZ = GetFloorHeight( newX, newY )
        local real newZ = casterZ + lengthZ
        local group targetGroup = d.targetGroup
        set updateTimer = null
        set d.lengthZ = lengthZ
        if ( casterZ < floorZ ) then
            set newX = casterX
            set newY = casterY
            set floorZ = GetFloorHeight( newX, newY )
        else
            call SetUnitX( casterSelf, newX )
            call SetUnitY( casterSelf, newY )
        endif
        call SetUnitFlyHeight(casterSelf, newZ - floorZ, 0)
        set casterSelf = null
        if ( Absolute( newZ - floorZ ) <= HIT_HEIGHT ) then
            call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, newX, newY ) )
        endif
        set TEMP_GROUP = targetGroup
        set TEMP_PLAYER = caster.owner
        set TEMP_REAL = casterZ
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, newX, newY, HIT_RADIUS, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            set damageAmount = d.damageAmount
            set damagePerIntervalAmount = d.damagePerIntervalAmount
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call GroupAddUnit( targetGroup, enumUnitSelf )
                call Target_Target_Start(abilityLevel, caster, damagePerIntervalAmount, enumUnit)
                call UnitDamageUnitBySpell( caster, enumUnit, damageAmount )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
            call PlaySoundFromTypeAtPosition( KITTY_JUMP_SLICE_SOUND_TYPE, newX, newY, newZ )
        endif
        set targetGroup = null
        call CheckMoveEvents( caster, newX, newY, newZ )
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local real angle
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local real distance = DistanceByCoordinates( casterX, casterY, targetX, targetY )
        local real lengthXY = distance / DURATION[abilityLevel] * UPDATE_TIME
        local timer updateTimer = CreateTimerWJ()
        if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
        else
            set angle = GetUnitFacingWJ( casterSelf )
        endif
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.damageAmount = DAMAGE[abilityLevel] + GetHeroStrengthTotal(caster) * DAMAGE_PER_STRENGTH_POINT[abilityLevel]
        set d.damagePerIntervalAmount = Target_Target_DAMAGE_PER_INTERVAL[abilityLevel] + GetHeroAgilityTotal(caster) * Target_Target_DAMAGE_PER_INTERVAL_PER_AGILITY_POINT[abilityLevel]
        set d.lengthX = lengthXY * Cos(angle)
        set d.lengthY = lengthXY * Sin(angle)
        set d.lengthZ = LENGTH_Z_START[abilityLevel]
        set d.targetGroup = CreateGroupWJ()
        set d.updateTimer = updateTimer
        call AttachIntegerById(casterId, KittyJump_SCOPE_ID, d)
        //! runtextmacro AddEventById( "casterId", "EVENT_ORDER2" )
        call AttachInteger(updateTimer, KittyJump_SCOPE_ID, d)
        call RemoveUnitPathing( caster )
        call AddUnitSilence( caster )
        call PlaySoundFromTypeAtPosition( KITTY_JUMP_START_SOUND_TYPE, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) )
        set casterSelf = null
        call TimerStart( updateTimer, UPDATE_TIME, true, function Move )
        set updateTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Order2 takes Unit caster returns string
        if ( GetAttachedIntegerById(caster.id, KittyJump_SCOPE_ID) != NULL ) then
            return ""
        endif
        return null
    endfunction

    private function Order2_Event takes nothing returns nothing
        set ERROR_MSG = Order2( ORDERED_UNIT )
    endfunction

    public function Order takes real casterX, real casterY, real targetX, real targetY returns string
        if ( DistanceByCoordinates( casterX, casterY, targetX, targetY ) < MINIMUM_RANGE ) then
            return ErrorStrings_TARGET_TOO_CLOSE
        endif
        if ( IsTerrainPathable( targetX, targetY, PATHING_TYPE_WALKABILITY ) ) then
            return ErrorStrings_INVALID_TARGET
        endif
        if ( IsPointInPlayRegion(targetX, targetY) == false ) then
            return ErrorStrings_INVALID_TARGET
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        local unit casterSelf = ORDERED_UNIT.self
        set ERROR_MSG = Order( GetUnitX(casterSelf), GetUnitY(casterSelf), TARGET_X, TARGET_Y )
        set casterSelf = null
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set ACCELERATION_Z[1] = -8
        set ACCELERATION_Z[2] = -8
        set ACCELERATION_Z[3] = -8
        set ACCELERATION_Z[4] = -8
        set ACCELERATION_Z[5] = -8
        set DAMAGE[1] = 25
        set DAMAGE[2] = 30
        set DAMAGE[3] = 35
        set DAMAGE[4] = 40
        set DAMAGE[5] = 45
        set DAMAGE_PER_STRENGTH_POINT[1] = 0
        set DAMAGE_PER_STRENGTH_POINT[2] = 0
        set DAMAGE_PER_STRENGTH_POINT[3] = 0
        set DAMAGE_PER_STRENGTH_POINT[4] = 0
        set DAMAGE_PER_STRENGTH_POINT[5] = 0
        set DURATION[1] = 1.75
        set DURATION[2] = 1.5
        set DURATION[3] = 1.25
        set DURATION[4] = 1
        set DURATION[5] = 0.75
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_ORDER2", "UnitGetsOrder_EVENT_KEY", "0", "function Order2_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        set WAVES_AMOUNT[1] = 6
        set WAVES_AMOUNT[2] = 7
        set WAVES_AMOUNT[3] = 8
        set WAVES_AMOUNT[4] = 9
        set WAVES_AMOUNT[5] = 10
        loop
            set ACCELERATION_Z[iteration] = ACCELERATION_Z[iteration] * HEIGHT / DURATION[iteration] / DURATION[iteration]
            set LENGTH_Z_START[iteration] = -ACCELERATION_Z[iteration] / 2 * DURATION[iteration] * UPDATE_TIME
            set LENGTH_Z_ADD[iteration] = ACCELERATION_Z[iteration] * UPDATE_TIME * UPDATE_TIME
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\KittyJump.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\LastGrave.j
//TESH.scrollpos=364
//TESH.alwaysfold=0
//! runtextmacro Scope("LastGrave")
    globals
        private constant integer ORDER_ID = 852221//OrderId( "deathanddecay" )
        public constant integer SPELL_ID = 'A07A'

        private constant string AREA_EFFECT_PATH = "Objects\\Spawnmodels\\Undead\\ImpaleTargetDust\\ImpaleTargetDust.mdl"
        private real array AREA_RANGE
        private real array BONUS_CRITICAL_STRIKE_DEFENSE
        private real array BONUS_CRITICAL_STRIKE_DEFENSE_PER_AGILITY_POINT
        private integer array DEBRIS_AMOUNT
        private constant string DEBRIS_EFFECT_PATH = "Objects\\Spawnmodels\\Undead\\UndeadDissipate\\UndeadDissipate.mdl"
        private constant integer DUMMY_UNIT_ID = 'n002'
        private real array DURATION
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private constant real INTERVAL = 1.
        private constant integer LEVELS_AMOUNT = 5
        private real array RELATIVE_DAMAGE_PER_INTERVAL
        private real array RELATIVE_DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        real bonusCriticalStrikeDefense
        unit dummyUnit
        timer durationTimer
        timer intervalTimer
        real relativeDamageAmount
        group targetGroup
        real targetX
        real targetY
        timer updateTimer
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private real array Target_DURATION
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\Banish\\BanishTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            Data d
            effect targetEffect
        endstruct

        public function Target_Ending takes real bonusCriticalStrikeDefense, Target_Data d, Unit target, group targetGroup returns nothing
            local effect targetEffect
            local integer targetId = target.id
            call GroupRemoveUnit( targetGroup, target.self )
            call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_EMPTY ) then
                set targetEffect = d.targetEffect
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                call DestroyEffectWJ( targetEffect )
            endif
            call d.destroy()
            call AddUnitCriticalStrikeDefense( target, bonusCriticalStrikeDefense )
        endfunction

        public function Target_EndingByEnding takes real bonusCriticalStrikeDefense, Data d, Unit target, group targetGroup returns nothing
            local Target_Data e
            local integer targetId = target.id
            local integer iteration = 0
            loop
                set e = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                exitwhen (e.d == d)
                set iteration = iteration + 1
            endloop
            call Target_Ending(bonusCriticalStrikeDefense, e, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Data d
            local Target_Data e
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set e = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                    set d = e.d
                    call Target_Ending( -d.bonusCriticalStrikeDefense, e, target, d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes real bonusCriticalStrikeDefense, Data d, Unit target returns nothing
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            set e.d = d
            call AddIntegerToTableById( targetId, Target_SCOPE_ID, e )
            if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_STARTED ) then
                set e.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            endif
            call AddUnitCriticalStrikeDefense( target, bonusCriticalStrikeDefense )
        endfunction

        public function Target_Init takes nothing returns nothing
            set Target_DURATION[1] = 15
            set Target_DURATION[2] = 15
            set Target_DURATION[3] = 15
            set Target_DURATION[4] = 15
            set Target_DURATION[5] = 15
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function Ending takes Unit caster, Data d returns nothing
        local integer abilityLevel = d.abilityLevel
        local real areaRange = AREA_RANGE[abilityLevel]
        local real bonusCriticalStrikeDefense = -d.bonusCriticalStrikeDefense
        local integer debrisAmount = DEBRIS_AMOUNT[abilityLevel]
        local unit dummyUnit = d.dummyUnit
        local timer durationTimer = d.durationTimer
        local real effectAngle
        local real effectAngleAdd = 2 * PI / debrisAmount
        local unit enumUnit
        local timer intervalTimer = d.intervalTimer
        local integer iteration = 1
        local real targetX = d.targetX
        local real targetY = d.targetY
        local group targetGroup = d.targetGroup
        local timer updateTimer = d.updateTimer
        call d.destroy()
        call FlushAttachedIntegerById( caster.id, LastGrave_SCOPE_ID )
        loop
            set enumUnit = FirstOfGroup( targetGroup )
            exitwhen ( enumUnit == null )
            call Target_Target_EndingByEnding( bonusCriticalStrikeDefense, d, GetUnit(enumUnit), targetGroup )
        endloop
        loop
            exitwhen ( iteration > debrisAmount )
            set effectAngle = iteration * effectAngleAdd
            call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, targetX + areaRange * Cos( effectAngle ), targetY + areaRange * Sin( effectAngle ) ) )
            set iteration = iteration + 1
        endloop
        call RemoveUnitWJ( dummyUnit )
        set dummyUnit = null
        call FlushAttachedInteger( durationTimer, LastGrave_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( intervalTimer, LastGrave_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
        call DestroyGroupWJ( targetGroup )
        set targetGroup = null
        call FlushAttachedInteger( updateTimer, LastGrave_SCOPE_ID )
        call DestroyTimerWJ( updateTimer )
        set updateTimer = null
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, LastGrave_SCOPE_ID)
        set durationTimer = null
        call StopUnit( d.caster )
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, LastGrave_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function DealDamage takes nothing returns nothing
        local real effectAngle
        local unit enumUnit
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, LastGrave_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local real areaRange = AREA_RANGE[abilityLevel]
        local Unit caster = d.caster
        local integer debrisAmount = DEBRIS_AMOUNT[abilityLevel]
        local real effectLength = GetRandomReal( areaRange / 2, areaRange )
        local integer iteration = 1
        local real relativeDamageAmount
        local real targetX = d.targetX
        local real targetY = d.targetY
        loop
            exitwhen ( iteration > debrisAmount )
            set effectAngle = GetRandomReal( 0, 2 * PI )
            call DestroyEffectWJ( AddSpecialEffectWJ( DEBRIS_EFFECT_PATH, targetX + effectLength * Cos( effectAngle ), targetY + effectLength * Sin( effectAngle ) ) )
            set iteration = iteration + 1
        endloop
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, areaRange, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set relativeDamageAmount = d.relativeDamageAmount
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), GetUnitState( enumUnit, UNIT_STATE_MAX_LIFE ) * relativeDamageAmount )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function Update takes integer abilityLevel, real areaRange, real bonusCriticalStrikeDefense, Unit caster, Data d, group targetGroup, real targetX, real targetY returns nothing
        local unit enumUnit
        local real enumUnitX
        local real enumUnitY
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, areaRange, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( -bonusCriticalStrikeDefense, d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                call Target_Target_Start(bonusCriticalStrikeDefense, d, GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, LastGrave_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        set updateTimer = null
        call Update( abilityLevel, AREA_RANGE[abilityLevel], d.bonusCriticalStrikeDefense, d.caster, d, d.targetGroup, d.targetX, d.targetY )
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real areaRange = AREA_RANGE[abilityLevel]
        local real bonusCriticalStrikeDefense = BONUS_CRITICAL_STRIKE_DEFENSE[abilityLevel] + GetHeroAgilityTotal( caster ) * BONUS_CRITICAL_STRIKE_DEFENSE_PER_AGILITY_POINT[abilityLevel]
        local Data d = Data.create()
        local unit dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, targetX, targetY, GetUnitFacingWJ( casterSelf ) )
        local real dummyUnitScale = areaRange / 150
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        local group targetGroup = CreateGroupWJ()
        local timer updateTimer = CreateTimerWJ()
        set casterSelf = null
        set d.abilityLevel = abilityLevel
        set d.bonusCriticalStrikeDefense = bonusCriticalStrikeDefense
        set d.caster = caster
        set d.dummyUnit = dummyUnit
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        set d.relativeDamageAmount = RELATIVE_DAMAGE_PER_INTERVAL[abilityLevel] + GetHeroIntelligenceTotal( caster ) * RELATIVE_DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[abilityLevel]
        set d.targetGroup = targetGroup
        set d.targetX = targetX
        set d.targetY = targetY
        set d.updateTimer = updateTimer
        call AttachIntegerById( caster.id, LastGrave_SCOPE_ID, d )
        call AttachInteger( durationTimer, LastGrave_SCOPE_ID, d )
        call AttachInteger( intervalTimer, LastGrave_SCOPE_ID, d )
        call AttachInteger( updateTimer, LastGrave_SCOPE_ID, d )
        call SetUnitAnimationByIndex( dummyUnit, 6 )
        call SetUnitScale( dummyUnit, dummyUnitScale, dummyUnitScale, dummyUnitScale )
        set dummyUnit = null
        call TimerStart( intervalTimer, INTERVAL, true, function DealDamage )
        set intervalTimer = null
        call TimerStart( updateTimer, UPDATE_TIME, true, function UpdateByTimer )
        set updateTimer = null
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function EndingByTimer )
        set durationTimer = null
        call Update( abilityLevel, areaRange, bonusCriticalStrikeDefense, caster, d, targetGroup, targetX, targetY )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set AREA_RANGE[1] = 275
        set AREA_RANGE[2] = 275
        set AREA_RANGE[3] = 275
        set AREA_RANGE[4] = 275
        set AREA_RANGE[5] = 325
        set BONUS_CRITICAL_STRIKE_DEFENSE[1] = -0.2
        set BONUS_CRITICAL_STRIKE_DEFENSE[2] = -0.3
        set BONUS_CRITICAL_STRIKE_DEFENSE[3] = -0.4
        set BONUS_CRITICAL_STRIKE_DEFENSE[4] = -0.5
        set BONUS_CRITICAL_STRIKE_DEFENSE[5] = -0.5
        set BONUS_CRITICAL_STRIKE_DEFENSE_PER_AGILITY_POINT[1] = -0.002
        set BONUS_CRITICAL_STRIKE_DEFENSE_PER_AGILITY_POINT[2] = -0.002
        set BONUS_CRITICAL_STRIKE_DEFENSE_PER_AGILITY_POINT[3] = -0.002
        set BONUS_CRITICAL_STRIKE_DEFENSE_PER_AGILITY_POINT[4] = -0.002
        set BONUS_CRITICAL_STRIKE_DEFENSE_PER_AGILITY_POINT[5] = -0.002
        set DEBRIS_AMOUNT[1] = 5
        set DEBRIS_AMOUNT[2] = 5
        set DEBRIS_AMOUNT[3] = 5
        set DEBRIS_AMOUNT[4] = 5
        set DEBRIS_AMOUNT[5] = 5
        set DURATION[1] = 15
        set DURATION[2] = 15
        set DURATION[3] = 15
        set DURATION[4] = 15
        set DURATION[5] = 15
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        set RELATIVE_DAMAGE_PER_INTERVAL[1] = 0.02
        set RELATIVE_DAMAGE_PER_INTERVAL[2] = 0.03
        set RELATIVE_DAMAGE_PER_INTERVAL[3] = 0.04
        set RELATIVE_DAMAGE_PER_INTERVAL[4] = 0.05
        set RELATIVE_DAMAGE_PER_INTERVAL[5] = 0.06
        set RELATIVE_DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[1] = 0
        set RELATIVE_DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[2] = 0
        set RELATIVE_DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[3] = 0
        set RELATIVE_DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[4] = 0
        set RELATIVE_DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[5] = 0
        loop
            set RELATIVE_DAMAGE_PER_INTERVAL[iteration] = RELATIVE_DAMAGE_PER_INTERVAL[iteration] * INTERVAL
            set RELATIVE_DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[iteration] = RELATIVE_DAMAGE_PER_INTERVAL_PER_INTELLIGENCE_POINT[iteration] * INTERVAL
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( DEBRIS_EFFECT_PATH )
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\LastGrave.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\LayEgg.j
//TESH.scrollpos=120
//TESH.alwaysfold=0
//! runtextmacro Scope("LayEgg")
    globals
        public constant integer SPELL_ID = 'A04B'

        private constant real INTERVAL = 5.
    endglobals

    private struct Data
        Unit caster
        timer intervalTimer
    endstruct

    public function Death takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, LayEgg_SCOPE_ID)
        local timer intervalTimer
        if ( d != NULL ) then
            set intervalTimer = d.intervalTimer
            call d.destroy()
            call FlushAttachedIntegerById( casterId, LayEgg_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            call FlushAttachedInteger( intervalTimer, LayEgg_SCOPE_ID )
            call DestroyTimerWJ( intervalTimer )
            set intervalTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    //! runtextmacro Scope("Egg")
        globals
            private constant real Egg_DURATION = 30.
            private constant real Egg_RELEASE_TIME = 5.
            private constant integer Egg_SPAWNS_AMOUNT = 2
            private integer array Egg_SPAWN_UNIT_IDS
        endglobals

        private struct Egg_Data
            Unit egg
            timer releaseTimer
        endstruct

        private function Egg_Ending takes Egg_Data d, Unit egg returns nothing
            local integer eggId = egg.id
            local timer releaseTimer = d.releaseTimer
            call FlushAttachedIntegerById( eggId, Egg_SCOPE_ID )
            //! runtextmacro RemoveEventById( "eggId", "Egg_EVENT_DEATH" )
            call FlushAttachedInteger( releaseTimer, Egg_SCOPE_ID )
            call DestroyTimerWJ( releaseTimer )
            set releaseTimer = null
        endfunction

        public function Egg_Death takes Unit egg returns nothing
            local Egg_Data d = GetAttachedIntegerById( egg.id, Egg_SCOPE_ID )
            if ( d != NULL ) then
                call Egg_Ending( d, egg )
            endif
        endfunction

        private function Egg_Death_Event takes nothing returns nothing
            call Egg_Death( DYING_UNIT )
        endfunction

        private function Egg_Release takes nothing returns nothing
            local integer iteration = Egg_SPAWNS_AMOUNT
            local timer releaseTimer = GetExpiredTimer()
            local Egg_Data d = GetAttachedInteger(releaseTimer, Egg_SCOPE_ID)
            local Unit egg = d.egg
            local player eggOwner = egg.owner
            local unit eggSelf = egg.self
            local real eggAngle = GetUnitFacingWJ( eggSelf )
            local real eggX = GetUnitX( eggSelf )
            local real eggY = GetUnitY( eggSelf )
            set releaseTimer = null
            call KillUnit( eggSelf )
            set eggSelf = null
            loop
                call UnitApplyTimedLifeWJ( CreateUnitEx( eggOwner, SPIDERLY_UNIT_ID, eggX, eggY, eggAngle ).self, Egg_DURATION )
                set iteration = iteration - 1
                exitwhen ( iteration < 1 )
            endloop
            set eggOwner = null
        endfunction

        public function Egg_Start takes Unit caster returns nothing
            local unit casterSelf = caster.self
            local real casterX = GetUnitX( casterSelf )
            local real casterY = GetUnitY( casterSelf )
            local Egg_Data d = Egg_Data.create()
            local Unit egg = CreateUnitEx( caster.owner, Egg_SPAWN_UNIT_IDS[GetRandomInt(0, 1)], casterX, casterY, GetRandomReal( 0, 2 * PI ) )
            local integer eggId = egg.id
            local timer releaseTimer = CreateTimerWJ()
            set casterSelf = null
            set d.egg = egg
            set d.releaseTimer = releaseTimer
            call AttachIntegerById( eggId, Egg_SCOPE_ID, d )
            //! runtextmacro AddEventById( "eggId", "Egg_EVENT_DEATH" )
            call AttachInteger( releaseTimer, Egg_SCOPE_ID, d )
            call TimerStart(releaseTimer, Egg_RELEASE_TIME, false, function Egg_Release )
            set releaseTimer = null
        endfunction

        public function Egg_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Egg_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Egg_Death_Event" )
            set Egg_SPAWN_UNIT_IDS[0] = SPIDERLY_EGG_UNIT_ID
            set Egg_SPAWN_UNIT_IDS[1] = SPIDERLY_EGG2_UNIT_ID
        endfunction
    //! runtextmacro Endscope()

    private function Interval takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, LayEgg_SCOPE_ID)
        call Egg_Egg_Start(d.caster)
        set intervalTimer = null
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = Data.create()
        local timer intervalTimer = CreateTimerWJ()
        set d.caster = caster
        set d.intervalTimer = intervalTimer
        call AttachIntegerById( casterId, LayEgg_SCOPE_ID, d )
        //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
        call AttachInteger( intervalTimer, LayEgg_SCOPE_ID, d )
        call TimerStart( intervalTimer, INTERVAL, true, function Interval )
        set intervalTimer = null
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Egg_Egg_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\LayEgg.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Libertine.j
//TESH.scrollpos=70
//TESH.alwaysfold=0
//! runtextmacro Scope("Libertine")
    globals
        public constant integer SPELL_ID = 'A06O'

        private constant real MAX_BONUS_SIGHT_RANGE = 300
        private constant real MAX_BONUS_SPEED = 80
        private constant real PRECISION_FACTOR = 100.
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        Unit caster
        real lifeFactor
        timer updateTimer
    endstruct

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Libertine_SCOPE_ID)
        local integer lifeFactor
        local timer updateTimer
        if ( d != NULL ) then
            set lifeFactor = R2I( -d.lifeFactor / PRECISION_FACTOR )
            call PauseTimer( d.updateTimer )
            call AddUnitSightRange( caster, lifeFactor * MAX_BONUS_SIGHT_RANGE )
            call AddUnitSpeed( caster, lifeFactor * MAX_BONUS_SPEED )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function Update takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, Libertine_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local integer lifeFactor = R2I( GetUnitState( casterSelf, UNIT_STATE_LIFE ) / GetUnitState( casterSelf, UNIT_STATE_MAX_LIFE ) * PRECISION_FACTOR )
        local integer lifeFactorAdd = R2I( ( lifeFactor - d.lifeFactor ) / PRECISION_FACTOR )
        local real bonusSightRange = lifeFactorAdd * MAX_BONUS_SIGHT_RANGE
        local real bonusSpeed = lifeFactorAdd * MAX_BONUS_SPEED
        set casterSelf = null
        set updateTimer = null
        set d.lifeFactor = lifeFactor
        call AddUnitSightRange( caster, bonusSightRange )
        call AddUnitSpeed( caster, bonusSpeed )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local Data d = Data.create()
        local integer lifeFactor = R2I( R2I( GetUnitState( casterSelf, UNIT_STATE_LIFE ) / GetUnitState( casterSelf, UNIT_STATE_MAX_LIFE ) * PRECISION_FACTOR ) / PRECISION_FACTOR )
        local real bonusSightRange = lifeFactor * MAX_BONUS_SIGHT_RANGE
        local real bonusSpeed = lifeFactor * MAX_BONUS_SPEED
        local timer updateTimer = CreateTimerWJ()
        set casterSelf = null
        set d.caster = caster
        set d.lifeFactor = lifeFactor
        set d.updateTimer = updateTimer
        call AttachIntegerById(casterId, Libertine_SCOPE_ID, d)
        //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro AddEventById( "casterId", "EVENT_REVIVE" )
        call AttachInteger(updateTimer, Libertine_SCOPE_ID, d)
        call AddUnitSightRange( caster, bonusSightRange )
        call AddUnitSpeed( caster, bonusSpeed )
        call TimerStart( updateTimer, UPDATE_TIME, true, function Update )
        set updateTimer = null
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Revive takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Libertine_SCOPE_ID)
        if ( d != NULL ) then
            call TimerStart(d.updateTimer, UPDATE_TIME, true, function Update)
        endif
    endfunction

    private function Revive_Event takes nothing returns nothing
        call Revive( REVIVING_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_REVIVE", "UnitFinishesReviving_EVENT_KEY", "0", "function Revive_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Libertine.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\LifeDrain.j
//TESH.scrollpos=222
//TESH.alwaysfold=0
//! runtextmacro Scope("LifeDrain")
    globals
        private constant integer ORDER_ID = 852487//OrderId( "drain" )
        public constant integer SPELL_ID = 'A00Z'

        private real array ABSORPTION_FACTOR
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Other\\Drain\\DrainCaster.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private real array DRAINED_LIFE_PER_INTERVAL
        private real array DRAINED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT
        private real array DURATION
        private constant string EFFECT_LIGHTNING_PATH = "DRAL"
        private constant real INTERVAL = 0.5
        private constant integer LEVELS_AMOUNT = 5
        private real array MAX_RANGE
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\Drain\\DrainTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real UPDATE_TIME = 0.1
        private real array WAVES_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        effect casterEffect
        timer distanceTimer
        real drainedLifePerInterval
        timer durationTimer
        lightning effectLightning
        sound effectSound
        timer intervalTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local effect casterEffect = d.casterEffect
        local timer distanceTimer = d.distanceTimer
        local timer durationTimer = d.durationTimer
        local lightning effectLightning = d.effectLightning
        local sound effectSound = d.effectSound
        local timer intervalTimer = d.intervalTimer
        local Unit target = d.target
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedIntegerById(caster.id, LifeDrain_SCOPE_ID_BASIC)
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call FlushAttachedInteger(distanceTimer, LifeDrain_SCOPE_ID)
        call DestroyTimerWJ( distanceTimer )
        set distanceTimer = null
        call FlushAttachedInteger(durationTimer, LifeDrain_SCOPE_ID)
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call DestroyLightningWJ( effectLightning )
        set effectLightning = null
        call FlushAttachedInteger(intervalTimer, LifeDrain_SCOPE_ID)
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
        call KillSound( effectSound, false )
        set effectSound = null
        call RemoveIntegerFromTableById( targetId, LifeDrain_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, LifeDrain_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
    endfunction

    public function Death takes Unit target returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, LifeDrain_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( targetId, LifeDrain_SCOPE_ID, iteration )
                call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, LifeDrain_SCOPE_ID_BASIC)
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, LifeDrain_SCOPE_ID)
        set durationTimer = null
        call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
    endfunction

    private function Drain takes nothing returns nothing
        local Unit caster
        local real drainedLife
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, LifeDrain_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit target = d.target
        local unit targetSelf = target.self
        set intervalTimer = null
        if ( IsUnitIllusionWJ( target ) ) then
            call KillUnit( targetSelf )
        else
            set caster = d.caster
            set drainedLife = d.drainedLifePerInterval
            call HealUnitBySpell( caster, Min( GetUnitState( targetSelf, UNIT_STATE_LIFE ), drainedLife ) * ABSORPTION_FACTOR[abilityLevel] )
            call UnitDamageUnitBySpell( caster, target, drainedLife )
        endif
        set targetSelf = null
    endfunction

    private function CheckDistance takes nothing returns nothing
        local real casterImpactZ
        local timer distanceTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(distanceTimer, LifeDrain_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local lightning effectLightning = d.effectLightning
        local Unit target = d.target
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        set distanceTimer = null
        if ( DistanceByCoordinates( casterX, casterY, targetX, targetY ) > MAX_RANGE[abilityLevel] ) then
            call IssueImmediateOrderById( casterSelf, STOP_ORDER_ID )
        else
            call MoveLightningEx( effectLightning, true, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster), targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target) )
        endif
        set casterSelf = null
        set effectLightning = null
        set targetSelf = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local timer distanceTimer = CreateTimerWJ()
        local timer durationTimer = CreateTimerWJ()
        local sound effectSound = CreateSoundFromType( LIFE_DRAIN_LOOP_SOUND_TYPE )
        local timer intervalTimer = CreateTimerWJ()
        local integer targetId = target.id
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
        set d.distanceTimer = distanceTimer
        set d.drainedLifePerInterval = DRAINED_LIFE_PER_INTERVAL[abilityLevel] + GetHeroStrengthTotal( caster ) * DRAINED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT[abilityLevel]
        set d.durationTimer = durationTimer
        set d.effectLightning = AddLightningWJ( EFFECT_LIGHTNING_PATH, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster), targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target) )
        set casterSelf = null
        set d.effectSound = effectSound
        set d.intervalTimer = intervalTimer
        set d.target = target
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        call AttachIntegerById( caster.id, LifeDrain_SCOPE_ID_BASIC, d )
        call AttachInteger( distanceTimer, LifeDrain_SCOPE_ID, d )
        call AttachInteger( durationTimer, LifeDrain_SCOPE_ID, d )
        call AttachInteger( intervalTimer, LifeDrain_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, LifeDrain_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, LifeDrain_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call AttachSoundToUnit( effectSound, targetSelf )
        set targetSelf = null
        call StartSound( effectSound )
        set effectSound = null
        call TimerStart( distanceTimer, UPDATE_TIME, true, function CheckDistance )
        set distanceTimer = null
        call TimerStart( intervalTimer, INTERVAL, true, function Drain )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit target returns string
        if ( GetUnitMagicImmunity( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set ABSORPTION_FACTOR[1] = 1.3
        set ABSORPTION_FACTOR[2] = 1.3
        set ABSORPTION_FACTOR[3] = 1.3
        set ABSORPTION_FACTOR[4] = 1.3
        set ABSORPTION_FACTOR[5] = 1.3
        set DRAINED_LIFE_PER_INTERVAL[1] = 210
        set DRAINED_LIFE_PER_INTERVAL[2] = 325
        set DRAINED_LIFE_PER_INTERVAL[3] = 440
        set DRAINED_LIFE_PER_INTERVAL[4] = 555
        set DRAINED_LIFE_PER_INTERVAL[5] = 670
        set DRAINED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT[1] = 4.25
        set DRAINED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT[2] = 4.25
        set DRAINED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT[3] = 4.25
        set DRAINED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT[4] = 4.25
        set DRAINED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT[5] = 4.25
        set DURATION[1] = 6
        set DURATION[2] = 6
        set DURATION[3] = 5.5
        set DURATION[4] = 5.5
        set DURATION[5] = 5
        loop
            set WAVES_AMOUNT[iteration] = R2I( DURATION[iteration] / INTERVAL )
            set DRAINED_LIFE_PER_INTERVAL[iteration] = DRAINED_LIFE_PER_INTERVAL[iteration] / WAVES_AMOUNT[iteration]
            set DRAINED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT[iteration] = DRAINED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT[iteration] / WAVES_AMOUNT[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set MAX_RANGE[1] = 1000
        set MAX_RANGE[2] = 1000
        set MAX_RANGE[3] = 1000
        set MAX_RANGE[4] = 1000
        set MAX_RANGE[5] = 1000
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\LifeDrain.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\LifeRegenerationAura.j
//TESH.scrollpos=217
//TESH.alwaysfold=0
//! runtextmacro Scope("LifeRegenerationAura")
    globals
        public constant integer SPELL_ID = 'A07S'

        private constant real AREA_RANGE = 550
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private constant real UPDATE_TIME = 0.2
        private constant real REFRESHED_LIFE = 1.25 * UPDATE_TIME
        private constant real REFRESHED_LIFE_HERO = 2. * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_LIFE = 0.005 * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_LIFE_HERO = 0.01 * UPDATE_TIME
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        Unit caster
        group targetGroup
        timer updateTimer
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            Data d
            effect targetEffect
        endstruct

        private function Target_Ending takes Target_Data d, Unit target, group targetGroup returns nothing
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_EMPTY) then
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            endif
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
            call GroupRemoveUnit( targetGroup, target.self )
        endfunction

        public function Target_EndingByEnding takes Data d, Unit target, group targetGroup returns nothing
            local Target_Data e
            local integer iteration = 0
            local integer targetId = target.id
            loop
                set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                exitwhen (e.d == d)
                set iteration = iteration + 1
            endloop
            call Target_Ending(e, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Target_Data d
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set d = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                    call Target_Ending( d, target, d.d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes Data d, Unit target returns nothing
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            set e.d = d
            set e.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
            call AddIntegerToTableById( targetId, Target_SCOPE_ID, e )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_STARTED) then
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, LifeRegenerationAura_SCOPE_ID)
        local unit enumUnit
        local group targetGroup
        local timer updateTimer
        if ( d != NULL ) then
            set casterId = caster.id
            set targetGroup = d.targetGroup
            set updateTimer = d.updateTimer
            call d.destroy()
            call FlushAttachedIntegerById(casterId, LifeRegenerationAura_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
            endloop
            call DestroyGroupWJ( targetGroup )
            set targetGroup = null
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( TRIGGER_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetPlayerId( FILTER_UNIT.owner ) > 11 ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) >= GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_MAX_LIFE ) ) then
            return false
        endif
        if ( TEMP_BOOLEAN and ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes nothing returns nothing
        local unit enumUnit
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, LifeRegenerationAura_SCOPE_ID)
        local Unit caster = d.caster
        local player casterOwner = caster.owner
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local group targetGroup = d.targetGroup
        set casterSelf = null
        set updateTimer = null
        set TEMP_BOOLEAN = ( GetPlayerId( casterOwner ) <= 11 )
        set TEMP_PLAYER = casterOwner
        set casterOwner = null
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if ( IsUnitInGroup( enumUnit, targetGroup ) == false ) then
                    call GroupAddUnit( targetGroup, enumUnit )
                    call Target_Target_Start(d, GetUnit(enumUnit))
                endif
                if ( IsUnitType( enumUnit, UNIT_TYPE_HERO ) ) then
                    call AddUnitState( enumUnit, UNIT_STATE_LIFE, REFRESHED_RELATIVE_LIFE_HERO * GetUnitState( enumUnit, UNIT_STATE_MAX_LIFE ) + REFRESHED_LIFE_HERO )
                else
                    call AddUnitState( enumUnit, UNIT_STATE_LIFE, REFRESHED_RELATIVE_LIFE * GetUnitState( enumUnit, UNIT_STATE_MAX_LIFE ) + REFRESHED_LIFE )
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set targetGroup = null
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, LifeRegenerationAura_SCOPE_ID)
        local timer updateTimer
        if ( d == NULL ) then
            set d = Data.create()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.targetGroup = CreateGroupWJ()
            set d.updateTimer = updateTimer
            call AttachIntegerById(casterId, LifeRegenerationAura_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger(updateTimer, LifeRegenerationAura_SCOPE_ID, d)
            call TimerStart( updateTimer, UPDATE_TIME, true, function Update )
            set updateTimer = null
        endif
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\LifeRegenerationAura.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\LifeRegenerationAuraNeutral.j
//TESH.scrollpos=213
//TESH.alwaysfold=0
//! runtextmacro Scope("LifeRegenerationAuraNeutral")
    globals
        public constant integer SPELL_ID = 'A02M'

        private constant real AREA_RANGE = 550
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private constant real UPDATE_TIME = 0.2
        private constant real REFRESHED_LIFE = 1.5 * UPDATE_TIME
        private constant real REFRESHED_LIFE_HERO = 1. * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_LIFE = 0.02 * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_LIFE_HERO = 0.02 * UPDATE_TIME
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        Unit caster
        group targetGroup
        timer updateTimer
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            Data d
            effect targetEffect
        endstruct

        private function Target_Ending takes Target_Data d, Unit target, group targetGroup returns nothing
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_EMPTY) then
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            endif
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
            call GroupRemoveUnit( targetGroup, target.self )
        endfunction

        public function Target_EndingByEnding takes Data d, Unit target, group targetGroup returns nothing
            local Target_Data e
            local integer iteration = 0
            local integer targetId = target.id
            loop
                set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                exitwhen (e.d == d)
                set iteration = iteration + 1
            endloop
            call Target_Ending(e, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Target_Data d
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set d = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                    call Target_Ending( d, target, d.d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes Data d, Unit target returns nothing
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            set e.d = d
            set e.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
            call AddIntegerToTableById( targetId, Target_SCOPE_ID, e )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_STARTED) then
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, LifeRegenerationAuraNeutral_SCOPE_ID)
        local unit enumUnit
        local group targetGroup
        local timer updateTimer
        if ( d != NULL ) then
            set targetGroup = d.targetGroup
            set updateTimer = d.updateTimer
            call d.destroy()
            call FlushAttachedIntegerById(casterId, LifeRegenerationAuraNeutral_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
            endloop
            call DestroyGroupWJ( targetGroup )
            set targetGroup = null
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetPlayerId( FILTER_UNIT.owner ) > 11 ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) >= GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_MAX_LIFE ) ) then
            return false
        endif
        if ( TEMP_BOOLEAN and ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes nothing returns nothing
        local unit enumUnit
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, LifeRegenerationAuraNeutral_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local player casterOwner = caster.owner
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local group targetGroup = d.targetGroup
        set casterSelf = null
        set updateTimer = null
        set TEMP_BOOLEAN = ( GetPlayerId( casterOwner ) <= 11 )
        set TEMP_PLAYER = casterOwner
        set casterOwner = null
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if ( IsUnitInGroup( enumUnit, targetGroup ) == false ) then
                    call GroupAddUnit( targetGroup, enumUnit )
                    call Target_Target_Start(d, GetUnit(enumUnit))
                endif
                if ( IsUnitType( enumUnit, UNIT_TYPE_HERO ) ) then
                    call AddUnitState( enumUnit, UNIT_STATE_LIFE, REFRESHED_RELATIVE_LIFE_HERO * GetUnitState( enumUnit, UNIT_STATE_MAX_LIFE ) + REFRESHED_LIFE_HERO )
                else
                    call AddUnitState( enumUnit, UNIT_STATE_LIFE, REFRESHED_RELATIVE_LIFE * GetUnitState( enumUnit, UNIT_STATE_MAX_LIFE ) + REFRESHED_LIFE )
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set targetGroup = null
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, LifeRegenerationAuraNeutral_SCOPE_ID)
        local timer updateTimer
        if ( d == NULL ) then
            set d = Data.create()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.targetGroup = CreateGroupWJ()
            set d.updateTimer = updateTimer
            call AttachIntegerById(casterId, LifeRegenerationAuraNeutral_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger(updateTimer, LifeRegenerationAuraNeutral_SCOPE_ID, d)
            call TimerStart( updateTimer, UPDATE_TIME, true, function Update )
            set updateTimer = null
        endif
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\LifeRegenerationAuraNeutral.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\LightningAttack.j
//TESH.scrollpos=212
//TESH.alwaysfold=0
//! runtextmacro Scope("LightningAttack")
    private struct Data
        Unit caster
        real damageAmount
        timer delayTimer
        integer jumpsAmount
        Unit target
        group targetGroup
    endstruct

    globals
        public constant integer SPELL_ID = 'A03Y'

        private constant real AREA_RANGE = 500.
        private constant real CHANCE = 0.1
        private trigger CHOOSE_TRIGGER
        private constant real DAMAGE_REDUCTION_PER_JUMP_FACTOR = 0.15
        private constant real DURATION = 1.
        private constant real EFFECT_LIGHTNING_DURATION = 0.35
        private constant string EFFECT_LIGHTNING_PATH = "CLPB"
        private constant string EFFECT_LIGHTNING2_PATH = "CLSB"
        private group ENUM_GROUP
        private constant real JUMP_DELAY = 0.2
        private constant integer MAX_TARGETS_AMOUNT = 5
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\AIlb\\AIlbSpecialArt.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"

        private Data chooseTriggerD
        private Unit chooseTriggerSource
    endglobals

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId = caster.id
        if (GetAttachedBooleanById(casterId, LightningAttack_SCOPE_ID)) then
            call FlushAttachedBooleanById(casterId, LightningAttack_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd(DYING_UNIT)
    endfunction

    private function Ending_Target takes Data d, Unit target returns nothing
        local integer targetId = target.id
        call RemoveIntegerFromTableById(targetId, LightningAttack_SCOPE_ID, d)
        if (CountIntegersInTableById(targetId, LightningAttack_SCOPE_ID) == TABLE_EMPTY) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DECAY" )
        endif
    endfunction

    private function Ending takes Unit caster, Data d, timer delayTimer, boolean isTargetNotNull, Unit target, group targetGroup returns nothing
        call d.destroy()
        call RemoveUnitRemainingReference( caster )
        call FlushAttachedInteger( delayTimer, LightningAttack_SCOPE_ID )
        call DestroyTimerWJ( delayTimer )
        if ( isTargetNotNull ) then
            call Ending_Target(d, target)
        endif
        call DestroyGroupWJ( targetGroup )
    endfunction

    private function TargetConditions_Single takes player casterOwner, Unit checkingUnit returns boolean
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitInvulnerability( checkingUnit ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( checkingUnit ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return false
        endif
        return true
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( IsUnitInGroup( FILTER_UNIT_SELF, TEMP_GROUP ) ) then
            return false
        endif
        if ( TargetConditions_Single( TEMP_PLAYER, GetUnit(FILTER_UNIT_SELF) ) == false ) then
            return false
        endif
        return true
    endfunction

    private function Impact takes nothing returns nothing
        local timer delayTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(delayTimer, LightningAttack_SCOPE_ID)
        local Unit caster = d.caster
        local real damageAmount = d.damageAmount
        local integer jumpsAmount
        local Unit target = d.target
        call Ending_Target(d, target)
        if ( target == null ) then
            call Ending( caster, d, delayTimer, false, NULL, d.targetGroup )
        else
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT ) )
            if ( TargetConditions_Single( caster.owner, target ) ) then
                set jumpsAmount = d.jumpsAmount + 1
                if ( jumpsAmount < MAX_TARGETS_AMOUNT ) then
                    set chooseTriggerD = d
                    set chooseTriggerSource = target
                    set d.jumpsAmount = jumpsAmount
                    call RunTrigger(CHOOSE_TRIGGER)
                else
                    call Ending( caster, d, delayTimer, true, target, d.targetGroup )
                endif
                call UnitDamageUnitEx( caster, target, damageAmount * GetAttackMultiplier(DMG_TYPE_NORMAL, GetUnitTypeArmorType(target.type)) * ( 1 - ( jumpsAmount - 1 ) * DAMAGE_REDUCTION_PER_JUMP_FACTOR ), null )
            else
                call Ending( caster, d, delayTimer, true, target, d.targetGroup )
            endif
        endif
        set delayTimer = null
    endfunction

    public function Decay takes Unit target returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById(targetId, LightningAttack_SCOPE_ID)
        if ( iteration > TABLE_EMPTY ) then
            loop
                set d = GetIntegerFromTableById(targetId, LightningAttack_SCOPE_ID, iteration)
                set d.target = NULL
                call Ending_Target(d, target)
                set iteration = iteration - 1
                exitwhen (iteration < TABLE_STARTED)
            endloop
        endif
    endfunction

    private function Decay_Event takes nothing returns nothing
        call Decay(TRIGGER_UNIT)
    endfunction

    public function Jump takes Data d, timer delayTimer, Unit source, Unit target, group targetGroup, string whichLightningTypeId returns nothing
        local integer targetId = target.id
        call DestroyLightningTimed( AddLightningBetweenUnits( whichLightningTypeId, source, target ), EFFECT_LIGHTNING_DURATION )
        set d.target = target
        call AddIntegerToTableById(targetId, LightningAttack_SCOPE_ID, d)
        if (CountIntegersInTableById(targetId, LightningAttack_SCOPE_ID) == TABLE_STARTED) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DECAY" )
        endif
        call GroupAddUnit( targetGroup, target.self )
        call TimerStart( delayTimer, JUMP_DELAY, false, function Impact )
    endfunction

    private function ChooseTrig takes nothing returns nothing
        local Data d = chooseTriggerD
        local Unit caster = d.caster
        local unit enumUnit
        local Unit source = chooseTriggerSource
        local unit sourceSelf = source.self
        local real sourceX = GetUnitX( sourceSelf )
        local real sourceY = GetUnitY( sourceSelf )
        local group targetGroup = d.targetGroup
        set sourceSelf = null
        set TEMP_GROUP = targetGroup
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, sourceX, sourceY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = GetNearestUnit( ENUM_GROUP, sourceX, sourceY )
        if ( enumUnit == null ) then
            call Ending( caster, d, d.delayTimer, false, GetUnit(enumUnit), targetGroup )
        else
            call Jump( d, d.delayTimer, source, GetUnit(enumUnit), targetGroup, EFFECT_LIGHTNING2_PATH )
            set enumUnit = null
        endif
        set targetGroup = null
    endfunction

    public function Damage takes Unit caster, Unit target returns nothing
        local Data d
        local timer delayTimer
        local group targetGroup
        if ( GetUnitAbilityLevel(caster.self, SPELL_ID) > 0 ) then
            set d = Data.create()
            set delayTimer = CreateTimerWJ()
            set targetGroup = CreateGroupWJ()
            set d.caster = caster
            set d.damageAmount = GetUnitDamage(caster)
            set d.delayTimer = delayTimer
            set d.jumpsAmount = 0
            set d.targetGroup = targetGroup
            call AddUnitRemainingReference( caster )
            call AttachInteger( delayTimer, LightningAttack_SCOPE_ID, d )
            call Jump( d, delayTimer, caster, target, targetGroup, EFFECT_LIGHTNING_PATH )
            set delayTimer = null
            set targetGroup = null
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage(DAMAGE_SOURCE, TRIGGER_UNIT)
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById(casterId, LightningAttack_SCOPE_ID, true)
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set CHOOSE_TRIGGER = CreateTriggerWJ()
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY", "UnitFinishesDecaying_EVENT_KEY", "0", "function Decay_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call AddTriggerCode(CHOOSE_TRIGGER, function ChooseTrig)
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\LightningAttack.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\LightOfPurge.j
//TESH.scrollpos=278
//TESH.alwaysfold=0
//! runtextmacro Scope("LightOfPurge")
    globals
        private constant integer ORDER_ID = 852111//OrderId( "purge" )
        public constant integer SPELL_ID = 'A009'

        private real array AREA_RANGE
        private real array DURATION
        private real array DURATION_FACTOR_PER_INTELLIGENCE_POINT
        private constant string EFFECT_LIGHTNING_PATH = "HWPB"
        private group ENUM_GROUP
        private constant integer LEVELS_AMOUNT = 5
        private integer array MAX_LEVEL
        private constant real MAX_RANGE = 1100.
        private real array REFRESHED_LIFE_PER_INTERVAL
        private real array REFRESHED_LIFE_PER_INTERVAL_PER_INTELLIGENCE_POINT
        private constant real SECONDARY_HEALING_FACTOR = 0.75
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Undead\\ReplenishHealth\\ReplenishHealthCaster.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real UPDATE_TIME = 0.1
        private integer array WAVES_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        timer durationTimer
        lightning effectLightning
        sound effectSound
        timer intervalTimer
        real refreshedLifePerInterval
        timer updateTimer
        Unit target
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local timer durationTimer = d.durationTimer
        local lightning effectLightning = d.effectLightning
        local sound effectSound = d.effectSound
        local timer intervalTimer = d.intervalTimer
        local Unit target = d.target
        local integer targetId = target.id
        local timer updateTimer = d.updateTimer
        call d.destroy()
        call FlushAttachedIntegerById( caster.id, LightOfPurge_SCOPE_ID_BASIC )
        call FlushAttachedInteger( durationTimer, LightOfPurge_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call DestroyLightningWJ( effectLightning )
        set effectLightning = null
        call KillSound( effectSound, false )
        set effectSound = null
        call FlushAttachedInteger( intervalTimer, LightOfPurge_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
        call RemoveIntegerFromTableById( targetId, LightOfPurge_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, LightOfPurge_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        call FlushAttachedInteger( updateTimer, LightOfPurge_SCOPE_ID )
        call DestroyTimerWJ( updateTimer )
        set updateTimer = null
    endfunction

    public function Death takes Unit target returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, LightOfPurge_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( targetId, LightOfPurge_SCOPE_ID, iteration )
                call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, LightOfPurge_SCOPE_ID_BASIC)
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, LightOfPurge_SCOPE_ID)
        local Unit caster = d.caster
        local player casterOwner = caster.owner
        local Unit target = d.target
        local unit targetSelf = target.self
        set durationTimer = null
        call IssueImmediateOrderById( caster.self, STOP_ORDER_ID )
        call DispelUnit( target, true, true, true )
        if ( ( IsUnitAlly( targetSelf, casterOwner ) == false ) and ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) == false ) and ( MAX_LEVEL[d.abilityLevel] >= GetUnitSupplyUsed( target ) ) ) then
            if ( IsUnitIllusionWJ( target ) ) then
                call KillUnit( targetSelf )
            else
                call SetUnitOwnerEx( target, casterOwner, true )
            endif
        endif
        set casterOwner = null
        set targetSelf = null
    endfunction

    private function CheckDistance takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, LightOfPurge_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Unit target = d.target
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        set updateTimer = null
        if ( DistanceByCoordinates( casterX, casterY, targetX, targetY ) > MAX_RANGE ) then
            call IssueImmediateOrderById( casterSelf, STOP_ORDER_ID )
        else
            call MoveLightningEx( d.effectLightning, true, casterX, casterY, GetUnitZ(casterSelf, casterX, casterY) + GetUnitImpactZ(caster), targetX, targetY, GetUnitZ(targetSelf, targetX, targetY) + GetUnitImpactZ(target) )
        endif
        set casterSelf = null
        set targetSelf = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Healing takes nothing returns nothing
        local unit enumUnit
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, LightOfPurge_SCOPE_ID)
        local real refreshedLife = d.refreshedLifePerInterval
        local Unit target = d.target
        local unit targetSelf = target.self
        set intervalTimer = null
        call HealUnitBySpell( target, refreshedLife )
        call DestroyEffectTimed( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT ), 2 )
        set TEMP_PLAYER = d.caster.owner
        call GroupEnumUnitsInRangeWithCollision(ENUM_GROUP, GetUnitX(targetSelf), GetUnitY(targetSelf), AREA_RANGE[d.abilityLevel], TARGET_CONDITIONS)
        set targetSelf = null
        set enumUnit = FirstOfGroup(ENUM_GROUP)
        if (enumUnit != null) then
            set refreshedLife = refreshedLife * SECONDARY_HEALING_FACTOR
            loop
                call GroupRemoveUnit(ENUM_GROUP, enumUnit)
                call HealUnitBySpell( GetUnit(enumUnit), refreshedLife )
                set enumUnit = FirstOfGroup(ENUM_GROUP)
                exitwhen (enumUnit == null)
            endloop
        endif
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local real casterIntelligence = GetHeroIntelligenceTotal(caster)
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local real duration = Max( 1, DURATION[abilityLevel] * Pow( DURATION_FACTOR_PER_INTELLIGENCE_POINT[abilityLevel], casterIntelligence ) )
        local timer durationTimer = CreateTimerWJ()
        local sound effectSound = CreateSoundFromType( LIGHT_OF_PURGE_LOOP_SOUND_TYPE )
        local timer intervalTimer = CreateTimerWJ()
        local integer targetId = target.id
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        local timer updateTimer = CreateTimerWJ()
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.durationTimer = durationTimer
        set d.effectLightning = AddLightningWJ( EFFECT_LIGHTNING_PATH, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitImpactZ(caster), targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target) )
        set casterSelf = null
        set d.effectSound = effectSound
        set d.intervalTimer = intervalTimer
        set d.refreshedLifePerInterval = REFRESHED_LIFE_PER_INTERVAL[abilityLevel] + casterIntelligence * REFRESHED_LIFE_PER_INTERVAL_PER_INTELLIGENCE_POINT[abilityLevel]
        set d.target = target
        set d.updateTimer = updateTimer
        call AttachIntegerById( caster.id, LightOfPurge_SCOPE_ID_BASIC, d )
        call AttachInteger( durationTimer, LightOfPurge_SCOPE_ID, d )
        call AttachInteger( intervalTimer, LightOfPurge_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, LightOfPurge_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, LightOfPurge_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call AttachInteger( updateTimer, LightOfPurge_SCOPE_ID, d )
        call AttachSoundToUnit( effectSound, targetSelf )
        set targetSelf = null
        call StartSound( effectSound )
        set effectSound = null
        call TimerStart( intervalTimer, ( duration - 0.01 ) / WAVES_AMOUNT[abilityLevel], true, function Healing )
        set intervalTimer = null
        call TimerStart( durationTimer, duration, false, function EndingByTimer )
        set durationTimer = null
        call TimerStart( updateTimer, UPDATE_TIME, true, function CheckDistance )
        set updateTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit caster, player casterOwner, Unit target returns string
        local UnitType targetType
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) == false ) then
            if ( GetUnitSupplyUsed( target ) > MAX_LEVEL[GetUnitAbilityLevel( caster.self, SPELL_ID )] ) then
                return ErrorStrings_TOO_MIGHTY
            endif
            if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_HERO ) ) then
                return ErrorStrings_TOO_MIGHTY
            endif
            set targetType = target.type
            if ( ( IsUnitTypeSpawn(targetType) == false ) and ( targetType.id != RESERVE_UNIT_ID ) ) then
                return ErrorStrings_ONLY_SPAWNS_OR_RESERVE
            endif
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_ONLY_ORGANIC
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT, ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set AREA_RANGE[1] = 150
        set AREA_RANGE[2] = 150
        set AREA_RANGE[3] = 150
        set AREA_RANGE[4] = 150
        set AREA_RANGE[5] = 150
        set DURATION[1] = 5
        set DURATION[2] = 5
        set DURATION[3] = 5
        set DURATION[4] = 5
        set DURATION[5] = 5
        set DURATION_FACTOR_PER_INTELLIGENCE_POINT[1] = 0.99
        set DURATION_FACTOR_PER_INTELLIGENCE_POINT[2] = 0.99
        set DURATION_FACTOR_PER_INTELLIGENCE_POINT[3] = 0.99
        set DURATION_FACTOR_PER_INTELLIGENCE_POINT[4] = 0.99
        set DURATION_FACTOR_PER_INTELLIGENCE_POINT[5] = 0.99
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set MAX_LEVEL[1] = 2
        set MAX_LEVEL[2] = 3
        set MAX_LEVEL[3] = 4
        set MAX_LEVEL[4] = 5
        set MAX_LEVEL[5] = 6
        set REFRESHED_LIFE_PER_INTERVAL[1] = 240
        set REFRESHED_LIFE_PER_INTERVAL[2] = 360
        set REFRESHED_LIFE_PER_INTERVAL[3] = 450
        set REFRESHED_LIFE_PER_INTERVAL[4] = 520
        set REFRESHED_LIFE_PER_INTERVAL[5] = 580
        set REFRESHED_LIFE_PER_INTERVAL_PER_INTELLIGENCE_POINT[1] = 0
        set REFRESHED_LIFE_PER_INTERVAL_PER_INTELLIGENCE_POINT[2] = 0
        set REFRESHED_LIFE_PER_INTERVAL_PER_INTELLIGENCE_POINT[3] = 0
        set REFRESHED_LIFE_PER_INTERVAL_PER_INTELLIGENCE_POINT[4] = 0
        set REFRESHED_LIFE_PER_INTERVAL_PER_INTELLIGENCE_POINT[5] = 0
        set TARGET_CONDITIONS = ConditionWJ(function TargetConditions)
        set WAVES_AMOUNT[1] = 10
        set WAVES_AMOUNT[2] = 10
        set WAVES_AMOUNT[3] = 10
        set WAVES_AMOUNT[4] = 10
        set WAVES_AMOUNT[5] = 10
        loop
            set REFRESHED_LIFE_PER_INTERVAL[iteration] = REFRESHED_LIFE_PER_INTERVAL[iteration] / WAVES_AMOUNT[iteration]
            set REFRESHED_LIFE_PER_INTERVAL_PER_INTELLIGENCE_POINT[iteration] = REFRESHED_LIFE_PER_INTERVAL_PER_INTELLIGENCE_POINT[iteration] / WAVES_AMOUNT[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\LightOfPurge.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\LinearBoomerang.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("LinearBoomerang")
    globals
        public constant integer SPELL_ID = 'A08K'

        private constant real AREA_RANGE = 90.
        private constant integer DUMMY_UNIT_ID = 'n034'
        private group ENUM_GROUP
        private constant real MAX_LENGTH = 700.
        private constant real DURATION = 1.5
        private constant real SPEED = 2 * MAX_LENGTH / DURATION
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
        private constant real SPEED_ADD = -SPEED / DURATION * UPDATE_TIME
        private constant real LENGTH_ADD = SPEED_ADD * UPDATE_TIME
    endglobals

    private struct Data
        Unit caster
        real damageAmount
        unit dummyUnit
        timer durationTimer
        real lengthX
        real lengthXAdd
        real lengthY
        real lengthYAdd
        group targetGroup
        timer updateTimer
        real x
        real y
    endstruct

    //! runtextmacro Scope("DrawBack")
        globals
            private constant real DrawBack_SPEED = 600.
            private constant real DrawBack_UPDATE_TIME = 0.035
            private constant real DrawBack_LENGTH = DrawBack_SPEED * DrawBack_UPDATE_TIME
        endglobals

        private struct DrawBack_Data
            Unit caster
            real damageAmount
            unit dummyUnit
            real length
            timer moveTimer
            group targetGroup
            real targetX
            real targetY
            real targetZ
            real x
            real y
            real z
        endstruct

        private function DrawBack_Ending takes Unit caster, DrawBack_Data d, unit dummyUnit, timer moveTimer returns nothing
            local integer casterId
            call d.destroy()
            call SetUnitAnimation( dummyUnit, "death" )
            call RemoveUnitTimed( dummyUnit, 2 )
            call FlushAttachedInteger( moveTimer, DrawBack_SCOPE_ID )
            call DestroyTimerWJ( moveTimer )
            if ( caster != NULL ) then
                set casterId = caster.id
                call RemoveIntegerFromTableById( casterId, DrawBack_SCOPE_ID, d )
                if ( CountIntegersInTableById( casterId, DrawBack_SCOPE_ID ) == TABLE_EMPTY ) then
                    //! runtextmacro RemoveEventById( "casterId", "DrawBack_EVENT_DEATH" )
                endif
            endif
            call RemoveUnitAttackSilence( caster )
        endfunction

        private function Death_ResetTarget takes Unit caster, real casterX, real casterY, real casterZ, DrawBack_Data d returns nothing
            local integer casterId = caster.id
            call RemoveIntegerFromTableById( casterId, DrawBack_SCOPE_ID, d )
            set d.caster = NULL
            if ( CountIntegersInTableById( casterId, DrawBack_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "casterId", "DrawBack_EVENT_DEATH" )
            endif
            set d.targetX = casterX
            set d.targetY = casterY
            set d.targetZ = casterZ
        endfunction

        public function DrawBack_Death takes Unit caster, real casterX, real casterY, real casterZ returns nothing
            local integer casterId = caster.id
            local DrawBack_Data d
            local integer iteration = CountIntegersInTableById( casterId, DrawBack_SCOPE_ID )
            if ( iteration > TABLE_EMPTY ) then
                loop
                    set d = GetIntegerFromTableById( casterId, DrawBack_SCOPE_ID, iteration )
                    call Death_ResetTarget( caster, casterX, casterY, casterZ, d )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function DrawBack_Death_Event takes nothing returns nothing
            local unit dyingUnitSelf = DYING_UNIT.self
            local real dyingUnitX = GetUnitX(dyingUnitSelf)
            local real dyingUnitY = GetUnitY(dyingUnitSelf)
            call DrawBack_Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
            set dyingUnitSelf = null
        endfunction

        private function DrawBack_Move takes nothing returns nothing
            local real angleLengthXYZ
            local real angleXY
            local unit casterSelf
            local real damageAmount
            local real distanceX
            local real distanceY
            local real distanceZ
            local unit enumUnit
            local real lengthXY
            local timer moveTimer = GetExpiredTimer()
            local DrawBack_Data d = GetAttachedInteger(moveTimer, DrawBack_SCOPE_ID)
            local Unit caster = d.caster
            local unit dummyUnit = d.dummyUnit
            local real dummyUnitX = d.x
            local real dummyUnitY = d.y
            local real dummyUnitZ = d.z
            local real length = d.length - LENGTH_ADD
            local boolean reachesTarget
            local group targetGroup
            local real targetX
            local real targetY
            local real targetZ
            if ( caster == null ) then
                set targetX = d.targetX
                set targetY = d.targetY
                set targetZ = d.targetZ
            else
                set casterSelf = caster.self
                set targetX = GetUnitX( casterSelf )
                set targetY = GetUnitY( casterSelf )
                set targetZ = GetUnitZ( casterSelf, targetX, targetY ) + GetUnitImpactZ(caster)
                set casterSelf = null
            endif
            set reachesTarget = ( DistanceByCoordinatesWithZ( dummyUnitX, dummyUnitY, dummyUnitZ, targetX, targetY, targetZ ) <= length )
            if ( reachesTarget ) then
                set dummyUnitX = targetX
                set dummyUnitY = targetY
                set dummyUnitZ = targetZ
            else
                set distanceZ = targetZ - dummyUnitZ
                set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( dummyUnitX, dummyUnitY, targetX, targetY ) )
                set distanceX = targetX - dummyUnitX
                set distanceY = targetY - dummyUnitY
                set angleXY = Atan2( distanceY, distanceX )
                set lengthXY = length * Cos( angleLengthXYZ )
                set dummyUnitX = dummyUnitX + lengthXY * Cos( angleXY )
                set dummyUnitY = dummyUnitY + lengthXY * Sin( angleXY )
                set dummyUnitZ = dummyUnitZ + length * Sin( angleLengthXYZ )
                call SetUnitFacingWJ( dummyUnit, angleXY )
            endif
            call SetUnitX( dummyUnit, dummyUnitX )
            call SetUnitY( dummyUnit, dummyUnitY )
            call SetUnitZ( dummyUnit, dummyUnitX, dummyUnitY, dummyUnitZ )
            call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, dummyUnitX, dummyUnitY, AREA_RANGE, TARGET_CONDITIONS )
            set enumUnit = FirstOfGroup( ENUM_GROUP )
            if ( enumUnit != null ) then
                set damageAmount = d.damageAmount
                set targetGroup = d.targetGroup
                loop
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    if (IsUnitInGroup(enumUnit, targetGroup) == false) then
                        call GroupAddUnit( targetGroup, enumUnit )
                        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnit, TARGET_EFFECT_ATTACHMENT_POINT ) )
                        call UnitDamageUnitEx( caster, GetUnit(enumUnit), damageAmount, null )
                    endif
                    set enumUnit = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
                set targetGroup = null
            endif
            if ( reachesTarget ) then
                call DrawBack_Ending( caster, d, dummyUnit, moveTimer )
            else
                set d.length = length
                set d.x = dummyUnitX
                set d.y = dummyUnitY
                set d.z = dummyUnitZ
            endif
            set moveTimer = null
        endfunction

        public function DrawBack_Start takes Unit caster, real damageAmount, unit dummyUnit, group targetGroup, real x, real y, real z returns nothing
            local integer casterId = caster.id
            local DrawBack_Data d = DrawBack_Data.create()
            local timer moveTimer = CreateTimer()
            set d.caster = caster
            set d.damageAmount = damageAmount
            set d.dummyUnit = dummyUnit
            set d.length = 0
            set d.moveTimer = moveTimer
            set d.targetGroup = targetGroup
            set d.x = x
            set d.y = y
            set d.z = z
            call AddIntegerToTableById( casterId, DrawBack_SCOPE_ID, d )
            if ( CountIntegersInTableById( casterId, DrawBack_SCOPE_ID ) == TABLE_STARTED ) then
                //! runtextmacro AddEventById( "casterId", "DrawBack_EVENT_DEATH" )
            endif
            call AttachInteger( moveTimer, DrawBack_SCOPE_ID, d )
            call SetUnitZ( dummyUnit, x, y, z )
            set dummyUnit = null
            call TimerStart( moveTimer, UPDATE_TIME, true, function DrawBack_Move )
            set moveTimer = null
        endfunction

        public function DrawBack_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "DrawBack_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function DrawBack_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, LinearBoomerang_SCOPE_ID)
        local Unit caster = d.caster
        local real damageAmount = d.damageAmount
        local unit dummyUnit = d.dummyUnit
        local group targetGroup = d.targetGroup
        local timer updateTimer = d.updateTimer
        local real x = d.x
        local real y = d.y
        call d.destroy()
        call FlushAttachedInteger( durationTimer, LinearBoomerang_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call DestroyGroupWJ( targetGroup )
        set targetGroup = null
        call FlushAttachedInteger( updateTimer, LinearBoomerang_SCOPE_ID )
        call DestroyTimerWJ( updateTimer )
        set updateTimer = null
        call DrawBack_DrawBack_Start(caster, damageAmount, dummyUnit, targetGroup, x, y, GetUnitZ(dummyUnit, x, y))
        set dummyUnit = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function Move takes nothing returns nothing
        local real damageAmount
        local unit enumUnit
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, LinearBoomerang_SCOPE_ID)
        local Unit caster = d.caster
        local unit dummyUnit = d.dummyUnit
        local real dummyUnitX = GetUnitX(dummyUnit)
        local real dummyUnitY = GetUnitY(dummyUnit)
        local real lengthX = d.lengthX + d.lengthXAdd
        local real lengthY = d.lengthY + d.lengthYAdd
        local real newX = d.x + lengthX
        local real newY = d.y + lengthY
        local group targetGroup = d.targetGroup
        set updateTimer = null
        set d.lengthX = lengthX
        set d.lengthY = lengthY
        set d.x = newX
        set d.y = newY
        call SetUnitXWJ( dummyUnit, newX )
        call SetUnitYWJ( dummyUnit, newY )
        set dummyUnit = null
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, newX, newY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set damageAmount = d.damageAmount
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if (IsUnitInGroup(enumUnit, targetGroup) == false) then
                    call GroupAddUnit( targetGroup, enumUnit )
                    call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnit, TARGET_EFFECT_ATTACHMENT_POINT ) )
                    call UnitDamageUnitEx( caster, GetUnit(enumUnit), damageAmount, null )
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set targetGroup = null
    endfunction

    public function Damage takes Unit caster, Unit target returns nothing
        local real angle
        local unit casterSelf = caster.self
        local real casterX
        local real casterY
        local Data d
        local unit dummyUnit
        local timer durationTimer
        local real partX
        local real partY
        local unit targetSelf
        local real targetX
        local real targetY
        local timer updateTimer
        if (GetUnitAbilityLevel(casterSelf, SPELL_ID) > 0) then
            set casterX = GetUnitX( casterSelf )
            set casterY = GetUnitY( casterSelf )
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set targetSelf = target.self
            set targetX = GetUnitX(targetSelf)
            set targetY = GetUnitY(targetSelf)
            set targetSelf = null
            set updateTimer = CreateTimerWJ()
            if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
                set angle = Atan2( targetY - casterY, targetX - casterX )
            else
                set angle = GetUnitFacingWJ( casterSelf )
            endif
            set dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, angle )
            set partX = Cos( angle )
            set partY = Sin( angle )
            set d.caster = caster
            set d.damageAmount = GetUnitDamageTotal(caster) * UPDATE_TIME
            set d.dummyUnit = dummyUnit
            set d.durationTimer = durationTimer
            set d.lengthX = LENGTH * partX
            set d.lengthXAdd = LENGTH_ADD * partX
            set d.lengthY = LENGTH * partY
            set d.lengthYAdd = LENGTH_ADD * partY
            set d.targetGroup = CreateGroupWJ()
            set d.updateTimer = updateTimer
            set d.x = casterX
            set d.y = casterY
            call AttachInteger( durationTimer, LinearBoomerang_SCOPE_ID, d )
            call AttachInteger( updateTimer, LinearBoomerang_SCOPE_ID, d )
            call AddUnitAttackSilence( caster )
            call SetUnitZ(dummyUnit, casterX, casterY, GetUnitZ(casterSelf, casterX, casterY) + GetUnitOutpactZ(caster))
            set dummyUnit = null
            call TimerStart( updateTimer, UPDATE_TIME, true, function Move )
            set updateTimer = null
            call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
            set durationTimer = null
        endif
        set casterSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitUnitType( DUMMY_UNIT_ID )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        call DrawBack_DrawBack_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\LinearBoomerang.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\LittleThunderstorm.j
//TESH.scrollpos=238
//TESH.alwaysfold=0
//! runtextmacro Scope("LittleThunderstorm")
    globals
        private constant integer ORDER_ID = 852587//OrderId( "forkedlightning" )
        public constant integer SPELL_ID = 'A00N'

        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Other\\Monsoon\\MonsoonRain.mdl"
        private real array AREA_RANGE
        private real array DAMAGE_PER_INTERVAL
        private real array DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT
        private real array DURATION
        private constant real INTERVAL = 1.25
        private constant integer LEVELS_AMOUNT = 5
        private integer array WAVES_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        effect areaEffect
        Unit caster
        real damagePerIntervalAmount
        timer durationTimer
        timer intervalTimer
        real targetX
        real targetY
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local effect areaEffect = d.areaEffect
        local timer durationTimer = d.durationTimer
        local timer intervalTimer = d.intervalTimer
        call d.destroy()
        call DestroyEffectWJ( areaEffect )
        set areaEffect = null
        call FlushAttachedIntegerById( caster.id, LittleThunderstorm_SCOPE_ID )
        call FlushAttachedInteger( durationTimer, LittleThunderstorm_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( intervalTimer, LittleThunderstorm_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, LittleThunderstorm_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, LittleThunderstorm_SCOPE_ID)
        set durationTimer = null
        call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
    endfunction

    //! runtextmacro Scope("Lightning")
        globals
            private real array Lightning_AREA_RANGE
            private integer array Lightning_DEBRIS_AMOUNT
            private constant real Lightning_DELAY = 0.5
            private group Lightning_ENUM_GROUP
            private constant string Lightning_SPECIAL_EFFECT_PATH = "MonsoonBoltTarget.mdl"
            private real array Lightning_STUN_DURATION
            private real array Lightning_STUN_HERO_DURATION
            private boolexpr Lightning_TARGET_CONDITIONS
        endglobals

        private struct Lightning_Data
            integer abilityLevel
            Unit caster
            real damageAmount
            real targetX
            real targetY
        endstruct

        private function Lightning_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
                return false
            endif
            set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
            if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
                return false
            endif
            if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
                return false
            endif
            return true
        endfunction

        private function Lightning_Ending takes nothing returns nothing
            local timer delayTimer = GetExpiredTimer()
            local Lightning_Data d = GetAttachedInteger(delayTimer, Lightning_SCOPE_ID)
            local integer abilityLevel = d.abilityLevel
            local Unit caster = d.caster
            local real damageAmount = d.damageAmount
            local Unit enumUnit
            local unit enumUnitSelf
            local real stunTime
            local real targetX = d.targetX
            local real targetY = d.targetY
            call FlushAttachedInteger( delayTimer, Lightning_SCOPE_ID )
            call DestroyTimerWJ( delayTimer )
            set delayTimer = null
            set TEMP_PLAYER = caster.owner
            call GroupEnumUnitsInRangeWithCollision( Lightning_ENUM_GROUP, targetX, targetY, Lightning_AREA_RANGE[abilityLevel], Lightning_TARGET_CONDITIONS )
            set enumUnitSelf = FirstOfGroup( Lightning_ENUM_GROUP )
            if (enumUnitSelf != null) then
                loop
                    set enumUnit = GetUnit(enumUnitSelf)
                    call GroupRemoveUnit( Lightning_ENUM_GROUP, enumUnitSelf )
                    if ( IsUnitType( enumUnitSelf, UNIT_TYPE_STRUCTURE ) == false ) then
                        if ( IsUnitType( enumUnitSelf, UNIT_TYPE_HERO ) ) then
                            set stunTime = Lightning_STUN_HERO_DURATION[abilityLevel]
                        else
                            set stunTime = Lightning_STUN_DURATION[abilityLevel]
                        endif
                        call SetUnitStunTimed( enumUnit, 1, stunTime )
                    endif
                    call UnitDamageUnitBySpell( caster, enumUnit, damageAmount )
                    set enumUnitSelf = FirstOfGroup( Lightning_ENUM_GROUP )
                    exitwhen ( enumUnitSelf == null )
                endloop
            endif
        endfunction

        public function Lightning_Start takes integer abilityLevel, Unit caster, real damageAmount, real targetX, real targetY returns nothing
            local real angle = GetRandomReal(0, 2 * PI)
            local real areaRange = AREA_RANGE[abilityLevel] - 50
            local Lightning_Data d = Lightning_Data.create()
            local integer debrisAmount = Lightning_DEBRIS_AMOUNT[abilityLevel]
            local real angleAdd = 2 * PI / debrisAmount
            local timer delayTimer = CreateTimerWJ()
            local integer iteration = debrisAmount
            local real length
            set d.abilityLevel = abilityLevel
            set d.caster = caster
            set d.damageAmount = damageAmount
            set d.targetX = targetX
            set d.targetY = targetY
            call AttachInteger( delayTimer, Lightning_SCOPE_ID, d )
            loop
                set length = GetRandomReal( 20, areaRange - 50 )
                call DestroyEffectWJ( AddSpecialEffectWJ( Lightning_SPECIAL_EFFECT_PATH, targetX + length * Cos( angle ), targetY + length * Sin( angle ) ) )
                set iteration = iteration - 1
                exitwhen ( iteration < 1 )
                set angle = angle + angleAdd
            endloop
            call TimerStart( delayTimer, Lightning_DELAY, false, function Lightning_Ending )
            set delayTimer = null
        endfunction

        public function Lightning_Init takes nothing returns nothing
            set Lightning_AREA_RANGE[1] = 200
            set Lightning_AREA_RANGE[2] = 250
            set Lightning_AREA_RANGE[3] = 275
            set Lightning_AREA_RANGE[4] = 290
            set Lightning_AREA_RANGE[5] = 310
            set Lightning_DEBRIS_AMOUNT[1] = 4
            set Lightning_DEBRIS_AMOUNT[2] = 4
            set Lightning_DEBRIS_AMOUNT[3] = 5
            set Lightning_DEBRIS_AMOUNT[4] = 5
            set Lightning_DEBRIS_AMOUNT[5] = 5
            set Lightning_ENUM_GROUP = CreateGroupWJ()
            set Lightning_STUN_DURATION[1] = 0.3
            set Lightning_STUN_DURATION[2] = 0.35
            set Lightning_STUN_DURATION[3] = 0.4
            set Lightning_STUN_DURATION[4] = 0.45
            set Lightning_STUN_DURATION[5] = 0.5
            set Lightning_STUN_HERO_DURATION[1] = 0.2
            set Lightning_STUN_HERO_DURATION[2] = 0.2
            set Lightning_STUN_HERO_DURATION[3] = 0.3
            set Lightning_STUN_HERO_DURATION[4] = 0.3
            set Lightning_STUN_HERO_DURATION[5] = 0.3
            set Lightning_TARGET_CONDITIONS = ConditionWJ( function Lightning_TargetConditions )
            call InitEffectType( Lightning_SPECIAL_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function Interval takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, LittleThunderstorm_SCOPE_ID)
        set intervalTimer = null
        call Lightning_Lightning_Start( d.abilityLevel, d.caster, d.damagePerIntervalAmount, d.targetX, d.targetY )
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local Data d = Data.create()
        local real damagePerIntervalAmount = DAMAGE_PER_INTERVAL[abilityLevel] + GetHeroStrength(caster) * DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[abilityLevel]
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        set d.abilityLevel = abilityLevel
        set d.areaEffect = AddSpecialEffectWJ( AREA_EFFECT_PATH, targetX, targetY )
        set d.caster = caster
        set d.damagePerIntervalAmount = damagePerIntervalAmount
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        set d.targetX = targetX
        set d.targetY = targetY
        call AttachIntegerById( caster.id, LittleThunderstorm_SCOPE_ID, d )
        call AttachInteger( intervalTimer, LittleThunderstorm_SCOPE_ID, d )
        call AttachInteger( durationTimer, LittleThunderstorm_SCOPE_ID, d )
        call TimerStart( intervalTimer, INTERVAL, true, function Interval )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function EndingByTimer )
        set durationTimer = null
        call Lightning_Lightning_Start( abilityLevel, caster, damagePerIntervalAmount, targetX, targetY )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set AREA_RANGE[1] = 200
        set AREA_RANGE[2] = 250
        set AREA_RANGE[3] = 275
        set AREA_RANGE[4] = 290
        set AREA_RANGE[5] = 310
        set DAMAGE_PER_INTERVAL[1] = 21
        set DAMAGE_PER_INTERVAL[2] = 23
        set DAMAGE_PER_INTERVAL[3] = 25
        set DAMAGE_PER_INTERVAL[4] = 27
        set DAMAGE_PER_INTERVAL[5] = 28
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[1] = 0.375
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[2] = 0.375
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[3] = 0.375
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[4] = 0.375
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[5] = 0.375
        set WAVES_AMOUNT[1] = 4
        set WAVES_AMOUNT[2] = 5
        set WAVES_AMOUNT[3] = 6
        set WAVES_AMOUNT[4] = 7
        set WAVES_AMOUNT[5] = 8
        loop
            set DURATION[iteration] = WAVES_AMOUNT[iteration] * INTERVAL + 0.5
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call InitEffectType( AREA_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Lightning_Lightning_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\LittleThunderstorm.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\MagicalLariat.j
//TESH.scrollpos=129
//TESH.alwaysfold=0
//! runtextmacro Scope("MagicalLariat")
    globals
        private constant integer ORDER_ID = 852480//OrderId( "magicleash" )
        public constant integer RESEARCH_ID = 'R016'
        public constant integer SPELL_ID = 'A08C'

        private constant real DURATION = 10.
        private constant string EFFECT_LIGHTNING_PATH = "LEAS"
        private constant real INTERVAL = 1.
        private constant real DAMAGE_PER_INTERVAL = 50 * INTERVAL / DURATION
        private constant real UPDATE_TIME = 0.1
    endglobals

    private struct Data
        Unit caster
        timer damageTimer
        timer durationTimer
        lightning effectLightning
        sound effectSound
        Unit target
        timer updateTimer
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local timer damageTimer = d.damageTimer
        local timer durationTimer = d.durationTimer
        local lightning effectLightning = d.effectLightning
        local sound effectSound = d.effectSound
        local Unit target = d.target
        local integer targetId = target.id
        local timer updateTimer = d.updateTimer
        call d.destroy()
        call FlushAttachedIntegerById( caster.id, MagicalLariat_SCOPE_ID_BASIC )
        call FlushAttachedInteger( damageTimer, MagicalLariat_SCOPE_ID )
        call DestroyTimerWJ( damageTimer )
        set damageTimer = null
        call FlushAttachedInteger( durationTimer, MagicalLariat_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call DestroyLightningWJ( effectLightning )
        set effectLightning = null
        call StopSoundWJ( effectSound, false )
        set effectSound = null
        call RemoveIntegerFromTableById( targetId, MagicalLariat_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, MagicalLariat_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        call FlushAttachedInteger( updateTimer, MagicalLariat_SCOPE_ID )
        call DestroyTimerWJ(updateTimer)
        set updateTimer = null
        call RemoveUnitStun( target, 0 )
    endfunction

    public function Death takes Unit target returns nothing
        local Unit caster
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, MagicalLariat_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( targetId, MagicalLariat_SCOPE_ID, iteration )
                call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, MagicalLariat_SCOPE_ID_BASIC )
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, MagicalLariat_SCOPE_ID)
        set durationTimer = null
        call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
    endfunction

    private function DealDamage takes nothing returns nothing
        local timer damageTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(damageTimer, MagicalLariat_SCOPE_ID)
        local Unit target = d.target
        set damageTimer = null
        if ( IsUnitIllusionWJ( target ) ) then
            call KillUnit( target.self )
        else
            call UnitDamageUnitBySpell( d.caster, target, DAMAGE_PER_INTERVAL )
        endif
    endfunction

    private function ResetLightning takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, MagicalLariat_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Unit target = d.target
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        set updateTimer = null
        call MoveLightningEx( d.effectLightning, true, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster), targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target) )
        set casterSelf = null
        set targetSelf = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local timer damageTimer = CreateTimerWJ()
        local real duration
        local timer durationTimer = CreateTimerWJ()
        local sound effectSound = CreateSoundFromType( MAGICAL_LARIAT_SOUND_TYPE )
        local integer targetId = target.id
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        local timer updateTimer = CreateTimerWJ()
        set d.caster = caster
        set d.damageTimer = damageTimer
        set d.durationTimer = durationTimer
        set d.effectLightning = AddLightningWJ( EFFECT_LIGHTNING_PATH, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster), targetX, targetY, GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target) )
        set casterSelf = null
        set d.effectSound = effectSound
        set d.target = target
        set d.updateTimer = updateTimer
        call AttachIntegerById( caster.id, MagicalLariat_SCOPE_ID_BASIC, d )
        call AttachInteger( damageTimer, MagicalLariat_SCOPE_ID, d )
        call AttachInteger( durationTimer, MagicalLariat_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, MagicalLariat_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, MagicalLariat_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call AttachInteger( updateTimer, MagicalLariat_SCOPE_ID, d )
        call AttachSoundToUnit( effectSound, targetSelf )
        set targetSelf = null
        call StartSound( effectSound )
        set effectSound = null
        call AddUnitStun( target, 0 )
        call TimerStart( damageTimer, INTERVAL, true, function DealDamage )
        set damageTimer = null
        call TimerStart( updateTimer, UPDATE_TIME, true, function ResetLightning )
        set updateTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit caster, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return ErrorStrings_NOT_HERO
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitMagicImmunity( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_MAGIC_IMMUNE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\MagicalLariat.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\MagicalSuperiority.j
//TESH.scrollpos=6
//TESH.alwaysfold=0
//! runtextmacro Scope("MagicalSuperiority")
    globals
        public constant integer SPELL_ID = 'A06N'

        private constant real BONUS_ARMOR_BY_SPELL = 0.1
        private constant real BONUS_ARMOR_BY_SPELL_PER_MANA = 0.2
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        real bonusArmorBySpell
        Unit caster
        timer updateTimer
    endstruct

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, MagicalSuperiority_SCOPE_ID )
        if ( d != NULL ) then
            call PauseTimer(d.updateTimer)
            call AddUnitArmorBySpellBonus( caster, -d.bonusArmorBySpell )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function Update takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, MagicalSuperiority_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real bonusArmorBySpell = BONUS_ARMOR_BY_SPELL + RoundTo( GetUnitState( casterSelf, UNIT_STATE_MANA ) / GetUnitState( casterSelf, UNIT_STATE_MAX_MANA ), 0.01 ) * BONUS_ARMOR_BY_SPELL_PER_MANA
        local real bonusArmorBySpellAdd = bonusArmorBySpell - d.bonusArmorBySpell
        set casterSelf = null
        set updateTimer = null
        set d.bonusArmorBySpell = bonusArmorBySpell
        call AddUnitArmorBySpellBonus( caster, bonusArmorBySpellAdd )
    endfunction

    private function Start takes Unit caster, Data d, timer updateTimer returns nothing
        local unit casterSelf = caster.self
        local real bonusArmorBySpell = BONUS_ARMOR_BY_SPELL + RoundTo( GetUnitState( casterSelf, UNIT_STATE_MANA ) / GetUnitState( casterSelf, UNIT_STATE_MAX_MANA ), 0.01 ) * BONUS_ARMOR_BY_SPELL_PER_MANA
        set casterSelf = null
        set d.bonusArmorBySpell = bonusArmorBySpell
        call AddUnitArmorBySpellBonus( caster, bonusArmorBySpell )
        call TimerStart( updateTimer, UPDATE_TIME, true, function Update )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = Data.create()
        local timer updateTimer = CreateTimerWJ()
        set d.caster = caster
        set d.updateTimer = updateTimer
        call AttachIntegerById(casterId, MagicalSuperiority_SCOPE_ID, d)
        //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro AddEventById( "casterId", "EVENT_REVIVE" )
        call AttachInteger(updateTimer, MagicalSuperiority_SCOPE_ID, d)
        call Start( caster, d, updateTimer )
        set updateTimer = null
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Revive takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, MagicalSuperiority_SCOPE_ID)
        if ( d != NULL ) then
            call Start( caster, d, d.updateTimer )
        endif
    endfunction

    private function Revive_Event takes nothing returns nothing
        call Revive( REVIVING_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_REVIVE", "UnitFinishesReviving_EVENT_KEY", "0", "function Revive_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\MagicalSuperiority.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ManaRegenerationAura.j
//TESH.scrollpos=213
//TESH.alwaysfold=0
//! runtextmacro Scope("ManaRegenerationAura")
    globals
        public constant integer SPELL_ID = 'A03U'

        private constant real AREA_RANGE = 550
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private constant real UPDATE_TIME = 0.2
        private constant real REFRESHED_MANA = 0.75 * UPDATE_TIME
        private constant real REFRESHED_MANA_HERO = 0.75 * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_MANA = 0.01 * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_MANA_HERO = 0.01 * UPDATE_TIME
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        Unit caster
        group targetGroup
        timer updateTimer
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\ANrl\\ANrlTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            Data d
            effect targetEffect
        endstruct

        private function Target_Ending takes Target_Data d, Unit target, group targetGroup returns nothing
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_EMPTY) then
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            endif
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
            call GroupRemoveUnit( targetGroup, target.self )
        endfunction

        public function Target_EndingByEnding takes Data d, Unit target, group targetGroup returns nothing
            local Target_Data e
            local integer iteration = 0
            local integer targetId = target.id
            loop
                set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                exitwhen (e.d == d)
                set iteration = iteration + 1
            endloop
            call Target_Ending(e, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Target_Data d
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set d = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                    call Target_Ending( d, target, d.d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes Data d, Unit target returns nothing
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            set e.d = d
            set e.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
            call AddIntegerToTableById( targetId, Target_SCOPE_ID, e )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_STARTED) then
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, ManaRegenerationAura_SCOPE_ID)
        local unit enumUnit
        local group targetGroup
        local timer updateTimer
        if ( d != NULL ) then
            set targetGroup = d.targetGroup
            set updateTimer = d.updateTimer
            call d.destroy()
            call FlushAttachedIntegerById(casterId, ManaRegenerationAura_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
            endloop
            call DestroyGroupWJ( targetGroup )
            set targetGroup = null
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( TRIGGER_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetPlayerId( FILTER_UNIT.owner ) > 11 ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_MANA ) >= GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_MAX_MANA ) ) then
            return false
        endif
        if ( TEMP_BOOLEAN and ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes nothing returns nothing
        local unit enumUnit
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, ManaRegenerationAura_SCOPE_ID)
        local Unit caster = d.caster
        local player casterOwner = caster.owner
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local group targetGroup = d.targetGroup
        set casterSelf = null
        set updateTimer = null
        set TEMP_BOOLEAN = ( GetPlayerId( casterOwner ) <= 11 )
        set TEMP_PLAYER = casterOwner
        set casterOwner = null
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if ( IsUnitInGroup( enumUnit, targetGroup ) == false ) then
                    call GroupAddUnit( targetGroup, enumUnit )
                    call Target_Target_Start(d, GetUnit(enumUnit))
                endif
                if ( IsUnitType( enumUnit, UNIT_TYPE_HERO ) ) then
                    call AddUnitState( enumUnit, UNIT_STATE_MANA, REFRESHED_RELATIVE_MANA_HERO * GetUnitState( enumUnit, UNIT_STATE_MAX_MANA ) + REFRESHED_MANA_HERO )
                else
                    call AddUnitState( enumUnit, UNIT_STATE_MANA, REFRESHED_RELATIVE_MANA * GetUnitState( enumUnit, UNIT_STATE_MAX_MANA ) + REFRESHED_MANA )
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set targetGroup = null
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, ManaRegenerationAura_SCOPE_ID)
        local timer updateTimer
        if ( d == NULL ) then
            set d = Data.create()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.targetGroup = CreateGroupWJ()
            set d.updateTimer = updateTimer
            call AttachIntegerById(casterId, ManaRegenerationAura_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger(updateTimer, ManaRegenerationAura_SCOPE_ID, d)
            call TimerStart( updateTimer, UPDATE_TIME, true, function Update )
            set updateTimer = null
        endif
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ManaRegenerationAura.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ManaRegenerationAuraNeutral.j
//TESH.scrollpos=213
//TESH.alwaysfold=0
//! runtextmacro Scope("ManaRegenerationAuraNeutral")
    globals
        public constant integer SPELL_ID = 'A03L'

        private constant real AREA_RANGE = 550
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private constant real UPDATE_TIME = 0.2
        private constant real REFRESHED_MANA = 0.75 * UPDATE_TIME
        private constant real REFRESHED_MANA_HERO = 0.5 * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_MANA = 0.01 * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_MANA_HERO = 0.02 * UPDATE_TIME
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        Unit caster
        group targetGroup
        timer updateTimer
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\ANrl\\ANrlTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            Data d
            effect targetEffect
        endstruct

        private function Target_Ending takes Target_Data d, Unit target, group targetGroup returns nothing
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_EMPTY) then
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            endif
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
            call GroupRemoveUnit( targetGroup, target.self )
        endfunction

        public function Target_EndingByEnding takes Data d, Unit target, group targetGroup returns nothing
            local Target_Data e
            local integer iteration = 0
            local integer targetId = target.id
            loop
                set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                exitwhen (e.d == d)
                set iteration = iteration + 1
            endloop
            call Target_Ending(e, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Target_Data d
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set d = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                    call Target_Ending( d, target, d.d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes Data d, Unit target returns nothing
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            set e.d = d
            set e.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
            call AddIntegerToTableById( targetId, Target_SCOPE_ID, e )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_STARTED) then
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, ManaRegenerationAuraNeutral_SCOPE_ID)
        local unit enumUnit
        local group targetGroup
        local timer updateTimer
        if ( d != NULL ) then
            set targetGroup = d.targetGroup
            set updateTimer = d.updateTimer
            call d.destroy()
            call FlushAttachedIntegerById(casterId, ManaRegenerationAuraNeutral_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
            endloop
            call DestroyGroupWJ( targetGroup )
            set targetGroup = null
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetPlayerId( FILTER_UNIT.owner ) > 11 ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if (GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_MANA ) >= GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_MAX_MANA )) then
            return false
        endif
        if ( TEMP_BOOLEAN and ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes nothing returns nothing
        local unit enumUnit
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, ManaRegenerationAuraNeutral_SCOPE_ID)
        local Unit caster = d.caster
        local player casterOwner = caster.owner
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local group targetGroup = d.targetGroup
        set casterSelf = null
        set updateTimer = null
        set TEMP_BOOLEAN = ( GetPlayerId( casterOwner ) <= 11 )
        set TEMP_PLAYER = casterOwner
        set casterOwner = null
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if ( IsUnitInGroup( enumUnit, targetGroup ) == false ) then
                    call GroupAddUnit( targetGroup, enumUnit )
                    call Target_Target_Start(d, GetUnit(enumUnit))
                endif
                if ( IsUnitType(enumUnit, UNIT_TYPE_HERO) ) then
                    call AddUnitState( enumUnit, UNIT_STATE_MANA, REFRESHED_RELATIVE_MANA_HERO * GetUnitState( enumUnit, UNIT_STATE_MAX_MANA ) + REFRESHED_MANA_HERO )
                else
                    call AddUnitState( enumUnit, UNIT_STATE_MANA, REFRESHED_RELATIVE_MANA * GetUnitState( enumUnit, UNIT_STATE_MAX_MANA ) + REFRESHED_MANA )
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set targetGroup = null
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, ManaRegenerationAuraNeutral_SCOPE_ID)
        local timer updateTimer
        if ( d == NULL ) then
            set d = Data.create()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.targetGroup = CreateGroupWJ()
            set d.updateTimer = updateTimer
            call AttachIntegerById(casterId, ManaRegenerationAuraNeutral_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger(updateTimer, ManaRegenerationAuraNeutral_SCOPE_ID, d)
            call TimerStart( updateTimer, UPDATE_TIME, true, function Update )
            set updateTimer = null
        endif
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ManaRegenerationAuraNeutral.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ManaTheft.j
//TESH.scrollpos=76
//TESH.alwaysfold=0
//! runtextmacro Scope("ManaTheft")
    globals
        private constant integer ORDER_ID = OrderId( "steal" )
        public constant integer SPELL_ID = 'A013'

        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Other\\Drain\\ManaDrainCaster.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "chest"
        private real array DURATION
        private real array STOLEN_MANA_FACTOR
        private real array STOLEN_MANA_FACTOR_PER_INTELLIGENCE_POINT
        private real array STOLEN_MANA_LOWER_CAP
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\Drain\\ManaDrainTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
    endglobals

    private struct Data
        Unit caster
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById(casterId, ManaTheft_SCOPE_ID)
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        call FlushAttachedInteger(durationTimer, ManaTheft_SCOPE_ID)
        call DestroyTimerWJ( durationTimer )
        call RemoveUnitInvulnerabilityWithEffect( caster )
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, ManaTheft_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, ManaTheft_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local boolean isTargetIllusion = IsUnitIllusionWJ( target )
        local real notStolenMana
        local real stolenMana
        local real stolenManaFactor
        local real stolenManaLowerCap
        local real targetManaFactorized
        local unit targetSelf = target.self
        local real targetMana = GetUnitState( targetSelf, UNIT_STATE_MANA )
        if ( isTargetIllusion ) then
            set stolenMana = 0
        else
            set stolenManaFactor = STOLEN_MANA_FACTOR[abilityLevel] + GetHeroIntelligenceTotal( caster ) * STOLEN_MANA_FACTOR_PER_INTELLIGENCE_POINT[abilityLevel]
            set stolenManaLowerCap = STOLEN_MANA_LOWER_CAP[abilityLevel]
            set targetManaFactorized = targetMana * stolenManaFactor
            if ( targetManaFactorized > stolenManaLowerCap ) then
                set stolenMana = targetManaFactorized
            elseif ( targetMana >= stolenManaLowerCap ) then
                set stolenMana = stolenManaLowerCap
            else
                set stolenMana = targetMana
            endif
        endif
        set notStolenMana = stolenManaLowerCap - stolenMana
        call DestroyEffectTimed( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT ), 2 )
        call DestroyEffectTimed( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT ), 2 )
        set d.caster = caster
        set d.durationTimer = d.durationTimer
        call AttachIntegerById(casterId, ManaTheft_SCOPE_ID, d)
        //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
        call AttachInteger(durationTimer, ManaTheft_SCOPE_ID, d)
        call AddUnitState( casterSelf, UNIT_STATE_MANA, stolenMana )
        set casterSelf = null
        call AddUnitInvulnerabilityWithEffect( caster )
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function EndingByTimer )
        set durationTimer = null
        if ( isTargetIllusion ) then
            call KillUnit( targetSelf )
        else
            call SetUnitState( targetSelf, UNIT_STATE_MANA, targetMana - stolenMana )
        endif
        set targetSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_MANA ) <= 0 ) then
            return ErrorStrings_NEEDS_MANA_POOL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        set DURATION[1] = 7
        set DURATION[2] = 12
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set STOLEN_MANA_FACTOR[1] = 0.5
        set STOLEN_MANA_FACTOR[2] = 0.8
        set STOLEN_MANA_FACTOR_PER_INTELLIGENCE_POINT[1] = 0.005
        set STOLEN_MANA_FACTOR_PER_INTELLIGENCE_POINT[2] = 0.005
        set STOLEN_MANA_LOWER_CAP[1] = 100
        set STOLEN_MANA_LOWER_CAP[2] = 125
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ManaTheft.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Meditation.j
//TESH.scrollpos=109
//TESH.alwaysfold=0
//! runtextmacro Scope("Meditation")
    globals
        private constant integer ORDER_ID = 852227//OrderId( "sleep" )
        public constant integer SPELL_ID = 'A06S'

        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Orc\\EtherealForm\\SpiritWalkerChange.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real DURATION = 8.
        private constant real DURATION_PER_INTELLIGENCE_POINT = -0.05
        private constant real INTERVAL = 0.25
        private constant real RELATIVE_REFRESHED_LIFE_PER_INTERVAL = 0.2 * INTERVAL
        private constant real RELATIVE_REFRESHED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT = 0.0011 * INTERVAL
        private constant real RELATIVE_REFRESHED_MANA_PER_INTERVAL = 0.2 * INTERVAL
        private constant real RELATIVE_REFRESHED_MANA_PER_INTERVAL_PER_STRENGTH_POINT = 0.0011 * INTERVAL
        public trigger WHIRLWIND_TRIGGER

        public Unit WHIRLWIND_CASTER
    endglobals

    private struct Data
        Unit caster
        timer durationTimer
        timer intervalTimer
        real refreshedRelativeLifePerInterval
        real refreshedRelativeManaPerInterval
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local timer durationTimer = d.durationTimer
        local timer intervalTimer = d.intervalTimer
        call d.destroy()
        call FlushAttachedIntegerById( casterId, Meditation_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
        call SetUnitAnimationByIndex( casterSelf, 12 )
        call QueueUnitAnimation( casterSelf, "stand" )
        call FlushAttachedInteger( durationTimer, Meditation_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( intervalTimer, Meditation_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Meditation_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Meditation_SCOPE_ID)
        local Unit caster = d.caster
        call StopUnit( caster )
        call DispelUnit( caster, true, false, true )
    endfunction

    private function Whirlwind takes nothing returns nothing
        call StopUnit( WHIRLWIND_CASTER )
    endfunction

    public function Damage takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, Meditation_SCOPE_ID )
        if ( d != NULL ) then
            call StopUnit( caster )
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( TRIGGER_UNIT )
    endfunction

    private function Heal takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, Meditation_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        set intervalTimer = null
        call DestroyEffectTimed( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT ), 1 )
        call HealUnitBySpell( caster, d.refreshedRelativeLifePerInterval * GetUnitState( casterSelf, UNIT_STATE_MAX_LIFE ) )
        call AddUnitState( casterSelf, UNIT_STATE_MANA, d.refreshedRelativeManaPerInterval * GetUnitState( casterSelf, UNIT_STATE_MAX_MANA ) )
        set casterSelf = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local real casterStrength = GetHeroStrengthTotal( caster )
        local Data d = Data.create()
        local real duration = Max( 1, DURATION + GetHeroIntelligenceTotal( caster ) * DURATION_PER_INTELLIGENCE_POINT )
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        local integer wavesAmount = R2I(duration / INTERVAL)
        call Whirlwind_Death( caster )
        set d.caster = caster
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        set d.refreshedRelativeLifePerInterval = (RELATIVE_REFRESHED_LIFE_PER_INTERVAL + casterStrength * RELATIVE_REFRESHED_LIFE_PER_INTERVAL_PER_STRENGTH_POINT) / wavesAmount
        set d.refreshedRelativeManaPerInterval = (RELATIVE_REFRESHED_MANA_PER_INTERVAL + casterStrength * RELATIVE_REFRESHED_MANA_PER_INTERVAL_PER_STRENGTH_POINT) / wavesAmount
        call AttachIntegerById( casterId, Meditation_SCOPE_ID, d )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        call AttachInteger( durationTimer, Meditation_SCOPE_ID, d )
        call AttachInteger( intervalTimer, Meditation_SCOPE_ID, d )
        call SetUnitAnimationByIndex( caster.self, 15 )
        call TimerStart( intervalTimer, INTERVAL, true, function Heal )
        set intervalTimer = null
        call TimerStart( durationTimer, duration, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY", "0", "function Damage_Event" )
        set WHIRLWIND_TRIGGER = CreateTriggerWJ()
        call AddTriggerCode(WHIRLWIND_TRIGGER, function Whirlwind)
        call InitEffectType( CASTER_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Meditation.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Metamorphosis.j
//TESH.scrollpos=193
//TESH.alwaysfold=0
//! runtextmacro Scope("Metamorphosis")
    globals
        private constant integer ORDER_ID = 852180//OrderId( "metamorphosis" )
        public constant integer SPELL_ID = 'A00Y'

        private real array AREA_RANGE
        private real array BONUS_DAMAGE
        private real array BONUS_SCALE
        private real array BONUS_SPEED
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Undead\\ThornyShield\\ThornyShieldTargetChestMountLeft.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "chest mount left"
        private constant string CASTER_EFFECT2_PATH = "Abilities\\Spells\\Undead\\ThornyShield\\ThornyShieldTargetChestMountRight.mdl"
        private constant string CASTER_EFFECT2_ATTACHMENT_POINT = "chest mount right"
        private constant string CASTER_EFFECT3_PATH = "Abilities\\Spells\\NightElf\\CorrosiveBreath\\ChimaeraAcidTargetArt.mdl"
        private constant string CASTER_EFFECT3_ATTACHMENT_POINT = "origin"
        private real array DAMAGE_PER_INTERVAL
        private real array DURATION
        private real array DURATION_PER_STRENGTH_POINT
        private group ENUM_GROUP
        private constant real INTERVAL = 1.
        private constant integer LEVELS_AMOUNT = 5
        private real array SCALE_TIME
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        effect casterEffect
        effect casterEffect2
        effect casterEffect3
        timer durationTimer
        timer intervalTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local integer abilityLevel = d.abilityLevel
        local effect casterEffect = d.casterEffect
        local effect casterEffect2 = d.casterEffect2
        local effect casterEffect3 = d.casterEffect3
        local integer casterId = caster.id
        local timer intervalTimer = d.intervalTimer
        call d.destroy()
        call FlushAttachedIntegerById( casterId, Metamorphosis_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        call DestroyEffectWJ(casterEffect)
        set casterEffect = null
        call DestroyEffectWJ(casterEffect2)
        set casterEffect2 = null
        call DestroyEffectWJ(casterEffect3)
        set casterEffect3 = null
        call FlushAttachedInteger( durationTimer, Metamorphosis_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( intervalTimer, Metamorphosis_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
        call AddUnitDamageBonus( caster, -BONUS_DAMAGE[abilityLevel] )
        call AddUnitSpeedBonus( caster, -BONUS_SPEED[abilityLevel] )
        call AddUnitScaleTimed( caster, -BONUS_SCALE[abilityLevel], SCALE_TIME[abilityLevel] )
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, Metamorphosis_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Metamorphosis_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( FILTER_UNIT ) ) then
            return false
        endif
        return true
    endfunction

    private function DealDamage takes nothing returns nothing
        local real damageAmount
        local unit enumUnit
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, Metamorphosis_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, GetUnitX(casterSelf), GetUnitY(casterSelf), AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        set casterSelf = null
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set damageAmount = DAMAGE_PER_INTERVAL[abilityLevel]
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), damageAmount )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local Data d = GetAttachedIntegerById(casterId, Metamorphosis_SCOPE_ID)
        local real duration = DURATION[abilityLevel] + GetHeroStrengthTotal( caster ) * DURATION_PER_STRENGTH_POINT[abilityLevel]
        local timer durationTimer
        local timer intervalTimer
        local boolean isNew = ( d == NULL )
        local integer oldAbilityLevel
        if ( isNew ) then
            set casterSelf = caster.self
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set intervalTimer = CreateTimerWJ()
            set d.caster = caster
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
            set d.casterEffect2 = AddSpecialEffectTargetWJ( CASTER_EFFECT2_PATH, casterSelf, CASTER_EFFECT2_ATTACHMENT_POINT )
            set d.casterEffect3 = AddSpecialEffectTargetWJ( CASTER_EFFECT3_PATH, casterSelf, CASTER_EFFECT3_ATTACHMENT_POINT )
            set casterSelf = null
            set d.durationTimer = durationTimer
            set d.intervalTimer = intervalTimer
            call AttachIntegerById( casterId, Metamorphosis_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger( durationTimer, Metamorphosis_SCOPE_ID, d )
            call AttachInteger( intervalTimer, Metamorphosis_SCOPE_ID, d )
        else
            set durationTimer = d.durationTimer
            set oldAbilityLevel = d.abilityLevel
        endif
        set d.abilityLevel = abilityLevel
        if ( isNew ) then
            call AddUnitDamageBonus( caster, BONUS_DAMAGE[abilityLevel] )
            call AddUnitScaleTimed( caster, BONUS_SCALE[abilityLevel], SCALE_TIME[abilityLevel] )
            call AddUnitSpeedBonus( caster, BONUS_SPEED[abilityLevel] )
            call TimerStart( intervalTimer, INTERVAL, true, function DealDamage )
            set intervalTimer = null
        else
            call AddUnitDamageBonus( caster, BONUS_DAMAGE[abilityLevel] - BONUS_DAMAGE[oldAbilityLevel] )
            call AddUnitScaleTimed( caster, BONUS_SCALE[abilityLevel] - BONUS_SCALE[oldAbilityLevel], SCALE_TIME[abilityLevel] - SCALE_TIME[oldAbilityLevel] )
            call AddUnitSpeedBonus( caster, BONUS_SPEED[abilityLevel] - BONUS_SPEED[oldAbilityLevel] )
        endif
        if ( duration > TimerGetRemaining( durationTimer ) ) then
            call TimerStart( durationTimer, duration, false, function EndingByTimer )
        endif
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set AREA_RANGE[1] = 200
        set AREA_RANGE[2] = 200
        set BONUS_DAMAGE[1] = 15
        set BONUS_DAMAGE[2] = 25
        set BONUS_SCALE[1] = 0.2
        set BONUS_SCALE[2] = 0.2
        set BONUS_SPEED[1] = 70
        set BONUS_SPEED[2] = 90
        set DAMAGE_PER_INTERVAL[1] = 35
        set DAMAGE_PER_INTERVAL[2] = 50
        loop
            set DAMAGE_PER_INTERVAL[iteration] = DAMAGE_PER_INTERVAL[iteration] * INTERVAL
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        set DURATION[1] = 30
        set DURATION[2] = 30
        set DURATION_PER_STRENGTH_POINT[1] = 0.1
        set DURATION_PER_STRENGTH_POINT[2] = 0.1
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set SCALE_TIME[1] = 2
        set SCALE_TIME[2] = 2.25
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitEffectType( CASTER_EFFECT2_PATH )
        call InitEffectType( CASTER_EFFECT3_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Metamorphosis.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\MightAura.j
//TESH.scrollpos=207
//TESH.alwaysfold=0
//! runtextmacro Scope("MightAura")
    globals
        public constant integer SPELL_ID = 'A03X'

        private constant real AREA_RANGE = 750
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private constant real UPDATE_TIME = 1
        private constant real BONUS_XP = 3. * UPDATE_TIME
        private constant real REFRESHED_MANA = 0.75 * UPDATE_TIME
        private constant real REFRESHED_MANA_HERO = 0.5 * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_MANA = 0.01 * UPDATE_TIME
        private constant real REFRESHED_RELATIVE_MANA_HERO = 0.03 * UPDATE_TIME
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        Unit caster
        group targetGroup
        timer updateTimer
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private constant string Target_TARGET_EFFECT_PATH = "MightAuraTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            Data d
            effect targetEffect
        endstruct

        private function Target_Ending takes Target_Data d, Unit target, group targetGroup returns nothing
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_EMPTY) then
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            endif
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
            call GroupRemoveUnit( targetGroup, target.self )
        endfunction

        public function Target_EndingByEnding takes Data d, Unit target, group targetGroup returns nothing
            local Target_Data e
            local integer iteration = 0
            local integer targetId = target.id
            loop
                set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                exitwhen (e.d == d)
                set iteration = iteration + 1
            endloop
            call Target_Ending(e, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Target_Data d
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set d = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                    call Target_Ending( d, target, d.d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes Data d, Unit target returns nothing
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            set e.d = d
            set e.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
            call AddIntegerToTableById( targetId, Target_SCOPE_ID, e )
            if (CountIntegersInTableById(targetId, Target_SCOPE_ID) == TABLE_STARTED) then
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, MightAura_SCOPE_ID)
        local unit enumUnit
        local group targetGroup
        local timer updateTimer
        if ( d != NULL ) then
            set targetGroup = d.targetGroup
            set updateTimer = d.updateTimer
            call d.destroy()
            call FlushAttachedIntegerById(casterId, MightAura_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
            endloop
            call DestroyGroupWJ( targetGroup )
            set targetGroup = null
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        local player filterUnitOwner
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ((TEMP_PLAYER != null) and (IsUnitEnemy(FILTER_UNIT_SELF, TEMP_PLAYER))) then
            set TEMP_BOOLEAN = false
        endif
        if (TEMP_PLAYER == null) then
            set filterUnitOwner = GetUnit(FILTER_UNIT_SELF).owner
            if (GetPlayerId(filterUnitOwner) <= MAX_PLAYER_INDEX) then
                set TEMP_PLAYER = filterUnitOwner
            endif
            set filterUnitOwner = null
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_HERO ) == false ) then
            return false
        endif
        return true
    endfunction

    private function Update takes nothing returns nothing
        local unit enumUnit
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, MightAura_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local boolean givesXP
        local group targetGroup = d.targetGroup
        set casterSelf = null
        set updateTimer = null
        set TEMP_BOOLEAN = true
        set TEMP_PLAYER = null
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        set givesXP = TEMP_BOOLEAN
        if ( enumUnit != null ) then
            loop
                if ( (givesXP == false) or (IsUnitInGroup( enumUnit, ENUM_GROUP ) == false) ) then
                    call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                if (givesXP) then
                    call AddUnitEP(enumUnit, BONUS_XP)
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( givesXP and (enumUnit != null) ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if ( IsUnitInGroup( enumUnit, targetGroup ) == false ) then
                    call GroupAddUnit( targetGroup, enumUnit )
                    call Target_Target_Start(d, GetUnit(enumUnit))
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set targetGroup = null
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, MightAura_SCOPE_ID)
        local timer updateTimer
        if ( d == NULL ) then
            set d = Data.create()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.targetGroup = CreateGroupWJ()
            set d.updateTimer = updateTimer
            call AttachIntegerById(casterId, MightAura_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger(updateTimer, MightAura_SCOPE_ID, d)
            call TimerStart( updateTimer, UPDATE_TIME, true, function Update )
            set updateTimer = null
        endif
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\MightAura.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\MindBreaker.j
//TESH.scrollpos=218
//TESH.alwaysfold=0
//! runtextmacro Scope("MindBreaker")
    globals
        private constant integer ORDER_ID = 852179//OrderId( "manaburn" )
        public constant integer SPELL_ID = 'A00J'

        private real array AREA_DAMAGE
        private real array AREA_DAMAGE_PER_INTELLIGENCE_POINT
        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"
        private constant string AREA_EFFECT2_PATH = "Units\\NightElf\\Wisp\\WispExplode.mdl"
        private real array AREA_RANGE
        private real array DAMAGE
        private real array DAMAGE_PER_STRENGTH_POINT
        private constant integer DUMMY_UNIT_ID = 'O009'
        private real array DESTROYED_MANA
        private real array DURATION
        private real array DURATION_PER_MANA_POINT
        private constant real EFFECT_INTERVAL = 0.75
        private constant real EFFECT_DURATION = (3 + 1) * EFFECT_INTERVAL
        private group ENUM_GROUP
        private real array HERO_DURATION
        private real array HERO_DURATION_PER_MANA_POINT
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Undead\\AbsorbMana\\AbsorbManaBirthMissile.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
        private constant string TARGET_EFFECT2_PATH = "Abilities\\Spells\\Undead\\AbsorbMana\\AbsorbManaBirthMissile.mdl"
        private constant string TARGET_EFFECT2_ATTACHMENT_POINT = "chest"
    endglobals

    private struct Data
        timer durationTimer
        timer intervalTimer
        Unit target
    endstruct

    public function Channel takes Unit caster, Unit target returns nothing
        local real angle
        local real angleAdd = PI / 1.5
        local playercolor casterColor = GetPlayerColor(caster.owner)
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit dummyUnit
        local integer iteration = 1
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        set targetSelf = null
        if ((casterX != targetX) or (casterY != targetY)) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
        else
            set angle = GetUnitFacingWJ(casterSelf)
        endif
        set casterSelf = null
        set angle = angle + PI / 3
        loop
            set angle = angle + angleAdd
            set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, targetX - 100 * Cos( angle ), targetY - 100 * Sin( angle ), angle )
            call SetUnitColor( dummyUnit, casterColor )
            call SetUnitTimeScale( dummyUnit, 1.5 )
            call SetUnitVertexColor( dummyUnit, 255, 255, 255, 127 )
            call SetUnitAnimationByIndex( dummyUnit, 2 )
            call RemoveUnitTimed( dummyUnit, 0.75 )
            set iteration = iteration + 1
            exitwhen ( iteration > 3 )
        endloop
        set casterColor = null
        set dummyUnit = null
    endfunction

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer targetId = target.id
        local timer intervalTimer = d.intervalTimer
        call d.destroy()
        call FlushAttachedInteger( durationTimer, MindBreaker_SCOPE_ID )
        call DestroyTimerWJ(durationTimer)
        call FlushAttachedInteger( intervalTimer, MindBreaker_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
        call RemoveIntegerFromTableById( targetId, MindBreaker_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, MindBreaker_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT2_PATH, target.self, TARGET_EFFECT2_ATTACHMENT_POINT ) )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, MindBreaker_SCOPE_ID)
        call Ending(d, durationTimer, d.target)
        set durationTimer = null
    endfunction

    public function Death takes Unit target returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, MindBreaker_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( targetId, MindBreaker_SCOPE_ID, iteration )
                call Ending( d, d.durationTimer, target )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function Interval takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, MindBreaker_SCOPE_ID)
        local Unit target = d.target
        local unit targetSelf = target.self
        set intervalTimer = null
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT2_PATH, targetSelf, TARGET_EFFECT2_ATTACHMENT_POINT ) )
        set targetSelf = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitInvulnerability( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
            return false
        endif
        return true
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local real areaDamageAmount
        local Data d = Data.create()
        local real duration
        local timer durationTimer = CreateTimerWJ()
        local unit enumUnit
        local timer intervalTimer = CreateTimerWJ()
        local integer targetId = target.id
        local unit targetSelf = target.self
        local real destroyedMana = Min(GetUnitState( targetSelf, UNIT_STATE_MANA ), DESTROYED_MANA[abilityLevel])
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        call Whirlwind_Death( caster )
        if ( GetUnitState( targetSelf, UNIT_STATE_MAX_MANA ) > 0 ) then
            call AddUnitState( targetSelf, UNIT_STATE_MANA, -destroyedMana )
        endif
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, targetX, targetY ) )
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT2_PATH, targetX, targetY ) )
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT2_PATH, targetSelf, TARGET_EFFECT2_ATTACHMENT_POINT ) )
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        set d.target = target
        call AttachInteger( durationTimer, MindBreaker_SCOPE_ID, d )
        call AttachInteger( intervalTimer, MindBreaker_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, MindBreaker_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, MindBreaker_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call TimerStart( intervalTimer, EFFECT_INTERVAL, true, function Interval )
        set intervalTimer = null
        call TimerStart( durationTimer, EFFECT_DURATION, true, function EndingByTimer )
        set durationTimer = null
        if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
            set duration = HERO_DURATION[abilityLevel] + destroyedMana * HERO_DURATION_PER_MANA_POINT[abilityLevel]
        else
            set duration = DURATION[abilityLevel] + destroyedMana * DURATION_PER_MANA_POINT[abilityLevel]
        endif
        if ( IsUnitIllusionWJ( target ) ) then
            call KillUnit( targetSelf )
        else
            call SetUnitStunTimed( target, 1, duration )
            call UnitDamageUnitEx( caster, target, DAMAGE[abilityLevel] + GetHeroStrengthTotal( caster ) * DAMAGE_PER_STRENGTH_POINT[abilityLevel], WEAPON_TYPE_METAL_HEAVY_BASH )
        endif
        set targetSelf = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set areaDamageAmount = AREA_DAMAGE[abilityLevel] + GetHeroIntelligenceTotal( caster ) * AREA_DAMAGE_PER_INTELLIGENCE_POINT[abilityLevel]
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), areaDamageAmount )
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes unit target returns string
        if ( IsUnitType( target, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_UNIT.self )
    endfunction

    public function Init takes nothing returns nothing
        set AREA_DAMAGE[1] = 75
        set AREA_DAMAGE[2] = 75
        set AREA_DAMAGE_PER_INTELLIGENCE_POINT[1] = 2
        set AREA_DAMAGE_PER_INTELLIGENCE_POINT[2] = 2
        set AREA_RANGE[1] = 350
        set AREA_RANGE[2] = 350
        set DAMAGE[1] = 25
        set DAMAGE[2] = 50
        set DAMAGE_PER_STRENGTH_POINT[1] = 0
        set DAMAGE_PER_STRENGTH_POINT[2] = 0
        set DESTROYED_MANA[1] = 200
        set DESTROYED_MANA[2] = 330
        set DURATION[1] = 4
        set DURATION[2] = 5
        set DURATION_PER_MANA_POINT[1] = 0.04
        set DURATION_PER_MANA_POINT[2] = 0.04
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set HERO_DURATION[1] = 2
        set HERO_DURATION[2] = 2
        set HERO_DURATION_PER_MANA_POINT[1] = 0.01
        set HERO_DURATION_PER_MANA_POINT[2] = 0.01
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT2_PATH )
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\MindBreaker.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\MysticalAttack.j
//TESH.scrollpos=32
//TESH.alwaysfold=0
//! runtextmacro Scope("MysticalAttack")
    globals
        public constant integer SPELL_ID = 'A03R'

        private constant real HERO_LIFE_FACTOR = 0.05
        private constant real HERO_MANA_FACTOR = 0.05
        private constant real LIFE_FACTOR = 0.05
        private constant real MANA_FACTOR = 0.05
    endglobals

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId
        if (GetUnitAbilityLevel(caster.self, SPELL_ID) > 0) then
            set casterId = caster.id
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( TRIGGER_UNIT )
    endfunction

    private function Damage_Conditions takes Unit target returns boolean
        set TEMP_UNIT_SELF = target.self
        if (IsUnitType(TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL)) then
            return false
        endif
        if (IsUnitType(TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE)) then
            return false
        endif
        if (GetUnitMagicImmunity(target) > 0) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, real damageAmount, Unit target returns real
        local real lifeFactor
        local real manaFactor
        local unit targetSelf
        if ( GetUnitAbilityLevel( caster.self, SPELL_ID ) > 0 ) then
            if (Damage_Conditions(target)) then
                set targetSelf = target.self
                if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
                    set lifeFactor = HERO_LIFE_FACTOR
                    set manaFactor = HERO_MANA_FACTOR
                else
                    set lifeFactor = LIFE_FACTOR
                    set manaFactor = MANA_FACTOR
                endif
                set damageAmount = damageAmount + GetUnitMaxLife( target ) * lifeFactor
                call AddUnitState( targetSelf, UNIT_STATE_MANA, -GetUnitState( targetSelf, UNIT_STATE_MAX_MANA ) * manaFactor )
                set targetSelf = null
            endif
        endif
        return damageAmount
    endfunction

    private function Damage_Event takes nothing returns nothing
        set DAMAGE_AMOUNT = Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_UNBLOCKABLE_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\MysticalAttack.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\NaturalEmbrace.j
//TESH.scrollpos=303
//TESH.alwaysfold=0
//! runtextmacro Scope("NaturalEmbrace")
    globals
        private constant integer ORDER_ID = 852147//OrderId( "entangle" )
        public constant integer SPELL_ID = 'A01P'

        private real array ABSORPTION_FACTOR
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Human\\Heal\\HealTarget.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private real array DAMAGE_PER_INTERVAL
        private constant real DUMMY_SCALE = 1.
        private constant integer DUMMY_UNIT_ID = 'h00G'
        private real array DURATION
        private real array HERO_DAMAGE_PER_INTERVAL
        private real array HERO_DURATION
        private integer array HERO_WAVES_AMOUNT
        private real array INTERVAL
        private constant integer LEVELS_AMOUNT = 5
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\NightElf\\EntanglingRoots\\EntanglingRootsTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant string TARGET_EFFECT2_PATH = "Abilities\\Spells\\Other\\Stampede\\StampedeMissileDeath.mdl"
        private constant string TARGET_EFFECT2_ATTACHMENT_POINT = "chest"
        private constant real TELEPORT_THRESHOLD = 500.
        private constant real UPDATE_TIME = 0.25
        private integer array WAVES_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        Unit array caster[LEVELS_AMOUNT]
        unit dummyUnit
        timer array durationTimer[LEVELS_AMOUNT]
        timer intervalTimer
        Unit target
        effect targetEffect
        timer updateTimer
        real x
        real y
    endstruct

    private function Interval takes nothing returns nothing
        local integer abilityLevel
        local real absorptionAmount
        local Unit caster
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, NaturalEmbrace_SCOPE_ID)
        local Unit target = d.target
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        local real x = d.x
        local real y = d.y
        local integer currentOrder = GetUnitCurrentOrder( targetSelf )
        set intervalTimer = null
        if ( ( x != targetX ) or ( y != targetY ) ) then
            set abilityLevel = d.abilityLevel
            set caster = d.caster
            if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
                set absorptionAmount = HERO_DAMAGE_PER_INTERVAL[abilityLevel]
            else
                set absorptionAmount = DAMAGE_PER_INTERVAL[abilityLevel]
            endif
            set absorptionAmount = Max(GetUnitState(targetSelf, UNIT_STATE_LIFE), absorptionAmount)
            set d.x = targetX
            set d.y = targetY
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT2_PATH, targetSelf, TARGET_EFFECT2_ATTACHMENT_POINT ) )
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, targetSelf, CASTER_EFFECT_ATTACHMENT_POINT ) )
            if ( IsUnitIllusionWJ( target ) ) then
                call KillUnit( targetSelf )
            else
                call UnitDamageUnitBySpell( caster, target, absorptionAmount )
                call HealUnitBySpell( caster, absorptionAmount * ABSORPTION_FACTOR[abilityLevel] )
            endif
        endif
        set targetSelf = null
    endfunction

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer abilityLevel = d.abilityLevel
        local unit dummyUnit
        local timer intervalTimer
        local integer iteration = abilityLevel - 1
        local effect targetEffect
        local integer targetId
        local timer updateTimer
        loop
            exitwhen (durationTimer == d.durationTimer[iteration])
            set iteration = iteration - 1
        endloop
        set d.durationTimer[iteration] = null
        if ( iteration > abilityLevel ) then
            loop
                exitwhen (iteration < 0)
                exitwhen (d.durationTimer[iteration] != null)
                set iteration = iteration - 1
            endloop
            if ( iteration > -1 ) then
                set d.abilityLevel = iteration + 1
                call TimerStart(d.intervalTimer, INTERVAL[iteration], true, function Interval)
            else
                set dummyUnit = d.dummyUnit
                set intervalTimer = d.intervalTimer
                set targetEffect = d.targetEffect
                set targetId = target.id
                set updateTimer = d.updateTimer
                call d.destroy()
                call RemoveUnitWJ(dummyUnit)
                set dummyUnit = null
                call FlushAttachedInteger(intervalTimer, NaturalEmbrace_SCOPE_ID)
                call DestroyTimerWJ(intervalTimer)
                set intervalTimer = null
                call DestroyEffectWJ( targetEffect )
                set targetEffect = null
                call FlushAttachedInteger(updateTimer, NaturalEmbrace_SCOPE_ID)
                call DestroyTimerWJ(updateTimer)
                set updateTimer = null
                call FlushAttachedIntegerById( targetId, NaturalEmbrace_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
            endif
        endif
        call FlushAttachedInteger( durationTimer, NaturalEmbrace_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
    endfunction

    public function Dispel takes Unit target returns nothing
        local integer abilityLevel
        local Data d = GetAttachedIntegerById(target.id, NaturalEmbrace_SCOPE_ID)
        local timer durationTimer
        local integer iteration
        if (d != NULL) then
            set abilityLevel = d.abilityLevel
            set iteration = 0
            loop
                set durationTimer = d.durationTimer[iteration]
                if ( durationTimer != null ) then
                    call Ending( d, durationTimer, target )
                endif
                set iteration = iteration + 1
                exitwhen ( iteration >= abilityLevel )
            endloop
            set durationTimer = null
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, NaturalEmbrace_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function Move takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, NaturalEmbrace_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local Unit target = d.target
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        local real x = d.x
        local real y = d.y
        set targetSelf = null
        set updateTimer = null
        if ( ( targetX != x ) or ( targetY != y ) ) then
            set d.x = x
            set d.y = y
            if ( DistanceByCoordinates( x, y, targetX, targetY ) > TELEPORT_THRESHOLD ) then
                call SetUnitX( dummyUnit, targetX )
                call SetUnitY( dummyUnit, targetY )
            else
                call IssuePointOrderById( dummyUnit, MOVE_ORDER_ID, targetX, targetY )
            endif
        endif
        set dummyUnit = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local integer abilityLevel = GetUnitAbilityLevel(caster.self, SPELL_ID)
        local unit dummyUnit
        local real duration
        local timer durationTimer
        local timer intervalTimer
        local integer iteration
        local integer oldAbilityLevel
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, NaturalEmbrace_SCOPE_ID)
        local boolean isNew = (d == NULL)
        local unit targetSelf = target.self
        local real targetX
        local real targetY
        local timer updateTimer
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set intervalTimer = CreateTimerWJ()
            set iteration = LEVELS_AMOUNT - 1
            set targetX = GetUnitX(targetSelf)
            set targetY = GetUnitY(targetSelf)
            set dummyUnit = CreateUnitWJ(NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, targetX, targetY, GetUnitFacingWJ(targetSelf))
            set updateTimer = CreateTimerWJ()
            set d.abilityLevel = abilityLevel
            set d.dummyUnit = dummyUnit
            set d.target = target
            set d.x = targetX
            set d.y = targetY
            loop
                if (iteration == abilityLevel) then
                    set d.caster[iteration] = caster
                    set d.durationTimer[iteration] = durationTimer
                else
                    set d.caster[iteration] = NULL
                    set d.durationTimer[iteration] = null
                endif
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call AttachInteger(durationTimer, NaturalEmbrace_SCOPE_ID, d)
            call AttachIntegerById(targetId, NaturalEmbrace_SCOPE_ID, d)
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        else
            set durationTimer = d.durationTimer[abilityLevel]
            set d.caster[abilityLevel] = caster
            if (durationTimer == null) then
                set durationTimer = CreateTimerWJ()
                set d.durationTimer[abilityLevel] = durationTimer
                call AttachInteger(durationTimer, NaturalEmbrace_SCOPE_ID, d)
            endif
            set oldAbilityLevel = d.abilityLevel
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            call SetUnitScale(dummyUnit, DUMMY_SCALE, DUMMY_SCALE, DUMMY_SCALE)
            set dummyUnit = null
            call TimerStart(intervalTimer, INTERVAL[abilityLevel], true, function Interval)
            set intervalTimer = null
            call TimerStart(updateTimer, UPDATE_TIME, true, function Move)
            set updateTimer = null
        elseif (abilityLevel >= oldAbilityLevel) then
            set d.abilityLevel = abilityLevel
            call TimerStart(d.intervalTimer, INTERVAL[abilityLevel], true, function Interval)
            call TimerStart(d.updateTimer, UPDATE_TIME, true, function Move)
        endif
        if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
            set duration = HERO_DURATION[abilityLevel]
        else
            set duration = DURATION[abilityLevel]
        endif
        set targetSelf = null
        call TimerStart( durationTimer, duration, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_ONLY_ORGANIC
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set ABSORPTION_FACTOR[1] = 1.5
        set ABSORPTION_FACTOR[2] = 1.5
        set ABSORPTION_FACTOR[3] = 1.5
        set ABSORPTION_FACTOR[4] = 1.5
        set ABSORPTION_FACTOR[5] = 1.5
        set DAMAGE_PER_INTERVAL[1] = 300
        set DAMAGE_PER_INTERVAL[2] = 375
        set DAMAGE_PER_INTERVAL[3] = 450
        set DAMAGE_PER_INTERVAL[4] = 525
        set DAMAGE_PER_INTERVAL[5] = 600
        set DURATION[1] = 12
        set DURATION[2] = 14
        set DURATION[3] = 16
        set DURATION[4] = 18
        set DURATION[5] = 20
        set HERO_DAMAGE_PER_INTERVAL[1] = 150
        set HERO_DAMAGE_PER_INTERVAL[2] = 210
        set HERO_DAMAGE_PER_INTERVAL[3] = 270
        set HERO_DAMAGE_PER_INTERVAL[4] = 330
        set HERO_DAMAGE_PER_INTERVAL[5] = 390
        set HERO_DURATION[1] = 6
        set HERO_DURATION[2] = 8
        set HERO_DURATION[3] = 10
        set HERO_DURATION[4] = 12
        set HERO_DURATION[5] = 14
        set INTERVAL[1] = 0.5
        set INTERVAL[2] = 0.5
        set INTERVAL[3] = 0.5
        set INTERVAL[4] = 0.5
        set INTERVAL[5] = 0.5
        loop
            set WAVES_AMOUNT[iteration] = R2I(DURATION[iteration] / INTERVAL[iteration])
            set DAMAGE_PER_INTERVAL[iteration] = DAMAGE_PER_INTERVAL[iteration] / WAVES_AMOUNT[iteration]
            set HERO_WAVES_AMOUNT[iteration] = R2I(HERO_DURATION[iteration] / INTERVAL[iteration])
            set HERO_DAMAGE_PER_INTERVAL[iteration] = HERO_DAMAGE_PER_INTERVAL[iteration] / HERO_WAVES_AMOUNT[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_NEGATIVE", "0", "function Dispel_Event" )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT2_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\NaturalEmbrace.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Net.j
//TESH.scrollpos=76
//TESH.alwaysfold=0
//! runtextmacro Scope("Net")
    globals
        private constant integer ORDER_ID = 852106//OrderId( "ensnare" )
        public constant integer SPELL_ID = 'A03H'

        private constant integer DUMMY_UNIT_ID = 'n01M'
        private constant real MAX_DURATION = 1.
        private constant real SPEED = 600.
        private constant real STUN_DURATION = 10.
        private constant real STUN_HERO_DURATION = 3.
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
    endglobals

    private struct Data
        real angle
        Unit caster
        unit dummyUnit
        timer durationTimer
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        real x
        real y
        real z
    endstruct

    private function Ending takes Data d, unit dummyUnit, timer durationTimer, boolean isTargetNotNull, timer moveTimer, Unit target returns nothing
        local integer targetId = target.id
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 2 )
        call RemoveUnitTimed( dummyUnit, 2 )
        call FlushAttachedInteger( durationTimer, Net_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( moveTimer, Net_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        if ( isTargetNotNull ) then
            set targetId = target.id
            call RemoveIntegerFromTableById( targetId, Net_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, Net_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
            endif
        endif
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Net_SCOPE_ID)
        local Unit target = d.target
        call Ending( d, d.dummyUnit, durationTimer, (target != NULL), d.moveTimer, target )
        set durationTimer = null
    endfunction

    private function Death_ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        set d.target = NULL
        call RemoveIntegerFromTableById( targetId, Net_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, Net_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, Net_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( targetId, Net_SCOPE_ID, iteration )
                call Death_ResetTarget( d, target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function Impact takes Unit target returns nothing
        local real stunTime
        if ( IsUnitType( target.self, UNIT_TYPE_HERO ) ) then
            set stunTime = STUN_HERO_DURATION
        else
            set stunTime = STUN_DURATION
        endif
        call SetUnitStunTimed( target, 3, stunTime )
    endfunction

    private function TargetConditions takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitInvulnerability( target ) > 0 ) then
            return ErrorStrings_TARGET_IS_INVULNERABLE
        endif
        return null
    endfunction

    private function Move takes nothing returns nothing
        local real angleLengthXYZ
        local real angleXY
        local Unit caster
        local real distanceX
        local real distanceY
        local real distanceZ
        local boolean isTargetNotNull
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, Net_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local boolean reachesTarget
        local Unit target = d.target
        local unit targetSelf = target.self
        local boolean isTargetNull = ( target == NULL )
        local real targetX
        local real targetY
        local real targetZ
        local real x = d.x
        local real y = d.y
        local real z = d.z
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
            set targetSelf = null
        endif
        set reachesTarget = ( DistanceByCoordinatesWithZ( x, y, z, targetX, targetY, targetZ ) <= LENGTH )
        if ( reachesTarget ) then
            set x = targetX
            set y = targetY
            set z = targetZ
        else
            set distanceZ = targetZ - z
            set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, targetX, targetY ) )
            set distanceX = targetX - x
            set distanceY = targetY - y
            set angleXY = Atan2( distanceY, distanceX )
            set lengthXY = LENGTH * Cos( angleLengthXYZ )
            set x = x + lengthXY * Cos( angleXY )
            set y = y + lengthXY * Sin( angleXY )
            set z = z + LENGTH * Sin( angleLengthXYZ )
            call SetUnitFacingWJ( dummyUnit, angleXY )
        endif
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        if ( reachesTarget ) then
            set caster = d.caster
            set isTargetNotNull = (isTargetNull == false)
            call Ending( d, dummyUnit, d.durationTimer, isTargetNotNull, moveTimer, target )
            if ( isTargetNotNull ) then
                if ( TargetConditions( caster.owner, target ) == null ) then
                    call Impact( target )
                endif
            endif
        else
            set d.x = x
            set d.y = y
            set d.z = z
        endif
        set dummyUnit = null
        set moveTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local real angle
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local real casterZ = GetUnitZ(casterSelf, casterX, casterY)
        local Data d
        local unit dummyUnit
        local timer durationTimer
        local timer moveTimer
        local integer targetId
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        local real targetZ = GetUnitZ(targetSelf, targetX, targetY)
        set casterSelf = null
        set targetSelf = null
        if ( ( casterX != targetX ) or ( casterY != targetY ) or (casterZ != targetZ) ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set moveTimer = CreateTimerWJ()
            set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, casterX, casterY, angle )
            set targetId = target.id
            set d.angle = angle
            set d.caster = caster
            set d.dummyUnit = dummyUnit
            set d.durationTimer = durationTimer
            set d.moveTimer = moveTimer
            set d.target = target
            set d.x = casterX
            set d.y = casterY
            set d.z = casterZ
            call AttachInteger( durationTimer, Net_SCOPE_ID, d )
            call AttachInteger( moveTimer, Net_SCOPE_ID, d )
            call AddIntegerToTableById( targetId, Net_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, Net_SCOPE_ID ) == TABLE_STARTED ) then
                //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            endif
            call SetUnitAnimationByIndex( dummyUnit, 0 )
            call SetUnitZ(dummyUnit, casterX, casterY, casterZ)
            set dummyUnit = null
            call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
            set moveTimer = null
            call TimerStart( durationTimer, MAX_DURATION, false, function EndingByTimer )
            set durationTimer = null
        else
            call Impact( target )
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        return TargetConditions( casterOwner, target )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Net.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Neutralization.j
//TESH.scrollpos=20
//TESH.alwaysfold=0
//! runtextmacro Scope("Neutralization")
    globals
        public constant integer RESEARCH_ID = 'R01H'
        public constant integer SPELL_ID = 'A08A'

        private constant real CHANCE = 0.15
        private constant real BONUS_SUMMONED_DAMAGE = 15.
    endglobals

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId = caster.id
        if (GetAttachedBooleanById( casterId, Neutralization_SCOPE_ID )) then
            call FlushAttachedBooleanById( casterId, Neutralization_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( TRIGGER_UNIT )
    endfunction

    private function Damage_Conditions takes player casterOwner, Unit target returns boolean
        set TEMP_UNIT_SELF = target.self
        if (IsUnitAlly(TEMP_UNIT_SELF, casterOwner)) then
            return false
        endif
        if (IsUnitType(TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL)) then
            return false
        endif
        if (IsUnitType(TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE)) then
            return false
        endif
        if (GetUnitMagicImmunity(target) > 0) then
            return false
        endif
        if (GetRandomReal(0.01, 1) > CHANCE) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, real damageAmount, Unit target returns real
        if ( GetAttachedBooleanById( caster.id, Neutralization_SCOPE_ID ) ) then
            if (Damage_Conditions(caster.owner, target)) then
                call DispelUnit(target, false, true, true)
                return (damageAmount * BONUS_SUMMONED_DAMAGE)
            endif
        endif
        return damageAmount
    endfunction

    private function Damage_Event takes nothing returns nothing
        set DAMAGE_AMOUNT = Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, Neutralization_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_UNBLOCKABLE_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call SetAbilityRequiredResearch( SPELL_ID, RESEARCH_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Neutralization.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\NextHero.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("NextHero")
    globals
        private constant integer ORDER_ID = 852046//OrderId( "load" )
        public constant integer SPELL_ID = 'A02U'
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        call Miscellaneous_Altar_Altar_NextHero(caster)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\NextHero.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Payday.j
//TESH.scrollpos=515
//TESH.alwaysfold=0
//! runtextmacro Scope("Payday")
    globals
        private constant integer ORDER_ID = 852520//OrderId( "taunt" )
        public constant integer SPELL_ID = 'A030'

        private real array AREA_RANGE
        private real array AREA_RANGE_PER_AGILITY_POINT
        private real array DURATION
        private group ENUM_GROUP
        private real array INTERVAL
        private constant integer LEVELS_AMOUNT = 5
        private integer array MAX_TARGETS_AMOUNT
        private boolexpr TARGET_CONDITIONS
        private integer array WAVES_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        real areaRange
        Unit caster
        timer durationTimer
        timer intervalTimer
    endstruct

    private function TargetConditions_Single takes player casterOwner, Unit checkingUnit returns boolean
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitInvulnerability( checkingUnit ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( checkingUnit ) > 0 ) then
            return false
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return false
        endif
        return true
    endfunction

    private function TargetConditions takes nothing returns boolean
        if ( TargetConditions_Single( TEMP_PLAYER, GetUnit(GetFilterUnit()) ) == false ) then
            return false
        endif
        return true
    endfunction

    //! runtextmacro Scope("AttackSilence")
        globals
            private group AttackSilence_ENUM_GROUP
            private group AttackSilence_ENUM_GROUP2
            private boolexpr AttackSilence_TARGET_CONDITIONS
            private constant real AttackSilence_UPDATE_TIME = 0.1
        endglobals

        private struct AttackSilence_Data
            Data d
            group targetGroup
            timer updateTimer
        endstruct

        private function AttackSilence_GetCasterData takes Unit caster returns AttackSilence_Data
            return GetAttachedIntegerById(caster.id, AttackSilence_SCOPE_ID)
        endfunction

        //! runtextmacro Scope("Target")
            globals
                private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Undead\\Sleep\\SleepTarget.mdl"
                private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "hand left"
                private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT2 = "hand right"
            endglobals

            private struct Target_Data
                group casterGroup
                AttackSilence_Data d
                effect targetEffect
                effect targetEffect2
            endstruct

            private function Target_Ending takes Unit caster, group casterGroup, Target_Data d, Unit target, group targetGroup returns nothing
                local effect targetEffect
                local effect targetEffect2
                local integer targetId
                call GroupRemoveUnit( casterGroup, caster.self )
                call GroupRemoveUnit( targetGroup, target.self )
                if (FirstOfGroup(casterGroup) == null) then
                    set targetEffect = d.targetEffect
                    set targetEffect2 = d.targetEffect2
                    set targetId = target.id
                    call d.destroy()
                    call DestroyGroupWJ(casterGroup)
                    call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
                    //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                    call DestroyEffectWJ( targetEffect )
                    set targetEffect = null
                    call DestroyEffectWJ( targetEffect2 )
                    set targetEffect2 = null
                    call RemoveUnitAttackSilence( target )
                endif
            endfunction

            public function Target_EndingByEnding takes Unit caster, Unit target, group targetGroup returns nothing
                local Target_Data e = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
                call Target_Ending(caster, e.casterGroup, e, target, targetGroup)
            endfunction

            public function Target_EndingByUpdate takes Unit caster, Unit target, group targetGroup returns nothing
                local Target_Data e = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
                call Target_Ending(caster, e.casterGroup, e, target, targetGroup)
            endfunction

            public function Target_Death takes Unit target returns nothing
                local Unit caster
                local group casterGroup
                local AttackSilence_Data d
                local Target_Data e = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
                local integer iteration
                if (e != NULL) then
                    set casterGroup = e.casterGroup
                    set iteration = CountUnits(casterGroup)
                    loop
                        set caster = GetUnit(FirstOfGroup(casterGroup))
                        set d = AttackSilence_GetCasterData(caster)
                        call Target_Ending(caster, casterGroup, e, target, d.targetGroup)
                        set iteration = iteration - 1
                        exitwhen (iteration < 1)
                    endloop
                    set casterGroup = null
                endif
            endfunction

            private function Target_Death_Event takes nothing returns nothing
                call Target_Death( DYING_UNIT )
            endfunction

            public function Target_Start takes Unit caster, Unit target returns nothing
                local group casterGroup
                local integer targetId = target.id
                local Target_Data d = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
                local unit targetSelf
                if ( d == NULL ) then
                    set casterGroup = CreateGroupWJ()
                    set targetSelf = target.self
                    set d = Target_Data.create()
                    set d.casterGroup = casterGroup
                    set d.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, targetSelf, Target_TARGET_EFFECT_ATTACHMENT_POINT )
                    set d.targetEffect2 = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, targetSelf, Target_TARGET_EFFECT_ATTACHMENT_POINT2 )
                    set targetSelf = null
                    call AttachIntegerById( targetId, Target_SCOPE_ID, d )
                    //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
                    call AddUnitAttackSilence( target )
                endif
                call GroupAddUnit(casterGroup, caster.self)
                set casterGroup = null
            endfunction

            public function Target_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
                call InitEffectType( Target_TARGET_EFFECT_PATH )
            endfunction
        //! runtextmacro Endscope()

        public function AttackSilence_Ending takes Unit caster returns nothing
            local AttackSilence_Data d = AttackSilence_GetCasterData(caster)
            local unit enumUnit
            local group targetGroup = d.targetGroup
            local timer updateTimer = d.updateTimer
            call d.destroy()
            set targetGroup = d.targetGroup
            call FlushAttachedIntegerById(caster.id, AttackSilence_SCOPE_ID)
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( caster, GetUnit(enumUnit), targetGroup )
            endloop
            call DestroyGroupWJ( targetGroup )
            set targetGroup = null
            call FlushAttachedInteger( updateTimer, AttackSilence_SCOPE_ID )
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endfunction

        private function AttackSilence_TargetConditions takes nothing returns boolean
            if ( TargetConditions_Single( TEMP_PLAYER, GetUnit(GetFilterUnit()) ) == false ) then
                return false
            endif
            return true
        endfunction

        private function AttackSilence_Update takes real areaRange, Unit caster, group targetGroup returns nothing
            local unit casterSelf = caster.self
            local unit enumUnit
            set TEMP_PLAYER = caster.owner
            call GroupEnumUnitsInRangeWithCollision( AttackSilence_ENUM_GROUP, GetUnitX(casterSelf), GetUnitY(casterSelf), areaRange, AttackSilence_TARGET_CONDITIONS )
            set casterSelf = null
            set enumUnit = FirstOfGroup( targetGroup )
            if ( enumUnit != null ) then
                loop
                    if ( IsUnitInGroup( enumUnit, AttackSilence_ENUM_GROUP ) == false ) then
                        call Target_Target_EndingByUpdate( caster, GetUnit(enumUnit), targetGroup )
                    else
                        call GroupRemoveUnit( AttackSilence_ENUM_GROUP, enumUnit )
                        call GroupRemoveUnit( targetGroup, enumUnit )
                        call GroupAddUnit( AttackSilence_ENUM_GROUP2, enumUnit )
                    endif
                    set enumUnit = FirstOfGroup( targetGroup )
                    exitwhen ( enumUnit == null )
                endloop
                set enumUnit = FirstOfGroup( AttackSilence_ENUM_GROUP2 )
                loop
                    call GroupRemoveUnit( AttackSilence_ENUM_GROUP2, enumUnit )
                    call GroupAddUnit( targetGroup, enumUnit )
                    set enumUnit = FirstOfGroup( AttackSilence_ENUM_GROUP2 )
                    exitwhen ( enumUnit == null )
                endloop
            endif
            set enumUnit = FirstOfGroup( AttackSilence_ENUM_GROUP )
            if ( enumUnit != null ) then
                loop
                    call GroupRemoveUnit( AttackSilence_ENUM_GROUP, enumUnit )
                    call GroupAddUnit( targetGroup, enumUnit )
                    call Target_Target_Start(caster, GetUnit(enumUnit))
                    set enumUnit = FirstOfGroup( AttackSilence_ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endfunction

        private function AttackSilence_UpdateByTimer takes nothing returns nothing
            local timer updateTimer = GetExpiredTimer()
            local AttackSilence_Data e = GetAttachedInteger(updateTimer, AttackSilence_SCOPE_ID)
            local Data d = e.d
            set updateTimer = null
            call AttackSilence_Update( d.areaRange, d.caster, e.targetGroup )
        endfunction

        public function AttackSilence_Start takes real areaRange, Unit caster, Data d returns nothing
            local AttackSilence_Data e = AttackSilence_Data.create()
            local group targetGroup = CreateGroupWJ()
            local timer updateTimer = CreateTimerWJ()
            set e.d = d
            set e.targetGroup = targetGroup
            set e.updateTimer = updateTimer
            call AttachIntegerById(caster.id, AttackSilence_SCOPE_ID, e)
            call AttachInteger( updateTimer, AttackSilence_SCOPE_ID, e )
            call TimerStart( updateTimer, AttackSilence_UPDATE_TIME, true, function AttackSilence_UpdateByTimer )
            call AttackSilence_Update( areaRange, caster, targetGroup )
            set targetGroup = null
            set updateTimer = null
        endfunction

        public function AttackSilence_Init takes nothing returns nothing
            set AttackSilence_ENUM_GROUP = CreateGroupWJ()
            set AttackSilence_ENUM_GROUP2 = CreateGroupWJ()
            set AttackSilence_TARGET_CONDITIONS = ConditionWJ( function AttackSilence_TargetConditions )
            call Target_Target_Init()
        endfunction
    //! runtextmacro Endscope()

    //! runtextmacro Scope("Missile")
        globals
            private constant string Missile_CASTER_EFFECT_PATH = "UI\\Feedback\\GoldCredit\\GoldCredit.mdl"
            private constant string Missile_CASTER_EFFECT_ATTACHMENT_POINT = "origin"
            private integer array Missile_DROP
            private constant real Missile_DROP_TEXT_TAG_Z_OFFESET = 100.
            private constant integer Missile_DUMMY_UNIT_ID = 'n011'
            private constant real Missile_SPEED = 600.
            private constant string Missile_TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\ResourceItems\\ResourceEffectTarget.mdl"
            private constant string Missile_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
            private constant real Missile_UPDATE_TIME = 0.035
            private constant real Missile_LENGTH = Missile_SPEED * Missile_UPDATE_TIME
        endglobals

        private struct Missile_Data
            integer abilityLevel
            Unit caster
            unit dummyUnit
            timer durationTimer
            real length
            timer moveTimer
            real x
            real y
            real z
        endstruct

        private function Missile_Ending takes Unit caster, Missile_Data d, unit dummyUnit, timer moveTimer returns nothing
            call RemoveIntegerFromTableById( caster.id, Missile_SCOPE_ID, d )
            call d.destroy()
            call SetUnitAnimationByIndex( dummyUnit, 2 )
            call RemoveUnitTimed( dummyUnit, 1 )
            call FlushAttachedInteger( moveTimer, Missile_SCOPE_ID )
            call DestroyTimerWJ( moveTimer )
        endfunction

        public function Missile_EndingByEnding takes Unit caster returns nothing
            local integer casterId = caster.id
            local Missile_Data d
            local integer iteration = CountIntegersInTableById(casterId, Missile_SCOPE_ID)
            if (iteration > TABLE_EMPTY) then
                loop
                    set d = GetIntegerFromTableById( casterId, Missile_SCOPE_ID, iteration )
                    call Missile_Ending( caster, d, d.dummyUnit, d.moveTimer )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Missile_GiveBounty takes Unit caster, Missile_Data d, integer drop, real dropTextTagX, real dropTextTagY, real dropTextTagZ, unit dummyUnit, timer moveTimer returns nothing
            local player casterOwner = caster.owner
            local texttag dropTextTag = CreateRisingTextTag( "+" + I2S( drop ), 0.02, dropTextTagX, dropTextTagY, dropTextTagZ, 80, 255, 204, 0, 255, 0, 1 )
            call Missile_Ending(caster, d, dummyUnit, moveTimer)
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( Missile_CASTER_EFFECT_PATH, caster.self, Missile_CASTER_EFFECT_PATH ) )
            call AddPlayerState( casterOwner, PLAYER_STATE_RESOURCE_GOLD, drop )
            if ( dropTextTag != null ) then
                call LimitTextTagVisibilityToPlayer( dropTextTag, casterOwner )
                set dropTextTag = null
            endif
            set casterOwner = null
            call PlaySoundFromTypeAtPosition( RECEIVE_GOLD_SOUND_TYPE, dropTextTagX, dropTextTagY, dropTextTagZ )
        endfunction

        private function Missile_Move takes nothing returns nothing
            local real angleLengthXYZ
            local real angleXY
            local real distanceX
            local real distanceY
            local real distanceZ
            local real lengthXY
            local timer moveTimer = GetExpiredTimer()
            local Missile_Data d = GetAttachedInteger(moveTimer, Missile_SCOPE_ID)
            local Unit caster = d.caster
            local real casterMissileAngle
            local unit casterSelf = caster.self
            local real casterX = GetUnitX( casterSelf )
            local real casterY = GetUnitY( casterSelf )
            local real casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitImpactZ(caster)
            local unit dummyUnit = d.dummyUnit
            local real x = d.x
            local real y = d.y
            local real z = d.z
            local boolean reachesCaster = ( DistanceByCoordinatesWithZ( x, y, z, casterX, casterY, casterZ ) <= Missile_LENGTH )
            set casterSelf = null
            if ( reachesCaster ) then
                set casterMissileAngle = Atan2( y - casterY, x - casterX )
                set x = casterX
                set y = casterY
                set z = casterZ
            else
                set distanceZ = casterZ - z
                set angleLengthXYZ = Atan2( distanceZ, DistanceByCoordinates( x, y, casterX, casterY ) )
                set distanceX = casterX - x
                set distanceY = casterY - y
                set angleXY = Atan2( distanceY, distanceX )
                set lengthXY = Missile_LENGTH * Cos( angleLengthXYZ )
                set x = x + lengthXY * Cos( angleXY )
                set y = y + lengthXY * Sin( angleXY )
                set z = z + Missile_LENGTH * Sin( angleLengthXYZ )
                call SetUnitFacingWJ( dummyUnit, angleXY )
            endif
            call SetUnitX( dummyUnit, x )
            call SetUnitY( dummyUnit, y )
            call SetUnitZ( dummyUnit, x, y, z )
            if ( reachesCaster ) then
                call Missile_GiveBounty( caster, d, Missile_DROP[d.abilityLevel], casterX + Missile_DROP_TEXT_TAG_Z_OFFESET * Cos( casterMissileAngle ), casterY + Missile_DROP_TEXT_TAG_Z_OFFESET * Sin( casterMissileAngle ), casterZ + GetUnitOutpactZ(caster), dummyUnit, moveTimer )
            else
                set d.x = x
                set d.y = y
                set d.z = z
            endif
            set dummyUnit = null
            set moveTimer = null
        endfunction

        public function Missile_Start takes integer abilityLevel, Unit caster, real casterX, real casterY, Unit target returns nothing
            local Missile_Data d = Missile_Data.create()
            local timer moveTimer = CreateTimerWJ()
            local unit targetSelf = target.self
            local real targetX = GetUnitX( targetSelf )
            local real targetY = GetUnitY( targetSelf )
            local unit dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, Missile_DUMMY_UNIT_ID, targetX, targetY, Atan2( targetY - casterY, targetX - casterX ) )
            local real targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitOutpactZ(target)
            set d.abilityLevel = abilityLevel
            set d.caster = caster
            set d.dummyUnit = dummyUnit
            set d.moveTimer = moveTimer
            set d.x = targetX
            set d.y = targetY
            set d.z = targetZ
            call AddIntegerToTableById(caster.id, Missile_SCOPE_ID, d)
            call AttachInteger( moveTimer, Missile_SCOPE_ID, d )
            call SetUnitZ( dummyUnit, targetX, targetY, targetZ )
            set dummyUnit = null
            call DestroyEffectWJ( AddSpecialEffectTargetWJ( Missile_TARGET_EFFECT_PATH, targetSelf, Missile_TARGET_EFFECT_ATTACHMENT_POINT ) )
            set targetSelf = null
            call TimerStart( moveTimer, Missile_UPDATE_TIME, true, function Missile_Move )
            set moveTimer = null
        endfunction

        public function Missile_Init takes nothing returns nothing
            set Missile_DROP[1] = 5
            set Missile_DROP[2] = 8
            call InitUnitType( Missile_DUMMY_UNIT_ID )
            call InitEffectType( Missile_CASTER_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function Ending takes Unit caster, Data d returns nothing
        local timer durationTimer = d.durationTimer
        local timer intervalTimer = d.intervalTimer
        call d.destroy()
        call FlushAttachedIntegerById( caster.id, Payday_SCOPE_ID )
        call FlushAttachedInteger( durationTimer, Payday_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( intervalTimer, Payday_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
        call AttackSilence_AttackSilence_Ending( caster )
        call Missile_Missile_EndingByEnding(caster)
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Payday_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Payday_SCOPE_ID)
        set durationTimer = null
        call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
    endfunction

    private function Interval takes integer abilityLevel, real areaRange, Unit caster, Data d returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local Unit enumUnit
        local unit enumUnitSelf
        local integer iteration
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, areaRange, TARGET_CONDITIONS )
        set casterSelf = null
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            set iteration = MAX_TARGETS_AMOUNT[abilityLevel]
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                if ( IsUnitIllusionWJ( enumUnit ) ) then
                    call KillUnit( enumUnitSelf )
                else
                    call Missile_Missile_Start(abilityLevel, caster, casterX, casterY, enumUnit)
                endif
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
                set iteration = iteration - 1
                exitwhen ( iteration < 1 )
            endloop
            if (iteration > 0) then
                set enumUnitSelf = null
            endif
        endif
    endfunction

    private function IntervalByTimer takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, Payday_SCOPE_ID)
        set intervalTimer = null
        call Interval( d.abilityLevel, d.areaRange, d.caster, d )
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local real areaRange = AREA_RANGE[abilityLevel] + GetHeroAgilityTotal( caster ) * AREA_RANGE_PER_AGILITY_POINT[abilityLevel]
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        set d.abilityLevel = abilityLevel
        set d.areaRange = areaRange
        set d.caster = caster
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        call AttachIntegerById( caster.id, Payday_SCOPE_ID, d )
        call AttachInteger( durationTimer, Payday_SCOPE_ID, d )
        call AttachInteger( intervalTimer, Payday_SCOPE_ID, d )
        call TimerStart( intervalTimer, INTERVAL[abilityLevel], true, function IntervalByTimer )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function EndingByTimer )
        set durationTimer = null
        call Interval( abilityLevel, areaRange, caster, d )
        call AttackSilence_AttackSilence_Start( areaRange, caster, d )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set AREA_RANGE[1] = 400
        set AREA_RANGE[2] = 400
        set AREA_RANGE_PER_AGILITY_POINT[1] = 5
        set AREA_RANGE_PER_AGILITY_POINT[2] = 5
        set INTERVAL[1] = 0.35
        set INTERVAL[2] = 0.35
        set ENUM_GROUP = CreateGroupWJ()
        set MAX_TARGETS_AMOUNT[1] = 4
        set MAX_TARGETS_AMOUNT[2] = 6
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        set WAVES_AMOUNT[1] = 18
        set WAVES_AMOUNT[2] = 18
        loop
            set DURATION[iteration] = INTERVAL[iteration] * (WAVES_AMOUNT[iteration] + 0.5)
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call AttackSilence_AttackSilence_Init()
        call Missile_Missile_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Payday.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\PoisonFountain.j
//TESH.scrollpos=114
//TESH.alwaysfold=0
//! runtextmacro Scope("PoisonFountain")
    globals
        private constant integer ORDER_ID = 852202//OrderId( "restoration" )
        private constant integer POISONED_FOUNTAIN_ID = 'n00O'
        public constant integer SPELL_ID = 'A02G'

        private constant real AREA_RANGE = 550
        private constant real DURATION = 30
        private group ENUM_GROUP
        private constant string FOUNTAIN_EFFECT_PATH = "Abilities\\Spells\\Undead\\Unsummon\\UnsummonTarget.mdl"
        private constant string FOUNTAIN_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real INTERVAL = 0.5
        private constant real DAMAGE_PER_INTERVAL = 20 * INTERVAL
        private constant integer POISON_EFFECT_CIRCLES_AMOUNT = 3
        private constant string POISON_EFFECT_PATH = "Abilities\\Spells\\Other\\Drain\\DrainCaster.mdl"
        private constant integer POISON_EFFECT_AMOUNT_PER_CIRCLE = 3
        private boolexpr TARGET_CONDITIONS

        private timer DURATION_TIMER
        private sound EFFECT_SOUND
        private effect FOUNTAIN_EFFECT
        private timer INTERVAL_TIMER
    endglobals

    private function Ending takes nothing returns nothing
        local integer iteration = GetTeams() - 1
        call DestroyTimerWJ( DURATION_TIMER )
        call StopSound( EFFECT_SOUND, true, false )
        call DestroyEffectWJ( FOUNTAIN_EFFECT )
        call DestroyTimerWJ( INTERVAL_TIMER )
        call RemoveUnitEx( FOUNTAIN )
        set FOUNTAIN = CreateUnitEx( NEUTRAL_PASSIVE_PLAYER, FOUNTAIN_UNIT_ID, 0, 0, STANDARD_ANGLE )
        loop
            exitwhen ( iteration < 0 )
            call UnitAddAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
            set iteration = iteration - 1
        endloop
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( FILTER_UNIT == FOUNTAIN ) then
            return false
        endif
        set TEMP_PLAYER = FILTER_UNIT.owner
        if ( GetPlayerId( TEMP_PLAYER ) == PLAYER_NEUTRAL_PASSIVE ) then
            return false
        endif
        if ( GetPlayerId( TEMP_PLAYER ) == PLAYER_NEUTRAL_AGGRESSIVE ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function DealDamage takes nothing returns nothing
        local real angle
        local unit enumUnit
        local real angleDifference = 2 * PI / POISON_EFFECT_AMOUNT_PER_CIRCLE
        local integer iteration = 1
        local integer iteration2
        local real length
        local real lengthDifference = AREA_RANGE / POISON_EFFECT_CIRCLES_AMOUNT
        loop
            exitwhen ( iteration > POISON_EFFECT_CIRCLES_AMOUNT )
            set iteration2 = 1
            loop
                exitwhen ( iteration2 > POISON_EFFECT_AMOUNT_PER_CIRCLE )
                set angle = GetRandomReal( 0, 2 * PI )
                set length = iteration * lengthDifference
                call DestroyEffectTimed( AddSpecialEffectWJ( POISON_EFFECT_PATH, length * Cos( angle ), length * Sin( angle ) ), 1 )
                set iteration2 = iteration2 + 1
            endloop
            set iteration = iteration + 1
        endloop
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, 0, 0, AREA_RANGE, TARGET_CONDITIONS )
        loop
            set enumUnit = FirstOfGroup( ENUM_GROUP )
            exitwhen ( enumUnit == null )
            call GroupRemoveUnit( ENUM_GROUP, enumUnit )
            call UnitDamageUnitBySpell( FOUNTAIN, GetUnit(enumUnit), DAMAGE_PER_INTERVAL )
        endloop
    endfunction

    public function SpellEffect takes player casterOwner returns nothing
        local integer casterTeam = GetPlayerTeam( casterOwner )
        local integer count = Infoboard_COUNT
        local unit fountainSelf
        local integer iteration = GetTeams() - 1
        call RemoveUnitEx( FOUNTAIN )
        set DURATION_TIMER = CreateTimerWJ()
        set EFFECT_SOUND = CreateSoundFromType( POISON_FOUNTAIN_LOOP_SOUND_TYPE )
        set FOUNTAIN = CreateUnitEx( casterOwner, POISONED_FOUNTAIN_UNIT_ID, 0, 0, STANDARD_ANGLE )
        set fountainSelf = FOUNTAIN.self
        set FOUNTAIN_EFFECT = AddSpecialEffectTargetWJ( FOUNTAIN_EFFECT_PATH, FOUNTAIN.self, FOUNTAIN_EFFECT_ATTACHMENT_POINT )
        set INTERVAL_TIMER = CreateTimerWJ()
        loop
            exitwhen ( iteration < 0 )
            call UnitRemoveAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
            set iteration = iteration - 1
        endloop
        call DisplayTextTimedWJ( "|cffff0000Attention: |cffffcc00Team " + I2S( casterTeam + 1 ) + "|r has poisoned the central fountain. It is advised to stay away from it until the poison soup has dispersed.\n(Start: " + GetTimeString( count ) + " End: " + GetTimeString( count + R2I( DURATION ) ) + ")|r", 10, GetLocalPlayer() )
        call PingMasterWizard( casterTeam )
        call AttachSoundToUnit( EFFECT_SOUND, fountainSelf )
        set fountainSelf = null
        call StartSound( EFFECT_SOUND )
        call TimerStart( INTERVAL_TIMER, INTERVAL, true, function DealDamage )
        call TimerStart( DURATION_TIMER, DURATION, false, function Ending )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER.owner )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( FOUNTAIN_EFFECT_PATH )
        call InitEffectType( POISON_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\PoisonFountain.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\PreviousHero.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("PreviousHero")
    globals
        private constant integer ORDER_ID = 852047//OrderId( "unload" )
        public constant integer SPELL_ID = 'A02T'
    endglobals

    public function SpellEffect takes Unit caster returns nothing
        call Miscellaneous_Altar_Altar_PreviousHero(caster)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\PreviousHero.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Pulverize.j
//TESH.scrollpos=58
//TESH.alwaysfold=0
//! runtextmacro Scope("Pulverize")
    globals
        public constant integer DUMMY_SPELL_ID = 'A07X'
        public constant integer SPELL_ID = 'A07Y'

        private constant real AREA_RANGE = 250.
        private constant real CHANCE = 0.3
        private constant real DAMAGE_FACTOR = 0.8
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
    endglobals

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId
        if (GetUnitAbilityLevel(caster.self, SPELL_ID) > 0) then
            set casterId = caster.id
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( TRIGGER_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if (IsUnitAlly(FILTER_UNIT_SELF, TEMP_PLAYER)) then
            return false
        endif
        if (FILTER_UNIT_SELF == TEMP_UNIT_SELF) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) != TEMP_BOOLEAN ) then
            return false
        endif
        if (GetUnitInvulnerability(GetUnit(FILTER_UNIT_SELF)) > 0) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, real damageAmount, Unit target returns nothing
        local unit casterSelf = caster.self
        local unit enumUnit
        if ( GetUnitAbilityLevel( casterSelf, DUMMY_SPELL_ID ) > 0 ) then
            set TEMP_BOOLEAN = IsUnitType( casterSelf, UNIT_TYPE_FLYING )
            set TEMP_PLAYER = caster.owner
            set TEMP_UNIT_SELF = target.self
            call GroupEnumUnitsInRange(ENUM_GROUP, GetUnitX(casterSelf), GetUnitY(casterSelf), AREA_RANGE, TARGET_CONDITIONS)
            set enumUnit = FirstOfGroup(ENUM_GROUP)
            if (enumUnit != null) then
                loop
                    call GroupRemoveUnit(ENUM_GROUP, enumUnit)
                    call UnitDamageUnitEx(caster, GetUnit(enumUnit), GetUnitDamageTotal(caster) * DAMAGE_FACTOR, null)
                    set enumUnit = FirstOfGroup(ENUM_GROUP)
                    exitwhen (enumUnit == null)
                endloop
            endif
        endif
        set casterSelf = null
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function TargetInRange takes Unit caster returns nothing
        local unit casterSelf = caster.self
        if (GetUnitAbilityLevel(casterSelf, SPELL_ID) > 0) then
            if (GetRandomReal(0.01, 1) < CHANCE) then
                call UnitAddAbility(casterSelf, DUMMY_SPELL_ID)
            else
                call UnitRemoveAbility(casterSelf, DUMMY_SPELL_ID)
            endif
        endif
        set casterSelf = null
    endfunction

    private function TargetInRange_Event takes nothing returns nothing
        call TargetInRange( TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_ACQUIRE", "UnitAcquiresTarget_EVENT_KEY", "0", "function TargetInRange_Event" )
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_UNBLOCKABLE_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Pulverize.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\RaiseDead.j
//TESH.scrollpos=126
//TESH.alwaysfold=0
//! runtextmacro Scope("RaiseDead")
    globals
        public constant integer ORDER_ID = 852132//OrderId( "autodispel" )
        public constant integer SPELL_ID = 'A014'

        private constant real AREA_RANGE = 350.
        private constant real DURATION = 30.
        private group ENUM_GROUP
        private constant real RELEASE_TIME = 2.
        private constant integer SPAWNS_AMOUNT = 2
        private constant integer SPAWN_ID = 'u00B'
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Undead\\RaiseSkeletonWarrior\\RaiseSkeleton.mdl"
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        timer releaseTimer
        Unit spawn
    endstruct

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) > 0 ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitCanNotBeRevived(GetUnit(FILTER_UNIT_SELF)) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function Release takes nothing returns nothing
        local timer releaseTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(releaseTimer, RaiseDead_SCOPE_ID)
        local Unit spawn = d.spawn
        local unit spawnSelf = spawn.self
        call d.destroy()
        call FlushAttachedInteger( releaseTimer, RaiseDead_SCOPE_ID )
        call DestroyTimerWJ( releaseTimer )
        set releaseTimer = null
        call SetUnitBlendTime( spawnSelf, 0.15 )
        call SetUnitInvulnerable( spawnSelf, false )
        call UnitApplyTimedLifeWJ( spawnSelf, DURATION )
        call SetUnitAnimationByIndex( spawnSelf, 0 )
        set spawnSelf = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local player casterOwner
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d
        local unit enumUnit
        local real enumUnitAngle
        local real enumUnitX
        local real enumUnitY
        local integer iteration
        local Unit spawn
        local unit spawnSelf
        local timer releaseTimer
        set casterSelf = null
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = GetNearestUnit( ENUM_GROUP, casterX, casterY )
        if ( enumUnit != null ) then
            set casterOwner = caster.owner
            set enumUnitAngle = GetUnitFacingWJ( enumUnit )
            set enumUnitX = GetUnitX( enumUnit )
            set enumUnitY = GetUnitY( enumUnit )
            set iteration = SPAWNS_AMOUNT
            call RemoveUnitEx( GetUnit(enumUnit) )
            loop
                exitwhen ( iteration < 1 )
                set d = Data.create()
                set spawn = CreateUnitEx( casterOwner, SPAWN_ID, enumUnitX, enumUnitY, enumUnitAngle )
                set spawnSelf = spawn.self
                set releaseTimer = CreateTimerWJ()
                set d.releaseTimer = releaseTimer
                set d.spawn = spawn
                call AttachInteger(releaseTimer, RaiseDead_SCOPE_ID, d)
                call SetUnitInvulnerable( spawnSelf, true )
                call SetUnitBlendTime( spawnSelf, 0 )
                call SetUnitAnimationByIndex( spawnSelf, 9 )
                call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, GetUnitX( spawnSelf ), GetUnitY( spawnSelf ) ) )
                call TimerStart( releaseTimer, RELEASE_TIME, false, function Release )
                set iteration = iteration - 1
            endloop
            set casterOwner = null
            set releaseTimer = null
            set spawnSelf = null
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Order takes real casterX, real casterY returns string
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        if ( FirstOfGroup( ENUM_GROUP ) == null ) then
            return ErrorStrings_NO_CORPSES_FOUND
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        local unit casterSelf = CASTER.self
        set ERROR_MSG = RaiseDead_Order( GetUnitX(casterSelf), GetUnitY(casterSelf) )
        set casterSelf = null
    endfunction

    //! runtextmacro Scope("Automatic")
        globals
            public constant integer Automatic_ACTIVATION_ORDER_ID = 852133//OrderId( "autodispelon" )
            public constant integer Automatic_DEACTIVATION_ORDER_ID = 852134//OrderId( "autodispeloff" )
        endglobals

        public function Automatic_TargetInRange takes Unit caster, player casterOwner returns nothing
            local unit enumUnit
            local unit casterSelf = caster.self
            local real casterX
            local real casterY
            if ( GetUnitAutomaticAbility(caster) == SPELL_ID ) then
                set casterX = GetUnitX( casterSelf )
                set casterY = GetUnitY( casterSelf )
                call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
                set enumUnit = GetRandomUnit( ENUM_GROUP )
                if ( enumUnit != null ) then
                    call IssueTargetOrderByIdTimed( caster, ORDER_ID, caster, 0 )
                endif
            endif
            set casterSelf = null
        endfunction

        private function Automatic_TargetInRange_Event takes nothing returns nothing
            call Automatic_TargetInRange( TRIGGER_UNIT, TRIGGER_UNIT.owner )
        endfunction

        public function Automatic_Activation_Order takes Unit caster returns nothing
            //! runtextmacro AddEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, SPELL_ID)
        endfunction

        private function Automatic_Activation_Order_Event takes nothing returns nothing
            call Automatic_Activation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Deactivation_Order takes Unit caster returns nothing
            //! runtextmacro RemoveEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, 0)
        endfunction

        private function Automatic_Deactivation_Order_Event takes nothing returns nothing
            call Automatic_Deactivation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Init takes nothing returns nothing
            call AddOrderAbility( Automatic_ACTIVATION_ORDER_ID, SPELL_ID )
            call AddOrderAbility( Automatic_DEACTIVATION_ORDER_ID, SPELL_ID )
            //! runtextmacro CreateEvent( "Automatic_EVENT_ACQUIRE", "UnitAcquiresTarget_EVENT_KEY", "0", "function Automatic_TargetInRange_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_ACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_ACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Activation_Order_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_DEACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_DEACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Deactivation_Order_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Automatic_Automatic_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\RaiseDead.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\RapidFire.j
//TESH.scrollpos=126
//TESH.alwaysfold=0
//! runtextmacro Scope("RapidFire")
    globals
        public constant integer SPELL_ID = 'A076'
    endglobals

    //! runtextmacro Scope("Buff")
        globals
            private constant real Buff_BONUS_RELATIVE_ATTACK_RATE = 1.
            private constant string Buff_CASTER_EFFECT_PATH = "Abilities\\Spells\\Orc\\TrollBerserk\\HeadhunterWEAPONSLeft.mdl"
            private constant string Buff_CASTER_EFFECT_ATTACHMENT_POINT = "weapon left"
            private constant string Buff_CASTER_EFFECT2_PATH = "Abilities\\Spells\\Orc\\TrollBerserk\\HeadhunterWEAPONSRight.mdl"
            private constant string Buff_CASTER_EFFECT2_ATTACHMENT_POINT = "weapon right"
            private constant real Buff_DURATION = 5.
        endglobals

        private struct Buff_Data
            Unit caster
            effect casterEffect
            effect casterEffect2
            timer durationTimer
        endstruct

        private function Buff_Ending takes Unit caster, Buff_Data d, timer durationTimer returns nothing
            local effect casterEffect = d.casterEffect
            local effect casterEffect2 = d.casterEffect2
            local integer casterId = caster.id
            call FlushAttachedIntegerById( casterId, Buff_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "Buff_EVENT_DEATH" )
            call DestroyEffectWJ( casterEffect )
            set casterEffect = null
            call DestroyEffectWJ( casterEffect2 )
            set casterEffect2 = null
            call FlushAttachedInteger( durationTimer, Buff_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call AddUnitAttackRate( caster, -Buff_BONUS_RELATIVE_ATTACK_RATE )
        endfunction

        public function Buff_Death takes Unit caster returns nothing
            local Buff_Data d = GetAttachedIntegerById(caster.id, Buff_SCOPE_ID)
            if (d != NULL) then
                call Buff_Ending(caster, d, d.durationTimer)
            endif
        endfunction

        private function Buff_Death_Event takes nothing returns nothing
            call Buff_Death( DYING_UNIT )
        endfunction

        private function Buff_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Buff_Data d = GetAttachedInteger(durationTimer, Buff_SCOPE_ID)
            call Buff_Ending( d.caster, d, durationTimer )
            set durationTimer = null
        endfunction

        public function Buff_Start takes Unit caster returns nothing
            local integer casterId = caster.id
            local unit casterSelf = caster.self
            local Buff_Data d = GetAttachedIntegerById(casterId, Buff_SCOPE_ID)
            local timer durationTimer
            local boolean isNew = (d == NULL)
            if ( isNew ) then
                set d = Buff_Data.create()
                set durationTimer = CreateTimerWJ()
                set d.caster = caster
                set d.durationTimer = durationTimer
                call AttachIntegerById( casterId, Buff_SCOPE_ID, d )
                //! runtextmacro AddEventById( "casterId", "Buff_EVENT_DEATH" )
                call AttachInteger( durationTimer, Buff_SCOPE_ID, d )
            else
                set durationTimer = d.durationTimer
                call DestroyEffectWJ( d.casterEffect )
                call DestroyEffectWJ( d.casterEffect2 )
            endif
            set d.casterEffect = AddSpecialEffectTargetWJ( Buff_CASTER_EFFECT_PATH, casterSelf, Buff_CASTER_EFFECT_ATTACHMENT_POINT )
            set d.casterEffect2 = AddSpecialEffectTargetWJ( Buff_CASTER_EFFECT2_PATH, casterSelf, Buff_CASTER_EFFECT2_ATTACHMENT_POINT )
            set casterSelf = null
            if (isNew) then
                call AddUnitAttackRate( caster, Buff_BONUS_RELATIVE_ATTACK_RATE )
            endif
            call TimerStart( durationTimer, Buff_DURATION, false, function Buff_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Buff_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Buff_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Buff_Death_Event" )
            call InitEffectType( Buff_CASTER_EFFECT_PATH )
            call InitEffectType( Buff_CASTER_EFFECT2_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Caster_Death takes Unit caster returns nothing
        local integer casterId
        if (GetUnitAbilityLevel(caster.self, SPELL_ID) > 0) then
            set casterId = caster.id
            //! runtextmacro RemoveEventById( "casterId", "EVENT_CASTER_DEATH" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_SOURCE_DEATH" )
        endif
    endfunction

    private function Caster_Death_Event takes nothing returns nothing
        call Caster_Death( DYING_UNIT )
    endfunction

    private function Source_Death_Conditions takes unit caster, player casterOwner, Unit source returns boolean
        if ( GetUnitAbilityLevel( caster, SPELL_ID ) <= 0 ) then
            return false
        endif
        if ( GetUnitState( caster, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( source.self, casterOwner ) ) then
            return false
        endif
        if ( IsUnitIllusionWJ( source ) ) then
            return false
        endif
        return true
    endfunction

    public function Source_Death takes Unit caster, player casterOwner, Unit source returns nothing
        if ( Source_Death_Conditions( caster.self, casterOwner, source ) ) then
            call Buff_Buff_Start(caster)
        endif
    endfunction

    private function Source_Death_Event takes nothing returns nothing
        call Source_Death( KILLING_UNIT, KILLING_UNIT.owner, DYING_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        //! runtextmacro AddEventById( "casterId", "EVENT_CASTER_DEATH" )
        //! runtextmacro AddEventById( "casterId", "EVENT_SOURCE_DEATH" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_CASTER_DEATH", "UnitDies_EVENT_KEY", "0", "function Caster_Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_SOURCE_DEATH", "UnitDies_EVENT_KEY_AS_KILLING_UNIT", "0", "function Source_Death_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Buff_Buff_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\RapidFire.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\RefillMana.j
//TESH.scrollpos=128
//TESH.alwaysfold=0
//! runtextmacro Scope("RefillMana")
    globals
        private constant integer ORDER_ID = 852548//OrderId( "replenishmana" )
        public constant integer SPELL_ID = 'A03K'

        private constant real DURATION = 10.
        private constant real INTERVAL = 1.
        private constant real MAX_RANGE = 800.
        private constant real REFRESHED_MANA_PER_INTERVAL = 100 / DURATION * INTERVAL
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\AIma\\AImaTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        Unit caster
        timer distanceTimer
        timer durationTimer
        timer intervalTimer
        Unit target
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local timer distanceTimer = d.distanceTimer
        local timer durationTimer = d.durationTimer
        local timer intervalTimer = d.intervalTimer
        local Unit target = d.target
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedIntegerById( caster.id, RefillMana_SCOPE_ID_BASIC )
        call FlushAttachedInteger( distanceTimer, RefillMana_SCOPE_ID )
        call DestroyTimerWJ( distanceTimer )
        set distanceTimer = null
        call FlushAttachedInteger( durationTimer, RefillMana_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( intervalTimer, RefillMana_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
        call RemoveIntegerFromTableById( targetId, RefillMana_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, RefillMana_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
    endfunction

    public function Death takes Unit target returns nothing
        local Data d
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, RefillMana_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTableById( targetId, RefillMana_SCOPE_ID, iteration )
                call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, RefillMana_SCOPE_ID_BASIC )
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, RefillMana_SCOPE_ID)
        set durationTimer = null
        call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
    endfunction

    private function Drain takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, RefillMana_SCOPE_ID)
        local Unit target = d.target
        local unit targetSelf = target.self
        set intervalTimer = null
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
        call PlaySoundFromTypeOnUnit( REFRESH_MANA_SOUND_TYPE, targetSelf )
        call AddUnitState( targetSelf, UNIT_STATE_MANA, REFRESHED_MANA_PER_INTERVAL )
        set targetSelf = null
    endfunction

    private function CheckDistance takes nothing returns nothing
        local timer distanceTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(distanceTimer, RefillMana_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local Unit target = d.target
        local unit targetSelf = target.self
        if ( DistanceByCoordinates( GetUnitX(casterSelf), GetUnitY(casterSelf), GetUnitX(targetSelf), GetUnitY(targetSelf) ) > MAX_RANGE ) then
            call IssueImmediateOrderById( casterSelf, STOP_ORDER_ID )
        endif
        set casterSelf = null
        set targetSelf = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local Data d = Data.create()
        local timer distanceTimer = CreateTimerWJ()
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        local integer targetId = target.id
        set d.caster = caster
        set d.distanceTimer = distanceTimer
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        set d.target = target
        call AttachIntegerById( caster.id, RefillMana_SCOPE_ID_BASIC, d )
        call AttachInteger( distanceTimer, RefillMana_SCOPE_ID, d )
        call AttachInteger( durationTimer, RefillMana_SCOPE_ID, d )
        call AttachInteger( intervalTimer, RefillMana_SCOPE_ID, d )
        call AddIntegerToTableById( targetId, RefillMana_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, RefillMana_SCOPE_ID ) == TABLE_STARTED ) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call TimerStart( distanceTimer, UPDATE_TIME, true, function CheckDistance )
        set distanceTimer = null
        call TimerStart( intervalTimer, INTERVAL, true, function Drain )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit caster, player casterOwner, Unit target returns string
        local real targetMaxMana
        if ( caster == target ) then
            return ErrorStrings_NOT_SELF
        endif
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) == false ) then
            return ErrorStrings_ONLY_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return ErrorStrings_NOT_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        set targetMaxMana = GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_MAX_MANA )
        if ( targetMaxMana <= 0 ) then
            return ErrorStrings_NEEDS_MANA_POOL
        endif
        if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_MANA ) >= targetMaxMana ) then
            return ErrorStrings_ALREADY_FULL_MANA
        endif
        if ( IsUnitIllusionWJ( target ) ) then
            return ErrorStrings_NOT_ILLUSION
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( CASTER, CASTER.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\RefillMana.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Reincarnation.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Reincarnation")
    globals
        public constant integer SPELL_ID = 'A07Q'

        private constant real COOLDOWN = 180.
    endglobals

    private struct Data
        Unit caster
        timer cooldownTimer
    endstruct

    private function Ending takes Unit caster, timer cooldownTimer, Data d returns nothing
        local integer casterId = caster.id
        local UnitType casterType = caster.type
        call d.destroy()
        call FlushAttachedIntegerById(casterId, Reincarnation_SCOPE_ID)
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY" )
        call FlushAttachedInteger(cooldownTimer, Reincarnation_SCOPE_ID)
        if (GetUnitDecay(caster) > B2I(IsUnitTypeDecay(casterType))) then
            call RemoveUnitDecay(caster)
            call SetUnitDecayTime(caster, GetUnitTypeDecayTime(casterType))
            call RemoveUnitExplode( caster )
        endif
    endfunction

    public function Decay takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Reincarnation_SCOPE_ID)
        if (d != NULL) then
            call Ending(caster, d.cooldownTimer, d)
        endif
    endfunction

    private function Decay_Event takes nothing returns nothing
        call Decay(TRIGGER_UNIT)
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer cooldownTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(cooldownTimer, Reincarnation_SCOPE_ID)
        call Ending(d.caster, cooldownTimer, d)
        set cooldownTimer = null
    endfunction

    public function BeforeDying takes Unit caster returns boolean
        local integer casterId
        local Data d
        local timer cooldownTimer
        if (GetUnitAbilityLevel(caster.self, SPELL_ID) > 0) then
            set casterId = caster.id
            set d = Data.create()
            set d.caster = caster
            set d.cooldownTimer = cooldownTimer
            call AttachIntegerById(casterId, Reincarnation_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DECAY" )
            call AttachInteger(cooldownTimer, Reincarnation_SCOPE_ID, d)
            call TimerStart(cooldownTimer, COOLDOWN, false, function EndingByTimer)
            set cooldownTimer = null
            return true
        endif
        return false
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DECAY", "UnitFinishesDecaying_EVENT_KEY", "0", "function Decay_Event" )
        call InitAbility( SPELL_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Reincarnation.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\RequestReinforcements.j
//TESH.scrollpos=106
//TESH.alwaysfold=0
//! runtextmacro Scope("RequestReinforcements")
    globals
        private constant integer ORDER_ID = 852079//OrderId( "tankdroppilot" )
        public constant integer SPELL_ID = 'A037'

        private constant integer DUMMY_UNIT_ID = 'n020'
        private constant real HEIGHT = 400.
        private integer array SPAWNS_AMOUNT
        private constant real SPEED = 400.
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
    endglobals

    private struct Data
        player casterOwner
        unit dummyUnit
        timer durationTimer
        real lengthX
        real lengthY
        timer moveTimer
        real targetX
        real targetY
        Race whichRace
        real x
        real y
    endstruct

    private function Ending takes player casterOwner, Data d, timer durationTimer returns nothing
        local unit dummyUnit = d.dummyUnit
        local timer moveTimer = d.moveTimer
        call d.destroy()
        call RemoveIntegerFromTable( casterOwner, RequestReinforcements_SCOPE_ID, d )
        call SetUnitAnimationByIndex( dummyUnit, 6 )
        call RemoveUnitTimed( dummyUnit, 1.667 )
        call FlushAttachedInteger( durationTimer, RequestReinforcements_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( moveTimer, RequestReinforcements_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        set moveTimer = null
    endfunction

    public function Death takes player casterOwner returns nothing
        local Data d
        local integer iteration = CountIntegersInTable( casterOwner, RequestReinforcements_SCOPE_ID )
        if (iteration > TABLE_EMPTY) then
            loop
                set d = GetIntegerFromTable( casterOwner, RequestReinforcements_SCOPE_ID, iteration )
                call Ending( casterOwner, d, d.durationTimer )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, RequestReinforcements_SCOPE_ID)
        local player casterOwner = d.casterOwner
        local integer iteration2
        local integer spawnTypeId
        local real targetX = d.targetX
        local real targetY = d.targetY
        local Race whichRace = d.whichRace
        local integer iteration = CountRaceTownHalls(whichRace)
        call Ending( casterOwner, d, durationTimer )
        set durationTimer = null
        loop
            exitwhen ( iteration < 0 )
            set spawnTypeId = GetUnitTypeSpawnTypeId(GetRaceTownHall(whichRace, iteration))
            set iteration2 = SPAWNS_AMOUNT[iteration] * (1 + GetUnitTypeSpawnBonus(spawnTypeId))
            loop
                exitwhen ( iteration2 < 1 )
                call CreateUnitEx( casterOwner, spawnTypeId, targetX, targetY, STANDARD_ANGLE )
                set iteration2 = iteration2 - 1
            endloop
            set iteration = iteration - 1
        endloop
        set casterOwner = null
    endfunction

    private function Move takes nothing returns nothing
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, RequestReinforcements_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local real x = d.x + d.lengthX
        local real y = d.y + d.lengthY
        set moveTimer = null
        set d.x = x
        set d.y = y
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, HEIGHT )
        set dummyUnit = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local unit casterSelf = caster.self
        local player casterOwner = caster.owner
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local real angle = Atan2( targetY - casterY, targetX - casterX )
        local Data d = Data.create()
        local real distanceX = targetX - casterX
        local real distanceY = targetY - casterY
        local real distance = SquareRoot( distanceX * distanceX + distanceY * distanceY )
        local unit dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, casterX, casterY, angle )
        local timer durationTimer = CreateTimerWJ()
        local timer moveTimer = CreateTimerWJ()
        set casterSelf = null
        set d.casterOwner = casterOwner
        set d.dummyUnit = dummyUnit
        set d.durationTimer = durationTimer
        set d.lengthX = LENGTH * Cos( angle )
        set d.lengthY = LENGTH * Sin( angle )
        set d.moveTimer = moveTimer
        set d.targetX = targetX
        set d.targetY = targetY
        set d.whichRace = GetPlayerRaceWJ(casterOwner)
        set d.x = casterX
        set d.y = casterY
        call AddIntegerToTable( casterOwner, RequestReinforcements_SCOPE_ID, d )
        call AttachInteger( durationTimer, RequestReinforcements_SCOPE_ID, d )
        call AttachInteger( moveTimer, RequestReinforcements_SCOPE_ID, d )
        call SetUnitColor( dummyUnit, GetPlayerColor( casterOwner ) )
        set casterOwner = null
        call SetUnitZ(dummyUnit, casterX, casterY, HEIGHT)
        call PlaySoundFromTypeOnUnit( REQUEST_REINFORCEMENTS_LAUNCH_SOUND_TYPE, dummyUnit )
        set dummyUnit = null
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
        call TimerStart( durationTimer, distance / SPEED, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Order takes Unit caster, player casterOwner, real targetX, real targetY returns string
        if ( GetPlayerRaceWJ(casterOwner) == NULL ) then
            return ErrorStrings_NEEDS_RACE
        endif
        if (IsPointInPlayRegion(targetX, targetY) == false) then
            return ErrorStrings_INVALID_TARGET
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT, ORDERED_UNIT.owner, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        set SPAWNS_AMOUNT[0] = 2
        set SPAWNS_AMOUNT[1] = 1
        set SPAWNS_AMOUNT[2] = 1
        set SPAWNS_AMOUNT[3] = 1
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\RequestReinforcements.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Resurrection.j
//TESH.scrollpos=157
//TESH.alwaysfold=0
//! runtextmacro Scope("Resurrection")
    globals
        private constant integer ORDER_ID = 852094//OrderId( "resurrection" )
        public constant integer SPELL_ID = 'A00D'

        private real array AREA_RANGE
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private integer array MAX_TARGETS_AMOUNT
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Human\\Resurrect\\ResurrectCaster.mdl"
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Human\\Resurrect\\ResurrectTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    //! runtextmacro Scope("Cooldown")
        globals
            private real array Cooldown_DURATION
            private real array Cooldown_DURATION_PER_AGILITY_POINT
        endglobals

        private struct Cooldown_Data
            integer abilityLevel
            Unit caster
        endstruct

        private function Cooldown_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Cooldown_Data d = GetAttachedInteger(durationTimer, Cooldown_SCOPE_ID)
            local integer abilityLevel = d.abilityLevel
            local Unit caster = d.caster
            local player casterOwner = caster.owner
            local unit casterSelf = caster.self
            call d.destroy()
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            if ( IsUnitSelected( casterSelf, casterOwner ) ) then
                call PlaySoundFromTypeForPlayer( COOLDOWN_SOUND_TYPE, casterOwner )
            endif
            set casterOwner = null
            call UnitAddAbility(casterSelf, SPELL_ID)
            call SetUnitAbilityLevel( casterSelf, SPELL_ID, abilityLevel )
            set casterSelf = null
        endfunction

        private function Cooldown_PreEnding takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Cooldown_Data d = GetAttachedInteger(durationTimer, Cooldown_SCOPE_ID)
            local Unit caster = d.caster
            local unit casterSelf = caster.self
            local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
            set d.abilityLevel = abilityLevel
            call UnitRemoveAbility( casterSelf, SPELL_ID )
            set casterSelf = null
            call TimerStart( durationTimer, 0.5, false, function Cooldown_Ending )
            set durationTimer = null
        endfunction

        public function Cooldown_Start takes integer abilityLevel, Unit caster returns nothing
            local timer durationTimer = CreateTimerWJ()
            local Cooldown_Data d = Cooldown_Data.create()
            set d.caster = caster
            call AttachInteger( durationTimer, Cooldown_SCOPE_ID, d )
            call TimerStart( durationTimer, Cooldown_DURATION[abilityLevel] + GetHeroAgilityTotal( caster ) * Cooldown_DURATION_PER_AGILITY_POINT[abilityLevel] - 0.5, false, function Cooldown_PreEnding )
            set durationTimer = null
        endfunction

        public function Cooldown_Init takes nothing returns nothing
            set Cooldown_DURATION[1] = 120
            set Cooldown_DURATION[2] = 120
            set Cooldown_DURATION_PER_AGILITY_POINT[1] = -0.75
            set Cooldown_DURATION_PER_AGILITY_POINT[2] = -0.75
        endfunction
    //! runtextmacro Endscope()

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) > 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitCanNotBeRevived(FILTER_UNIT) > 0 ) then
            return false
        endif
        if ( IsUnitTypeSpawn(FILTER_UNIT.type) == false ) then
            return false
        endif
        return true
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local integer currentLevel
        local Unit enumUnit
        local unit enumUnitSelf
        local integer enumUnitLevel
        local boolean found
        local integer iteration = MAX_TARGETS_AMOUNT[abilityLevel]
        local real newUnitAngle
        local Unit newUnit
        local player newUnitOwner
        local integer newUnitTypeId
        local real newUnitX
        local real newUnitY
        set casterSelf = null
        call DestroyEffect( AddSpecialEffect( SPECIAL_EFFECT_PATH, casterX, casterY ) )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        loop
            set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
            exitwhen ( enumUnitSelf == null )
            set found = false
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                call GroupAddUnit( ENUM_GROUP2, enumUnitSelf )
                set enumUnitLevel = GetUnitLevelWJ( enumUnit )
                if ( found == false ) then
                    set currentLevel = enumUnitLevel
                    set found = true
                elseif ( enumUnitLevel > currentLevel ) then
                    set currentLevel = enumUnitLevel
                endif
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
            loop
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP2 )
                set enumUnit = GetUnit(enumUnitSelf)
                exitwhen ( enumUnitSelf == null )
                call GroupRemoveUnit( ENUM_GROUP2, enumUnitSelf )
                if ( GetUnitLevelWJ( enumUnit ) == currentLevel ) then
                    set newUnitAngle = GetUnitFacingWJ( enumUnitSelf )
                    set newUnitOwner = enumUnit.owner
                    set newUnitTypeId = GetUnitTypeId( enumUnitSelf )
                    set newUnitX = GetUnitX( enumUnitSelf )
                    set newUnitY = GetUnitY( enumUnitSelf )
                    call RemoveUnitEx( enumUnit )
                    set newUnit = CreateUnitEx( newUnitOwner, newUnitTypeId, newUnitX, newUnitY, newUnitAngle )
                    call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, newUnit.self, TARGET_EFFECT_ATTACHMENT_POINT ) )
                    set iteration = iteration - 1
                else
                    call GroupAddUnit( ENUM_GROUP, enumUnitSelf )
                endif
            endloop
            exitwhen ( iteration < 1 )
        endloop
        set newUnitOwner = null
        call Cooldown_Cooldown_Start(abilityLevel, caster)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Order takes unit caster, player casterOwner, real casterX, real casterY returns string
        local integer abilityLevel = GetUnitAbilityLevel( caster, SPELL_ID )
        set TEMP_PLAYER = casterOwner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        if ( FirstOfGroup( ENUM_GROUP ) == null ) then
            return ErrorStrings_NO_CORPSES_FOUND
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        local unit casterSelf = ORDERED_UNIT.self
        set ERROR_MSG = Order( casterSelf, ORDERED_UNIT.owner, GetUnitX(casterSelf), GetUnitY(casterSelf) )
        set casterSelf = null
    endfunction

    public function Init takes nothing returns nothing
        set AREA_RANGE[1] = 1000
        set AREA_RANGE[2] = 1000
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        set MAX_TARGETS_AMOUNT[1] = 6
        set MAX_TARGETS_AMOUNT[2] = 10
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Cooldown_Cooldown_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Resurrection.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Riposte.j
//TESH.scrollpos=77
//TESH.alwaysfold=0
//! runtextmacro Scope("Riposte")
    globals
        public constant integer SPELL_ID = 'A074'

        private constant real AREA_RANGE = 500.
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\NightElf\\ThornsAura\\ThornsAura.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        Unit caster
        effect casterEffect
        group targetGroup
        timer updateTimer
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private constant real Target_REFLECTION_FACTOR = 0.25
            private constant string Target_SPECIAL_EFFECT_PATH = "Abilities\\Spells\\NightElf\\ThornsAura\\ThornsAuraDamage.mdl"
            private constant string Target_SPECIAL_EFFECT_ATTACHMENT_POINT = "head"
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            Data d
            effect targetEffect
        endstruct

        private function Target_Ending takes Target_Data d, Unit target, group targetGroup returns nothing
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call d.destroy()
            call RemoveIntegerFromTableById( targetId, Target_SCOPE_ID, d )
            if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_EMPTY ) then
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DAMAGE" )
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                call DestroyEffectWJ( targetEffect )
            endif
            set targetEffect = null
            call GroupRemoveUnit( targetGroup, target.self )
        endfunction

        public function Target_EndingByEnding takes Data d, Unit target, group targetGroup returns nothing
            local Target_Data e
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            loop
                set e = GetIntegerFromTableById(targetId, Target_SCOPE_ID, iteration)
                exitwhen (e.d == d)
                set iteration = iteration - 1
            endloop
            call Target_Ending( e, target, targetGroup )
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Data d
            local Target_Data e
            local integer targetId = target.id
            local integer iteration = CountIntegersInTableById( targetId, Target_SCOPE_ID )
            if (iteration > TABLE_EMPTY) then
                loop
                    set e = GetIntegerFromTableById( targetId, Target_SCOPE_ID, iteration )
                    set d = e.d
                    call Target_Ending( e, target, d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen ( iteration < TABLE_STARTED )
                endloop
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        private function Target_Damage_Conditions takes Unit damageSource, integer damageSourceTypeId, Unit target returns boolean
            if ( CountIntegersInTableById( target.id, Target_SCOPE_ID ) < TABLE_STARTED ) then
                return false
            endif
            set TEMP_UNIT_SELF = damageSource.self
            if ( GetUnitState( TEMP_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MELEE_ATTACKER ) == false ) and ( IsUnitTypeMelee(damageSource.type) ) ) then
                return false
            endif
            if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
                return false
            endif
            if ( GetUnitInvulnerability( damageSource ) > 0 ) then
                return false
            endif
            if ( IsUnitIllusionWJ( target ) ) then
                return false
            endif
            return true
        endfunction

        public function Target_Damage takes real damageAmount, Unit damageSource, Unit target returns nothing
            local unit damageSourceSelf = damageSource.self
            if ( Target_Damage_Conditions( damageSource, GetUnitTypeId( damageSourceSelf ), target ) ) then
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( Target_SPECIAL_EFFECT_PATH, damageSourceSelf, Target_SPECIAL_EFFECT_ATTACHMENT_POINT ) )
                call UnitDamageUnitEx( target, damageSource, damageAmount * Target_REFLECTION_FACTOR, null )
            endif
            set damageSourceSelf = null
        endfunction

        private function Target_Damage_Event takes nothing returns nothing
            call Target_Damage( DAMAGE_AMOUNT, DAMAGE_SOURCE, TRIGGER_UNIT )
        endfunction

        public function Target_Start takes Data d, Unit target returns nothing
            local Target_Data e = Target_Data.create()
            local integer targetId = target.id
            set e.d = d
            call AddIntegerToTableById( targetId, Target_SCOPE_ID, e )
            if ( CountIntegersInTableById( targetId, Target_SCOPE_ID ) == TABLE_STARTED ) then
                set e.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DAMAGE" )
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY", "0", "function Target_Damage_Event" )
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_SPECIAL_EFFECT_PATH )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local effect casterEffect
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, Riposte_SCOPE_ID)
        local unit enumUnit
        local group targetGroup
        local timer updateTimer
        if ( d != NULL ) then
            set casterEffect = d.casterEffect
            set targetGroup = d.targetGroup
            set updateTimer = d.updateTimer
            call d.destroy()
            call FlushAttachedIntegerById( casterId, Riposte_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
            call DestroyEffectWJ( casterEffect )
            set casterEffect = null
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
            endloop
            call DestroyGroupWJ( targetGroup )
            set targetGroup = null
            call FlushAttachedInteger( updateTimer, Riposte_SCOPE_ID )
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes Unit caster, Data d, group targetGroup returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit enumUnit
        local real enumUnitX
        local real enumUnitY
        set casterSelf = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                call Target_Target_Start(d, GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, Riposte_SCOPE_ID)
        set updateTimer = null
        call Update( d.caster, d, d.targetGroup )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = Data.create()
        local group targetGroup = CreateGroupWJ()
        local timer updateTimer = CreateTimerWJ()
        set d.caster = caster
        set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT )
        set d.targetGroup = targetGroup
        set d.updateTimer = updateTimer
        call AttachIntegerById( casterId, Riposte_SCOPE_ID, d )
        //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
        call AttachInteger( updateTimer, Riposte_SCOPE_ID, d )
        call TimerStart( updateTimer, UPDATE_TIME, true, function UpdateByTimer )
        set updateTimer = null
        call Update( caster, d, targetGroup )
        set targetGroup = null
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Riposte.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Rust.j
//TESH.scrollpos=83
//TESH.alwaysfold=0
//! runtextmacro Scope("Rust")
    globals
        private constant integer ORDER_ID = 852189//OrderId( "cripple" )
        public constant integer SPELL_ID = 'A03J'

        private constant real BONUS_RELATIVE_ATTACK_RATE = -0.3
        private constant real BONUS_SPEED_RELATIVE = -0.2
        private constant real DURATION = 20.
        private constant real HERO_DURATION = 7.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Undead\\Cripple\\CrippleTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        real bonusSpeed
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local real bonusSpeed = d.bonusSpeed
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, Rust_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, Rust_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call AddUnitAttackRate( target, -BONUS_RELATIVE_ATTACK_RATE )
        call AddUnitSpeedBonus( target, -bonusSpeed )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, Rust_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Rust_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit target returns nothing
        local real duration
        local timer durationTimer
        local real newBonusSpeed = GetUnitSpeedTotal( target ) * BONUS_SPEED_RELATIVE
        local real oldBonusSpeed
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, Rust_SCOPE_ID)
        local boolean isNew = (d == NULL)
        local unit targetSelf = target.self
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger( durationTimer, Rust_SCOPE_ID, d )
            call AttachIntegerById( targetId, Rust_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        else
            set durationTimer = d.durationTimer
            set oldBonusSpeed = d.bonusSpeed
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.bonusSpeed = newBonusSpeed
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            call AddUnitAttackRate( target, BONUS_RELATIVE_ATTACK_RATE )
            call AddUnitSpeedBonus( target, newBonusSpeed )
        else
            call AddUnitSpeedBonus( target, newBonusSpeed - oldBonusSpeed )
        endif
        if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
            set duration = HERO_DURATION
        else
            set duration = DURATION
        endif
        set targetSelf = target.self
        call TimerStart( durationTimer, duration, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return ErrorStrings_NOT_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( CASTER.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_NEGATIVE", "0", "function Dispel_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Rust.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Sales.j
//TESH.scrollpos=348
//TESH.alwaysfold=0
//! runtextmacro Scope("Sales")
    globals
        public constant integer SPELL_ID = 'A02Z'

        private real array AREA_RANGE
        private real array BONUS_DAMAGE_RELATIVE
        private real array BONUS_DROP_RELATIVE
        public real array BONUS_GOLD_COIN_RELATIVE
        public real array BONUS_GOLD_COIN_RELATIVE_PER_INTELLIGENCE_POINT
        private constant string CASTER_EFFECT_PATH = "SalesAuraCaster.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        effect casterEffect
        group targetGroup
        timer updateTimer
    endstruct

    private function GetCasterData takes Unit caster returns Data
        return GetAttachedIntegerById(caster.id, Sales_SCOPE_ID)
    endfunction

    //! runtextmacro Scope("Target")
        globals
            private group Target_ENUM_GROUP
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\GeneralAuraTarget\\GeneralAuraTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            Data d
            real bonusDamage
            group casterGroup
            effect targetEffect
        endstruct

        private function Target_Ending takes Unit caster, group casterGroup, Data d, Target_Data e, integer oldAbilityLevel, real oldBonusDropRelative, Unit target, group targetGroup returns nothing
            local real bonusDamage
            local Unit enumUnit
            local unit enumUnitSelf
            local integer enumUnitAbilityLevel
            local integer iteration
            local integer newLevel
            local real oldBonusDamage
            local effect targetEffect
            local integer targetId
            call GroupRemoveUnit( casterGroup, caster.self )
            call GroupRemoveUnit( targetGroup, target.self )
            if (e.d == d) then
                set iteration = oldAbilityLevel - 1
                set oldBonusDamage = e.bonusDamage
                set enumUnitSelf = FirstOfGroup(casterGroup)
                if (enumUnitSelf == null) then
                    set targetEffect = e.targetEffect
                    set targetId = target.id
                    call e.destroy()
                    call DestroyGroupWJ(casterGroup)
                    call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
                    //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                    call DestroyEffectWJ( targetEffect )
                    set targetEffect = null
                    call AddUnitDamageBonus( target, -oldBonusDamage )
                    call AddUnitDropByKillRelativeBonus( target, oldBonusDropRelative )
                else
                    set newLevel = 0
                    loop
                        set enumUnit = GetUnit(enumUnitSelf)
                        set enumUnitAbilityLevel = GetCasterData(enumUnit).abilityLevel
                        call GroupRemoveUnit(casterGroup, enumUnitSelf)
                        if (enumUnitAbilityLevel > newLevel) then
                            set caster = enumUnit
                            set newLevel = enumUnitAbilityLevel
                        endif
                        call GroupAddUnit(Target_ENUM_GROUP, enumUnitSelf)
                        set enumUnitSelf = FirstOfGroup(casterGroup)
                        exitwhen (enumUnitSelf == null)
                    endloop
                    set enumUnitSelf = FirstOfGroup(Target_ENUM_GROUP)
                    loop
                        call GroupRemoveUnit(Target_ENUM_GROUP, enumUnitSelf)
                        call GroupAddUnit(casterGroup, enumUnitSelf)
                        set enumUnitSelf = FirstOfGroup(Target_ENUM_GROUP)
                        exitwhen (enumUnitSelf == null)
                    endloop
                    set bonusDamage = BONUS_DAMAGE_RELATIVE[newLevel] * GetUnitDamage( target )
                    set e.bonusDamage = bonusDamage
                    set e.d = GetCasterData(caster)
                    call AddUnitDamageBonus( target, bonusDamage - oldBonusDamage )
                    call AddUnitDropByKillRelativeBonus( target, BONUS_DROP_RELATIVE[newLevel] - oldBonusDropRelative )
                endif
            endif
        endfunction

        public function Target_EndingByEnding takes integer abilityLevel, real bonusDropRelative, Unit caster, Data d, Unit target, group targetGroup returns nothing
            local Target_Data e = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            call Target_Ending(caster, e.casterGroup, d, e, abilityLevel, bonusDropRelative, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local integer abilityLevel
            local Data d
            local Target_Data e = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            local group casterGroup = e.casterGroup
            local integer iteration
            if (e != NULL) then
                set iteration = CountUnits(casterGroup)
                loop
                    set d = e.d
                    set abilityLevel = d.abilityLevel
                    call Target_Ending( GetUnit(FirstOfGroup(casterGroup)), casterGroup, d, e, abilityLevel, BONUS_DROP_RELATIVE[abilityLevel], target, d.targetGroup )
                    set iteration = iteration - 1
                    exitwhen (iteration < 1)
                endloop
            endif
            set casterGroup = null
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes integer abilityLevel, real bonusDamageRelative, real bonusDropRelative, Unit caster, Data d, Unit target returns nothing
            local real bonusDamage = bonusDamageRelative * GetUnitDamage( target )
            local group casterGroup
            local integer oldAbilityLevel
            local real oldBonusDamage
            local integer targetId = target.id
            local Target_Data e = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
            local boolean isNew = (e == NULL)
            if (isNew) then
                set casterGroup = CreateGroupWJ()
                set e = Target_Data.create()
                set e.casterGroup = casterGroup
                set e.d = d
                set e.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
                call AttachIntegerById(targetId, Target_SCOPE_ID, e)
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            else
                set casterGroup = e.casterGroup
                set oldAbilityLevel = e.d.abilityLevel
                set oldBonusDamage = e.bonusDamage
            endif
            set e.bonusDamage = bonusDamage
            call GroupAddUnit(casterGroup, caster.self)
            set casterGroup = null
            if (isNew) then
                call AddUnitDamageBonus( target, bonusDamage )
                call AddUnitDropByKillRelativeBonus( target, bonusDropRelative )
            elseif (abilityLevel >= oldAbilityLevel) then
                set e.d = d
                call AddUnitDamageBonus( target, bonusDamage - oldBonusDamage )
                call AddUnitDropByKillRelativeBonus( target, bonusDropRelative - BONUS_DROP_RELATIVE[oldAbilityLevel] )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            set Target_ENUM_GROUP = CreateGroupWJ()
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local integer abilityLevel
        local real bonusDropRelative
        local effect casterEffect
        local Data d = GetAttachedIntegerById(caster.id, Sales_SCOPE_ID)
        local unit enumUnit
        local group targetGroup
        if ( d != NULL ) then
            set abilityLevel = d.abilityLevel
            set bonusDropRelative = BONUS_DROP_RELATIVE[abilityLevel]
            set casterEffect = d.casterEffect
            set targetGroup = d.targetGroup
            call DestroyEffectWJ( casterEffect )
            set casterEffect = null
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByEnding( abilityLevel, bonusDropRelative, caster, d, GetUnit(enumUnit), targetGroup )
            endloop
            set targetGroup = null
            call PauseTimer( d.updateTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitEnemy( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes integer abilityLevel, Unit caster, Data d, group targetGroup returns nothing
        local real bonusDamageRelative
        local real bonusDropRelative
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit enumUnit
        set casterSelf = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE[abilityLevel], TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            set bonusDropRelative = -BONUS_DROP_RELATIVE[abilityLevel]
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByEnding( abilityLevel, bonusDropRelative, caster, d, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            set bonusDamageRelative = BONUS_DAMAGE_RELATIVE[abilityLevel]
            set bonusDropRelative = BONUS_DROP_RELATIVE[abilityLevel]
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                call Target_Target_Start(abilityLevel, bonusDamageRelative, bonusDropRelative, caster, d, GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, Sales_SCOPE_ID)
        set updateTimer = null
        call Update( d.abilityLevel, d.caster, d, d.targetGroup )
    endfunction

    public function Revive takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Sales_SCOPE_ID)
        if ( d != NULL ) then
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT )
            call TimerStart( d.updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            call Update( d.abilityLevel, caster, d, d.targetGroup )
        endif
    endfunction

    private function Revive_Event takes nothing returns nothing
        call Revive( REVIVING_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel(casterSelf, SPELL_ID)
        local Data d = GetAttachedIntegerById(casterId, Sales_SCOPE_ID)
        local unit enumUnit
        local boolean isNew = ( d == NULL )
        local integer oldAbilityLevel
        local group targetGroup
        local timer updateTimer
        if ( isNew ) then
            set d = Data.create()
            set targetGroup = CreateGroupWJ()
            set updateTimer = CreateTimerWJ()
            set d.caster = caster
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
            set d.targetGroup = targetGroup
            set d.updateTimer = updateTimer
            call AttachIntegerById(casterId, Sales_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_REVIVE" )
            call AttachInteger(updateTimer, Sales_SCOPE_ID, d)
        else
            set oldAbilityLevel = d.abilityLevel
            set targetGroup = d.targetGroup
            set updateTimer = d.updateTimer
        endif
        set casterSelf = null
        set d.abilityLevel = abilityLevel
        if ( isNew ) then
            call TimerStart( updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            set updateTimer = null
        else
            set enumUnit = FirstOfGroup( targetGroup )
            if ( enumUnit != null ) then
                loop
                    call Target_Target_EndingByEnding(oldAbilityLevel, BONUS_DROP_RELATIVE[oldAbilityLevel], caster, d, GetUnit(enumUnit), targetGroup)
                    set enumUnit = FirstOfGroup( ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endif
        call Update( abilityLevel, caster, d, targetGroup )
        set targetGroup = null
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set AREA_RANGE[1] = 500
        set AREA_RANGE[2] = 500
        set AREA_RANGE[3] = 500
        set AREA_RANGE[4] = 500
        set AREA_RANGE[5] = 500
        set BONUS_DAMAGE_RELATIVE[1] = 0.03
        set BONUS_DAMAGE_RELATIVE[2] = 0.03
        set BONUS_DAMAGE_RELATIVE[3] = 0.03
        set BONUS_DAMAGE_RELATIVE[4] = 0.04
        set BONUS_DAMAGE_RELATIVE[5] = 0.04
        set BONUS_DROP_RELATIVE[1] = 0.2
        set BONUS_DROP_RELATIVE[2] = 0.25
        set BONUS_DROP_RELATIVE[3] = 0.29
        set BONUS_DROP_RELATIVE[4] = 0.33
        set BONUS_DROP_RELATIVE[5] = 0.36
        set BONUS_GOLD_COIN_RELATIVE[1] = 0.35
        set BONUS_GOLD_COIN_RELATIVE[2] = 0.6
        set BONUS_GOLD_COIN_RELATIVE[3] = 0.85
        set BONUS_GOLD_COIN_RELATIVE[4] = 1.1
        set BONUS_GOLD_COIN_RELATIVE[5] = 1.35
        set BONUS_GOLD_COIN_RELATIVE_PER_INTELLIGENCE_POINT[1] = 0.0166
        set BONUS_GOLD_COIN_RELATIVE_PER_INTELLIGENCE_POINT[2] = 0.0166
        set BONUS_GOLD_COIN_RELATIVE_PER_INTELLIGENCE_POINT[3] = 0.0166
        set BONUS_GOLD_COIN_RELATIVE_PER_INTELLIGENCE_POINT[4] = 0.0166
        set BONUS_GOLD_COIN_RELATIVE_PER_INTELLIGENCE_POINT[5] = 0.0166
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_REVIVE", "UnitFinishesReviving_EVENT_KEY", "0", "function Revive_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Sales.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SelfHeal.j
//TESH.scrollpos=67
//TESH.alwaysfold=0
//! runtextmacro Scope("SelfHeal")
    globals
        private constant integer ORDER_ID = 852146//OrderId( "eattree" )
        public constant integer RESEARCH_ID = 'R00R'
        public constant integer SPELL_ID = 'A031'

        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Human\\MarkOfChaos\\MarkOfChaosTarget.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private constant real DURATION = 5.
        private constant real INTERVAL = 1.
        private constant real REFRESHED_LIFE_PER_INTERVAL = 325 * INTERVAL / DURATION
    endglobals

    private struct Data
        Unit caster
        timer durationTimer
        timer intervalTimer
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local timer durationTimer = d.durationTimer
        local timer intervalTimer = d.intervalTimer
        call d.destroy()
        call FlushAttachedIntegerById( caster.id, SelfHeal_SCOPE_ID )
        call FlushAttachedInteger( durationTimer, SelfHeal_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( intervalTimer, SelfHeal_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, SelfHeal_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, SelfHeal_SCOPE_ID)
        set durationTimer = null
        call IssueImmediateOrderById(d.caster.self, STOP_ORDER_ID)
    endfunction

    private function Heal takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, SelfHeal_SCOPE_ID)
        local Unit caster = d.caster
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT ) )
        call HealUnitBySpell( caster, REFRESHED_LIFE_PER_INTERVAL )
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        set d.caster = caster
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        call AttachIntegerById( caster.id, SelfHeal_SCOPE_ID, d )
        call AttachInteger( durationTimer, SelfHeal_SCOPE_ID, d )
        call AttachInteger( intervalTimer, SelfHeal_SCOPE_ID, d )
        call TimerStart( intervalTimer, INTERVAL, true, function Heal )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        call InitEffectType( CASTER_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SelfHeal.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ShadowMeld.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("ShadowMeld")
    globals
        public constant integer RESEARCH_ID = 'R01F'
        public constant integer SPELL_ID = 'A07L'
    endglobals

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ShadowMeld.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ShockWave.j
//TESH.scrollpos=123
//TESH.alwaysfold=0
//! runtextmacro Scope("ShockWave")
    globals
        private constant integer ORDER_ID = 852125//OrderId( "shockwave" )
        public constant integer SPELL_ID = 'A077'

        private constant real AREA_RANGE = 150
        private constant real DAMAGE = 140
        private constant integer DUMMY_UNIT_ID = 'n02P'
        private group ENUM_GROUP
        private constant real MAX_LENGTH = 700
        private constant real SPEED = 1000
        private constant real DURATION = MAX_LENGTH / SPEED
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        Unit caster
        unit dummyUnit
        timer durationTimer
        real lengthX
        real lengthY
        timer intervalTimer
        group targetGroup
    endstruct

    private function Ending takes Data d, unit dummyUnit, timer durationTimer, timer intervalTimer, group targetGroup returns nothing
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 2 )
        call RemoveUnitTimed( dummyUnit, 0.5 )
        call FlushAttachedInteger( durationTimer, ShockWave_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( intervalTimer, ShockWave_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        call DestroyGroupWJ( targetGroup )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, ShockWave_SCOPE_ID)
        call Ending( d, d.dummyUnit, durationTimer, d.intervalTimer, d.targetGroup )
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
        if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
            return false
        endif
        if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function Move takes nothing returns nothing
        local unit enumUnit
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, ShockWave_SCOPE_ID)
        local Unit caster = d.caster
        local unit dummyUnit = d.dummyUnit
        local real newX = GetUnitX( dummyUnit ) + d.lengthX
        local real newY = GetUnitY( dummyUnit ) + d.lengthY
        local boolean isEnding = IsTerrainPathable( newX, newY, PATHING_TYPE_WALKABILITY )
        local group targetGroup = d.targetGroup
        if ( isEnding == false ) then
            call SetUnitXWJ( dummyUnit, newX )
            call SetUnitYWJ( dummyUnit, newY )
        endif
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, newX, newY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                if ( IsUnitInGroup( enumUnit, targetGroup ) == false ) then
                    call GroupAddUnit( targetGroup, enumUnit )
                    call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), DAMAGE )
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
        if ( isEnding ) then
            call Ending( d, dummyUnit, d.durationTimer, intervalTimer, targetGroup )
        endif
        set dummyUnit = null
        set intervalTimer = null
        set targetGroup = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local real angle
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d = Data.create()
        local unit dummyUnit
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        if ( ( casterX != targetX ) or ( casterY != targetY ) ) then
            set angle = Atan2( targetY - casterY, targetX - casterX )
        else
            set angle = GetUnitFacingWJ( casterSelf )
        endif
        set casterSelf = null
        set d.caster = caster
        set d.dummyUnit = CreateUnitWJ( caster.owner, DUMMY_UNIT_ID, casterX, casterY, angle )
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        set d.lengthX = LENGTH * Cos(angle)
        set d.lengthY = LENGTH * Sin(angle)
        set d.targetGroup = CreateGroupWJ()
        call AttachInteger( durationTimer, ShockWave_SCOPE_ID, d )
        call AttachInteger( intervalTimer, ShockWave_SCOPE_ID, d )
        call TimerStart( intervalTimer, UPDATE_TIME, true, function Move )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ShockWave.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SilverSpores.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("SilverSpores")
    globals
        private constant integer ORDER_ID = 852069//OrderId( "invisibility" )
        public constant integer SPELL_ID = 'A03F'

        private constant real BONUS_ALPHA = -127.
        private constant real DURATION = 30.
        private constant real FADE_TIME = 1.
        private constant real HERO_DURATION = 10.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\NightElf\\FaerieDragonInvis\\FaerieDragon_Invis.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
    endglobals

    private struct Data
        timer dummyTimer
        boolean isInvisible
        Unit target
    endstruct

    private function Ending takes Data d, timer dummyTimer, Unit target returns nothing
        local boolean isInvisible = d.isInvisible
        local integer targetId = target.id
        call FlushAttachedInteger( dummyTimer, SilverSpores_SCOPE_ID )
        call DestroyTimerWJ( dummyTimer )
        call FlushAttachedIntegerById( targetId, SilverSpores_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        if (isInvisible) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
            call RemoveUnitInvisibility( target )
        else
            call RemoveUnitAttackSilence(target)
        endif
        call AddUnitVertexColorTimed( target, 0, 0, 0, -BONUS_ALPHA, null, FADE_TIME )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById( target.id, SilverSpores_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( d, d.dummyTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Attack takes Unit target returns nothing
        call Dispel( target )
    endfunction

    public function BeginCast takes Unit target returns nothing
        call Dispel( target )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer dummyTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(dummyTimer, SilverSpores_SCOPE_ID)
        call Ending( d, dummyTimer, d.target )
        set dummyTimer = null
    endfunction

    private function SetInvisible takes nothing returns nothing
        local timer dummyTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(dummyTimer, SilverSpores_SCOPE_ID)
        local real duration
        local Unit target = d.target
        call RemoveUnitAttackSilence(target)
        set d.isInvisible = true
        //! runtextmacro AddEventById( "target.id", "EVENT_DISPEL" )
        call AddUnitInvisibility( target )
        if ( IsUnitType( target.self, UNIT_TYPE_HERO ) ) then
            set duration = HERO_DURATION
        else
            set duration = DURATION
        endif
        call TimerStart( dummyTimer, duration, false, function EndingByTimer )
        set dummyTimer = null
    endfunction

    public function SpellEffect takes Unit target returns nothing
        local timer dummyTimer
        local real duration
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, SilverSpores_SCOPE_ID)
        local unit targetSelf = target.self
        call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
        if ( d == NULL ) then
            set d = Data.create()
            set dummyTimer = CreateTimerWJ()
            set d.dummyTimer = dummyTimer
            set d.isInvisible = false
            set d.target = target
            call AttachInteger( dummyTimer, SilverSpores_SCOPE_ID, d )
            call AttachIntegerById( targetId, SilverSpores_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            call AddUnitAttackSilence(target)
            call AddUnitVertexColorTimed( target, 0, 0, 0, BONUS_ALPHA, null, FADE_TIME )
            call TimerStart( dummyTimer, FADE_TIME, false, function SetInvisible )
        elseif (d.isInvisible) then
            set dummyTimer = d.dummyTimer
            if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
                set duration = HERO_DURATION
            else
                set duration = DURATION
            endif
            call TimerStart( dummyTimer, duration, false, function EndingByTimer )
        endif
        set dummyTimer = null
        if ( GetUnitCurrentOrder( targetSelf ) == ATTACK_ORDER_ID ) then
            call IssueImmediateOrderById(targetSelf, STOP_ORDER_ID)
        endif
        set targetSelf = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( TARGET_UNIT )
    endfunction

    public function Order takes player casterOwner, Unit target returns string
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) == false ) then
            return ErrorStrings_ONLY_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitWard( target ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SilverSpores.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Slam.j
//TESH.scrollpos=135
//TESH.alwaysfold=0
//! runtextmacro Scope("Slam")
    globals
        public constant integer ORDER_ID = 852127//OrderId("stomp")
        public constant integer RESEARCH_ID = 'R01K'
        public constant integer SPELL_ID = 'A08B'

        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Orc\\WarStomp\\WarStompCaster.mdl"
        private constant real AREA_RANGE = 175.
        private constant real BONUS_RELATIVE_SPEED = -0.5
        private constant real DAMAGE = 30.
        private constant real DURATION = 7.5
        private group ENUM_GROUP
        private constant real HERO_DURATION = 4.
        private constant real RELATIVE_BONUS_ATTACK_RATE = -0.5
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Orc\\StasisTrap\\StasisTotemTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "overhead"
    endglobals

    private struct Data
        real bonusSpeed
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local real bonusSpeed = d.bonusSpeed
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, Slam_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, Slam_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call AddUnitAttackRate( target, -RELATIVE_BONUS_ATTACK_RATE )
        call AddUnitSpeedBonus( target, -bonusSpeed )
    endfunction

    public function Death takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, Slam_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Slam_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    private function StartTarget takes Unit caster, Unit target returns nothing
        local real bonusSpeed = GetUnitSpeed( target ) * BONUS_RELATIVE_SPEED
        local real duration
        local timer durationTimer
        local real oldBonusSpeed
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById( targetId, Slam_SCOPE_ID )
        local boolean isNew = (d == NULL)
        local unit targetSelf = target.self
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger( durationTimer, Slam_SCOPE_ID, d )
            call AttachIntegerById( targetId, Slam_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        else
            set durationTimer = d.durationTimer
            set oldBonusSpeed = d.bonusSpeed
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.bonusSpeed = bonusSpeed
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            call AddUnitAttackRate( target, RELATIVE_BONUS_ATTACK_RATE )
            call AddUnitSpeedBonus( target, bonusSpeed )
        else
            call AddUnitSpeedBonus( target, bonusSpeed - oldBonusSpeed )
        endif
        if (IsUnitType(targetSelf, UNIT_TYPE_HERO)) then
            set duration = HERO_DURATION
        else
            set duration = DURATION
        endif
        set targetSelf = null
        call TimerStart( durationTimer, duration, false, function EndingByTimer )
        set durationTimer = null
        call UnitDamageUnitEx( caster, target, DAMAGE, null )
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit enumUnit
        set casterSelf = null
        call DestroyEffectWJ( AddSpecialEffectWJ( AREA_EFFECT_PATH, casterX, casterY ) )
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if (enumUnit != null) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call StartTarget(caster, GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Slam.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SlowPoison.j
//TESH.scrollpos=154
//TESH.alwaysfold=0
//! runtextmacro Scope("SlowPoison")
    globals
        public constant integer RESEARCH_ID = 'R01L'
        public constant integer SPELL_ID = 'A03O'

        private constant real BONUS_RELATIVE_SPEED = -0.25
        private constant real DURATION = 10.
        private constant real INTERVAL = 1.
        private constant real DAMAGE_PER_INTERVAL = 50 * INTERVAL / DURATION
        private constant real RELATIVE_BONUS_ATTACK_RATE = -0.25
        private constant string TARGET_EFFECT_PATH = "Abilities\\Weapons\\PoisonSting\\PoisonStingTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        real bonusSpeed
        Unit caster
        timer durationTimer
        timer intervalTimer
        Unit target
        effect targetEffect
    endstruct

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId = caster.id
        if (GetAttachedBooleanById(casterId, SlowPoison_SCOPE_ID)) then
            call FlushAttachedBooleanById(casterId, SlowPoison_SCOPE_ID)
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( TRIGGER_UNIT )
    endfunction

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local real bonusSpeed = d.bonusSpeed
        local timer intervalTimer = d.intervalTimer
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, SlowPoison_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedInteger( intervalTimer, SlowPoison_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
        call FlushAttachedIntegerById( targetId, SlowPoison_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call AddUnitAttackRate( target, -RELATIVE_BONUS_ATTACK_RATE )
        call AddUnitSpeedBonus( target, -bonusSpeed )
    endfunction

    public function Death takes Unit target returns nothing
        local Data d = GetAttachedIntegerById( target.id, SlowPoison_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, SlowPoison_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function Interval takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, SlowPoison_SCOPE_ID)
        local Unit target = d.target
        set intervalTimer = null
        call UnitDamageUnitEx( d.caster, target, Min( DAMAGE_PER_INTERVAL, GetUnitState( target.self, UNIT_STATE_LIFE ) - LIMIT_OF_IMMORTALS ), null )
    endfunction

    private function Damage_TargetConditions takes Unit caster, player casterOwner, Unit target returns boolean
        if ( GetAttachedBooleanById( caster.id, SlowPoison_SCOPE_ID ) == false ) then
            return false
        endif
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if (GetUnitInvulnerability(target) > 0) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, Unit target returns nothing
        local real bonusSpeed
        local Data d
        local timer durationTimer
        local timer intervalTimer
        local boolean isNew
        local real oldBonusSpeed
        local integer targetId
        local unit targetSelf
        if ( Damage_TargetConditions( caster, caster.owner, target ) ) then
            set bonusSpeed = BONUS_RELATIVE_SPEED * GetUnitSpeed(target)
            set targetId = target.id
            set d = GetAttachedIntegerById( targetId, SlowPoison_SCOPE_ID )
            set targetSelf = target.self
            set isNew = ( d == NULL )
            if ( isNew ) then
                set d = Data.create()
                set durationTimer = CreateTimerWJ()
                set intervalTimer = CreateTimerWJ()
                set d.bonusSpeed = bonusSpeed
                set d.durationTimer = durationTimer
                set d.intervalTimer = intervalTimer
                set d.target = target
                call AttachInteger( durationTimer, SlowPoison_SCOPE_ID, d )
                call AttachInteger( intervalTimer, SlowPoison_SCOPE_ID, d )
                call AttachIntegerById( targetId, SlowPoison_SCOPE_ID, d )
                //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
                call TimerStart( intervalTimer, INTERVAL, true, function Interval )
            else
                set durationTimer = d.durationTimer
                call DestroyEffectWJ( d.targetEffect )
            endif
            set d.caster = caster
            set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
            set targetSelf = null
            if (isNew) then
                call AddUnitAttackRate( target, RELATIVE_BONUS_ATTACK_RATE )
                call AddUnitSpeedBonus( target, bonusSpeed )
            else
                set oldBonusSpeed = d.bonusSpeed
                if (bonusSpeed != oldBonusSpeed) then
                    set d.bonusSpeed = bonusSpeed
                    call AddUnitSpeedBonus( target, bonusSpeed - oldBonusSpeed )
                endif
            endif
            call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
            set durationTimer = null
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, SlowPoison_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call SetAbilityRequiredResearch( SPELL_ID, RESEARCH_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SlowPoison.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SoulVessel.j
//TESH.scrollpos=249
//TESH.alwaysfold=0
//! runtextmacro Scope("SoulVessel")
    globals
        public constant integer SPELL_ID = 'A06V'

        private constant real BONUS_RELATIVE_DAMAGE_BY_SPELL_PER_VESSEL = 0.1
        private constant real HEIGHT = 15.
        private constant real HEIGHT_WINDOW = 15.
        private constant integer MAX_VESSELS_AMOUNT = 3
        private constant real ANGLE_GAP = 2 * PI / MAX_VESSELS_AMOUNT
        private constant real OFFSET = 125.
        private constant real PERIOD_FACTOR = 0.5
        private constant real RELATIVE_REFRESHED_LIFE_PER_VESSEL = 0.1
        private constant real UPDATE_TIME = 0.035
        private constant real ANGLE_ADD = PI / 4 * UPDATE_TIME
    endglobals

    private struct Data
        real angle
        Unit caster
        timer moveTimer
        Unit array vessels[MAX_VESSELS_AMOUNT]
        integer vesselsAmount
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local integer casterId = caster.id
        local timer moveTimer = d.moveTimer
        call d.destroy()
        call FlushAttachedIntegerById( casterId, SoulVessel_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_CAST" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_CASTER_DEATH" )
        call FlushAttachedInteger( moveTimer, SoulVessel_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        set moveTimer = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer amount
        local unit casterSelf
        local integer count
        local integer iteration
        local Data d = GetAttachedIntegerById(caster.id, SoulVessel_SCOPE_ID)
        local Unit vessel
        local Unit array vessels
        if (d != NULL) then
            set casterSelf = caster.self
            set count = -1
            set iteration = MAX_VESSELS_AMOUNT
            loop
                set vessel = d.vessels[iteration]
                if (vessel != NULL) then
                    set count = count + 1
                    set vessels[count] = vessel
                endif
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            set iteration = count
            loop
                call KillUnit(vessels[iteration].self)
                set iteration = iteration - 1
                exitwhen (iteration < 0)
            endloop
            call AddUnitState(casterSelf, UNIT_STATE_LIFE, (count + 1) * RELATIVE_REFRESHED_LIFE_PER_VESSEL * GetUnitState(casterSelf, UNIT_STATE_MAX_LIFE))
            set casterSelf = null
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Move takes real angle, real casterX, real casterY, Unit vessel returns nothing
        local real newX = casterX + OFFSET * Cos( angle )
        local real newY = casterY + OFFSET * Sin( angle )
        local unit vesselSelf = vessel.self
        call SetUnitFacingWJ( vesselSelf, angle )
        call SetUnitX( vesselSelf, newX )
        call SetUnitY( vesselSelf, newY )
        call SetUnitZ( vesselSelf, newX, newY, HEIGHT + HEIGHT_WINDOW * Sin( PERIOD_FACTOR * angle ) )
        set vesselSelf = null
    endfunction

    //! runtextmacro Scope("Vessel")
        private struct Vessel_Data
            Data d
            integer index
        endstruct

        public function Vessel_RemoveVessel takes Data d, integer index returns nothing
            set d.vessels[index] = NULL
        endfunction

        public function Vessel_Death takes Unit vessel returns nothing
            local Data d
            local Unit caster
            local integer index
            local integer newAmount
            local integer vesselId = vessel.id
            local Vessel_Data e = GetAttachedIntegerById(vesselId, Vessel_SCOPE_ID)
            if ( e != NULL ) then
                set d = e.d
                set caster = d.caster
                set index = e.index
                call e.destroy()
                set newAmount = d.vesselsAmount - 1
                call Vessel_RemoveVessel( d, index )
                call FlushAttachedIntegerById( vesselId, Vessel_SCOPE_ID )
                //! runtextmacro RemoveEventById( "vesselId", "Vessel_EVENT_DEATH" )
                if ( newAmount == 0 ) then
                    call Ending( caster, d )
                else
                    set d.vesselsAmount = newAmount
                endif
                call AddUnitDamageBySpellBonus( caster, -BONUS_RELATIVE_DAMAGE_BY_SPELL_PER_VESSEL )
            endif
        endfunction

        private function Vessel_Death_Event takes nothing returns nothing
            call Vessel_Death( DYING_UNIT )
        endfunction

        public function Vessel_Start takes Unit caster, player casterOwner, Data d, boolean isNew, integer vesselsAmount returns nothing
            local real angle
            local unit casterSelf = caster.self
            local real casterX = GetUnitX( casterSelf )
            local real casterY = GetUnitY( casterSelf )
            local Vessel_Data e = Vessel_Data.create()
            local integer iteration
            local Unit vessel
            local integer vesselId
            set casterSelf = null
            if ( isNew ) then
                set angle = 0
                set iteration = 0
            else
                set angle = d.angle
                set iteration = vesselsAmount - 1
                loop
                    exitwhen (d.vessels[iteration] == NULL)
                    set iteration = iteration - 1
                endloop
            endif
            set angle = angle + iteration * ANGLE_GAP
            set vessel = CreateUnitEx( casterOwner, SOUL_VESSEL_UNIT_ID, 0, 0, angle )
            set vesselId = vessel.id
            set d.vessels[iteration] = vessel
            set d.vesselsAmount = vesselsAmount
            set e.d = d
            set e.index = iteration
            call AttachIntegerById( vesselId, Vessel_SCOPE_ID, e )
            //! runtextmacro AddEventById( "vesselId", "Vessel_EVENT_DEATH" )
            call SetUnitPathing( vessel.self, false )
            call Move( angle, casterX, casterY, vessel )
        endfunction

        public function Vessel_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Vessel_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Vessel_Death_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Caster_Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, SoulVessel_SCOPE_ID)
        local integer iteration
        local Unit specificVessel
        local Unit array vessels
        local integer vesselsAmount
        if ( d != NULL ) then
            set iteration = 0
            set vesselsAmount = d.vesselsAmount
            loop
                set vessels[iteration] = d.vessels[iteration]
                set iteration = iteration + 1
                exitwhen (iteration >= vesselsAmount)
            endloop
            set iteration = 0
            loop
                set specificVessel = vessels[iteration]
                if (specificVessel != NULL) then
                    call KillUnit( specificVessel.self )
                endif
                set iteration = iteration + 1
                exitwhen ( iteration >= vesselsAmount )
            endloop
        endif
    endfunction

    private function Caster_Death_Event takes nothing returns nothing
        call Caster_Death( DYING_UNIT )
    endfunction

    private function MoveByTimer takes nothing returns nothing
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, SoulVessel_SCOPE_ID)
        local real angle = d.angle + ANGLE_ADD
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local integer iteration = MAX_VESSELS_AMOUNT - 1
        local Unit vessel
        set casterSelf = null
        set moveTimer = null
        set d.angle = angle
        loop
            set vessel = d.vessels[iteration]
            if (vessel != NULL) then
                call Move( angle, casterX, casterY, vessel )
            endif
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
            set angle = angle + ANGLE_GAP
        endloop
    endfunction

    private function TargetConditions takes unit caster, player casterOwner, Unit source returns boolean
        if ( GetUnitAbilityLevel( caster, SPELL_ID ) <= 0 ) then
            return false
        endif
        if ( GetUnitState( caster, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( source.self, casterOwner ) ) then
            return false
        endif
        if ( IsUnitIllusionWJ( source ) ) then
            return false
        endif
        return true
    endfunction

    public function TryGeneratingVessel takes Unit caster, player casterOwner returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, SoulVessel_SCOPE_ID)
        local boolean isNew = (d == NULL)
        local timer moveTimer
        local integer vesselsAmount
        if (isNew) then
            set d = Data.create()
            set moveTimer = CreateTimerWJ()
            set vesselsAmount = 1
            set d.caster = caster
            set d.moveTimer = moveTimer
            call AttachIntegerById(casterId, SoulVessel_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_CAST" )
            //! runtextmacro AddEventById( "casterId", "EVENT_CASTER_DEATH" )
            call AttachInteger(moveTimer, SoulVessel_SCOPE_ID, d)
            call TimerStart( moveTimer, UPDATE_TIME, true, function MoveByTimer )
            set moveTimer = null
        else
            set vesselsAmount = d.vesselsAmount + 1
        endif
        if ( vesselsAmount <= MAX_VESSELS_AMOUNT ) then
            set d.vesselsAmount = vesselsAmount
            call AddUnitDamageBySpellBonus( caster, BONUS_RELATIVE_DAMAGE_BY_SPELL_PER_VESSEL )
            call Vessel_Vessel_Start(caster, casterOwner, d, isNew, vesselsAmount)
        endif
    endfunction

    public function Source_Death takes Unit caster, player casterOwner, Unit source returns nothing
        if ( TargetConditions( caster.self, casterOwner, source ) ) then
            call TryGeneratingVessel( caster, casterOwner )
        endif
    endfunction

    private function Source_Death_Event takes nothing returns nothing
        call Source_Death( KILLING_UNIT, KILLING_UNIT.owner, DYING_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        //! runtextmacro AddEventById( "caster.id", "EVENT_SOURCE_DEATH" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_CAST", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        //! runtextmacro CreateEvent( "EVENT_CASTER_DEATH", "UnitDies_EVENT_KEY", "0", "function Caster_Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_SOURCE_DEATH", "UnitDies_EVENT_KEY_AS_KILLING_UNIT", "0", "function Source_Death_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Vessel_Vessel_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SoulVessel.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SpellDisconnection.j
//TESH.scrollpos=213
//TESH.alwaysfold=0
//! runtextmacro Scope("SpellDisconnection")
    private struct Data
        integer abilityLevel
        Unit caster
        unit dummyUnit
        real duration
        integer gold
        integer goldPerBuff
        real heroDuration
        integer jumpsAmount
        timer moveTimer
        Unit target
        real targetX
        real targetY
        real targetZ
        group targetGroup
        boolean targetsAreAllied
        real x
        real y
        real z
    endstruct

    globals
        private constant integer ORDER_ID = 852665//OrderId( "transmute" )
        public constant integer SPELL_ID = 'A01X'

        private constant real AREA_RANGE = 500
        private trigger CHOOSE_TRIGGER
        private constant real DAMAGE_SUMMON = 400.
        private constant integer DUMMY_UNIT_ID = 'h00K'
        private real array DURATION
        private real array DURATION_PER_INTELLIGENCE_POINT
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private integer array GOLD
        private integer array GOLD_PER_INTELLIGENCE_POINT
        private integer array GOLD_PER_BUFF
        private integer array GOLD_PER_BUFF_PER_INTELLIGENCE_POINT
        private real array HERO_DURATION
        private real array HERO_DURATION_PER_INTELLIGENCE_POINT
        private integer array MAX_TARGETS_AMOUNT
        private constant real SPEED = 400.
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 0.035
        private constant real LENGTH = SPEED * UPDATE_TIME

        private Data chooseTriggerD
    endglobals

    private function Ending takes Data d, unit dummyUnit, timer moveTimer, group targetGroup returns nothing
        call d.destroy()
        call SetUnitAnimationByIndex( dummyUnit, 2 )
        call RemoveUnitTimed( dummyUnit, 1 )
        call FlushAttachedReal( moveTimer, SpellDisconnection_SCOPE_ID )
        call DestroyTimerWJ( moveTimer )
        call DestroyGroupWJ( targetGroup )
    endfunction

    private function EndTarget takes Data d, Unit target returns nothing
        local integer targetId = target.id
        call RemoveIntegerFromTableById( targetId, SpellDisconnection_SCOPE_ID, d )
        if ( CountIntegersInTableById( targetId, SpellDisconnection_SCOPE_ID ) == TABLE_EMPTY ) then
            //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        endif
    endfunction

    private function Death_ResetTarget takes Data d, Unit target, real targetX, real targetY, real targetZ returns nothing
        set d.target = NULL
        set d.targetX = targetX
        set d.targetY = targetY
        set d.targetZ = targetZ
        call EndTarget(d, target)
    endfunction

    public function Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
        local integer targetId = target.id
        local integer iteration = CountIntegersInTableById( targetId, SpellDisconnection_SCOPE_ID )
        if ( iteration > TABLE_EMPTY ) then
            loop
                call Death_ResetTarget( GetIntegerFromTableById( targetId, SpellDisconnection_SCOPE_ID, iteration ), target, targetX, targetY, targetZ )
                set iteration = iteration - 1
                exitwhen ( iteration < TABLE_STARTED )
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        local real dyingUnitX = GetUnitX(dyingUnitSelf)
        local real dyingUnitY = GetUnitY(dyingUnitSelf)
        call Death( DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY) )
        set dyingUnitSelf = null
    endfunction

    private function TargetConditions_Single takes Unit checkingUnit, boolean targetsAreAllied returns string
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_MECHANICAL ) and ( targetsAreAllied == false ) ) then
            return ErrorStrings_NOT_ENEMY_MECHANICAL
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( GetUnitInvulnerability( checkingUnit ) > 0 ) then
            return ErrorStrings_TARGET_IS_INVULNERABLE
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) != TEMP_BOOLEAN ) then
            return false
        endif
        if ( IsUnitInGroup( FILTER_UNIT_SELF, TEMP_GROUP ) ) then
            return false
        endif
        if ( TargetConditions_Single( GetUnit(FILTER_UNIT_SELF), TEMP_BOOLEAN ) != null ) then
            return false
        endif
        return true
    endfunction

    private function Move takes nothing returns nothing
        local integer abilityLevel
        local real angleXY
        local real angleYZ
        local Unit caster
        local player casterOwner
        local real distance
        local texttag dropTextTag
        local real duration
        local unit enumUnit
        local boolean found
        local integer gold
        local integer goldPerBuff
        local integer jumpsAmount
        local real lengthXY
        local timer moveTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(moveTimer, SpellDisconnection_SCOPE_ID)
        local unit dummyUnit = d.dummyUnit
        local boolean reachesTarget
        local Unit target = d.target
        local boolean isTargetNull = (target == NULL)
        local boolean targetsAreAllied
        local boolean targetsAreNotAllied
        local unit targetSelf
        local real targetX
        local real targetY
        local real targetZ
        local real x = d.x
        local real y = d.y
        local real z = d.z
        if ( isTargetNull ) then
            set targetX = d.targetX
            set targetY = d.targetY
            set targetZ = d.targetZ
        else
            set targetSelf = target.self
            set targetX = GetUnitX( targetSelf )
            set targetY = GetUnitY( targetSelf )
            set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
        endif
        set distance = DistanceByCoordinatesWithZ( x, y, z, targetX, targetY, targetZ )
        set reachesTarget = ( distance <= LENGTH )
        if ( reachesTarget ) then
            set x = targetX
            set y = targetY
            set z = targetZ
        else
            set angleXY = Atan2( targetX - x, DistanceByCoordinates( y, z, targetY, targetZ ) )
            set angleYZ = Atan2( targetZ - z, targetY - y )
            set lengthXY = Cos( angleXY )
            set x = x + LENGTH * Sin( angleXY )
            set y = y + LENGTH * Cos( angleYZ ) * lengthXY
            set z = z + LENGTH * Sin( angleYZ ) * lengthXY
        endif
        call SetUnitX( dummyUnit, x )
        call SetUnitY( dummyUnit, y )
        call SetUnitZ( dummyUnit, x, y, z )
        if ( reachesTarget ) then
            set abilityLevel = d.abilityLevel
            set caster = d.caster
            set casterOwner = caster.owner
            set gold = d.gold
            set goldPerBuff = d.goldPerBuff
            set jumpsAmount = d.jumpsAmount + 1
            set targetsAreAllied = d.targetsAreAllied
            if ( jumpsAmount >= MAX_TARGETS_AMOUNT[abilityLevel] ) then
                call Ending( d, dummyUnit, moveTimer, d.targetGroup )
            else
                set d.x = x
                set d.y = y
                set d.z = z
                set chooseTriggerD = d
                call RunTrigger(CHOOSE_TRIGGER)
            endif
            if (isTargetNull == false) then
                call EndTarget(d, target)
                if ( TargetConditions_Single( target, targetsAreAllied ) == null ) then
                    set targetsAreNotAllied = ( targetsAreAllied == false )
                    call PlaySoundFromTypeAtPosition( SPELL_DISCONNECTION_IMPACT_SOUND_TYPE, x, y, z )
                    if ( targetsAreAllied ) then
                        set gold = gold + R2I( CountUnitDispelableBuffs( target, targetsAreNotAllied, targetsAreAllied ) * goldPerBuff )
                        set dropTextTag = CreateRisingTextTag( "+" + I2S( gold ), 0.023, targetX, targetY, targetZ, 80, 255, 204, 0, 255, 0, 3 )
                        call AddPlayerState( casterOwner, PLAYER_STATE_RESOURCE_GOLD, gold )
                        if ( dropTextTag != null ) then
                            call LimitTextTagVisibilityToPlayer( dropTextTag, casterOwner )
                            set dropTextTag = null
                        endif
                    else
                        if ( IsUnitIllusionWJ( target ) ) then
                            call KillUnit( targetSelf )
                        else
                            call DispelUnit( target, targetsAreAllied, targetsAreNotAllied, true )
                            if ( targetsAreNotAllied ) then
                                if ( IsUnitType( targetSelf, UNIT_TYPE_HERO ) ) then
                                    set duration = HERO_DURATION[abilityLevel]
                                else
                                    set duration = DURATION[abilityLevel]
                                endif
                                call SetUnitStunTimed( target, 1, duration )
                            endif
                            if (IsUnitType( targetSelf, UNIT_TYPE_SUMMONED )) then
                                call UnitDamageUnitBySpell(caster, target, DAMAGE_SUMMON)
                            endif
                        endif
                    endif
                endif
            endif
            set casterOwner = null
        else
            set d.x = x
            set d.y = y
            set d.z = z
        endif
        set dummyUnit = null
        set moveTimer = null
        set targetSelf = null
    endfunction

    private function StartTarget takes Data d, Unit target, group targetGroup returns nothing
        local integer targetId = target.id
        set d.target = target
        call AddIntegerToTableById( targetId, SpellDisconnection_SCOPE_ID, d )
        if (CountIntegersInTableById(targetId, SpellDisconnection_SCOPE_ID) == TABLE_STARTED) then
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
        endif
        call GroupAddUnit( targetGroup, target.self )
    endfunction

    private function ChooseTrig takes nothing returns nothing
        local Data d = chooseTriggerD
        local Unit caster = d.caster
        local integer currentDispelableBuffsAmount
        local unit enumUnit
        local integer enumUnitDispelableBuffsAmount
        local boolean found
        local group targetGroup = d.targetGroup
        local boolean targetsAreAllied = d.targetsAreAllied
        local boolean targetsAreNotAllied
        local real x = d.x
        local real y = d.y
        set TEMP_BOOLEAN = targetsAreAllied
        set TEMP_GROUP = targetGroup
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, x, y, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit == null ) then
            call Ending( d, d.dummyUnit, d.moveTimer, targetGroup )
        else
            set found = false
            set targetsAreNotAllied = (targetsAreAllied == false)
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call GroupAddUnit( ENUM_GROUP2, enumUnit )
                set enumUnitDispelableBuffsAmount = CountUnitDispelableBuffs( GetUnit(enumUnit), targetsAreNotAllied, targetsAreAllied )
                if ( found == false ) then
                    set currentDispelableBuffsAmount = enumUnitDispelableBuffsAmount
                    set found = true
                elseif ( enumUnitDispelableBuffsAmount > currentDispelableBuffsAmount ) then
                    set currentDispelableBuffsAmount = enumUnitDispelableBuffsAmount
                endif
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
            loop
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                if ( CountUnitDispelableBuffs( GetUnit(enumUnit), targetsAreNotAllied, targetsAreAllied ) == currentDispelableBuffsAmount ) then
                    call GroupAddUnit( ENUM_GROUP, enumUnit )
                endif
            endloop
            set enumUnit = GetNearestUnit( ENUM_GROUP, x, y )
            call StartTarget(d, GetUnit(enumUnit), targetGroup)
            set d.jumpsAmount = d.jumpsAmount + 1
            set enumUnit = null
        endif
        set targetGroup = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local real casterIntelligence = GetHeroIntelligenceTotal( caster )
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local real casterZ = GetUnitZ( casterSelf, casterX, casterY ) + GetUnitOutpactZ(caster)
        local Data d = Data.create()
        local timer moveTimer = CreateTimerWJ()
        local group targetGroup = CreateGroupWJ()
        local unit targetSelf = target.self
        local real targetX = GetUnitX( targetSelf )
        local real targetY = GetUnitY( targetSelf )
        local real angle = Atan2( targetY - casterY, targetX - casterX )
        local unit dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, DUMMY_UNIT_ID, casterX, casterY, angle )
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.dummyUnit = dummyUnit
        set d.duration = DURATION[abilityLevel] + casterIntelligence * DURATION_PER_INTELLIGENCE_POINT[abilityLevel]
        set d.gold = R2I( GOLD[abilityLevel] + casterIntelligence * GOLD_PER_INTELLIGENCE_POINT[abilityLevel] )
        set d.goldPerBuff = R2I( GOLD_PER_BUFF[abilityLevel] + casterIntelligence * GOLD_PER_BUFF_PER_INTELLIGENCE_POINT[abilityLevel] )
        set d.heroDuration = HERO_DURATION[abilityLevel] + casterIntelligence * HERO_DURATION_PER_INTELLIGENCE_POINT[abilityLevel]
        set d.jumpsAmount = 0
        set d.moveTimer = moveTimer
        set d.targetGroup = targetGroup
        set d.targetsAreAllied = IsUnitAlly( targetSelf, caster.owner )
        set targetSelf = null
        set d.x = casterX
        set d.y = casterY
        set d.z = casterZ
        call AttachInteger( moveTimer, SpellDisconnection_SCOPE_ID, d )
        call StartTarget(d, target, targetGroup)
        set targetGroup = null
        call SetUnitZ( dummyUnit, casterX, casterY, casterZ )
        set dummyUnit = null
        call PlaySoundFromTypeAtPosition( SPELL_DISCONNECTION_LAUNCH_SOUND_TYPE, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) )
        set casterSelf = null
        call TimerStart( moveTimer, UPDATE_TIME, true, function Move )
        set moveTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    public function Order takes Unit caster, player casterOwner, Unit target returns string
        return TargetConditions_Single( target, IsUnitAlly( target.self, casterOwner ) )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT, ORDERED_UNIT.owner, TARGET_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        set CHOOSE_TRIGGER = CreateTriggerWJ()
        set DURATION[1] = 5
        set DURATION[2] = 5
        set DURATION_PER_INTELLIGENCE_POINT[1] = 0.03
        set DURATION_PER_INTELLIGENCE_POINT[2] = 0.03
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set GOLD[1] = 10
        set GOLD[2] = 20
        set GOLD_PER_INTELLIGENCE_POINT[1] = 0
        set GOLD_PER_INTELLIGENCE_POINT[2] = 0
        set GOLD_PER_BUFF[1] = 20
        set GOLD_PER_BUFF[2] = 20
        set GOLD_PER_BUFF_PER_INTELLIGENCE_POINT[1] = 0
        set GOLD_PER_BUFF_PER_INTELLIGENCE_POINT[2] = 0
        set HERO_DURATION[1] = 4
        set HERO_DURATION[2] = 4
        set HERO_DURATION_PER_INTELLIGENCE_POINT[1] = 0.02
        set HERO_DURATION_PER_INTELLIGENCE_POINT[2] = 0.02
        set MAX_TARGETS_AMOUNT[1] = 6
        set MAX_TARGETS_AMOUNT[2] = 8
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call AddTriggerCode(CHOOSE_TRIGGER, function ChooseTrig)
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SpellDisconnection.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Stability.j
//TESH.scrollpos=230
//TESH.alwaysfold=0
//! runtextmacro Scope("Stability")
    globals
        private constant integer ORDER_ID = 852604//OrderId( "submerge" )
        public constant integer SPELL_ID = 'A00B'

        private constant real AREA_RANGE = 400.
        private real array BONUS_ARMOR
        private real array BONUS_ARMOR_PER_AGILITY_POINT
        private real array BONUS_ARMOR_BY_SPELL
        private real array BONUS_ARMOR_BY_SPELL_PER_AGILITY_POINT
        private real array DURATION
        private group ENUM_GROUP
        private constant integer LEVELS_AMOUNT = 5
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Items\\AIda\\AIdaCaster.mdl"
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\AIda\\AIdaTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "overhead"
    endglobals

    private struct Data
        integer abilityLevel
        real array bonusArmor[LEVELS_AMOUNT]
        real array bonusArmorBySpell[LEVELS_AMOUNT]
        timer array durationTimer[LEVELS_AMOUNT]
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local integer abilityLevel = d.abilityLevel
        local real bonusArmor
        local real bonusArmorBySpell
        local integer iteration = abilityLevel - 1
        local effect targetEffect
        local integer targetId
        loop
            exitwhen (durationTimer == d.durationTimer[iteration])
            set iteration = iteration - 1
        endloop
        set d.durationTimer[iteration] = null
        if ( abilityLevel - 1 <= iteration ) then
            set bonusArmor = d.bonusArmor[abilityLevel - 1]
            set bonusArmorBySpell = d.bonusArmorBySpell[abilityLevel - 1]
            loop
                exitwhen (iteration < 0)
                exitwhen (d.durationTimer[iteration] != null)
                set iteration = iteration - 1
            endloop
            if ( iteration > -1 ) then
                set d.abilityLevel = iteration + 1
                call AddUnitArmorBonus( target, d.bonusArmor[iteration] - bonusArmor )
                call AddUnitArmorBySpellBonus( target, d.bonusArmorBySpell[iteration] - bonusArmorBySpell )
            else
                set targetEffect = d.targetEffect
                set targetId = target.id
                call d.destroy()
                call FlushAttachedIntegerById( targetId, Stability_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
                //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
                call DestroyEffectWJ( targetEffect )
                set targetEffect = null
                call AddUnitArmorBonus( target, -bonusArmor )
                call AddUnitArmorBySpellBonus( target, -bonusArmorBySpell )
            endif
        endif
        call FlushAttachedInteger( durationTimer, Stability_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
    endfunction

    public function Dispel takes Unit target returns nothing
        local integer abilityLevel
        local Data d = GetAttachedIntegerById(target.id, Stability_SCOPE_ID)
        local timer durationTimer
        local integer iteration
        if (d != NULL) then
            set abilityLevel = d.abilityLevel
            set iteration = 0
            loop
                set durationTimer = d.durationTimer[iteration]
                if ( durationTimer != null ) then
                    call Ending( d, durationTimer, target )
                endif
                set iteration = iteration + 1
                exitwhen ( iteration >= abilityLevel )
            endloop
            set durationTimer = null
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Stability_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        return true
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local real casterAgility = GetHeroAgilityTotal( caster )
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local real bonusArmor = BONUS_ARMOR[abilityLevel] + casterAgility * BONUS_ARMOR_PER_AGILITY_POINT[abilityLevel]
        local real bonusArmorBySpell = BONUS_ARMOR_BY_SPELL[abilityLevel] + casterAgility * BONUS_ARMOR_BY_SPELL_PER_AGILITY_POINT[abilityLevel]
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d
        local real duration
        local timer durationTimer
        local Unit enumUnit
        local integer enumUnitId
        local unit enumUnitSelf
        local boolean isNew
        local integer iteration
        local integer oldAbilityLevel
        local real oldBonusArmor
        local real oldBonusArmorBySpell
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, casterX, casterY ) )
        call PlaySoundFromTypeAtPosition( STABILITY_SOUND_TYPE, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) )
        set casterSelf = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if (enumUnitSelf != null) then
            set duration = DURATION[abilityLevel]
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                set enumUnitId = enumUnit.id
                set d = GetAttachedIntegerById(enumUnitId, Stability_SCOPE_ID)
                set isNew = (d == NULL)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                if ( isNew ) then
                    set d = Data.create()
                    set durationTimer = CreateTimerWJ()
                    set iteration = LEVELS_AMOUNT - 1
                    set d.abilityLevel = abilityLevel
                    set d.target = enumUnit
                    loop
                        if (iteration == abilityLevel - 1) then
                            set d.durationTimer[iteration] = durationTimer
                        else
                            set d.durationTimer[iteration] = null
                        endif
                        set iteration = iteration - 1
                        exitwhen (iteration < 0)
                    endloop
                    call AttachInteger(durationTimer, Stability_SCOPE_ID, d)
                    call AttachIntegerById(enumUnitId, Stability_SCOPE_ID, d)
                    //! runtextmacro AddEventById( "enumUnitId", "EVENT_DEATH" )
                    //! runtextmacro AddEventById( "enumUnitId", "EVENT_DISPEL" )
                else
                    set durationTimer = d.durationTimer[abilityLevel - 1]
                    if (durationTimer == null) then
                        set durationTimer = CreateTimerWJ()
                        set d.durationTimer[abilityLevel - 1] = durationTimer
                        call AttachInteger(durationTimer, Stability_SCOPE_ID, d)
                    endif
                    set oldAbilityLevel = d.abilityLevel
                    set oldBonusArmor = d.bonusArmor[abilityLevel - 1]
                    set oldBonusArmorBySpell = d.bonusArmorBySpell[abilityLevel - 1]
                    call DestroyEffectWJ( d.targetEffect )
                endif
                set d.bonusArmor[abilityLevel - 1] = bonusArmor
                set d.bonusArmorBySpell[abilityLevel - 1] = bonusArmorBySpell
                set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnitSelf, TARGET_EFFECT_ATTACHMENT_POINT )
                if ( isNew ) then
                    call AddUnitArmorBonus( enumUnit, bonusArmor )
                    call AddUnitArmorBySpellBonus( enumUnit, bonusArmorBySpell )
                elseif (abilityLevel > oldAbilityLevel) then
                    set d.abilityLevel = abilityLevel
                    call AddUnitArmorBonus( enumUnit, bonusArmor - oldBonusArmor )
                    call AddUnitArmorBySpellBonus( enumUnit, bonusArmorBySpell - oldBonusArmorBySpell )
                endif
                call TimerStart( durationTimer, duration, false, function EndingByTimer )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen (enumUnitSelf == null)
            endloop
            set durationTimer = null
        endif
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        set BONUS_ARMOR[1] = 3
        set BONUS_ARMOR[2] = 5
        set BONUS_ARMOR[3] = 7
        set BONUS_ARMOR[4] = 9
        set BONUS_ARMOR[5] = 11
        set BONUS_ARMOR_PER_AGILITY_POINT[1] = 0.1
        set BONUS_ARMOR_PER_AGILITY_POINT[2] = 0.1
        set BONUS_ARMOR_PER_AGILITY_POINT[3] = 0.1
        set BONUS_ARMOR_PER_AGILITY_POINT[4] = 0.1
        set BONUS_ARMOR_PER_AGILITY_POINT[5] = 0.1
        set BONUS_ARMOR_BY_SPELL[1] = -0.25
        set BONUS_ARMOR_BY_SPELL[2] = -0.25
        set BONUS_ARMOR_BY_SPELL[3] = -0.25
        set BONUS_ARMOR_BY_SPELL[4] = -0.25
        set BONUS_ARMOR_BY_SPELL[5] = -0.25
        set BONUS_ARMOR_BY_SPELL_PER_AGILITY_POINT[1] = -0.0033
        set BONUS_ARMOR_BY_SPELL_PER_AGILITY_POINT[2] = -0.0033
        set BONUS_ARMOR_BY_SPELL_PER_AGILITY_POINT[3] = -0.0033
        set BONUS_ARMOR_BY_SPELL_PER_AGILITY_POINT[4] = -0.0033
        set BONUS_ARMOR_BY_SPELL_PER_AGILITY_POINT[5] = -0.0033
        set DURATION[1] = 16
        set DURATION[2] = 16
        set DURATION[3] = 16
        set DURATION[4] = 16
        set DURATION[5] = 16
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Stability.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\StrongArm.j
//TESH.scrollpos=53
//TESH.alwaysfold=0
//! runtextmacro Scope("StrongArm")
    globals
        public constant integer RESEARCH_ID = 'R015'
        public constant integer SPELL_ID = 'A088'

        private constant real CHANCE = 0.25
        private constant real DURATION = 2.
        private constant real HERO_DURATION = 1.
    endglobals

    public function DecayEnd takes Unit caster returns nothing
        local integer casterId = caster.id
        if ( GetAttachedBooleanById( casterId, StrongArm_SCOPE_ID ) ) then
            call FlushAttachedBooleanById( casterId, StrongArm_SCOPE_ID )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DECAY_END" )
            //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
        endif
    endfunction

    private function DecayEnd_Event takes nothing returns nothing
        call DecayEnd( DYING_UNIT )
    endfunction

    private function Damage_Conditions takes Unit caster, Unit target returns boolean
        if ( GetAttachedBooleanById( caster.id, StrongArm_SCOPE_ID ) == false ) then
            return false
        endif
        if ( IsUnitType( target.self, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( target.self, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( target ) ) then
            return false
        endif
        if ( GetRandomReal( 0.01, 1 ) > CHANCE ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, Unit target returns nothing
        local real duration
        if ( Damage_Conditions( caster, target ) ) then
            call SetUnitStunTimed( target, 1, DURATION )
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, StrongArm_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro AddEventById( "casterId", "EVENT_DECAY_END" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DECAY_END", "UnitFinishesDecaying_End_End_EVENT_KEY", "0", "function DecayEnd_Event" )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call SetAbilityRequiredResearch( SPELL_ID, RESEARCH_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\StrongArm.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SuddenFrost.j
//TESH.scrollpos=99
//TESH.alwaysfold=0
//! runtextmacro Scope("SuddenFrost")
    globals
        public constant integer SPELL_ID = 'A06Q'

        private constant real BONUS_ARMOR = -2.
        private constant real BONUS_HEAL_BY_SPELL = -0.25
        private constant real DURATION = 10.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\FrostDamage\\FrostDamage.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        private constant string TARGET_EFFECT2_PATH = "Abilities\\Spells\\Items\\AIob\\AIobTarget.mdl"
        private constant string TARGET_EFFECT2_ATTACHMENT_POINT = "head"
    endglobals

    private struct Data
        timer durationTimer
        Unit target
        effect targetEffect
        effect targetEffect2
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local effect targetEffect = d.targetEffect
        local effect targetEffect2 = d.targetEffect2
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, SuddenFrost_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, SuddenFrost_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call DestroyEffectWJ( targetEffect2 )
        set targetEffect2 = null
        call AddUnitArmorBonus( target, -BONUS_ARMOR )
        call AddUnitHealBySpell( target, -BONUS_HEAL_BY_SPELL )
    endfunction

    public function Death takes Unit target returns nothing
        local Data d = GetAttachedIntegerById( target.id, SuddenFrost_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, SuddenFrost_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function Damage_TargetConditions takes player casterOwner, unit target returns boolean
        if ( IsUnitAlly( target, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( target, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, Unit target returns nothing
        local Data d
        local timer durationTimer
        local integer targetId
        local unit targetSelf = target.self
        if (GetAttachedBooleanById(caster.id, SuddenFrost_SCOPE_ID)) then
            if ( Damage_TargetConditions( caster.owner, targetSelf ) ) then
                set targetId = target.id
                set d = GetAttachedIntegerById( targetId, SuddenFrost_SCOPE_ID )
                if ( d == NULL ) then
                    set d = Data.create()
                    set durationTimer = CreateTimerWJ()
                    set d.durationTimer = durationTimer
                    set d.target = target
                    call AttachInteger( durationTimer, SuddenFrost_SCOPE_ID, d )
                    call AttachIntegerById( targetId, SuddenFrost_SCOPE_ID, d )
                    //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
                    call AddUnitArmorBonus( target, BONUS_ARMOR )
                    call AddUnitHealBySpell( target, BONUS_HEAL_BY_SPELL )
                else
                    set durationTimer = d.durationTimer
                    call DestroyEffectWJ( d.targetEffect )
                    call DestroyEffectWJ( d.targetEffect2 )
                endif
                set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_ATTACHMENT_POINT )
                set d.targetEffect2 = AddSpecialEffectTargetWJ( TARGET_EFFECT2_PATH, targetSelf, TARGET_EFFECT2_ATTACHMENT_POINT )
                set targetSelf = null
                call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
                set durationTimer = null
            endif
        endif
    endfunction

    private function Damage_Event takes nothing returns nothing
        call Damage( DAMAGE_SOURCE, TRIGGER_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        call AttachBooleanById( casterId, SuddenFrost_SCOPE_ID, true )
        //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call InitEffectType( TARGET_EFFECT2_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SuddenFrost.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Suicide.j
//TESH.scrollpos=80
//TESH.alwaysfold=0
//! runtextmacro Scope("Suicide")
    globals
        private constant integer ORDER_ID = 852593//OrderId( "stampede" )
        public constant integer SPELL_ID = 'A047'

        private constant real DURATION = 3.
    endglobals

    private struct Data
        Unit caster
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local timer durationTimer = d.durationTimer
        call d.destroy()
        call FlushAttachedIntegerById( caster.id, Suicide_SCOPE_ID )
        call FlushAttachedInteger( durationTimer, Suicide_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, Suicide_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    //! runtextmacro Scope("Fade")
        globals
            private constant real Fade_DURATION = 5.
        endglobals

        private struct Fade_Data
            Unit caster
            timer durationTimer
        endstruct

        private function Fade_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Fade_Data d = GetAttachedInteger(durationTimer, Fade_SCOPE_ID)
            local Unit caster = d.caster
            call FlushAttachedIntegerById( caster.id, Fade_SCOPE_ID )
            call FlushAttachedInteger( durationTimer, Fade_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            call KillUnit( caster.self )
        endfunction

        public function Fade_Start takes Unit caster, timer durationTimer returns nothing
            local unit casterSelf = caster.self
            local Fade_Data d = Fade_Data.create()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById( caster.id, Fade_SCOPE_ID, d )
            call AttachInteger( durationTimer, Fade_SCOPE_ID, d )
            call AddUnitVertexColorTimed( caster, 0, 0, 0, -255, null, Fade_DURATION )
            call SetUnitAnimationByIndex( casterSelf, 11 )
            call AddUnitLocust( casterSelf )
            set casterSelf = null
            call TimerStart( durationTimer, Fade_DURATION, false, function Fade_Ending )
        endfunction
    //! runtextmacro Endscope()

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Suicide_SCOPE_ID)
        local Unit caster = d.caster
        local timer FadeTimer = CreateTimerWJ()
        call RemoveUnitDecay(caster)
        call KillUnit( caster.self )
        call Fade_Fade_Start(caster, durationTimer)
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        set d.caster = caster
        set d.durationTimer = durationTimer
        call AttachIntegerById( caster.id, Suicide_SCOPE_ID, d )
        call AttachInteger( durationTimer, Suicide_SCOPE_ID, d )
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Suicide.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SummonFaust.j
//TESH.scrollpos=135
//TESH.alwaysfold=0
//! runtextmacro Scope("SummonFaust")
    globals
        private constant integer ATTACK_GRAPHIC_SPELL_ID = 'A00R'
        private constant integer FAUST_ID = 'n00N'
        private constant integer ORDER_ID = 852594//OrderId( "summongrizzly" )
        public constant integer SPELL_ID = 'A02H'

        private constant real AREA_RANGE = 800.
        private constant real BONUS_HEAL_BY_SPELL = -0.5
        private constant real DURATION = 60.
        private constant real RELEASE_TIME = 1.5
        private timer RELEASE_TIMER
        private constant string SPECIAL_EFFECT_PATH = "Objects\\Spawnmodels\\Other\\ToonBoom\\ToonBoom.mdl"
        private constant real UPDATE_TIME = 0.035
        private constant real ANGLE_ADD = 600 * DEG_TO_RAD * UPDATE_TIME / RELEASE_TIME
        private timer UPDATE_TIMER

        private real FACING
        private Unit FAUST = NULL
        private effect SPECIAL_EFFECT
    endglobals

    //! runtextmacro Scope("AttackGraphic")
        globals
            public constant integer AttackGraphic_SPELL_ID = 'A00R'

            private constant string AttackGraphic_CASTER_EFFECT_PATH = "Abilities\\Weapons\\AvengerMissile\\AvengerMissile.mdl"
            private constant string AttackGraphic_CASTER_EFFECT_ATTACHMENT_POINT = "weapon"
            private constant string AttackGraphic_TARGET_EFFECT_PATH = "Abilities\\Weapons\\Catapult\\CatapultMissile.mdl"
            private constant string AttackGraphic_TARGET_EFFECT_ATTACHMENT_POINT = "origin"

            private effect AttackGraphic_CASTER_EFFECT
        endglobals

        public function AttackGraphic_Death takes Unit caster returns nothing
            local integer casterId
            if ( caster.type.id == FAUST_UNIT_ID ) then
                set casterId = caster.id
                //! runtextmacro RemoveEventById( "casterId", "AttackGraphic_EVENT_DAMAGE" )
                //! runtextmacro RemoveEventById( "casterId", "AttackGraphic_EVENT_DEATH" )
                call DestroyEffectWJ(AttackGraphic_CASTER_EFFECT)
            endif
        endfunction

        private function AttackGraphic_Death_Event takes nothing returns nothing
            call AttackGraphic_Death( DYING_UNIT )
        endfunction

        public function AttackGraphic_Damage takes unit caster, unit target returns nothing
            if ( GetUnitAbilityLevel( caster, SPELL_ID ) > 0 ) then
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( AttackGraphic_TARGET_EFFECT_PATH, target, AttackGraphic_TARGET_EFFECT_PATH ) )
            endif
        endfunction

        private function AttackGraphic_Damage_Event takes nothing returns nothing
            call AttackGraphic_Damage( DAMAGE_SOURCE.self, TRIGGER_UNIT.self )
        endfunction

        public function AttackGraphic_Learn takes Unit caster returns nothing
            local integer casterId = caster.id
            //! runtextmacro AddEventById( "casterId", "AttackGraphic_EVENT_DAMAGE" )
            //! runtextmacro AddEventById( "casterId", "AttackGraphic_EVENT_DEATH" )
            set AttackGraphic_CASTER_EFFECT = AddSpecialEffectTargetWJ( AttackGraphic_CASTER_EFFECT_PATH, caster.self, AttackGraphic_CASTER_EFFECT_ATTACHMENT_POINT )
        endfunction

        private function AttackGraphic_Learn_Event takes nothing returns nothing
            call AttackGraphic_Learn(LEARNER)
        endfunction

        public function AttackGraphic_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "AttackGraphic_EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_AS_DAMAGE_SOURCE", "0", "function AttackGraphic_Damage_Event" )
            //! runtextmacro CreateEvent( "AttackGraphic_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function AttackGraphic_Death_Event" )
            call InitEffectType( AttackGraphic_CASTER_EFFECT_PATH )
            call InitEffectType( AttackGraphic_TARGET_EFFECT_PATH )
            //! runtextmacro AddNewEventById( "AttackGraphic_EVENT_LEARN", "AttackGraphic_SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function AttackGraphic_Learn_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit faust returns nothing
        local integer iteration
        if ( faust.type.id == FAUST_UNIT_ID ) then
            set iteration = GetTeams() - 1
            //! runtextmacro RemoveEventById( "FAUST.id", "EVENT_DEATH" )
            loop
                exitwhen ( iteration < 0 )
                call UnitAddAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
                set iteration = iteration - 1
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function Release takes nothing returns nothing
        local unit faustSelf = FAUST.self
        call DestroyEffectWJ(SPECIAL_EFFECT)
        call PauseTimer( RELEASE_TIMER )
        call PauseTimer( UPDATE_TIMER )
        call SetUnitInvulnerable( faustSelf, false )
        call PauseUnit( faustSelf, false )
        call UnitApplyTimedLifeWJ( faustSelf, DURATION )
        set faustSelf = null
    endfunction

    private function Turn takes nothing returns nothing
        set FACING = FACING + ANGLE_ADD
        call SetUnitFacingWJ( FAUST.self, FACING )
    endfunction

    public function SpellEffect takes player casterOwner returns nothing
        local real angle = GetRandomReal( 0, PI * 2 )
        local integer casterTeam = GetPlayerTeam( casterOwner )
        local unit faustSelf
        local integer iteration = GetTeams() - 1
        local real length = GetRandomReal( 0, AREA_RANGE )
        local real x = length * Cos( angle )
        local real y = length * Sin( angle )
        set FACING = GetRandomReal( 0, 2 * PI )
        set FAUST = CreateUnitEx( casterOwner, FAUST_UNIT_ID, x, y, FACING )
        set faustSelf = FAUST.self
        loop
            exitwhen ( iteration < 0 )
            call UnitRemoveAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
            set iteration = iteration - 1
        endloop
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, x, y ) )
        set SPECIAL_EFFECT = AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, x, y )
        //! runtextmacro AddEventById( "FAUST.id", "EVENT_DEATH" )
        call AddUnitHealBySpell( FAUST, BONUS_HEAL_BY_SPELL )
        call SetUnitInvulnerable( faustSelf, true )
        call PauseUnit( faustSelf, true )
        set faustSelf = null
        call AddUnitScaleTimed( FAUST, 1.75, RELEASE_TIME )
        call DisplayTextTimedWJ( ColorStrings_RED + "Attention: Faust has entered this world - your world. In his terrifying state of frenzy, he massacres everyone fatuous enough stepping into his battle range.|r", 10, GetLocalPlayer() )
        call PingMasterWizard( casterTeam )
        call PlaySoundFromType( FAUST_LAUGH_SOUND_TYPE )
        call TimerStart( UPDATE_TIMER, UPDATE_TIME, true, function Turn )
        call TimerStart( RELEASE_TIMER, RELEASE_TIME, false, function Release )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER.owner )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set RELEASE_TIMER = CreateTimerWJ()
        set UPDATE_TIMER = CreateTimerWJ()
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call AttackGraphic_AttackGraphic_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SummonFaust.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SummonInfernal.j
//TESH.scrollpos=179
//TESH.alwaysfold=0
//! runtextmacro Scope("SummonInfernal")
    globals
        private constant integer ORDER_ID = 852489//OrderId( "summonphoenix" )
        public constant integer SPELL_ID = 'A007'

        private constant integer DUMMY_UNIT_ID = 'n006'
        private real array DURATION
        private real array DURATION_PER_STRENGTH_POINT
        private constant integer LEVELS_AMOUNT = 2
        private constant real RELEASE_TIME = 1.7
        private integer array SPAWN_UNIT_ID
    endglobals

    private struct Data
        integer abilityLevel
        real duration
        Unit infernal
    endstruct

    //! runtextmacro Scope("Fire")
        globals
            private real array Fire_AREA_RANGE
            private real array Fire_DAMAGE_PER_INTERVAL
            private real array Fire_DURATION
            private constant integer Fire_DUMMY_UNIT_ID = 'n02Y'
            private group Fire_ENUM_GROUP
            private constant real Fire_INTERVAL = 0.5
            private boolexpr Fire_TARGET_CONDITIONS
        endglobals

        private struct Fire_Data
            integer abilityLevel
            Unit caster
            unit dummyUnit
            timer intervalTimer
            real targetX
            real targetY
        endstruct

        private function Fire_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Fire_Data d = GetAttachedInteger(durationTimer, Fire_SCOPE_ID)
            local unit dummyUnit = d.dummyUnit
            local timer intervalTimer = d.intervalTimer
            call d.destroy()
            call SetUnitAnimationByIndex( dummyUnit, 2 )
            call RemoveUnitTimed( dummyUnit, 2 )
            set dummyUnit = null
            call FlushAttachedInteger( durationTimer, Fire_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            call FlushAttachedInteger( intervalTimer, Fire_SCOPE_ID )
            call DestroyTimerWJ( intervalTimer )
            set intervalTimer = null
        endfunction

        private function Fire_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
                return false
            endif
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
            if ( GetUnitInvulnerability( FILTER_UNIT ) > 0 ) then
                return false
            endif
            if ( GetUnitMagicImmunity( FILTER_UNIT ) > 0 ) then
                return false
            endif
            return true
        endfunction

        private function Fire_Interval takes nothing returns nothing
            local real damageAmount
            local unit enumUnit
            local timer intervalTimer = GetExpiredTimer()
            local Fire_Data d = GetAttachedInteger(intervalTimer, Fire_SCOPE_ID)
            local integer abilityLevel = d.abilityLevel
            local Unit caster = d.caster
            local real targetX = d.targetX
            local real targetY = d.targetY
            set TEMP_PLAYER = caster.owner
            call GroupEnumUnitsInRangeWithCollision( Fire_ENUM_GROUP, targetX, targetY, Fire_AREA_RANGE[abilityLevel], Fire_TARGET_CONDITIONS )
            set enumUnit = FirstOfGroup( Fire_ENUM_GROUP )
            if ( enumUnit != null ) then
                set damageAmount = Fire_DAMAGE_PER_INTERVAL[abilityLevel]
                loop
                    call GroupRemoveUnit( Fire_ENUM_GROUP, enumUnit )
                    call UnitDamageUnitBySpell( caster, GetUnit(enumUnit), damageAmount )
                    set enumUnit = FirstOfGroup( Fire_ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
        endfunction

        public function Fire_Start takes integer abilityLevel, Unit caster, real targetX, real targetY returns nothing
            local Fire_Data d = Fire_Data.create()
            local unit dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, Fire_DUMMY_UNIT_ID, targetX, targetY, GetRandomReal( 0, 2 * PI ) )
            local real dummyUnitScale = Fire_AREA_RANGE[abilityLevel] / 200
            local timer durationTimer = CreateTimerWJ()
            local timer intervalTimer = CreateTimerWJ()
            set d.abilityLevel = abilityLevel
            set d.caster = caster
            set d.dummyUnit = dummyUnit
            set d.intervalTimer = intervalTimer
            set d.targetX = targetX
            set d.targetY = targetY
            call AttachInteger( durationTimer, Fire_SCOPE_ID, d )
            call AttachInteger( intervalTimer, Fire_SCOPE_ID, d )
            call SetUnitAnimationByIndex( dummyUnit, 0 )
            call SetUnitScale( dummyUnit, dummyUnitScale, dummyUnitScale, dummyUnitScale )
            set dummyUnit = null
            call TimerStart( intervalTimer, Fire_INTERVAL, true, function Fire_Interval )
            set intervalTimer = null
            call TimerStart( durationTimer, Fire_DURATION[abilityLevel], true, function Fire_Ending )
            set durationTimer = null
        endfunction

        public function Fire_Init takes nothing returns nothing
            local integer iteration = LEVELS_AMOUNT
            set Fire_AREA_RANGE[1] = 350
            set Fire_AREA_RANGE[2] = 350
            set Fire_DAMAGE_PER_INTERVAL[1] = 225.
            set Fire_DAMAGE_PER_INTERVAL[2] = 225.
            set Fire_DURATION[1] = 5
            set Fire_DURATION[2] = 5
            loop
                set Fire_DAMAGE_PER_INTERVAL[iteration] = Fire_DAMAGE_PER_INTERVAL[iteration] / R2I(Fire_DURATION[iteration] / Fire_INTERVAL)
                set iteration = iteration - 1
                exitwhen (iteration < 1)
            endloop
            set Fire_ENUM_GROUP = CreateGroupWJ()
            set Fire_TARGET_CONDITIONS = ConditionWJ( function Fire_TargetConditions )
            call InitUnitType( Fire_DUMMY_UNIT_ID )
        endfunction
    //! runtextmacro Endscope()

    private function Release takes nothing returns nothing
        local timer releaseTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(releaseTimer, SummonInfernal_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit infernal = d.infernal
        local unit infernalSelf = infernal.self
        call d.destroy()
        call FlushAttachedInteger( releaseTimer, SummonInfernal_SCOPE_ID )
        call DestroyTimerWJ( releaseTimer )
        set releaseTimer = null
        call SetUnitTimeScale( infernalSelf, 1 )
        call SetUnitBlendTime( infernalSelf, 0.15 )
        call SetUnitAnimationByIndex( infernalSelf, 0 )
        call PauseUnit( infernalSelf, false )
        call SetUnitInvulnerable( infernalSelf, false )
        call UnitApplyTimedLifeWJ( infernalSelf, DURATION[abilityLevel] )
        set infernalSelf = null
    endfunction

    public function SpellEffect takes Unit caster, real targetX, real targetY returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local player casterOwner = caster.owner
        local Data d = Data.create()
        local unit dummyUnit = CreateUnitWJ( casterOwner, DUMMY_UNIT_ID, targetX, targetY, STANDARD_ANGLE )
        local Unit infernal = CreateUnitEx( casterOwner, SPAWN_UNIT_ID[abilityLevel], 0, 0, GetRandomReal( 0, 2 * PI ) )
        local unit infernalSelf = infernal.self
        local timer releaseTimer = CreateTimerWJ()
        set casterOwner = null
        call RemoveUnitTimed( dummyUnit, 2 )
        set dummyUnit = null
        set d.abilityLevel = abilityLevel
        set d.duration = DURATION[abilityLevel] + GetHeroStrengthTotal(caster) * DURATION_PER_STRENGTH_POINT[abilityLevel]
        set d.infernal = infernal
        call AttachInteger( releaseTimer, SummonInfernal_SCOPE_ID, d )
        call SetUnitBlendTime( infernalSelf, 0 )
        call SetUnitTimeScale( infernalSelf, 1.4 )
        call SetUnitAnimationByIndex( infernalSelf, 7 )
        call PauseUnit( infernalSelf, true )
        call SetUnitInvulnerable( infernalSelf, true )
        call SetUnitX( infernalSelf, targetX )
        call SetUnitY( infernalSelf, targetY )
        set infernalSelf = null
        call TimerStart( releaseTimer, RELEASE_TIME, false, function Release )
        set releaseTimer = null
        call Fire_Fire_Start(abilityLevel, caster, targetX, targetY)
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_X, TARGET_Y )
    endfunction

    public function Order takes real targetX, real targetY returns string
        if (IsPointInPlayRegion(targetX, targetY) == false) then
            return ErrorStrings_INVALID_TARGET
        endif
        return null
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( TARGET_X, TARGET_Y )
    endfunction

    public function Init takes nothing returns nothing
        set DURATION[1] = 40
        set DURATION[2] = 40
        set DURATION_PER_STRENGTH_POINT[1] = 1.5
        set DURATION_PER_STRENGTH_POINT[2] = 1.5
        set SPAWN_UNIT_ID[1] = INFERNAL_UNIT_ID
        set SPAWN_UNIT_ID[2] = MONSTROUS_INFERNAL_UNIT_ID
        call InitUnitType( DUMMY_UNIT_ID )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Fire_Fire_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SummonInfernal.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SummonPeq.j
//TESH.scrollpos=72
//TESH.alwaysfold=0
//! runtextmacro Scope("SummonPeq")
    globals
        private constant integer ORDER_ID = 852595//OrderId( "summonquillbeast" )
        public constant integer SPELL_ID = 'A038'

        private constant real AREA_RANGE = 800.
        private constant real BONUS_HEAL_BY_SPELL = -0.5
        private constant real DURATION = 80.
        private constant real RELEASE_TIME = 1.5
        private timer RELEASE_TIMER
        private constant string SPECIAL_EFFECT_PATH = "Objects\\Spawnmodels\\Other\\ToonBoom\\ToonBoom.mdl"
        private constant real UPDATE_TIME = 0.035
        private timer UPDATE_TIMER
        private constant real ANGLE_ADD = 600 * DEG_TO_RAD * UPDATE_TIME / RELEASE_TIME

        private real FACING
        private Unit PEQ = NULL
    endglobals

    public function Death takes Unit peq returns nothing
        local integer iteration
        if ( peq == PEQ ) then
            set iteration = GetTeams() - 1
            //! runtextmacro RemoveEventById( "PEQ.id", "EVENT_DEATH" )
            loop
                exitwhen ( iteration < 0 )
                call UnitAddAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
                set iteration = iteration - 1
            endloop
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function Release takes nothing returns nothing
        local unit peqSelf = PEQ.self
        call PauseTimer( UPDATE_TIMER )
        //! runtextmacro AddEventById( "PEQ.id", "EVENT_DEATH" )
        call SetUnitInvulnerable( peqSelf, false )
        call PauseUnit( peqSelf, false )
        call UnitApplyTimedLifeWJ( peqSelf, DURATION )
        set peqSelf = null
    endfunction

    private function Turn takes nothing returns nothing
        set FACING = FACING + ANGLE_ADD
        call SetUnitFacingWJ( PEQ.self, FACING )
    endfunction

    public function SpellEffect takes player casterOwner returns nothing
        local real angle = GetRandomReal( 0, PI * 2 )
        local integer casterTeam = GetPlayerTeam( casterOwner )
        local integer iteration = GetTeams() - 1
        local real length = GetRandomReal( 0, AREA_RANGE )
        local unit peqSelf
        local real x = length * Cos( angle )
        local real y = length * Sin( angle )
        set FACING = GetRandomReal( 0, 2 * PI )
        set PEQ = CreateUnitEx( casterOwner, PEQ_UNIT_ID, x, y, FACING )
        set peqSelf = PEQ.self
        loop
            exitwhen ( iteration < 0 )
            call UnitRemoveAbility( MASTER_WIZARDS[iteration].self, SPELL_ID )
            set iteration = iteration - 1
        endloop
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, x, y ) )
        call AddUnitHealBySpell( PEQ, BONUS_HEAL_BY_SPELL )
        call SetUnitInvulnerable( peqSelf, true )
        call PauseUnit( peqSelf, true )
        set peqSelf = null
        call AddUnitScaleTimed( PEQ, 1.75, RELEASE_TIME )
        call DisplayTextTimedWJ( ColorStrings_RED + "Attention please: Peq the Sorcerer was summoned and strives for the mortals' lives.|r", 10, GetLocalPlayer() )
        call PingMasterWizard( casterTeam )
        call PlaySoundFromType( PEQ_WARCRY_SOUND_TYPE )
        call TimerStart( UPDATE_TIMER, UPDATE_TIME, true, function Turn )
        call TimerStart( RELEASE_TIMER, RELEASE_TIME, false, function Release )
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER.owner )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        set RELEASE_TIMER = CreateTimer()
        set UPDATE_TIMER = CreateTimer()
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SummonPeq.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SummonPeqqiBeast.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("SummonPeqqiBeast")
    globals
        private constant integer ORDER_ID = 852596//OrderId( "summonwareagle" )
        public constant integer SPELL_ID = 'A03P'

        private constant real DURATION = 30.
        private constant real OFFSET = 100.
        private constant real RELEASE_TIME = 1.034
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl"
        private constant integer SUMMONS_AMOUNT = 2
    endglobals

    private struct Data
        Unit array beasts[SUMMONS_AMOUNT]
        timer releaseTimer
    endstruct

    private function Release takes nothing returns nothing
        local Unit beast
        local Unit array beasts
        local unit beastSelf
        local integer count = SUMMONS_AMOUNT - 1
        local integer iteration = count
        local timer releaseTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(releaseTimer, SummonPeqqiBeast_SCOPE_ID)
        loop
            set beasts[iteration] = d.beasts[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        set iteration = count
        call d.destroy()
        call FlushAttachedInteger(releaseTimer, SummonPeqqiBeast_SCOPE_ID)
        call DestroyTimerWJ( releaseTimer )
        set releaseTimer = null
        loop
            set beast = beasts[iteration]
            set beastSelf = beast.self
            call PauseUnit( beastSelf, false )
            call SetUnitInvulnerable( beastSelf, false )
            call SetUnitBlendTime( beastSelf, 0.15 )
            call UnitApplyTimedLifeWJ( beastSelf, DURATION )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set beastSelf = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local Unit beast
        local unit beastSelf
        local player casterOwner = caster.owner
        local unit casterSelf = caster.self
        local real casterAngle = GetUnitFacingWJ( casterSelf )
        local real casterX = GetUnitX( casterSelf ) + OFFSET * Cos(casterAngle)
        local real casterY = GetUnitY( casterSelf ) + OFFSET * Sin(casterAngle)
        local Data d = Data.create()
        local integer iteration = SUMMONS_AMOUNT - 1
        local timer releaseTimer = CreateTimerWJ()
        set casterSelf = null
        set d.releaseTimer = releaseTimer
        call AttachInteger(releaseTimer, SummonPeqqiBeast_SCOPE_ID, d)
        loop
            set beast = CreateUnitEx( casterOwner, PEQQI_BEAST_UNIT_ID, casterX, casterY, casterAngle )
            set beastSelf = beast.self
            call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, GetUnitX( beastSelf ), GetUnitY( beastSelf ) ) )
            set d.beasts[iteration] = beast
            call SetUnitBlendTime( beastSelf, 0 )
            call SetUnitAnimation( beastSelf, "birth" )
            call PauseUnit( beastSelf, true )
            call SetUnitInvulnerable( beastSelf, true )
            set iteration = iteration - 1
            exitwhen ( iteration < 0 )
        endloop
        set beastSelf = null
        set casterOwner = null
        call TimerStart( releaseTimer, RELEASE_TIME, false, function Release )
        set releaseTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SummonPeqqiBeast.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\SwitchShops.j
//TESH.scrollpos=18
//TESH.alwaysfold=0
//! runtextmacro Scope("SwitchShops")
    globals
        private constant integer ORDER_ID = 854299//OrderId( "spiritlink" )
        public constant integer SPELL_ID = 'A07T'

        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Demon\\DarkPortal\\DarkPortalTarget.mdl"
    endglobals

    public function SpellEffect takes player casterOwner returns nothing
        local integer casterTeam = GetPlayerTeam(casterOwner)
        local unit goblinShopSelf = GOBLIN_SHOPS[casterTeam].self
        local real goblinShopX = GetUnitX(goblinShopSelf)
        local real goblinShopY = GetUnitY(goblinShopSelf)
        local Unit shredder = SHREDDERS[casterTeam]
        local real shredderX = SHREDDERS_X[casterTeam]
        local real shredderY = SHREDDERS_Y[casterTeam]
        local unit workshopSelf = WORKSHOPS[casterTeam].self
        local real workshopX = GetUnitX(workshopSelf)
        local real workshopY = GetUnitY(workshopSelf)
        call DestroyEffectWJ(AddSpecialEffectWJ(SPECIAL_EFFECT_PATH, workshopX, workshopY))
        call SetUnitPosition(goblinShopSelf, workshopX, workshopY)
        set goblinShopSelf = null
        call DestroyEffectWJ(AddSpecialEffectWJ(SPECIAL_EFFECT_PATH, goblinShopX, goblinShopY))
        call SetUnitPosition(workshopSelf, goblinShopX, goblinShopY)
        set workshopSelf = null

        set SHREDDERS_X[casterTeam] = goblinShopX
        set SHREDDERS_Y[casterTeam] = goblinShopY
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER.owner )
    endfunction

    public function Init takes nothing returns nothing
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\SwitchShops.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ThermalFissure.j
//TESH.scrollpos=197
//TESH.alwaysfold=0
//! runtextmacro Scope("ThermalFissure")
    globals
        private constant integer ORDER_ID = 852121//OrderId( "earthquake" )
        public constant integer SPELL_ID = 'A06X'

        private constant real AREA_RANGE = 500.
        private constant string AREA_EFFECT_PATH = "Abilities\\Spells\\Orc\\EarthQuake\\EarthQuakeTarget.mdl"
        private group ENUM_GROUP
        private constant real DELAY = 2.
        private boolexpr TARGET_CONDITIONS
    endglobals

    private struct Data
        effect areaEffect
        Unit caster
        real targetX
        real targetY
    endstruct

    //! runtextmacro Scope("Target")
        globals
            private constant real Target_DURATION = 13.
            private constant real Target_INTERVAL = 1.
            private constant integer Target_WAVES_AMOUNT = R2I(Target_DURATION / Target_INTERVAL)
            private constant real Target_RELATIVE_RESTORED_LIFE_PER_INTERVAL = 0.5 / Target_WAVES_AMOUNT
            private constant real Target_RELATIVE_RESTORED_MANA_PER_INTERVAL = 0.5 / Target_WAVES_AMOUNT
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\ANrm\\ANrmTarget.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            timer durationTimer
            timer intervalTimer
            Unit target
            effect targetEffect
        endstruct

        private function Target_Ending takes Target_Data d, timer durationTimer, Unit target returns nothing
            local timer intervalTimer = d.intervalTimer
            local effect targetEffect = d.targetEffect
            local integer targetId = target.id
            call DestroyTimerWJ( durationTimer )
            call FlushAttachedInteger( intervalTimer, Target_SCOPE_ID )
            call DestroyTimerWJ( intervalTimer )
            set intervalTimer = null
            call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
            //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DAMAGE" )
            //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
            //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DISPEL" )
            call DestroyEffectWJ( targetEffect )
            set targetEffect = null
        endfunction

        public function Target_Dispel takes Unit target returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            if ( d != NULL ) then
                call Target_Ending( d, d.durationTimer, target )
            endif
        endfunction

        private function Target_Dispel_Event takes nothing returns nothing
            call Target_Dispel( TRIGGER_UNIT )
        endfunction

        public function Target_Damage takes Unit target returns nothing
            call Target_Dispel( target )
        endfunction

        private function Target_Damage_Event takes nothing returns nothing
            call Target_Damage( TRIGGER_UNIT )
        endfunction

        public function Target_Death takes Unit target returns nothing
            call Target_Dispel( target )
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( TRIGGER_UNIT )
        endfunction

        private function Target_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Target_Data d = GetAttachedInteger(durationTimer, Target_SCOPE_ID)
            call Target_Ending( d, durationTimer, d.target )
            set durationTimer = null
        endfunction

        private function Target_IntervalByTimer takes nothing returns nothing
            local timer intervalTimer = GetExpiredTimer()
            local Target_Data d = GetAttachedInteger(intervalTimer, Target_SCOPE_ID)
            local Unit target = d.target
            local unit targetSelf = target.self
            set intervalTimer = null
            call HealUnitBySpell( target, Target_RELATIVE_RESTORED_LIFE_PER_INTERVAL * GetUnitState( targetSelf, UNIT_STATE_MAX_LIFE ) )
            call AddUnitState( targetSelf, UNIT_STATE_MANA, Target_RELATIVE_RESTORED_MANA_PER_INTERVAL * GetUnitState(targetSelf, UNIT_STATE_MAX_MANA) )
            set targetSelf = null
        endfunction

        public function Target_Start takes Unit target returns nothing
            local timer durationTimer
            local timer intervalTimer
            local integer targetId = target.id
            local Target_Data d = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
            if ( d == NULL ) then
                set d = Target_Data.create()
                set durationTimer = CreateTimerWJ()
                set intervalTimer = CreateTimerWJ()
                set d.durationTimer = durationTimer
                set d.intervalTimer = intervalTimer
                set d.target = target
                call AttachInteger( durationTimer, Target_SCOPE_ID, d )
                call AttachInteger( intervalTimer, Target_SCOPE_ID, d )
                call AttachIntegerById( targetId, Target_SCOPE_ID, d )
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DAMAGE" )
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DISPEL" )
            else
                set durationTimer = d.durationTimer
                set intervalTimer = d.intervalTimer
                call DestroyEffectWJ( d.targetEffect )
            endif
            set d.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
            call TimerStart( intervalTimer, Target_INTERVAL, true, function Target_IntervalByTimer )
            set intervalTimer = null
            call TimerStart( durationTimer, Target_DURATION, false, function Target_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY", "0", "function Target_Damage_Event" )
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            //! runtextmacro CreateEvent( "Target_EVENT_DISPEL", "UnitDies_EVENT_KEY", "0", "function Target_Dispel_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_FLYING ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        return true
    endfunction

    private function StartByTimer takes nothing returns nothing
        local timer delayTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(delayTimer, ThermalFissure_SCOPE_ID)
        local effect areaEffect = d.areaEffect
        local Unit caster = d.caster
        local unit enumUnit
        local real targetX = d.targetX
        local real targetY = d.targetY
        call d.destroy()
        call DestroyEffectWJ( areaEffect )
        set areaEffect = null
        call FlushAttachedInteger( delayTimer, ThermalFissure_SCOPE_ID )
        call DestroyTimerWJ( delayTimer )
        set delayTimer = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, targetX, targetY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call Target_Target_Start(GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local unit casterSelf = caster.self
        local Data d = Data.create()
        local timer delayTimer = CreateTimerWJ()
        local real targetX = GetUnitX( casterSelf )
        local real targetY = GetUnitY( casterSelf )
        set casterSelf = null
        set d.areaEffect = AddSpecialEffectWJ( AREA_EFFECT_PATH, targetX, targetY )
        set d.caster = caster
        set d.targetX = targetX
        set d.targetY = targetY
        call AttachInteger( delayTimer, ThermalFissure_SCOPE_ID, d )
        call TimerStart( delayTimer, DELAY, false, function StartByTimer )
        set delayTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( AREA_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ThermalFissure.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\ToadReflection.j
//TESH.scrollpos=89
//TESH.alwaysfold=0
//! runtextmacro Scope("ToadReflection")
    globals
        private constant integer ORDER_ID = 852123//OrderId( "mirrorimage" )
        public constant integer RESEARCH_ID = 'R01J'
        public constant integer SPELL_ID = 'A08L'

        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Orc\\MirrorImage\\MirrorImageCaster.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "overhead"
        private constant real DELAY = 1.
        private constant real DURATION = 25.
        private constant real OFFSET = 65.
    endglobals

    private struct Data
        Unit caster
        effect casterEffect
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local effect casterEffect = d.casterEffect
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById( casterId, ToadReflection_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call FlushAttachedInteger( durationTimer, ToadReflection_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call RemoveUnitInvulnerability( caster )
        call RemoveUnitStun( caster, 5 )
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, ToadReflection_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, ToadReflection_SCOPE_ID)
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real angle = GetUnitFacingWJ( casterSelf ) + PI / 2
        local real casterX = GetUnitX(casterSelf)
        local real casterY = GetUnitY(casterSelf)
        local Unit illusion = CreateIllusion( caster, caster.owner )
        local unit illusionSelf = illusion.self
        local integer random = 1 - GetRandomInt(0, 1) * 2
        local real offsetX = random * OFFSET * Cos(angle)
        local real offsetY = random * OFFSET * Sin(angle)
        call Ending( caster, d, durationTimer )
        set durationTimer = null
        call SetUnitPosition(casterSelf, casterX + offsetX, casterY + offsetY)
        set casterSelf = null
        call AddUnitArmorRelativeBonus( illusion, -1 )
        call UnitApplyTimedLifeWJ( illusionSelf, DURATION )
        call SetUnitPosition(illusionSelf, casterX - offsetX, casterY - offsetY)
        set illusionSelf = null
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local Data d = GetAttachedIntegerById(casterId, ToadReflection_SCOPE_ID)
        local timer durationTimer
        local boolean isNew = (d == NULL)
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById(casterId, ToadReflection_SCOPE_ID, d)
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            call AttachInteger(durationTimer, ToadReflection_SCOPE_ID, d)
        else
            set durationTimer = d.durationTimer
            call DestroyEffectWJ( d.casterEffect )
        endif
        set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
        set casterSelf = null
        if (isNew) then
            call AddUnitInvulnerability( caster )
            call AddUnitStun( caster, 5 )
        endif
        call TimerStart( durationTimer, DELAY, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        local ResearchType d = InitResearchType( RESEARCH_ID )
        call SetResearchTypeGoldCost(d, 1, 300)

        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        call InitEffectType( CASTER_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\ToadReflection.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\TonelessMist.j
//TESH.scrollpos=36
//TESH.alwaysfold=0
//! runtextmacro Scope("TonelessMist")
    globals
        private constant integer ORDER_ID = 852592//OrderId( "silence" )
        public constant integer SPELL_ID = 'A01T'

        private real array AREA_RANGE
        private real array DURATION
    endglobals

    private function Target_Ending takes integer Target returns nothing
        local integer TargetEffect = GetAttachedInteger( TonelessMist_Id(), "TargetEffect" )
        local integer TargetGroup = GetAttachedInteger( TonelessMist_Id(), "TargetGroup" )
        call FlushAttachedInteger( Target, "TonelessMist_TargetEffect" )
        call DestroyEffectWJ( TargetEffect )
        call GroupRemoveUnitWJ( TargetGroup, Target )
        call RemoveEvent( Target, UnitDies_EVENT_KEY, 0, GetAttachedInteger( TonelessMist_Id(), "EventDeath" ) )
        call AddUnitSilence( Target, -1 )
    endfunction

    public function Target_Death takes integer DyingUnit returns nothing
        local integer TargetGroup = GetAttachedInteger( TonelessMist_Id(), "TargetGroup" )
        if ( IsUnitInGroupWJ( DyingUnit, TargetGroup ) ) then
            call Target_Ending( DyingUnit )
        endif
    endfunction

    private function Target_Death_Event takes nothing returns nothing
        call Target_Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set filterUnit = GetFilterUnit()
        if ( GetUnitState( filterUnit, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( filterUnit, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( filterUnit, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        return true
    endfunction

    private function Update takes nothing returns nothing
        local integer AbilityLevel
        local integer CasterGroup = GetAttachedInteger( TonelessMist_Id(), "CasterGroup" )
        local integer Caster
        local integer DurationTimer
        local integer EnumGroup
        local integer EnumUnit
        local integer FertilizerAbilityLevel
        local integer FirstUnit = FirstOfGroupWJ( CasterGroup )
        local integer TargetGroup = GetAttachedInteger( TonelessMist_Id(), "TargetGroup" )
        set TEMP_PLAYER = GetOwningPlayer(caster)
        if ( FirstUnit == Null() ) then
            set EnumUnit = FirstUnit
            loop
                call GroupRemoveUnitWJ( CasterGroup, EnumUnit )
                call GroupAddUnitWJ( CasterGroup, EnumUnit )
                set AbilityLevel = GetAttachedInteger( DurationTimer, "AbilityLevel" )
                set Caster = GetAttachedInteger( DurationTimer, "Caster" )
                set FertilizerAbilityLevel = GetUnitAbilityLevelWJ( Caster, Fertilizer_Id() )
                call GroupEnumUnitsInRangeWithCollision( EnumGroup, GetUnitXWJ( Caster ), GetUnitYWJ( Caster ), GetAttachedReal( TonelessMist_Id(), "AreaRange" + I2S( AbilityLevel ) ) + GetAttachedReal( Fertilizer_Id(), "TonelessMist_BonusAreaRange" + I2S( FertilizerAbilityLevel ) ), GetAttachedInteger( TonelessMist_Id(), "TargetConditions" ) )
                set EnumUnit = FirstOfGroupWJ( CasterGroup )
                exitwhen ( ( EnumUnit == FirstUnit ) or ( EnumUnit == Null() ) )
            endloop
        endif
        set FirstUnit = FirstOfGroupWJ( TargetGroup )
        if ( FirstUnit != Null() ) then
            set EnumUnit = FirstUnit
            loop
                call GroupRemoveUnitWJ( TargetGroup, EnumUnit )
                if ( IsUnitInGroupWJ( EnumUnit, EnumUnit ) ) then
                    call GroupAddUnitWJ( TargetGroup, EnumUnit )
                    call GroupRemoveUnitWJ( EnumGroup, EnumUnit )
                else
                    call TonelessMist_Target_Ending( EnumUnit )
                endif
                set EnumUnit = FirstOfGroupWJ( TargetGroup )
                exitwhen ( ( EnumUnit == FirstUnit ) or ( EnumUnit == Null() ) )
            endloop
        endif
        loop
            set EnumUnit = FirstOfGroupWJ( EnumGroup )
            exitwhen ( EnumUnit == Null() )
            call GroupRemoveUnitWJ( EnumGroup, EnumUnit )
            call GroupAddUnitWJ( TargetGroup, EnumUnit )
            call AttachInteger( EnumUnit, "TargetEffect", AddSpecialEffectTargetWJ( GetAttachedString( TonelessMist_Id(), "GraphicTarget" ), EnumUnit, GetAttachedString( TonelessMist_Id(), "GraphicTargetAttachmentPoint" ) ) )
            call AddEvent( EnumUnit, UnitDies_EVENT_KEY, 0, GetAttachedInteger( TonelessMist_Id(), "EventDeath" ) )
            call AddUnitSilence( EnumUnit, 1 )
        endloop
    endfunction

    private function Caster_Ending takes integer DurationTimer returns nothing
        local integer CasterGroup = GetAttachedInteger( TonelessMist_Id(), "CasterGroup" )
        local integer Caster = GetAttachedInteger( DurationTimer, "Caster" )
        local integer GraphicCaster = GetAttachedInteger( DurationTimer, "GraphicCaster" )
        call FlushAttachedInteger( Caster, "TonelessMist_DurationTimer" )
        call FlushAttachedInteger( DurationTimer, "AbilityLevel" )
        call FlushAttachedInteger( DurationTimer, "Caster" )
        call FlushAttachedInteger( DurationTimer, "GraphicCaster" )
        call FlushAttachedInteger( DurationTimer, "UpdateTimer" )
        call DestroyTimerWJ( DurationTimer )
        call GroupRemoveUnitWJ( CasterGroup, Caster )
        if ( FirstOfGroupWJ( CasterGroup ) == Null() ) then
            call PauseTimerWJ( GetAttachedInteger( TonelessMist_Id(), "UpdateTimer" ) )
        else
            call Update()
        endif
    endfunction

    public function Caster_Death takes integer DyingUnit returns nothing
        local integer DurationTimer = GetAttachedInteger( DyingUnit, "DurationTimer" )
        if ( DurationTimer != Null() ) then
            call Caster_Ending( DurationTimer )
        endif
    endfunction

    private function Caster_Death_Event takes nothing returns nothing
        call Caster_Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local integer DurationTimer = GetExpiredTimerWJ()
        call Caster_Ending( DurationTimer )
    endfunction

    public function SpellEffect takes integer Caster returns nothing
        local integer AbilityLevel = GetUnitAbilityLevelWJ( Caster, TonelessMist_Id() )
        local integer CasterGroup = GetAttachedInteger( TonelessMist_Id(), "CasterGroup" )
        local integer DurationTimer = GetAttachedInteger( Caster, "Frenzy_DurationTimer" )
        if ( DurationTimer == Null() ) then
            set DurationTimer = CreateTimerWJ()
            call AttachInteger( Caster, "TonelessMist_DurationTimer", DurationTimer )
            call AttachInteger( DurationTimer, "AbilityLevel", AbilityLevel )
            call AttachInteger( DurationTimer, "Caster", Caster )
            call AttachInteger( DurationTimer, "GraphicCaster", AddSpecialEffectTargetWJ( GetAttachedString( TonelessMist_Id(), "GraphicCaster" ), Caster, GetAttachedString( TonelessMist_Id(), "GraphicCasterAttachmentPoint" ) ) )
            call GroupAddUnitWJ( CasterGroup, Caster )
            call TonelessMist_Update()
            call TimerStartWJ( GetAttachedInteger( TonelessMist_Id(), "UpdateTimer" ), GetAttachedReal( TonelessMist_Id(), "UpdateTime" ), true, function Update )
        endif
        call TimerStartWJ( DurationTimer, GetAttachedReal( TonelessMist_Id(), "Duration" + I2S( AbilityLevel ) ), false, function EndingByTimer )
    endfunction

    public function Init takes nothing returns nothing
        set AREA_RANGE[1] = 400
        set AREA_RANGE[2] = 400
        set DURATION[1] = 30
        set DURATION[2] = 30
        call AttachInteger( TonelessMist_Id(), "CasterGroup", CreateGroupWJ() )
        set ENUM_GROUP = CreateGroupWJ()
        call AttachInteger( TonelessMist_Id(), "EventCasterDeath", CreateEvent( function Caster_Death_Event ) )
        call AttachInteger( TonelessMist_Id(), "EventTargetDeath", CreateEvent( function Target_Death_Event ) )
        call AttachString( TonelessMist_Id(), "GraphicCaster", "Abilities\\Spells\\Other\\Silence\\SilenceTarget.mdl" )
        call AttachString( TonelessMist_Id(), "GraphicCasterAttachmentPoint", "Abilities\\Spells\\Other\\Silence\\SilenceTarget.mdl" )
        call AttachString( TonelessMist_Id(), "GraphicTarget", "Abilities\\Spells\\Other\\Silence\\SilenceTarget.mdl" )
        call AttachString( TonelessMist_Id(), "GraphicTargetAttachmentPoint", "overhead" )
        call AttachInteger( TonelessMist_Id(), "TargetConditions", ConditionWJ( function TargetConditions ) )
        call AttachInteger( TonelessMist_Id(), "TargetGroup", CreateGroupWJ() )
        call AttachReal( TonelessMist_Id(), "UpdateTime", 0.5 )
        call AttachInteger( TonelessMist_Id(), "UpdateTimer", CreateTimerWJ() )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\TonelessMist.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\UnholyArmor.j
//TESH.scrollpos=248
//TESH.alwaysfold=0
//! runtextmacro Scope("UnholyArmor")
    globals
        public constant integer SPELL_ID = 'A06R'

        private constant real AREA_RANGE = 500.
        private constant real BONUS_RELATIVE_STUN_DURATION = -0.3
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Items\\OrbDarkness\\OrbDarkness.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "chest"
        private group ENUM_GROUP
        private group ENUM_GROUP2
        private boolexpr TARGET_CONDITIONS
        private constant real UPDATE_TIME = 1.
    endglobals

    private struct Data
        Unit caster
        effect casterEffect
        group targetGroup
        timer updateTimer
    endstruct

    private function GetCasterData takes Unit caster returns Data
        return GetAttachedIntegerById(caster.id, UnholyArmor_SCOPE_ID)
    endfunction

    //! runtextmacro Scope("Target")
        globals
            private constant real Target_BONUS_RELATIVE_SIGHT_RANGE = -0.25
            private constant string Target_TARGET_EFFECT_PATH = "Abilities\\Spells\\Undead\\CarrionSwarm\\CarrionSwarmDamage.mdl"
            private constant string Target_TARGET_EFFECT_ATTACHMENT_POINT = "origin"
        endglobals

        private struct Target_Data
            real bonusSightRange
            group casterGroup
            effect targetEffect
        endstruct

        private function Target_Ending takes Unit caster, group casterGroup, Target_Data d, Unit target, group targetGroup returns nothing
            local real bonusSightRange
            local effect targetEffect
            local integer targetId
            call GroupRemoveUnit( casterGroup, caster.self )
            call GroupRemoveUnit( targetGroup, target.self )
            if ( FirstOfGroup(casterGroup) == null ) then
                set bonusSightRange = d.bonusSightRange
                set targetEffect = d.targetEffect
                set targetId = target.id
                call d.destroy()
                call DestroyGroupWJ(casterGroup)
                call FlushAttachedIntegerById( targetId, Target_SCOPE_ID )
                //! runtextmacro RemoveEventById( "targetId", "Target_EVENT_DEATH" )
                call DestroyEffectWJ( targetEffect )
                set targetEffect = null
                call AddUnitSightRange( target, -bonusSightRange )
            endif
            set casterGroup = null
        endfunction

        public function Target_EndingByDeath takes Unit caster, Unit target, group targetGroup returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            call Target_Ending(caster, d.casterGroup, d, target, targetGroup)
        endfunction

        public function Target_EndingByUpdate takes Unit caster, Unit target, group targetGroup returns nothing
            local Target_Data d = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            call Target_Ending(caster, d.casterGroup, d, target, targetGroup)
        endfunction

        public function Target_Death takes Unit target returns nothing
            local Unit caster
            local group casterGroup
            local Data d
            local Target_Data e = GetAttachedIntegerById(target.id, Target_SCOPE_ID)
            local integer iteration
            if (e != NULL) then
                set casterGroup = e.casterGroup
                set iteration = CountUnits( casterGroup )
                if (iteration > 0) then
                    loop
                        set caster = GetUnit(FirstOfGroup(casterGroup))
                        set d = GetCasterData(caster)
                        call Target_Ending( caster, casterGroup, e, target, d.targetGroup )
                        set iteration = iteration - 1
                        exitwhen ( iteration < 1 )
                    endloop
                endif
                set casterGroup = null
            endif
        endfunction

        private function Target_Death_Event takes nothing returns nothing
            call Target_Death( DYING_UNIT )
        endfunction

        public function Target_Start takes Unit caster, Unit target returns nothing
            local real bonusSightRange = GetUnitSightRange( target ) * Target_BONUS_RELATIVE_SIGHT_RANGE
            local group casterGroup
            local real oldBonusSightRange
            local integer targetId = target.id
            local Target_Data d = GetAttachedIntegerById(targetId, Target_SCOPE_ID)
            local boolean isNew = (d == NULL)
            if (isNew) then
                set casterGroup = CreateGroupWJ()
                set d = Target_Data.create()
                set d.bonusSightRange = bonusSightRange
                set d.casterGroup = casterGroup
                set d.targetEffect = AddSpecialEffectTargetWJ( Target_TARGET_EFFECT_PATH, target.self, Target_TARGET_EFFECT_ATTACHMENT_POINT )
                call AttachIntegerById(targetId, Target_SCOPE_ID, d)
                //! runtextmacro AddEventById( "targetId", "Target_EVENT_DEATH" )
            else
                set casterGroup = d.casterGroup
                set oldBonusSightRange = d.bonusSightRange
                set d.bonusSightRange = bonusSightRange
            endif
            call GroupAddUnit(casterGroup, caster.self)
            set casterGroup = null
            if (isNew) then
                call AddUnitSightRange( target, bonusSightRange )
            else
                call AddUnitSightRange( target, bonusSightRange - oldBonusSightRange )
            endif
        endfunction

        public function Target_Init takes nothing returns nothing
            //! runtextmacro CreateEvent( "Target_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Target_Death_Event" )
            call InitEffectType( Target_TARGET_EFFECT_PATH )
        endfunction
    //! runtextmacro Endscope()

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, UnholyArmor_SCOPE_ID)
        local unit enumUnit
        local group targetGroup
        if ( d != NULL ) then
            set targetGroup = d.targetGroup
            call DestroyEffectWJ( d.casterEffect )
            loop
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
                call Target_Target_EndingByDeath( caster, GetUnit(enumUnit), targetGroup )
            endloop
            set targetGroup = null
            call PauseTimer( d.updateTimer )
            call AddUnitStunDurationRelativeBonus( caster, -BONUS_RELATIVE_STUN_DURATION )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( GetUnitMagicImmunity( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function Update takes Unit caster, group targetGroup returns nothing
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local unit enumUnit
        set casterSelf = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS )
        set enumUnit = FirstOfGroup( targetGroup )
        if ( enumUnit != null ) then
            loop
                if ( IsUnitInGroup( enumUnit, ENUM_GROUP ) == false ) then
                    call Target_Target_EndingByUpdate( caster, GetUnit(enumUnit), targetGroup )
                else
                    call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                    call GroupRemoveUnit( targetGroup, enumUnit )
                    call GroupAddUnit( ENUM_GROUP2, enumUnit )
                endif
                set enumUnit = FirstOfGroup( targetGroup )
                exitwhen ( enumUnit == null )
            endloop
            set enumUnit = FirstOfGroup( ENUM_GROUP2 )
            loop
                call GroupRemoveUnit( ENUM_GROUP2, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                set enumUnit = FirstOfGroup( ENUM_GROUP2 )
                exitwhen ( enumUnit == null )
            endloop
        endif
        set enumUnit = FirstOfGroup( ENUM_GROUP )
        if ( enumUnit != null ) then
            loop
                call GroupRemoveUnit( ENUM_GROUP, enumUnit )
                call GroupAddUnit( targetGroup, enumUnit )
                call Target_Target_Start(caster, GetUnit(enumUnit))
                set enumUnit = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnit == null )
            endloop
        endif
    endfunction

    private function UpdateByTimer takes nothing returns nothing
        local timer updateTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(updateTimer, UnholyArmor_SCOPE_ID)
        set updateTimer = null
        call Update( d.caster, d.targetGroup )
    endfunction

    public function Revive takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, UnholyArmor_SCOPE_ID)
        if ( d != NULL ) then
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT )
            call AddUnitStunDurationRelativeBonus( caster, BONUS_RELATIVE_STUN_DURATION )
            call TimerStart( d.updateTimer, UPDATE_TIME, true, function UpdateByTimer )
            call Update( caster, d.targetGroup )
        endif
    endfunction

    private function Revive_Event takes nothing returns nothing
        call Revive( REVIVING_UNIT )
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = Data.create()
        local group targetGroup = CreateGroupWJ()
        local timer updateTimer = CreateTimerWJ()
        set d.caster = caster
        set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, caster.self, CASTER_EFFECT_ATTACHMENT_POINT )
        set d.targetGroup = targetGroup
        set d.updateTimer = updateTimer
        call AttachIntegerById( casterId, UnholyArmor_SCOPE_ID, d )
        //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro AddEventById( "casterId", "EVENT_REVIVE" )
        call AttachInteger( updateTimer, UnholyArmor_SCOPE_ID, d )
        call AddUnitStunDurationRelativeBonus( caster, BONUS_RELATIVE_STUN_DURATION )
        call TimerStart( updateTimer, UPDATE_TIME, true, function UpdateByTimer )
        set updateTimer = null
        call Update( caster, targetGroup )
        set targetGroup = null
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        set ENUM_GROUP2 = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_REVIVE", "UnitFinishesReviving_EVENT_KEY", "0", "function Revive_Event" )
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Target_Target_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\UnholyArmor.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\UtilizationOfRests.j
//TESH.scrollpos=267
//TESH.alwaysfold=0
//! runtextmacro Scope("UtilizationOfRests")
    globals
        public constant integer SPELL_ID = 'A079'

        private constant real AREA_RANGE = 500.
        private boolexpr CASTER_CONDITIONS
        private real array CHANCE
        private real array CHANCE_PER_AGILITY_POINT
        private group ENUM_GROUP
        private constant integer MAX_MAX_SERVANTS_AMOUNT = 5
        private integer array MAX_SERVANTS_AMOUNT
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Undead\\RaiseSkeletonWarrior\\RaiseSkeleton.mdl"
    endglobals

    private struct Data
        integer abilityLevel
        Unit array servants[MAX_MAX_SERVANTS_AMOUNT]
        integer servantsAmount
    endstruct

    //! runtextmacro Scope("Servant")
        globals
            private real array Servant_DURATION
            private integer array Servant_SUMMON_UNIT_ID
        endglobals

        private struct Servant_Data
            Data d
            integer index
        endstruct

        //! runtextmacro Scope("Release")
            globals
                private constant real Release_RELEASE_TIME = 1.2
            endglobals

            private struct Release_Data
                integer abilityLevel
                timer releaseTimer
                Unit servant
            endstruct

            private function Release_Ending takes Release_Data d, timer releaseTimer, Unit servant returns nothing
                local integer servantId = servant.id
                call d.destroy()
                call FlushAttachedInteger( releaseTimer, Release_SCOPE_ID )
                call DestroyTimerWJ( releaseTimer )
                call FlushAttachedIntegerById(servantId, Release_SCOPE_ID)
                //! runtextmacro RemoveEventById( "servantId", "Release_EVENT_DEATH" )
            endfunction

            public function Release_Death takes Unit servant returns nothing
                local Release_Data d = GetAttachedIntegerById(servant.id, Release_SCOPE_ID)
                if (d != NULL) then
                    call Release_Ending(d, d.releaseTimer, servant)
                endif
            endfunction

            private function Release_Death_Event takes nothing returns nothing
                call Release_Death(DYING_UNIT)
            endfunction

            private function Release_EndingByTimer takes nothing returns nothing
                local timer releaseTimer = GetExpiredTimer()
                local Release_Data d = GetAttachedInteger(releaseTimer, Release_SCOPE_ID)
                local integer abilityLevel = d.abilityLevel
                local Unit servant = d.servant
                local unit servantSelf = servant.self
                call Release_Ending(d, releaseTimer, servant)
                set releaseTimer = null
                call SetUnitBlendTime( servantSelf, 0.15 )
                call SetUnitTimeScale( servantSelf, 1 )
                call SetUnitAnimationByIndex( servantSelf, 0 )
                call PauseUnit( servantSelf, false )
                call SetUnitInvulnerable( servantSelf, false )
                call UnitApplyTimedLifeWJ( servantSelf, Servant_DURATION[abilityLevel] )
                set servantSelf = null
            endfunction

            public function Release_Start takes integer abilityLevel, Unit servant returns nothing
                local Release_Data d = Release_Data.create()
                local timer releaseTimer = CreateTimerWJ()
                local integer servantId = servant.id
                local unit servantSelf = servant.self
                set d.abilityLevel = abilityLevel
                set d.releaseTimer = releaseTimer
                set d.servant = servant
                call AttachInteger( releaseTimer, Release_SCOPE_ID, d )
                call AttachIntegerById(servantId, Release_SCOPE_ID, d)
                //! runtextmacro AddEventById( "servantId", "Release_EVENT_DEATH" )
                call SetUnitBlendTime( servantSelf, 0 )
                call SetUnitTimeScale( servantSelf, 2 )
                call SetUnitAnimationByIndex( servantSelf, 5 )
                call PauseUnit( servantSelf, true )
                call SetUnitInvulnerable( servantSelf, true )
                set servantSelf = null
                call TimerStart( releaseTimer, Release_RELEASE_TIME, false, function Release_EndingByTimer )
                set releaseTimer = null
            endfunction

            public function Release_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "Release_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Release_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        public function Servant_Death takes Unit servant returns nothing
            local Data d
            local integer index
            local integer servantId = servant.id
            local Servant_Data e = GetAttachedIntegerById(servantId, Servant_SCOPE_ID)
            local integer servantsAmount
            if ( e != NULL ) then
                set d = e.d
                set index = e.index
                set servantsAmount = d.servantsAmount - 1
                call e.destroy()
                set d.servants[index] = d.servants[servantsAmount]
                set d.servantsAmount = servantsAmount
                call FlushAttachedIntegerById( servantId, Servant_SCOPE_ID )
                //! runtextmacro RemoveEventById( "servantId", "Servant_EVENT_DEATH" )
            endif
        endfunction

        private function Servant_Death_Event takes nothing returns nothing
            call Servant_Death( DYING_UNIT )
        endfunction

        public function Servant_Start takes integer abilityLevel, real angle, Unit caster, Data d, real x, real y returns nothing
            local Servant_Data e = Servant_Data.create()
            local integer index = d.servantsAmount
            local Unit servant = CreateUnitEx( caster.owner, Servant_SUMMON_UNIT_ID[abilityLevel], x, y, angle )
            local integer servantId = servant.id
            local integer servantsAmount = index + 1
            set d.servants[index] = servant
            set d.servantsAmount = servantsAmount
            set e.d = d
            set e.index = servantsAmount - 1
            call AttachIntegerById( servantId, Servant_SCOPE_ID, e )
            //! runtextmacro AddEventById( "servantId", "Servant_EVENT_DEATH" )
            call Release_Release_Start(abilityLevel, servant)
        endfunction

        public function Servant_Init takes nothing returns nothing
            set Servant_DURATION[1] = 30
            set Servant_DURATION[2] = 30
            set Servant_DURATION[3] = 30
            set Servant_DURATION[4] = 30
            set Servant_DURATION[5] = 30
            //! runtextmacro CreateEvent( "Servant_EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Servant_Death_Event" )
            set Servant_SUMMON_UNIT_ID[1] = ZOMBIE_LEVEL1_UNIT_ID
            set Servant_SUMMON_UNIT_ID[2] = ZOMBIE_LEVEL2_UNIT_ID
            set Servant_SUMMON_UNIT_ID[3] = ZOMBIE_LEVEL3_UNIT_ID
            set Servant_SUMMON_UNIT_ID[4] = ZOMBIE_LEVEL4_UNIT_ID
            set Servant_SUMMON_UNIT_ID[5] = ZOMBIE_LEVEL5_UNIT_ID
            call Release_Release_Init()
        endfunction
    //! runtextmacro Endscope()

    public function Caster_Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, UtilizationOfRests_SCOPE_ID)
        local integer iteration
        if (d != NULL) then
            set iteration = d.servantsAmount - 1
            loop
                call KillUnit( d.servants[iteration].self )
                set iteration = iteration - 1
                exitwhen ( iteration < 0 )
            endloop
        endif
    endfunction

    private function Caster_Death_Event takes nothing returns nothing
        call Caster_Death( DYING_UNIT )
    endfunction

    private function CasterConditions takes nothing returns boolean
        local Data d
        set FILTER_UNIT_SELF = GetFilterUnit()
        set d = GetAttachedIntegerById(GetUnit(FILTER_UNIT_SELF).id, UtilizationOfRests_SCOPE_ID)
        if ( d == NULL ) then
            return false
        endif
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( d.servantsAmount >= MAX_SERVANTS_AMOUNT[d.abilityLevel] ) then
            return false
        endif
        return true
    endfunction

    private function Source_Death_Conditions takes Unit source returns boolean
        if ( GetUnitCanNotBeRevived(source) > 0 ) then
            return false
        endif
        set TEMP_UNIT_SELF = source.self
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_HERO ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitIllusionWJ( source ) ) then
            return false
        endif
        if ( IsUnitWard( source ) ) then
            return false
        endif
        return true
    endfunction

    public function Source_Death takes Unit source, real sourceX, real sourceY returns nothing
        local integer abilityLevel
        local Unit enumUnit
        local unit enumUnitSelf
        local boolean found
        local real sourceAngle
        if ( Source_Death_Conditions( source ) ) then
            set found = false
            call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, sourceX, sourceY, AREA_RANGE, CASTER_CONDITIONS )
            set enumUnitSelf = GetNearestUnit( ENUM_GROUP, sourceX, sourceY )
            if (enumUnitSelf != null) then
                loop
                    set abilityLevel = GetUnitAbilityLevel(enumUnitSelf, SPELL_ID)
                    set enumUnit = GetUnit(enumUnitSelf)
                    call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                    if ( GetRandomReal( 0.01, 1 ) < CHANCE[abilityLevel] + GetHeroAgilityTotal( enumUnit ) * CHANCE_PER_AGILITY_POINT[abilityLevel] ) then
                        set found = true
                        set sourceAngle = GetUnitFacingWJ( source.self )
                        call RemoveUnitEx( source )
                        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, sourceX, sourceY ) )
                        call Servant_Servant_Start(abilityLevel, sourceAngle, enumUnit, GetAttachedIntegerById(enumUnit.id, UtilizationOfRests_SCOPE_ID), sourceX, sourceY )
                    endif
                    exitwhen (found)
                    set enumUnitSelf = GetNearestUnit( ENUM_GROUP, sourceX, sourceY )
                    exitwhen ( enumUnitSelf == null )
                endloop
                if (found) then
                    set enumUnitSelf = null
                endif
            endif
        endif
    endfunction

    private function Source_Death_Event takes nothing returns nothing
        local unit dyingUnitSelf = DYING_UNIT.self
        call Source_Death( DYING_UNIT, GetUnitX(dyingUnitSelf), GetUnitY(dyingUnitSelf) )
        set dyingUnitSelf = null
    endfunction

    public function Learn takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, UtilizationOfRests_SCOPE_ID)
        if (d == NULL) then
            set d = Data.create()
            call AttachIntegerById(casterId, UtilizationOfRests_SCOPE_ID, d)
        endif
        set d.abilityLevel = GetUnitAbilityLevel(caster.self, SPELL_ID)
    endfunction

    private function Learn_Event takes nothing returns nothing
        call Learn( LEARNER )
    endfunction

    public function Init takes nothing returns nothing
        set CASTER_CONDITIONS = ConditionWJ( function CasterConditions )
        set CHANCE[1] = 0.3
        set CHANCE[2] = 0.3
        set CHANCE[3] = 0.3
        set CHANCE[4] = 0.3
        set CHANCE[5] = 0.3
        set CHANCE_PER_AGILITY_POINT[1] = 0.003
        set CHANCE_PER_AGILITY_POINT[2] = 0.003
        set CHANCE_PER_AGILITY_POINT[3] = 0.003
        set CHANCE_PER_AGILITY_POINT[4] = 0.003
        set CHANCE_PER_AGILITY_POINT[5] = 0.003
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_CASTER_DEATH", "UnitDies_EVENT_KEY", "0", "function Caster_Death_Event" )
        set MAX_SERVANTS_AMOUNT[1] = 4
        set MAX_SERVANTS_AMOUNT[2] = 4
        set MAX_SERVANTS_AMOUNT[3] = 4
        set MAX_SERVANTS_AMOUNT[4] = 4
        set MAX_SERVANTS_AMOUNT[5] = 4
        call InitEffectType( SPECIAL_EFFECT_PATH )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_LEARN", "SPELL_ID", "UnitLearnsSkill_EVENT_KEY", "0", "function Learn_Event" )
        call Servant_Servant_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\UtilizationOfRests.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\VioletDefense.j
//TESH.scrollpos=129
//TESH.alwaysfold=0
//! runtextmacro Scope("VioletDefense")
    globals
        public constant integer ORDER_ID = 852132//OrderId( "autodispel" )
        public constant integer SPELL_ID = 'A07W'

        private constant real BONUS_ARMOR_BY_SPELL = 0.3
        private constant real DURATION = 30.
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Other\\HowlOfTerror\\HowlTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger(durationTimer, VioletDefense_SCOPE_ID)
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedIntegerById(targetId, VioletDefense_SCOPE_ID)
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call AddUnitArmorBySpellBonus( target, -BONUS_ARMOR_BY_SPELL )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, VioletDefense_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, VioletDefense_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    public function SpellEffect takes Unit caster, Unit target returns nothing
        local player casterOwner = caster.owner
        local timer durationTimer
        local integer targetId = target.id
        local Data d = GetAttachedIntegerById(targetId, VioletDefense_SCOPE_ID)
        local boolean isNew = ( d == NULL )
        set casterOwner = null
        if ( isNew ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.durationTimer = durationTimer
            set d.target = target
            call AttachInteger( durationTimer, VioletDefense_SCOPE_ID, d )
            call AttachIntegerById( targetId, VioletDefense_SCOPE_ID, d )
            //! runtextmacro AddEventById( "targetId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "targetId", "EVENT_DISPEL" )
        else
            set durationTimer = d.durationTimer
            call DestroyEffectWJ( d.targetEffect )
        endif
        set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, target.self, TARGET_EFFECT_ATTACHMENT_POINT )
        if ( isNew ) then
            call AddUnitArmorBySpellBonus( target, BONUS_ARMOR_BY_SPELL )
        endif
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER, TARGET_UNIT )
    endfunction

    private function TargetConditions_Single_String takes player casterOwner, Unit checkingUnit returns string
        set TEMP_UNIT_SELF = checkingUnit.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) == false ) then
            return ErrorStrings_ONLY_ALLY
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return ErrorStrings_NOT_STRUCTURE
        endif
        if ( IsUnitWard( checkingUnit ) ) then
            return ErrorStrings_NOT_WARD
        endif
        return null
    endfunction

    public function Order takes Unit caster, Unit target returns string
        return TargetConditions_Single_String( caster.owner, target )
    endfunction

    private function Order_Event takes nothing returns nothing
        set ERROR_MSG = Order( ORDERED_UNIT, TARGET_UNIT )
    endfunction

    //! runtextmacro Scope("Automatic")
        globals
            public constant integer Automatic_ACTIVATION_ORDER_ID = 852133//OrderId( "autodispelon" )
            public constant integer Automatic_DEACTIVATION_ORDER_ID = 852134//OrderId( "autodispeloff" )

            private constant real Automatic_AREA_RANGE = 500.
            private group Automatic_ENUM_GROUP
            private boolexpr Automatic_TARGET_CONDITIONS
        endglobals

        private function Automatic_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            set FILTER_UNIT = GetUnit(FILTER_UNIT_SELF)
            if ( TargetConditions_Single_String( TEMP_PLAYER, FILTER_UNIT ) != null ) then
                return false
            endif
            if ( GetAttachedIntegerById( FILTER_UNIT.id, VioletDefense_SCOPE_ID ) != NULL ) then
                return false
            endif
            return true
        endfunction

        public function Automatic_TargetInRange takes Unit caster, player casterOwner returns nothing
            local unit casterSelf
            local unit enumUnit
            if ( GetUnitAutomaticAbility(caster) == SPELL_ID ) then
                set casterSelf = caster.self
                set TEMP_PLAYER = casterOwner
                call GroupEnumUnitsInRangeWithCollision( Automatic_ENUM_GROUP, GetUnitX( casterSelf ), GetUnitY( casterSelf ), Automatic_AREA_RANGE, Automatic_TARGET_CONDITIONS )
                set enumUnit = GetRandomUnit( Automatic_ENUM_GROUP )
                if ( enumUnit != null ) then
                    call IssueTargetOrderByIdTimed( caster, ORDER_ID, GetUnit(enumUnit), 0 )
                    set enumUnit = null
                endif
                set casterSelf = null
            endif
        endfunction

        private function Automatic_TargetInRange_Event takes nothing returns nothing
            call Automatic_TargetInRange( TRIGGER_UNIT, TRIGGER_UNIT.owner )
        endfunction

        public function Automatic_Activation_Order takes Unit caster returns nothing
            //! runtextmacro AddEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, SPELL_ID)
        endfunction

        private function Automatic_Activation_Order_Event takes nothing returns nothing
            call Automatic_Activation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Deactivation_Order takes Unit caster returns nothing
            //! runtextmacro RemoveEventById( "caster.id", "Automatic_EVENT_ACQUIRE" )
            call SetUnitAutomaticAbility(caster, 0)
        endfunction

        private function Automatic_Deactivation_Order_Event takes nothing returns nothing
            call Automatic_Deactivation_Order( ORDERED_UNIT )
        endfunction

        public function Automatic_Init takes nothing returns nothing
            set Automatic_ENUM_GROUP = CreateGroupWJ()
            set Automatic_TARGET_CONDITIONS = ConditionWJ( function Automatic_TargetConditions )
            call AddOrderAbility( Automatic_ACTIVATION_ORDER_ID, SPELL_ID )
            call AddOrderAbility( Automatic_DEACTIVATION_ORDER_ID, SPELL_ID )
            //! runtextmacro CreateEvent( "Automatic_EVENT_ACQUIRE", "UnitAcquiresTarget_EVENT_KEY", "0", "function Automatic_TargetInRange_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_ACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_ACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Activation_Order_Event" )
            //! runtextmacro AddNewEventById( "Automatic_EVENT_DEACTIVATION_ORDER", "GetAbilityOrderId( SPELL_ID, Automatic_DEACTIVATION_ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Automatic_Deactivation_Order_Event" )
        endfunction
    //! runtextmacro Endscope()

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_EVENT_KEY", "0", "function Order_Event" )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call Automatic_Automatic_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\VioletDefense.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\VividStrikes.j
//TESH.scrollpos=107
//TESH.alwaysfold=0
//! runtextmacro Scope("VividStrikes")
    globals
        private constant integer ORDER_ID = 852157//OrderId( "recharge" )
        public constant integer SPELL_ID = 'A06T'

        private constant real ABSORPTION_FACTOR_START = 0.03
        private constant real ABSORPTION_FACTOR_START_PER_INTELLIGENCE_POINT = 0.00033
        private constant real ABSORPTION_FACTOR_ADD = 0.01
        private constant real ABSORPTION_FACTOR_ADD_PER_INTELLIGENCE_POINT = 0.00011
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Items\\VampiricPotion\\VampPotionCaster.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "origin"
        private constant string CASTER_EFFECT2_PATH = "VividStrikesCaster2.mdl"
        private constant string CASTER_EFFECT2_ATTACHMENT_POINT = "origin"
        private constant real DAMAGE_FACTOR = 0.01
        private constant real DAMAGE_FACTOR_PER_INTELLIGENCE_POINT = 0.00033
        private constant real DURATION = 15.
        private constant string EFFECT_SOUND_PATH = "VividStrikes"
        private constant integer MAX_STRIKES_AMOUNT = 5
        private constant string TARGET_EFFECT_PATH = "Abilities\\Weapons\\MeatwagonMissile\\MeatwagonMissile.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
    endglobals

    private struct Data
        real absorptionFactor
        real absorptionFactorAdd
        Unit caster
        effect casterEffect
        real damageFactor
        timer durationTimer
        integer strikesAmount
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local effect casterEffect = d.casterEffect
        local integer casterId = caster.id
        call d.destroy()
        call FlushAttachedIntegerById( casterId, VividStrikes_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DAMAGE" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
    //    //! runtextmacro RemoveEventById( "casterId", "EVENT_DISPEL" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call FlushAttachedInteger( durationTimer, VividStrikes_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
    endfunction

    public function Dispel takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, VividStrikes_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit caster returns nothing
        call Dispel( caster )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, VividStrikes_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    private function Damage_Conditions takes player casterOwner, Unit target returns boolean
        set TEMP_UNIT_SELF = target.self
        if ( IsUnitAlly( TEMP_UNIT_SELF, casterOwner ) ) then
            return false
        endif
        if ( IsUnitType( TEMP_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitIllusionWJ( target ) ) then
            return false
        endif
        if ( IsUnitWard( target ) ) then
            return false
        endif
        return true
    endfunction

    public function Damage takes Unit caster, real damageAmount, Unit target returns real
        local real absorptionFactor
        local unit casterSelf
        local Data d = GetAttachedIntegerById(caster.id, VividStrikes_SCOPE_ID)
        local integer strikesAmount
        local unit targetSelf
        if (d != NULL) then
            if ( Damage_Conditions( caster.owner, target ) ) then
                set absorptionFactor = d.absorptionFactor
                set casterSelf = caster.self
                set strikesAmount = d.strikesAmount + 1
                set targetSelf = target.self
                set damageAmount = damageAmount + d.damageFactor * GetUnitState( targetSelf, UNIT_STATE_MAX_LIFE )
                if ( strikesAmount >= MAX_STRIKES_AMOUNT ) then
                    call Ending( caster, d, d.durationTimer )
                else
                    set d.absorptionFactor = absorptionFactor + d.absorptionFactorAdd
                    set d.strikesAmount = strikesAmount
                endif
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( CASTER_EFFECT2_PATH, casterSelf, CASTER_EFFECT2_ATTACHMENT_POINT ) )
                call DestroyEffectWJ( AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, targetSelf, TARGET_EFFECT_PATH ) )
                call HealUnitBySpell( caster, absorptionFactor * GetUnitState( casterSelf, UNIT_STATE_MAX_LIFE ) )
                set casterSelf = null
            endif
            set targetSelf = null
        endif
        return damageAmount
    endfunction

    private function Damage_Event takes nothing returns nothing
        set DAMAGE_AMOUNT = Damage( DAMAGE_SOURCE, DAMAGE_AMOUNT, TRIGGER_UNIT )
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local integer casterId = caster.id
        local Data d = GetAttachedIntegerById(casterId, VividStrikes_SCOPE_ID)
        local real casterIntelligence = GetHeroIntelligenceTotal( caster )
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local timer durationTimer
        if ( d == NULL ) then
            set d = Data.create()
            set durationTimer = CreateTimerWJ()
            set d.caster = caster
            set d.durationTimer = durationTimer
            call AttachIntegerById( casterId, VividStrikes_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "EVENT_DAMAGE" )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
    //        //! runtextmacro AddEventById( "casterId", "EVENT_DISPEL" )
            call AttachInteger( durationTimer, VividStrikes_SCOPE_ID, d )
        else
            set durationTimer = d.durationTimer
            call DestroyEffectWJ( d.casterEffect )
        endif
        set d.absorptionFactor = ABSORPTION_FACTOR_START + casterIntelligence * ABSORPTION_FACTOR_START_PER_INTELLIGENCE_POINT
        set d.absorptionFactorAdd = ABSORPTION_FACTOR_ADD + casterIntelligence * ABSORPTION_FACTOR_ADD_PER_INTELLIGENCE_POINT
        set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
        set casterSelf = null
        set d.damageFactor = DAMAGE_FACTOR + casterIntelligence * DAMAGE_FACTOR_PER_INTELLIGENCE_POINT
        set d.strikesAmount = 0
    //    call PlaySoundFromLabelAtPosition( EFFECT_SOUND_PATH, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) )
        call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        //! runtextmacro CreateEvent( "EVENT_DAMAGE", "UnitTakesDamage_EVENT_KEY_PRIMARY_FOR_UNBLOCKABLE_AS_DAMAGE_SOURCE", "0", "function Damage_Event" )
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
    //    //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        call InitEffectType( CASTER_EFFECT_PATH )
        call InitEffectType( CASTER_EFFECT2_PATH )
        call InitEffectType( TARGET_EFFECT_PATH )
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\VividStrikes.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\WhipLash.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("WhipLash")
    globals
        private constant integer ORDER_ID = 852129//OrderId( "windwalk" )
        public constant integer SPELL_ID = 'A07O'

        private constant real AREA_RANGE = 525.
        private constant real BONUS_RELATIVE_ATTACK_RATE = 0.25
        private constant real BONUS_RELATIVE_SPEED = 0.5
        private constant real DURATION = 10.
        private group ENUM_GROUP
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_PATH = "Abilities\\Spells\\Items\\AIsp\\SpeedTarget.mdl"
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "origin"
    endglobals

    private struct Data
        real bonusSpeed
        timer durationTimer
        Unit target
        effect targetEffect
    endstruct

    private function Ending takes Data d, timer durationTimer, Unit target returns nothing
        local real bonusSpeed = -d.bonusSpeed
        local effect targetEffect = d.targetEffect
        local integer targetId = target.id
        call d.destroy()
        call FlushAttachedInteger( durationTimer, WhipLash_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call FlushAttachedIntegerById( targetId, WhipLash_SCOPE_ID )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "targetId", "EVENT_DISPEL" )
        call DestroyEffectWJ( targetEffect )
        set targetEffect = null
        call AddUnitAttackRate( target, -BONUS_RELATIVE_ATTACK_RATE )
        call AddUnitSpeedBonus( target, bonusSpeed )
    endfunction

    public function Dispel takes Unit target returns nothing
        local Data d = GetAttachedIntegerById(target.id, WhipLash_SCOPE_ID)
        if ( d != NULL ) then
            call Ending( d, d.durationTimer, target )
        endif
    endfunction

    private function Dispel_Event takes nothing returns nothing
        call Dispel( TRIGGER_UNIT )
    endfunction

    public function Death takes Unit target returns nothing
        call Dispel( target )
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, WhipLash_SCOPE_ID)
        call Ending( d, durationTimer, d.target )
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) == false ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
            return false
        endif
        if ( IsUnitWard( GetUnit(FILTER_UNIT_SELF) ) ) then
            return false
        endif
        return true
    endfunction

    public function SpellEffect takes Unit caster returns nothing
        local real bonusSpeed
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Data d
        local timer durationTimer
        local Unit enumUnit
        local integer enumUnitId
        local unit enumUnitSelf
        local boolean isNew
        local real oldBonusSpeed
        call PlaySoundFromTypeAtPosition( WHIP_LASH_SOUND_TYPE, casterX, casterY, GetUnitZ( casterSelf, casterX, casterY ) )
        set casterSelf = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision(ENUM_GROUP, casterX, casterY, AREA_RANGE, TARGET_CONDITIONS)
        set enumUnitSelf = FirstOfGroup(ENUM_GROUP)
        if (enumUnitSelf != null) then
            loop
                set enumUnit = GetUnit(enumUnitSelf)
                set bonusSpeed = GetUnitSpeed( enumUnit ) * BONUS_RELATIVE_SPEED
                set enumUnitId = enumUnit.id
                set d = GetAttachedIntegerById(enumUnitId, WhipLash_SCOPE_ID)
                set isNew = ( d == NULL )
                call GroupRemoveUnit(ENUM_GROUP, enumUnitSelf)
                if ( isNew ) then
                    set d = Data.create()
                    set durationTimer = CreateTimerWJ()
                    set d.durationTimer = durationTimer
                    set d.target = enumUnit
                    call AttachInteger( durationTimer, WhipLash_SCOPE_ID, d )
                    call AttachIntegerById( enumUnitId, WhipLash_SCOPE_ID, d )
                    //! runtextmacro AddEventById( "enumUnitId", "EVENT_DEATH" )
                    //! runtextmacro AddEventById( "enumUnitId", "EVENT_DISPEL" )
                else
                    set durationTimer = d.durationTimer
                    set oldBonusSpeed = d.bonusSpeed
                    call DestroyEffectWJ( d.targetEffect )
                endif
                set d.bonusSpeed = bonusSpeed
                set d.targetEffect = AddSpecialEffectTargetWJ( TARGET_EFFECT_PATH, enumUnitSelf, TARGET_EFFECT_ATTACHMENT_POINT )
                if ( isNew ) then
                    call AddUnitAttackRate( enumUnit, BONUS_RELATIVE_ATTACK_RATE )
                    call AddUnitSpeedBonus( enumUnit, bonusSpeed )
                else
                    call AddUnitSpeedBonus( enumUnit, bonusSpeed - oldBonusSpeed )
                endif
                call TimerStart( durationTimer, DURATION, false, function EndingByTimer )
                set enumUnitSelf = FirstOfGroup(ENUM_GROUP)
                exitwhen (enumUnitSelf == null)
            endloop
        endif
        set durationTimer = null
    endfunction

    private function SpellEffect_Event takes nothing returns nothing
        call SpellEffect( CASTER )
    endfunction

    public function Init takes nothing returns nothing
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_DISPEL", "UnitIsDispelled_EVENT_KEY_POSITIVE", "0", "function Dispel_Event" )
        set TARGET_CONDITIONS = ConditionWJ(function TargetConditions)
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_CAST", "SPELL_ID", "UnitStartsEffectOfAbility_EVENT_KEY", "0", "function SpellEffect_Event" )
        call InitEffectType( TARGET_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\WhipLash.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\Whirlwind.j
//TESH.scrollpos=240
//TESH.alwaysfold=0
//! runtextmacro Scope("Whirlwind")
    globals
        private constant integer ORDER_ID = 852129//OrderId("windwalk")
        public constant integer SPELL_ID = 'A00F'

        private real array AREA_RANGE
        private real array BONUS_ARMOR
        private constant real BONUS_RELATIVE_SPEED = -0.4
        private constant string CASTER_EFFECT_PATH = "Abilities\\Spells\\Other\\Stampede\\StampedeMissile.mdl"
        private constant string CASTER_EFFECT_ATTACHMENT_POINT = "weapon"
        private real array DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT
        private real array DURATION
        private real array DURATION_PER_AGILITY_POINT
        private constant real EFFECT_INTERVAL = 0.75
        private group ENUM_GROUP
        private constant real INTERVAL = 0.25
        private constant real EFFECT_CHANCE = INTERVAL / EFFECT_INTERVAL
        private constant integer LEVELS_AMOUNT = 5
        private real array MAX_DAMAGE_PER_INTERVAL
        private real array MIN_DAMAGE_PER_INTERVAL
        private boolexpr TARGET_CONDITIONS
        private constant string TARGET_EFFECT_ATTACHMENT_POINT = "chest"
        private integer array WAVES_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        unit attackTarget
        real bonusSpeed
        Unit caster
        effect casterEffect
        real damagePerIntervalHighAmount
        real damagePerIntervalLowAmount
        timer damageTimer
        timer durationTimer
    endstruct

    private function Ending takes Unit caster, Data d, timer durationTimer returns nothing
        local integer abilityLevel = d.abilityLevel
        local unit attackTarget = d.attackTarget
        local real bonusSpeed = -d.bonusSpeed
        local effect casterEffect = d.casterEffect
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local timer damageTimer = d.damageTimer
        call d.destroy()
        call FlushAttachedIntegerById( casterId, Whirlwind_SCOPE_ID )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_DEATH" )
        //! runtextmacro RemoveEventById( "casterId", "EVENT_ORDER_EXECUTE2" )
        call DestroyEffectWJ( casterEffect )
        set casterEffect = null
        call FlushAttachedInteger( damageTimer, Whirlwind_SCOPE_ID )
        call DestroyTimerWJ( damageTimer )
        set damageTimer = null
        call FlushAttachedInteger( durationTimer, Whirlwind_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        call AddUnitAnimationProperties( casterSelf, "attack", false )
        call AddUnitArmorBonus( caster, -BONUS_ARMOR[abilityLevel] )
        call SetUnitBlendTime( casterSelf, 0.15 )
        call AddUnitSpeedBonus( caster, bonusSpeed )
        call AddUnitPathing( caster )
        if ( attackTarget != null ) then
            call IssueTargetOrderById( casterSelf, ATTACK_ORDER_ID, attackTarget )
        endif
        set casterSelf = null
    endfunction

    public function Death takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, Whirlwind_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( caster, d, d.durationTimer )
        endif
    endfunction

    private function Death_Event takes nothing returns nothing
        call Death( DYING_UNIT )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, Whirlwind_SCOPE_ID)
        call Ending( d.caster, d, durationTimer )
        set durationTimer = null
    endfunction

    private function TargetConditions takes nothing returns boolean
        set FILTER_UNIT_SELF = GetFilterUnit()
        if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
            return false
        endif
        if ( IsUnitAlly( FILTER_UNIT_SELF, TEMP_PLAYER ) ) then
            return false
        endif
        if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_MECHANICAL ) ) then
            return false
        endif
        if ( GetUnitInvulnerability( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
            return false
        endif
        return true
    endfunction

    private function DealDamage takes nothing returns nothing
        local real attackDifferenceX
        local real attackDifferenceY
        local real casterZ
        local real damageAmount
        local real damageAmountHigh
        local real damageAmountLow
        local timer damageTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(damageTimer, Whirlwind_SCOPE_ID)
        local integer abilityLevel = d.abilityLevel
        local Unit caster = d.caster
        local unit casterSelf = caster.self
        local real casterX = GetUnitX( casterSelf )
        local real casterY = GetUnitY( casterSelf )
        local Unit enumUnit
        local unit enumUnitSelf
        set damageTimer = null
        set TEMP_PLAYER = caster.owner
        call GroupEnumUnitsInRangeWithCollision( ENUM_GROUP, casterX, casterY, AREA_RANGE[abilityLevel] * GetUnitScale( caster ), TARGET_CONDITIONS )
        set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
        if ( enumUnitSelf != null ) then
            set casterZ = GetUnitZ( casterSelf, casterX, casterY )
            set damageAmountHigh = d.damagePerIntervalHighAmount
            set damageAmountLow = d.damagePerIntervalLowAmount
            loop
                set damageAmount = GetRandomReal( damageAmountLow, damageAmountHigh )
                set enumUnit = GetUnit(enumUnitSelf)
                call GroupRemoveUnit( ENUM_GROUP, enumUnitSelf )
                if ( GetRandomReal( 0.01, 1 ) <= EFFECT_CHANCE ) then
                    call DestroyEffectWJ( AddSpecialEffectTargetWJ( GetUnitBlood( enumUnit ), enumUnitSelf, TARGET_EFFECT_ATTACHMENT_POINT ) )
                endif
                if ( ( GetRandomReal( 0.01, 1 ) <= GetUnitCriticalStrike( caster ) - GetUnitCriticalStrikeDefense( enumUnit ) ) and ( GetUnitCriticalStrikeImmunity( enumUnit ) == 0 ) ) then
                    set attackDifferenceX = GetUnitX( enumUnitSelf ) - casterX
                    set attackDifferenceY = GetUnitY( enumUnitSelf ) - casterY
                    set damageAmount = damageAmount * CRITICAL_STRIKE_DAMAGE_FACTOR
                    call CreateMovingTextTag( I2S( R2I( damageAmount ) ) + "!", 0.02, casterX, casterY, casterZ, attackDifferenceX, attackDifferenceY, 150, 255, 0, 0, 255, 0, 1 )
                endif
                call UnitDamageUnitEx( caster, enumUnit, damageAmount, WEAPON_TYPE_METAL_LIGHT_SLICE )
                set enumUnitSelf = FirstOfGroup( ENUM_GROUP )
                exitwhen ( enumUnitSelf == null )
            endloop
        endif
        set casterSelf = null
    endfunction

    public function Attack takes Unit caster, unit target returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Whirlwind_SCOPE_ID)
        if ( d != NULL ) then
            call IssueTargetOrderById( caster.self, MOVE_ORDER_ID, target )
            set d.attackTarget = target
        endif
    endfunction

    public function OrderExecute2 takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById(caster.id, Whirlwind_SCOPE_ID)
        if (d != NULL) then
            set d.attackTarget = null
        endif
    endfunction

    private function OrderExecute2_Event takes nothing returns nothing
        call OrderExecute2( ORDERED_UNIT )
    endfunction

    public function OrderExecute takes Unit caster returns nothing
        local real bonusSpeed = GetUnitSpeed( caster ) * BONUS_RELATIVE_SPEED
        local integer casterId = caster.id
        local unit casterSelf = caster.self
        local integer abilityLevel = GetUnitAbilityLevel( casterSelf, SPELL_ID )
        local integer currentOrder
        local widget currentTarget
        local Data d = GetAttachedIntegerById(casterId, Whirlwind_SCOPE_ID)
        local real damageAmountPerIntervalByStrengthPoints = GetHeroStrengthTotal( caster ) * DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[abilityLevel]
        local timer damageTimer
        local real duration = DURATION[abilityLevel] + GetHeroAgilityTotal( caster ) * DURATION_PER_AGILITY_POINT[abilityLevel]
        local timer durationTimer
        local boolean isNew = ( d == NULL )
        local integer oldAbilityLevel
        local real oldBonusSpeed
        set Meditation_WHIRLWIND_CASTER = caster
        call RunTrigger( Meditation_WHIRLWIND_TRIGGER )
        if ( isNew ) then
            set currentOrder = GetUnitCurrentOrder( casterSelf )
            set currentTarget = GetUnitCurrentTarget( caster )
            set d = Data.create()
            set damageTimer = CreateTimerWJ()
            set durationTimer = CreateTimerWJ()
            set d.attackTarget = null
            set d.caster = caster
            set d.casterEffect = AddSpecialEffectTargetWJ( CASTER_EFFECT_PATH, casterSelf, CASTER_EFFECT_ATTACHMENT_POINT )
            set d.damageTimer = damageTimer
            set d.durationTimer = durationTimer
            call AttachIntegerById( casterId, Whirlwind_SCOPE_ID, d )
            //! runtextmacro AddEventById( "casterId", "EVENT_DEATH" )
            //! runtextmacro AddEventById( "casterId", "EVENT_ORDER_EXECUTE2" )
            call AttachInteger( damageTimer, Whirlwind_SCOPE_ID, d )
            call AttachInteger( durationTimer, Whirlwind_SCOPE_ID, d )
        else
            set oldAbilityLevel = d.abilityLevel
            set oldBonusSpeed = d.bonusSpeed
        endif
        set d.abilityLevel = abilityLevel
        set d.bonusSpeed = bonusSpeed
        set d.damagePerIntervalHighAmount = MAX_DAMAGE_PER_INTERVAL[abilityLevel] + damageAmountPerIntervalByStrengthPoints
        set d.damagePerIntervalLowAmount = MIN_DAMAGE_PER_INTERVAL[abilityLevel] + damageAmountPerIntervalByStrengthPoints
        if ( isNew ) then
            call AddUnitAnimationProperties( casterSelf, "attack", true )
            call AddUnitArmorBonus( caster, BONUS_ARMOR[abilityLevel] )
            call SetUnitBlendTime( casterSelf, 0 )
            call RemoveUnitPathing( caster )
            call AddUnitSpeedBonus( caster, bonusSpeed )
            call TimerStart( damageTimer, INTERVAL, true, function DealDamage )
            set damageTimer = null
        else
            call AddUnitArmorBonus( caster, BONUS_ARMOR[abilityLevel] - BONUS_ARMOR[oldAbilityLevel] )
            call AddUnitSpeedBonus( caster, bonusSpeed - oldBonusSpeed )
        endif
        if ( duration > TimerGetRemaining( durationTimer ) ) then
            call TimerStart( durationTimer, duration, false, function EndingByTimer )
        endif
        set durationTimer = null
        if (isNew) then
            if ( currentTarget != null ) then
                call StopUnit( caster )
                call IssueTargetOrderById( casterSelf, currentOrder, currentTarget )
                set currentTarget = null
            endif
        endif
        set casterSelf = null
    endfunction

    private function OrderExecute_Event takes nothing returns nothing
        call OrderExecute( ORDERED_UNIT )
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set AREA_RANGE[1] = 230
        set AREA_RANGE[2] = 230
        set AREA_RANGE[3] = 230
        set AREA_RANGE[4] = 230
        set AREA_RANGE[5] = 230
        set BONUS_ARMOR[1] = 4
        set BONUS_ARMOR[2] = 4
        set BONUS_ARMOR[3] = 4
        set BONUS_ARMOR[4] = 4
        set BONUS_ARMOR[5] = 4
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[1] = 1
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[2] = 1
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[3] = 1
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[4] = 1
        set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[5] = 1
        set DURATION[1] = 3
        set DURATION[2] = 3
        set DURATION[3] = 3.5
        set DURATION[4] = 3.5
        set DURATION[5] = 4
        set DURATION_PER_AGILITY_POINT[1] = 0
        set DURATION_PER_AGILITY_POINT[2] = 0
        set DURATION_PER_AGILITY_POINT[3] = 0
        set DURATION_PER_AGILITY_POINT[4] = 0
        set DURATION_PER_AGILITY_POINT[5] = 0
        set ENUM_GROUP = CreateGroupWJ()
        //! runtextmacro CreateEvent( "EVENT_DEATH", "UnitDies_EVENT_KEY", "0", "function Death_Event" )
        //! runtextmacro CreateEvent( "EVENT_ORDER_EXECUTE2", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function OrderExecute2_Event" )
        set MAX_DAMAGE_PER_INTERVAL[1] = 112
        set MAX_DAMAGE_PER_INTERVAL[2] = 144
        set MAX_DAMAGE_PER_INTERVAL[3] = 171
        set MAX_DAMAGE_PER_INTERVAL[4] = 195
        set MAX_DAMAGE_PER_INTERVAL[5] = 226
        set MIN_DAMAGE_PER_INTERVAL[1] = 40
        set MIN_DAMAGE_PER_INTERVAL[2] = 56
        set MIN_DAMAGE_PER_INTERVAL[3] = 70
        set MIN_DAMAGE_PER_INTERVAL[4] = 81
        set MIN_DAMAGE_PER_INTERVAL[5] = 93
        loop
            set WAVES_AMOUNT[iteration] = R2I( DURATION[iteration] / INTERVAL )
            set DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[iteration] = DAMAGE_PER_INTERVAL_PER_STRENGTH_POINT[iteration] / WAVES_AMOUNT[iteration]
            set MAX_DAMAGE_PER_INTERVAL[iteration] = MAX_DAMAGE_PER_INTERVAL[iteration] / WAVES_AMOUNT[iteration]
            set MIN_DAMAGE_PER_INTERVAL[iteration] = MIN_DAMAGE_PER_INTERVAL[iteration] / WAVES_AMOUNT[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 1)
        endloop
        set TARGET_CONDITIONS = ConditionWJ( function TargetConditions )
        call InitEffectType(CASTER_EFFECT_PATH)
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ORDER_EXECUTE", "GetAbilityOrderId( SPELL_ID, ORDER_ID )", "UnitGetsOrder_Executed_Executed_EVENT_KEY", "0", "function OrderExecute_Event" )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\Whirlwind.j

//file: D:\Warcraft III\Mapping\WFW\Data\Spells\WonderSeeds.j
//TESH.scrollpos=133
//TESH.alwaysfold=0
//! runtextmacro Scope("WonderSeeds")
    globals
        private constant integer ORDER_ID = 852176//OrderId( "forceofnature" )
        public constant integer SPELL_ID = 'A01Q'

        private real array DURATION
        private real array INTERVAL
        private constant integer LEVELS_AMOUNT = 5
        private integer array SUMMONS_AMOUNT
    endglobals

    private struct Data
        integer abilityLevel
        Unit caster
        timer durationTimer
        timer intervalTimer
        real targetX
        real targetY
    endstruct

    private function Ending takes Unit caster, Data d returns nothing
        local timer durationTimer = d.durationTimer
        local timer intervalTimer = d.intervalTimer
        call FlushAttachedIntegerById( caster.id, WonderSeeds_SCOPE_ID )
        call FlushAttachedInteger( durationTimer, WonderSeeds_SCOPE_ID )
        call DestroyTimerWJ( durationTimer )
        set durationTimer = null
        call FlushAttachedInteger( intervalTimer, WonderSeeds_SCOPE_ID )
        call DestroyTimerWJ( intervalTimer )
        set intervalTimer = null
    endfunction

    public function EndCast takes Unit caster returns nothing
        local Data d = GetAttachedIntegerById( caster.id, WonderSeeds_SCOPE_ID )
        if ( d != NULL ) then
            call Ending( caster, d )
        endif
    endfunction

    private function EndCast_Event takes nothing returns nothing
        call EndCast( CASTER )
    endfunction

    private function EndingByTimer takes nothing returns nothing
        local timer durationTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(durationTimer, WonderSeeds_SCOPE_ID)
        set durationTimer = null
        call IssueImmediateOrderById( d.caster.self, STOP_ORDER_ID )
    endfunction

    //! runtextmacro Scope("Release")
        globals
            private real array Release_DURATION
            private constant real Release_RELEASE_TIME = 1.2
        endglobals

        private struct Release_Data
            integer abilityLevel
            Unit spawn
        endstruct

        private function Release_Ending takes nothing returns nothing
            local timer releaseTimer = GetExpiredTimer()
            local Release_Data d = GetAttachedInteger(releaseTimer, Release_SCOPE_ID)
            local integer abilityLevel = d.abilityLevel
            local Unit spawn = d.spawn
            local unit spawnSelf = spawn.self
            call d.destroy()
            call FlushAttachedInteger( releaseTimer, Release_SCOPE_ID )
            call DestroyTimerWJ( releaseTimer )
            set releaseTimer = null
            call SetUnitBlendTime( spawnSelf, 0.15 )
            call SetUnitAnimationByIndex( spawnSelf, 1 )
            call PauseUnit( spawnSelf, false )
            call SetUnitInvulnerable( spawnSelf, false )
            call UnitApplyTimedLifeWJ( spawnSelf, Release_DURATION[abilityLevel] )
            set spawnSelf = null
        endfunction

        public function Release_Start takes integer abilityLevel, Unit caster, real x, real y returns nothing
            local Release_Data d = Release_Data.create()
            local timer releaseTimer = CreateTimerWJ()
            local Unit spawn = CreateUnitEx( caster.owner, TREANT_UNIT_ID, x, y, STANDARD_ANGLE )
            local unit spawnSelf = spawn.self
            set d.abilityLevel = abilityLevel
            set d.spawn = spawn
            call AttachInteger(releaseTimer, Release_SCOPE_ID, d)
            call SetUnitBlendTime( spawnSelf, 0 )
            call SetUnitAnimationByIndex( spawnSelf, 7 )
            call PauseUnit( spawnSelf, true )
            call SetUnitInvulnerable( spawnSelf, true )
            set spawnSelf = null
            call TimerStart( releaseTimer, Release_RELEASE_TIME, false, function Release_Ending )
            set releaseTimer = null
        endfunction

        public function Release_Init takes nothing returns nothing
            set Release_DURATION[1] = 30
            set Release_DURATION[2] = 30
            set Release_DURATION[3] = 30
            set Release_DURATION[4] = 30
            set Release_DURATION[5] = 30
        endfunction
    //! runtextmacro Endscope()

    private function Interval takes nothing returns nothing
        local timer intervalTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(intervalTimer, WonderSeeds_SCOPE_ID)
        set intervalTimer = null
        call Release_Release_Start(d.abilityLevel, d.caster, d.targetX, d.targetY)
    endfunction

    public function BeginCast takes Unit caster, real targetX, real targetY returns nothing
        local integer abilityLevel = GetUnitAbilityLevel( caster.self, SPELL_ID )
        local Data d = Data.create()
        local timer durationTimer = CreateTimerWJ()
        local timer intervalTimer = CreateTimerWJ()
        set d.abilityLevel = abilityLevel
        set d.caster = caster
        set d.durationTimer = durationTimer
        set d.intervalTimer = intervalTimer
        set d.targetX = targetX
        set d.targetY = targetY
        call AttachIntegerById( caster.id, WonderSeeds_SCOPE_ID, d )
        call AttachInteger( durationTimer, WonderSeeds_SCOPE_ID, d )
        call AttachInteger( intervalTimer, WonderSeeds_SCOPE_ID, d )
        call TimerStart( intervalTimer, INTERVAL[abilityLevel], true, function Interval )
        set intervalTimer = null
        call TimerStart( durationTimer, DURATION[abilityLevel], false, function EndingByTimer )
        set durationTimer = null
    endfunction

    public function Init takes nothing returns nothing
        local integer iteration = LEVELS_AMOUNT
        set INTERVAL[1] = 0.75
        set INTERVAL[2] = 0.75
        set INTERVAL[3] = 0.75
        set INTERVAL[4] = 0.75
        set INTERVAL[5] = 0.75
        set SUMMONS_AMOUNT[1] = 5
        set SUMMONS_AMOUNT[2] = 8
        set SUMMONS_AMOUNT[3] = 11
        set SUMMONS_AMOUNT[4] = 14
        set SUMMONS_AMOUNT[5] = 17
        loop
            set DURATION[iteration] = SUMMONS_AMOUNT[iteration] * INTERVAL[iteration]
            set iteration = iteration - 1
            exitwhen (iteration < 0)
        endloop
        call AddOrderAbility( ORDER_ID, SPELL_ID )
        call InitAbility( SPELL_ID )
        //! runtextmacro AddNewEventById( "EVENT_ENDCAST", "SPELL_ID", "UnitFinishesCasting_EVENT_KEY", "0", "function EndCast_Event" )
        call Release_Release_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Spells\WonderSeeds.j

//file: D:\Warcraft III\Mapping\WFW\Data\test\a.j
ESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_a_Actions takes nothing returns nothing
    local string s = GetEventPlayerChatString()
    local integer amount
    local integer iteration = 11
    local Unit newUnit
    local player whichPlayer
    local integer whichType
    local real x = 0
    local real y = 0
    loop
        exitwhen ( SubStringBJ( s, iteration, iteration ) == " " )
        set iteration = iteration + 1
    endloop
    set amount = S2I( SubStringBJ( s, 10, iteration - 1 ) )
    set whichPlayer = PlayerWJ( 11 )
    set whichType = GetSavedInteger( "UnitTypes", SubStringBJ( s, iteration + 1, StringLength( s ) ) )
    set iteration = 1
    loop
        exitwhen ( iteration > amount )
        set newUnit = CreateUnitEx( whichPlayer, whichType, x, y, 0 )
//        call KillUnit( newUnit.self )
        set iteration = iteration + 1
    endloop
    set whichPlayer = null
    call WriteBug( I2S( iteration ) )
endfunction

function InitTrig_a takes nothing returns nothing
    local integer iteration = 0
    set gg_trg_a = CreateTrigger()
    loop
        exitwhen ( iteration > 11 )
        call TriggerRegisterPlayerChatEvent( gg_trg_a, Player( iteration ), "-createe", false )
        set iteration = iteration + 1
    endloop
    call TriggerAddAction( gg_trg_a, function Trig_a_Actions )
endfunction

//end of file: D:\Warcraft III\Mapping\WFW\Data\test\a.j

//file: D:\Warcraft III\Mapping\WFW\Data\test\b.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
function Trig_b_Actions takes nothing returns nothing
    local string s = GetEventPlayerChatString()
    local integer amount
    local integer iteration = 10
    local Unit newUnit
    local player whichPlayer
    local integer whichType
    local real x = 0
    local real y = 0
    loop
        exitwhen ( SubStringBJ( s, iteration, iteration ) == " " )
        set iteration = iteration + 1
    endloop
    set amount = S2I( SubStringBJ( s, 9, iteration - 1 ) )
    set whichPlayer = GetTriggerPlayer()
    set whichType = GetSavedInteger( "UnitTypes", SubStringBJ( s, iteration + 1, StringLength( s ) ) )
    set iteration = 1
    loop
        exitwhen ( iteration > amount )
        set newUnit = CreateUnitEx( whichPlayer, whichType, x, y, 0 )
//        call KillUnit( newUnit )
        set iteration = iteration + 1
    endloop
    set whichPlayer = null
    call WriteBug( I2S( iteration ) )
endfunction

function InitTrig_b takes nothing returns nothing
    local integer iteration = 0
    set gg_trg_b = CreateTrigger()
    loop
        exitwhen ( iteration > 11 )
        call TriggerRegisterPlayerChatEvent( gg_trg_b, Player( iteration ), "-create ", false )
        set iteration = iteration + 1
    endloop
    call TriggerAddAction( gg_trg_b, function Trig_b_Actions )
endfunction

//end of file: D:\Warcraft III\Mapping\WFW\Data\test\b.j

//file: D:\Warcraft III\Mapping\WFW\Data\test\create new worldcaster.j


//end of file: D:\Warcraft III\Mapping\WFW\Data\test\create new worldcaster.j

//file: D:\Warcraft III\Mapping\WFW\Data\test\killunitsel.j
a

//end of file: D:\Warcraft III\Mapping\WFW\Data\test\killunitsel.j

//file: D:\Warcraft III\Mapping\WFW\Data\test\worldcastertest.j

//end of file: D:\Warcraft III\Mapping\WFW\Data\test\worldcastertest.j

//file: D:\Warcraft III\Mapping\WFW\Data\Training\ReleaseUnitShredder.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("ReleaseUnitShredder")
    globals
        private constant real DURATION = 180.
        private constant real RELEASE_TIME = 1.634
        private constant string SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Orc\\FeralSpirit\\feralspirittarget.mdl"
    endglobals

    private struct Data
        Unit shredder
    endstruct

    private function Release takes nothing returns nothing
        local timer releaseTimer = GetExpiredTimer()
        local Data d = GetAttachedInteger(releaseTimer, ReleaseUnitShredder_SCOPE_ID)
        local Unit shredder = d.shredder
        local unit shredderSelf = shredder.self
        call d.destroy()
        call FlushAttachedInteger( releaseTimer, ReleaseUnitShredder_SCOPE_ID )
        call DestroyTimerWJ( releaseTimer )
        set releaseTimer = null
        call PauseUnit( shredderSelf, false )
        call SetUnitInvulnerable( shredderSelf, false )
        call SetUnitBlendTime( shredderSelf, 0.15 )
        call SetUnitAnimationByIndex( shredderSelf, 0 )
        call UnitApplyTimedLifeWJ( shredderSelf, DURATION )
        set shredderSelf = null
    endfunction

    public function Attack takes Unit shredder, Unit triggerUnit returns nothing
        if ( ( shredder.type == GetUnitType(UNIT_SHREDDER_UNIT_ID) ) and ( IsUnitAlly( triggerUnit.self, shredder.owner ) == false ) ) then
            call StopUnit( shredder )
        endif
    endfunction

    public function SellUnitExecute takes player owner, Unit shop, unit shredderSelf returns nothing
        local Data d = Data.create()
        local timer releaseTimer = CreateTimerWJ()
        local unit shopSelf = shop.self
        local real angle = GetUnitFacingWJ( shopSelf )
        local Unit shredder
        local real x = GetUnitX( shopSelf )
        local real y = GetUnitY( shopSelf )
        set shopSelf = null
        call RemoveUnitEx( shop )
        set SHREDDERS[GetPlayerTeam(owner)] = NULL
        call RemoveUnitWJ( shredderSelf )
        set shredder = CreateUnitEx( owner, UNIT_SHREDDER_RELEASED_UNIT_ID, x, y, PI / 2 + B2I( Absolute( 1.5 - GetPlayerTeam( owner ) ) > 1 ) * PI )
        set owner = null
        set shredderSelf = shredder.self
        set d.shredder = shredder
        call SetUnitX( shredderSelf, x )
        call SetUnitY( shredderSelf, y )
        call DestroyEffectWJ( AddSpecialEffectWJ( SPECIAL_EFFECT_PATH, x, y ) )
        call SetUnitBlendTime( shredderSelf, 0 )
        call SetUnitAnimationByIndex( shredderSelf, 3 )
        call PauseUnit( shredderSelf, true )
        call SetUnitInvulnerable( shredderSelf, true )
        set shredderSelf = null
        call AttachInteger( releaseTimer, ReleaseUnitShredder_SCOPE_ID, d )
        call TimerStart( releaseTimer, RELEASE_TIME, false, function Release )
        set releaseTimer = null
    endfunction

    public function Init takes nothing returns nothing
        call InitEffectType( SPECIAL_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Training\ReleaseUnitShredder.j

//file: D:\Warcraft III\Mapping\WFW\Data\Training\Reserve.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Reserve")
    globals
        private constant integer AMOUNT = 3
    endglobals

    public function SellUnitExecute takes Unit reserve, UnitType reserveType returns nothing
        local integer iteration = 2
        local player owner = reserve.owner
        local unit reserveSelf = reserve.self
        local real angle = GetUnitFacingWJ(reserveSelf)
        local integer supplyUsed
        local real x = GetUnitX(reserveSelf)
        local real y = GetUnitY(reserveSelf)
        set reserveSelf = null
        set supplyUsed = GetUnitTypeSupplyUsed(reserveType) / AMOUNT
        loop
            call SetUnitSupplyUsed( reserve, owner, supplyUsed )
            exitwhen ( iteration > AMOUNT )
            set reserve = CreateUnitEx( owner, RESERVE_UNIT_ID, x, y, angle )
            set iteration = iteration + 1
        endloop
        set owner = null
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Training\Reserve.j

//file: D:\Warcraft III\Mapping\WFW\Data\Training\Spawn.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Spawn")
    public function Death takes player spawnOwner, UnitType spawnType returns nothing
        local Unit rax
        if ( IsUnitTypeSpawn(spawnType) ) then
            set rax = GetPlayerTownHall(spawnOwner)
            if (rax != NULL) then
                call Miscellaneous_Spawn_Spawn_StartByDeath( rax, spawnOwner )
            endif
        endif
    endfunction

    public function FinishTraining takes Unit rax, unit spawn, player spawnOwner, UnitType spawnType, integer spawnTypeId returns nothing
        if ( IsUnitTypeSpawn(spawnType) ) then
            call RemoveUnitWJ( spawn )
            call Miscellaneous_Spawn_Spawn_Start( rax, spawnTypeId, spawnOwner )
        endif
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Training\Spawn.j

//file: D:\Warcraft III\Mapping\WFW\Data\Training\Worker.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Worker")
    globals
        private constant integer MAX_UNITS_AMOUNT = 5
        private integer array WORKERS_AMOUNT
    endglobals

    public function Death takes player workerOwner, UnitType workerType returns nothing
        local integer ownerId
        if ( workerType.id == WORKER_UNIT_ID ) then
            set ownerId = GetPlayerId(workerOwner)
            set WORKERS_AMOUNT[ownerId] = WORKERS_AMOUNT[ownerId] - 1
        endif
    endfunction

    private function Add takes Unit worker, player workerOwner returns nothing
        local integer ownerId = GetPlayerId(workerOwner)
        local integer amount = WORKERS_AMOUNT[ownerId] + 1
        set WORKERS_AMOUNT[ownerId] = amount
        call IssueImmediateOrderById( worker.self, HARVESTING_AUTO_ORDER_ID )
    endfunction

    public function Appearance takes Unit worker, player workerOwner, UnitType workerType returns nothing
        if ( workerType.id == WORKER_UNIT_ID ) then
            call Add(worker, workerOwner)
        endif
    endfunction

    public function SellUnit takes player workerOwner returns string
        local integer ownerId = GetPlayerId(workerOwner)
        if ( WORKERS_AMOUNT[ownerId] + 1 > MAX_UNITS_AMOUNT ) then
            return "You can only train up to " + I2S( MAX_UNITS_AMOUNT ) + " workers"
        endif
        return null
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Training\Worker.j

//file: D:\Warcraft III\Mapping\WFW\Data\Weather\DisplayWeather.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("DisplayWeather")
    public function Chat takes string chatMessage, player triggerPlayer returns nothing
        local boolean displaysWeatherEffects
        local integer iteration
        local weathereffect specificWeatherEffect
        local integer triggerPlayerId
        set chatMessage = StringCase( chatMessage, false )
        if ( chatMessage == "-w" ) then
            set triggerPlayerId = GetPlayerId(triggerPlayer)
            set displaysWeatherEffects = WeatherEffect_PLAYER_HIDES[triggerPlayerId]
            set iteration = WeatherEffect_COUNT
            set WeatherEffect_PLAYER_HIDES[triggerPlayerId] = ( displaysWeatherEffects == false )
            loop
                exitwhen ( iteration < 0 )
                set specificWeatherEffect = WeatherEffect_ALL[iteration]
                if ( WeatherEffect_IS_DISPLAYED[GetWeatherEffectIndex(specificWeatherEffect)] ) then
                    call EnableWeatherEffectWJ( specificWeatherEffect, triggerPlayer, displaysWeatherEffects )
                endif
                set iteration = iteration - 1
            endloop
            set specificWeatherEffect = null
        endif
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Weather\DisplayWeather.j

//file: D:\Warcraft III\Mapping\WFW\Data\Weather\Mist.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Mist")
    globals
        private SoundType array EFFECT_SOUND_TYPES
        private timer INTERVAL_TIMER
        private constant real MAX_INTERVAL = 10.
        private constant real MIN_INTERVAL = 8.
        private constant real SOUND_MAX_INTERVAL = 9.
        private constant real SOUND_MIN_INTERVAL = 6.
        private timer SOUND_TIMER
    endglobals

    //! runtextmacro Scope("Cloud")
        private struct Cloud_Data
            unit dummyUnit
            timer durationTimer
            rect targetRect
        endstruct

        globals
            private trigger Cloud_DUMMY_TRIGGER
            private constant integer Cloud_DUMMY_UNIT_ID = 'n00F'
            private constant real Cloud_MAX_DURATION = 20.
            private constant real Cloud_MIN_DURATION = 16.
            private group Cloud_ENUM_GROUP
            private constant real Cloud_SIZE = 320.
            private boolexpr Cloud_TARGET_CONDITIONS
            private group Cloud_TARGET_GROUP
            private region Cloud_TARGET_REGION

            private Cloud_Data array DS
            private integer DS_AMOUNT
        endglobals

        private function Cloud_TargetConditions_Single takes unit checkingUnit, boolean isBoarding returns boolean
            if ( IsUnitInGroup( checkingUnit, Cloud_TARGET_GROUP ) == isBoarding ) then
                return false
            endif
            if ( IsUnitType( checkingUnit, UNIT_TYPE_FLYING ) ) then
                return false
            endif
            return true
        endfunction

        private function Cloud_TargetConditions takes nothing returns boolean
            if ( Cloud_TargetConditions_Single( GetFilterUnit(), true ) == false ) then
                return false
            endif
            return true
        endfunction

        private function Cloud_EndTarget takes Unit target returns nothing
            local unit targetSelf = target.self
            if ( Cloud_TargetConditions_Single( targetSelf, false ) ) then
                call GroupRemoveUnit( Cloud_TARGET_GROUP, targetSelf )
                call AddUnitEvasionChance( target, -0.2 )
            endif
            set targetSelf = null
        endfunction

        private function Cloud_StartTarget takes Unit target returns nothing
            local unit targetSelf = target.self
            if ( Cloud_TargetConditions_Single( targetSelf, true ) ) then
                call GroupAddUnit( Cloud_TARGET_GROUP, targetSelf )
                call AddUnitEvasionChance( target, 0.2 )
            endif
            set targetSelf = null
        endfunction

        private function Cloud_Trig_UnitEntersOrLeaves takes nothing returns nothing
            local Unit triggerUnit = GetUnit(GetTriggerUnit())
            if ( GetHandleId(GetTriggerEventId()) == 5 ) then
                call Cloud_StartTarget( triggerUnit )
            else
                call Cloud_EndTarget( triggerUnit )
            endif
        endfunction

        private function Cloud_Ending takes Cloud_Data d, timer durationTimer returns nothing
            local unit dummyUnit = d.dummyUnit
            local unit enumUnit
            local integer iteration
            local rect targetRect = d.targetRect
            local rect targetRect2
            call d.destroy()
            call SetUnitAnimationByIndex( dummyUnit, 2 )
            call RemoveUnitTimed( dummyUnit, 0.5 )
            set dummyUnit = null
            call FlushAttachedInteger( durationTimer, Cloud_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            set DS_AMOUNT = DS_AMOUNT - 1
            set iteration = DS_AMOUNT
            loop
                exitwhen (DS[iteration] == d)
                set iteration = iteration - 1
            endloop
            set DS[iteration] = DS[DS_AMOUNT]
            set iteration = DS_AMOUNT
            call RegionClearRect( Cloud_TARGET_REGION, PLAY_RECT )
            loop
                exitwhen ( iteration < 0 )
                set d = DS[iteration]
                set targetRect2 = d.targetRect
                call RegionAddRect( Cloud_TARGET_REGION, targetRect2 )
                set iteration = iteration + 1
            endloop
            set targetRect2 = null
            call GroupEnumUnitsInRectWJ( Cloud_ENUM_GROUP, targetRect, Cloud_TARGET_CONDITIONS )
            set enumUnit = FirstOfGroup( Cloud_ENUM_GROUP )
            if (enumUnit != null) then
                loop
                    call GroupRemoveUnit( Cloud_ENUM_GROUP, enumUnit )
                    if ( IsUnitInRegion( Cloud_TARGET_REGION, enumUnit ) == false ) then
                        call Cloud_EndTarget( GetUnit(enumUnit) )
                    endif
                    set enumUnit = FirstOfGroup( Cloud_ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
            call RemoveRectWJ( targetRect )
            set targetRect = null
        endfunction

        public function Cloud_EndingByEnding takes nothing returns nothing
            local Cloud_Data d
            local integer iteration = DS_AMOUNT - 1
            loop
                exitwhen ( iteration < 0 )
                set d = DS[iteration]
                call Cloud_Ending( d, d.durationTimer )
                set iteration = iteration - 1
            endloop
        endfunction

        private function Cloud_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Cloud_Data d = GetAttachedInteger(durationTimer, Cloud_SCOPE_ID)
            call Cloud_Ending( d, durationTimer )
            set durationTimer = null
        endfunction

        public function Cloud_Start takes nothing returns nothing
            local Cloud_Data d = Cloud_Data.create()
            local timer durationTimer = CreateTimerWJ()
            local unit enumUnit
            local real x = GetRandomReal( PLAY_RECT_MIN_X, PLAY_RECT_MAX_X )
            local real y = GetRandomReal( PLAY_RECT_MIN_Y, PLAY_RECT_MAX_Y )
            local rect targetRect = CreateRectWithSize( x, y, Cloud_SIZE, Cloud_SIZE )
            set d.dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, Cloud_DUMMY_UNIT_ID, x, y, STANDARD_ANGLE )
            set d.targetRect = targetRect
            call AttachInteger( durationTimer, Cloud_SCOPE_ID, d )
            call AttachInteger( durationTimer, Cloud_SCOPE_ID, d )
            set DS[DS_AMOUNT] = d
            set DS_AMOUNT = DS_AMOUNT + 1
            call RegionAddRect( Cloud_TARGET_REGION, targetRect )
            call GroupEnumUnitsInRectWJ( Cloud_ENUM_GROUP, targetRect, Cloud_TARGET_CONDITIONS )
            set targetRect = null
            set enumUnit = FirstOfGroup(Cloud_ENUM_GROUP)
            if (enumUnit != null) then
                loop
                    call GroupRemoveUnit( Cloud_ENUM_GROUP, enumUnit )
                    call Cloud_StartTarget( GetUnit(enumUnit) )
                    set enumUnit = FirstOfGroup( Cloud_ENUM_GROUP )
                    exitwhen ( enumUnit == null )
                endloop
            endif
            call TimerStart( durationTimer, GetRandomReal( Cloud_MIN_DURATION, Cloud_MAX_DURATION ), false, function Cloud_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Cloud_Init takes nothing returns nothing
            set Cloud_DUMMY_TRIGGER = CreateTriggerWJ()
            set Cloud_ENUM_GROUP = CreateGroupWJ()
            set Cloud_TARGET_CONDITIONS = ConditionWJ(function Cloud_TargetConditions)
            set Cloud_TARGET_GROUP = CreateGroupWJ()
            set Cloud_TARGET_REGION = CreateRegionWJ()
            call InitUnitType( Cloud_DUMMY_UNIT_ID )
            call AddTriggerCode( Cloud_DUMMY_TRIGGER, function Cloud_Trig_UnitEntersOrLeaves )
            call TriggerRegisterEnterRegion( Cloud_DUMMY_TRIGGER, Cloud_TARGET_REGION, null )
            call TriggerRegisterLeaveRegion( Cloud_DUMMY_TRIGGER, Cloud_TARGET_REGION, null )
        endfunction
    //! runtextmacro Endscope()

    public function Ending takes nothing returns nothing
    return
        call Cloud_Cloud_EndingByEnding()
    endfunction

    private function EffectSound takes nothing returns nothing
        local sound effectSound
        set effectSound = CreateSoundFromType( EFFECT_SOUND_TYPES[GetRandomInt(1, 7)] )
        call StartSound( effectSound )
        call StopSound(effectSound, true, true)
        set effectSound = null
        call TimerStart( SOUND_TIMER, GetRandomReal( SOUND_MIN_INTERVAL, SOUND_MAX_INTERVAL ), false, function EffectSound )
    endfunction

    private function Interval takes nothing returns nothing
        call Cloud_Cloud_Start()
        call TimerStart( INTERVAL_TIMER, GetRandomReal( MIN_INTERVAL, MAX_INTERVAL), false, function Interval )
    endfunction

    public function Start takes nothing returns nothing
        call DisplayTextTimedWJ( "Mist", 15, GetLocalPlayer() )
        return
        call TimerStart( INTERVAL_TIMER, GetRandomReal( MIN_INTERVAL, MAX_INTERVAL ), false, function Interval )
        call TimerStart( SOUND_TIMER, GetRandomReal( SOUND_MIN_INTERVAL, SOUND_MAX_INTERVAL ), false, function EffectSound )
    endfunction

    public function Init takes nothing returns nothing
        set EFFECT_SOUND_TYPES[1] = MIST_SOUND_TYPE
        set EFFECT_SOUND_TYPES[2] = MIST2_SOUND_TYPE
        set EFFECT_SOUND_TYPES[3] = MIST3_SOUND_TYPE
        set EFFECT_SOUND_TYPES[4] = MIST4_SOUND_TYPE
        set EFFECT_SOUND_TYPES[5] = MIST5_SOUND_TYPE
        set EFFECT_SOUND_TYPES[6] = MIST6_SOUND_TYPE
        set EFFECT_SOUND_TYPES[7] = MIST7_SOUND_TYPE
        set INTERVAL_TIMER = CreateTimerWJ()
        set SOUND_TIMER = CreateTimerWJ()
        call Cloud_Cloud_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Weather\Mist.j

//file: D:\Warcraft III\Mapping\WFW\Data\Weather\Rain.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Rain")
    globals
        private sound EFFECT_SOUND
        private weathereffect EFFECT_WEATHER_EFFECT
        private constant real EFFECT_WEATHER_EFFECT_FADE_OUT = 3
        private constant integer EFFECT_WEATHER_EFFECT_PATH = 'RLlr'
        private timer INTERVAL_TIMER
        private constant real MAX_INTERVAL = 15.
        private constant real MIN_INTERVAL = 5.
    endglobals

    //! runtextmacro Scope("Cloud")
        private struct Cloud_Data
            timer dropTimer
            unit dummyUnit
            timer durationTimer
            real lengthX
            real lengthY
            timer lightningTimer
            timer moveTimer
            real x
            real y
        endstruct

        globals
            private constant integer Cloud_DUMMY_UNIT_ID = 'n00E'
            private constant real Cloud_DROP_AREA_RANGE = 800.
            private constant real Cloud_DROP_DURATION = 2.
            private constant string Cloud_DROP_EFFECT_PATH = "Abilities\\Spells\\Human\\SpellSteal\\SpellStealTarget.mdl"
            private constant real Cloud_DROP_INTERVAL = 0.5
            private constant real Cloud_MAX_LIGHTNING_INTERVAL = 8.
            private constant real Cloud_MIN_LIGHTNING_INTERVAL = 0.5
            private constant real Cloud_SIZE = 300.
            private constant real Cloud_SPEED = 200.
            private constant real Cloud_UPDATE_TIME = 0.035
            private constant real Cloud_LENGTH = Cloud_SPEED * Cloud_UPDATE_TIME

            private Cloud_Data array DS
            private integer DS_AMOUNT
        endglobals

        public function Cloud_Ending takes Cloud_Data d, timer durationTimer returns nothing
            local timer dropTimer = d.dropTimer
            local unit dummyUnit = d.dummyUnit
            local integer iteration
            local timer lightningTimer = d.lightningTimer
            local timer moveTimer = d.moveTimer
            call d.destroy()
            call FlushAttachedInteger( dropTimer, Cloud_SCOPE_ID )
            call DestroyTimerWJ( dropTimer )
            set dropTimer = null
            call SetUnitAnimationByIndex( dummyUnit, 2 )
            call RemoveUnitTimed( dummyUnit, 0.5 )
            set dummyUnit = null
            call FlushAttachedInteger( durationTimer, Cloud_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            call FlushAttachedInteger( lightningTimer, Cloud_SCOPE_ID )
            call DestroyTimerWJ( lightningTimer )
            set lightningTimer = null
            call FlushAttachedInteger( moveTimer, Cloud_SCOPE_ID )
            call DestroyTimerWJ( moveTimer )
            set moveTimer = null
            set DS_AMOUNT = DS_AMOUNT - 1
            set iteration = DS_AMOUNT
            loop
                exitwhen (DS[iteration] == d)
            endloop
            set DS[iteration] = DS[DS_AMOUNT]
        endfunction

        public function Cloud_EndingByEnding takes nothing returns nothing
            local Cloud_Data d
            local integer iteration = DS_AMOUNT - 1
            loop
                exitwhen ( iteration < 0 )
                set d = DS[iteration]
                call Cloud_Ending( d, d.durationTimer )
                set iteration = iteration - 1
            endloop
        endfunction

        private function Cloud_EndingByTimer takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Cloud_Data d = GetAttachedInteger(durationTimer, Cloud_SCOPE_ID)
            call Cloud_Ending( d, durationTimer )
            set durationTimer = null
        endfunction

        //! runtextmacro Scope("Lightning")
            globals
                private constant real Lightning_AREA_RANGE = 125.
                private constant real Lightning_DAMAGE = 20.
                private group Lightning_ENUM_GROUP
                private constant real Lightning_HIT_DELAY = 0.85
                private constant real Lightning_LIGHTNING_EFFECT_DURATION = 1.5
                private constant string Lightning_LIGHTNING_EFFECT_PATH = "Abilities\\Spells\\Other\\Monsoon\\MonsoonBoltTarget.mdl"
                private constant string Lightning_SPECIAL_EFFECT_PATH = "Abilities\\Spells\\Other\\BreathOfFire\\BreathOfFireDamage.mdl"
                private constant real Lightning_STUN_DURATION = 3.
                private constant real Lightning_STUN_HERO_DURATION = 1.5
                private boolexpr Lightning_TARGET_CONDITIONS
            endglobals

            private struct Lightning_Data
                real targetX
                real targetY
            endstruct

            private function Lightning_TargetConditions takes nothing returns boolean
                set FILTER_UNIT_SELF = GetFilterUnit()
                if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                    return false
                endif
                if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
                    return false
                endif
                if ( GetUnitInvulnerability( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
                    return false
                endif
                return true
            endfunction

            private function Lightning_Ending takes nothing returns nothing
                local real duration
                local timer durationTimer = GetExpiredTimer()
                local Lightning_Data d = GetAttachedInteger(durationTimer, Lightning_SCOPE_ID)
                local Unit enumUnit
                local unit enumUnitSelf
                local real targetX = d.targetX
                local real targetY = d.targetY
                call d.destroy()
                call FlushAttachedInteger( durationTimer, Lightning_SCOPE_ID )
                call DestroyTimerWJ( durationTimer )
                set durationTimer = null
                call DestroyEffectTimed( AddSpecialEffectWJ( Lightning_SPECIAL_EFFECT_PATH, targetX, targetY ), 0.5 )
                call GroupEnumUnitsInRangeWithCollision( Lightning_ENUM_GROUP, targetX, targetY, Lightning_AREA_RANGE, Lightning_TARGET_CONDITIONS )
                set enumUnitSelf = FirstOfGroup(Lightning_ENUM_GROUP)
                if ( enumUnitSelf != null ) then
                    loop
                        set enumUnit = GetUnit(enumUnitSelf)
                        call GroupRemoveUnit( Lightning_ENUM_GROUP, enumUnitSelf )
                        if ( IsUnitType( enumUnitSelf, UNIT_TYPE_HERO ) ) then
                            set duration = Lightning_STUN_HERO_DURATION
                        else
                            set duration = Lightning_STUN_DURATION
                        endif
                        call SetUnitStunTimed( enumUnit, 1, duration )
                        call UnitDamageUnitBySpell( enumUnit, enumUnit, Lightning_DAMAGE )
                        set enumUnitSelf = FirstOfGroup( Lightning_ENUM_GROUP )
                        exitwhen ( enumUnitSelf == null )
                    endloop
                endif
            endfunction

            public function Lightning_Start takes unit dummyUnit, real targetX, real targetY returns nothing
                local real angle = GetRandomRealWJ( 0, 2 * PI )
                local real length = GetRandomReal( 0, Cloud_SIZE )
                local Lightning_Data d = Lightning_Data.create()
                local timer durationTimer = CreateTimerWJ()
                set targetX = targetX + length * Cos( angle )
                set targetY = targetY + length * Sin( angle )
                if ( GetRandomInt( 0, 0 ) == 0 ) then
                    call PlaySoundFromTypeAtPosition( LIGHTNING_IMPACT_SOUND_TYPE, targetX, targetY, GetFloorHeight( targetX, targetY ) )
                endif
                set d.targetX = targetX
                set d.targetY = targetY
                call AttachInteger(durationTimer, Lightning_SCOPE_ID, d)
                call DestroyEffectTimed( AddSpecialEffectWJ( Lightning_LIGHTNING_EFFECT_PATH, targetX, targetY ), Lightning_LIGHTNING_EFFECT_DURATION )
                call TimerStart( durationTimer, Lightning_HIT_DELAY, false, function Lightning_Ending )
                set durationTimer = null
            endfunction

            public function Lightning_Init takes nothing returns nothing
                set Lightning_ENUM_GROUP = CreateGroupWJ()
                set Lightning_TARGET_CONDITIONS = ConditionWJ( function Lightning_TargetConditions )
                call InitEffectType( Lightning_LIGHTNING_EFFECT_PATH )
                call InitEffectType( Lightning_SPECIAL_EFFECT_PATH )
            endfunction
        //! runtextmacro Endscope()

        private function Cloud_Lightning takes nothing returns nothing
            local timer lightningTimer = GetExpiredTimer()
            local Cloud_Data d = GetAttachedInteger(lightningTimer, Cloud_SCOPE_ID)
            call TimerStart( lightningTimer, GetRandomReal( Cloud_MIN_LIGHTNING_INTERVAL, Cloud_MAX_LIGHTNING_INTERVAL ), false, function Cloud_Lightning )
            set lightningTimer = null
            call Lightning_Lightning_Start( d.dummyUnit, d.x, d.y )
        endfunction

        private function Cloud_Drop takes nothing returns nothing
            local timer dropTimer = GetExpiredTimer()
            local Cloud_Data d = GetAttachedInteger(dropTimer, Cloud_SCOPE_ID)
            local real angle = GetRandomReal( 0, 2 * PI )
            local real length = GetRandomReal( 0, Cloud_DROP_AREA_RANGE )
            local real targetX = d.x + length * Cos( angle )
            local real targetY = d.y + length * Sin( angle )
            set dropTimer = null
            call DestroyEffectTimed( AddSpecialEffectWJ( Cloud_DROP_EFFECT_PATH, targetX, targetY ), Cloud_DROP_DURATION )
        endfunction

        private function Cloud_Move takes nothing returns nothing
            local timer moveTimer = GetExpiredTimer()
            local Cloud_Data d = GetAttachedInteger(moveTimer, Cloud_SCOPE_ID)
            local unit dummyUnit = d.dummyUnit
            local real x = d.x + d.lengthX
            local real y = d.y + d.lengthY
            set d.x = x
            set d.y = y
            call SetUnitX( dummyUnit, x )
            call SetUnitY( dummyUnit, y )
            set dummyUnit = null
        endfunction

        public function Cloud_Start takes nothing returns nothing
            local real angle
            local Cloud_Data d = Cloud_Data.create()
            local timer dropTimer = CreateTimerWJ()
            local unit dummyUnit
            local timer durationTimer = CreateTimerWJ()
            local integer iteration = 0
            local timer lightningTimer = CreateTimerWJ()
            local real maxDuration
            local timer moveTimer = CreateTimerWJ()
            local integer random = GetRandomInt( 0, 1 )
            local real sourceX
            local real sourceY
            local real targetX
            local real targetY
            if ( random == 0 ) then
                set random = GetRandomInt( 0, 1 )
                if ( random == 0 ) then
                    set sourceX = PLAY_RECT_MIN_X
                    set targetX = PLAY_RECT_MAX_X
                else
                    set sourceX = PLAY_RECT_MAX_X
                    set targetX = PLAY_RECT_MIN_X
                endif
                set sourceY = GetRandomReal( PLAY_RECT_MIN_Y, PLAY_RECT_MAX_Y )
                set targetY = GetRandomReal( PLAY_RECT_MIN_Y, PLAY_RECT_MAX_Y )
            else
                set random = GetRandomInt( 0, 1 )
                if ( random == 0 ) then
                    set sourceY = PLAY_RECT_MIN_Y
                    set targetY = PLAY_RECT_MAX_Y
                else
                    set sourceY = PLAY_RECT_MAX_Y
                    set targetY = PLAY_RECT_MIN_Y
                endif
                set sourceX = GetRandomReal( PLAY_RECT_MIN_X, PLAY_RECT_MAX_X )
                set targetX = GetRandomReal( PLAY_RECT_MIN_X, PLAY_RECT_MAX_X )
            endif
            set angle = Atan2( targetY - sourceY, targetX - sourceX )
            set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, Cloud_DUMMY_UNIT_ID, sourceX, sourceY, STANDARD_ANGLE )
            set maxDuration = DistanceByCoordinates( sourceX, sourceY, targetX, targetY ) / Cloud_SPEED
            set d.dropTimer = dropTimer
            set d.dummyUnit = dummyUnit
            set d.durationTimer = durationTimer
            set d.lengthX = Cloud_LENGTH * Cos(angle)
            set d.lengthY = Cloud_LENGTH * Sin(angle)
            set d.lightningTimer = lightningTimer
            set d.moveTimer = moveTimer
            set d.x = sourceX
            set d.y = sourceY
            loop
                exitwhen ( iteration > 11 )
                call UnitShareVision( dummyUnit, PlayerWJ( iteration ), true )
                set iteration = iteration + 1
            endloop
            set dummyUnit = null
            call AttachInteger( durationTimer, Cloud_SCOPE_ID, d )
            call AttachInteger( dropTimer, Cloud_SCOPE_ID, d )
            call AttachInteger( lightningTimer, Cloud_SCOPE_ID, d )
            call AttachInteger( moveTimer, Cloud_SCOPE_ID, d )
            set DS[DS_AMOUNT] = d
            set DS_AMOUNT = DS_AMOUNT + 1
            call TimerStart( dropTimer, Cloud_DROP_INTERVAL, true, function Cloud_Drop )
            set dropTimer = null
            call TimerStart( moveTimer, Cloud_UPDATE_TIME, true, function Cloud_Move )
            set moveTimer = null
            call TimerStart( lightningTimer, GetRandomReal( Cloud_MIN_LIGHTNING_INTERVAL, Cloud_MAX_LIGHTNING_INTERVAL ), false, function Cloud_Lightning )
            set lightningTimer = null
            call TimerStart( durationTimer, GetRandomReal( maxDuration / 2, maxDuration ), false, function Cloud_EndingByTimer )
            set durationTimer = null
        endfunction

        public function Cloud_Init takes nothing returns nothing
            call InitEffectType( Cloud_DROP_EFFECT_PATH )
            call InitUnitType(Cloud_DUMMY_UNIT_ID)
            call Lightning_Lightning_Init()
        endfunction
    //! runtextmacro Endscope()

    function Rain_Ending takes nothing returns nothing
        call EnableWeatherEffectTimed( EFFECT_WEATHER_EFFECT, null, false, EFFECT_WEATHER_EFFECT_FADE_OUT )
        return
        call Cloud_Cloud_EndingByEnding()
        call StopSound( EFFECT_SOUND, false, true )
    endfunction

    private function Interval takes nothing returns nothing
        call TimerStart( INTERVAL_TIMER, GetRandomReal( MIN_INTERVAL, MAX_INTERVAL ), false, function Interval )
        call Cloud_Cloud_Start()
    endfunction

    public function Start takes nothing returns nothing
        call DisplayTextTimedWJ( "Rain", 15, GetLocalPlayer() )
        call EnableWeatherEffectWJ( EFFECT_WEATHER_EFFECT, null, true )
        return
        call StartSound( EFFECT_SOUND )
        call TimerStart( INTERVAL_TIMER, GetRandomReal( MIN_INTERVAL, MAX_INTERVAL ), false, function Interval )
    endfunction

    public function Init takes nothing returns nothing
        set EFFECT_SOUND = CreateSoundFromType( RAIN_SOUND_TYPE )
        set EFFECT_WEATHER_EFFECT = AddWeatherEffectWJ( PLAY_RECT, EFFECT_WEATHER_EFFECT_PATH )
        call SetSoundVolume( EFFECT_SOUND, 127 )
        call Cloud_Cloud_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Weather\Rain.j

//file: D:\Warcraft III\Mapping\WFW\Data\Weather\Snow.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Snow")
    globals
        private weathereffect EFFECT_WEATHER_EFFECT
        private constant real EFFECT_WEATHER_EFFECT_FADE_OUT = 3
        private constant integer EFFECT_WEATHER_EFFECT_PATH = 'SNls'
        private timer INTERVAL_TIMER
        private constant real MAX_INTERVAL = 7.
        private constant real MIN_INTERVAL = 5.
    endglobals

    public function Ending takes nothing returns nothing
        call EnableWeatherEffectTimed( EFFECT_WEATHER_EFFECT, null, false, EFFECT_WEATHER_EFFECT_FADE_OUT )
        return
        call SetCineFilterTextureWJ( GetLocalPlayer(), "ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp" )
        call SetCineFilterBlendModeWJ( GetLocalPlayer(), BLEND_MODE_BLEND )
        call SetCineFilterTexMapFlagsWJ( GetLocalPlayer(), TEXMAP_FLAG_NONE )
        call SetCineFilterUVWJ( GetLocalPlayer(), 0, 0, 1, 1 )
        call SetCineFilterColorWJ( GetLocalPlayer(), 0, 0, 0, 0 )
        call DisplayCineFilterWJ( GetLocalPlayer(), true )
    endfunction

    //! runtextmacro Scope("Ghost")
        globals
            private constant real Ghost_AREA_RANGE = 250.
            private constant real Ghost_BURN_INTERVAL = 0.25
            private constant real Ghost_BURNED_MANA = 40.
            private constant integer Ghost_DUMMY_UNIT_ID = 'n00Q'
            private constant real Ghost_DUMMY_UNIT_OUTPACT_Z = 60
            private constant real Ghost_EFFECT_LIGHTNING_DURATION = 1.5
            private group Ghost_ENUM_GROUP
            private constant real Ghost_SPEED = 250.
            private constant real Ghost_UPDATE_TIME = 0.035
            private constant real Ghost_LENGTH = Ghost_SPEED * Ghost_UPDATE_TIME
            private boolexpr Ghost_TARGET_CONDITIONS
        endglobals

        private struct Ghost_Data
            timer burnTimer
            unit dummyUnit
            real lengthX
            real lengthY
            group targetGroup
            timer updateTimer
            real x
            real y
        endstruct

        //! runtextmacro Scope("EffectLightning")
            globals
                private constant string EffectLightning_EFFECT_LIGHTNING_PATH = "MBUR"
                private constant real EffectLightning_UPDATE_TIME = 0.035
            endglobals

            private struct EffectLightning_Data
                Ghost_Data d
                lightning effectLightning
                Unit target
                real targetX
                real targetY
                real targetZ
                timer updateTimer
            endstruct

            private function EffectLightning_Ending takes EffectLightning_Data d, lightning effectLightning, unit source, Unit target returns nothing
                local integer targetId
                local timer updateTimer = d.updateTimer
                call d.destroy()
                call FlushAttachedInteger(effectLightning, EffectLightning_SCOPE_ID)
                if (source != null) then
                    call RemoveIntegerFromTable(source, EffectLightning_SCOPE_ID, d)
                endif
                if (target != NULL) then
                    set targetId = target.id
                    call RemoveIntegerFromTableById(targetId, EffectLightning_SCOPE_ID, d)
                    if (CountIntegersInTableById(targetId, EffectLightning_SCOPE_ID) == TABLE_EMPTY) then
                        //! runtextmacro RemoveEventById( "targetId", "EffectLightning_EVENT_TARGET_DEATH" )
                    endif
                endif
                call DestroyTimerWJ(updateTimer)
                set updateTimer = null
            endfunction

            public function EffectLightning_EffectLightning_Death takes lightning effectLightning returns nothing
                local EffectLightning_Data d = GetAttachedInteger(effectLightning, EffectLightning_SCOPE_ID)
                if (d != NULL) then
                    call EffectLightning_Ending(d, effectLightning, d.d.dummyUnit, d.target)
                endif
            endfunction

            public function EffectLightning_Source_Death takes unit source returns nothing
                local EffectLightning_Data d
                local integer iteration = CountIntegersInTable(source, EffectLightning_SCOPE_ID)
                if (iteration > TABLE_EMPTY) then
                    loop
                        set d = GetIntegerFromTable(source, EffectLightning_SCOPE_ID, iteration)
                        call EffectLightning_Ending(d, d.effectLightning, source, d.target)
                        set iteration = iteration - 1
                        exitwhen (iteration < TABLE_STARTED)
                    endloop
                endif
            endfunction

            public function EffectLightning_Target_Death takes Unit target, real targetX, real targetY, real targetZ returns nothing
                local EffectLightning_Data d
                local integer targetId = target.id
                local integer iteration = CountIntegersInTableById(targetId, EffectLightning_SCOPE_ID)
                if (iteration > TABLE_EMPTY) then
                    loop
                        set d = GetIntegerFromTableById(targetId, EffectLightning_SCOPE_ID, iteration)
                        set d.targetX = targetX
                        set d.targetY = targetY
                        set d.targetZ = targetZ + GetUnitImpactZ(target)
                        call RemoveIntegerFromTableById(targetId, EffectLightning_SCOPE_ID, d)
                        if (CountIntegersInTableById(targetId, EffectLightning_SCOPE_ID) == TABLE_EMPTY) then
                            //! runtextmacro RemoveEventById( "targetId", "EffectLightning_EVENT_TARGET_DEATH" )
                        endif
                        set iteration = iteration - 1
                        exitwhen (iteration < TABLE_STARTED)
                    endloop
                endif
            endfunction

            private function EffectLightning_Target_Death_Event takes nothing returns nothing
                local unit dyingUnitSelf = DYING_UNIT.self
                local real dyingUnitX = GetUnitX(dyingUnitSelf)
                local real dyingUnitY = GetUnitY(dyingUnitSelf)
                call EffectLightning_Target_Death(DYING_UNIT, dyingUnitX, dyingUnitY, GetUnitZ(dyingUnitSelf, dyingUnitX, dyingUnitY))
                set dyingUnitSelf = null
            endfunction

            private function EffectLightning_Move takes nothing returns nothing
                local timer updateTimer = GetExpiredTimer()
                local EffectLightning_Data d = GetAttachedInteger(updateTimer, EffectLightning_SCOPE_ID)
                local Ghost_Data e = d.d
                local unit source = e.dummyUnit
                local real sourceX = e.x
                local real sourceY = e.y
                local real sourceZ = GetUnitZ( source, sourceX, sourceY )
                local Unit target = d.target
                local unit targetSelf
                local real targetX
                local real targetY
                local real targetZ
                set updateTimer = null
                if ( target == NULL ) then
                    set targetX = d.targetX
                    set targetY = d.targetY
                    set targetZ = d.targetZ
                else
                    set targetSelf = target.self
                    set targetX = GetUnitX( targetSelf )
                    set targetY = GetUnitY( targetSelf )
                    set targetZ = GetUnitZ( targetSelf, targetX, targetY ) + GetUnitImpactZ(target)
                    set targetSelf = null
                endif
                call MoveLightningEx( d.effectLightning, true, sourceX, sourceY, sourceZ + Ghost_DUMMY_UNIT_OUTPACT_Z, targetX, targetY, targetZ )
            endfunction

            public function EffectLightning_Start takes Ghost_Data e, unit dummyUnit, real sourceX, real sourceY, real sourceZ, Unit target, real targetX, real targetY, real targetZ returns lightning
                local EffectLightning_Data d = EffectLightning_Data.create()
                local real dummyUnitX = GetUnitX(dummyUnit)
                local real dummyUnitY = GetUnitY(dummyUnit)
                local integer targetId = target.id
                local lightning effectLightning = AddLightningWJ( EffectLightning_EFFECT_LIGHTNING_PATH, sourceX, sourceY, sourceZ, targetX, targetY, targetZ + GetUnitImpactZ(target) )
                local timer updateTimer = CreateTimerWJ()
                set d.d = e
                set d.effectLightning = effectLightning
                set d.target = target
                call AddIntegerToTable( dummyUnit, EffectLightning_SCOPE_ID, d )
                call AttachInteger( effectLightning, EffectLightning_SCOPE_ID, d )
                call AddIntegerToTableById( targetId, EffectLightning_SCOPE_ID, d )
                if ( CountIntegersInTableById(targetId, EffectLightning_SCOPE_ID) == TABLE_STARTED) then
                    //! runtextmacro AddEventById( "targetId", "EffectLightning_EVENT_TARGET_DEATH" )
                endif
                call AttachInteger( updateTimer, EffectLightning_SCOPE_ID, d )
                call TimerStart( updateTimer, EffectLightning_UPDATE_TIME, true, function EffectLightning_Move )
                set updateTimer = null
                set TEMP_LIGHTNING = effectLightning
                set effectLightning = null
                return TEMP_LIGHTNING
            endfunction

            public function EffectLightning_Init takes nothing returns nothing
                //! runtextmacro CreateEvent( "EffectLightning_EVENT_TARGET_DEATH", "UnitDies_EVENT_KEY", "0", "function EffectLightning_Target_Death_Event" )
            endfunction
        //! runtextmacro Endscope()

        private function Ghost_Ending takes nothing returns nothing
            local timer durationTimer = GetExpiredTimer()
            local Ghost_Data d = GetAttachedInteger(durationTimer, Ghost_SCOPE_ID)
            local timer burnTimer = d.burnTimer
            local unit dummyUnit = d.dummyUnit
            local group targetGroup = d.targetGroup
            local timer updateTimer = d.updateTimer
            call d.destroy()
            call FlushAttachedInteger( burnTimer, Ghost_SCOPE_ID )
            call DestroyTimerWJ( burnTimer )
            set burnTimer = null
            call FlushAttachedInteger( durationTimer, Ghost_SCOPE_ID )
            call DestroyTimerWJ( durationTimer )
            set durationTimer = null
            call SetUnitAnimationByIndex( dummyUnit, 4 )
            call EffectLightning_EffectLightning_Source_Death(dummyUnit)
            call RemoveUnitTimed(dummyUnit, 3)
            call DestroyGroupWJ( targetGroup )
            set targetGroup = null
            call FlushAttachedInteger( updateTimer, Ghost_SCOPE_ID )
            call DestroyTimerWJ( updateTimer )
            set updateTimer = null
        endfunction

        private function Ghost_TargetConditions takes nothing returns boolean
            set FILTER_UNIT_SELF = GetFilterUnit()
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_LIFE ) <= 0 ) then
                return false
            endif
            if ( GetUnitState( FILTER_UNIT_SELF, UNIT_STATE_MANA ) <= 0 ) then
                return false
            endif
            if ( IsUnitInGroup( FILTER_UNIT_SELF, TEMP_GROUP ) ) then
                return false
            endif
            if ( IsUnitType( FILTER_UNIT_SELF, UNIT_TYPE_STRUCTURE ) ) then
                return false
            endif
            if ( GetUnitInvulnerability( GetUnit(FILTER_UNIT_SELF) ) > 0 ) then
                return false
            endif
            return true
        endfunction

        private function Ghost_BurnMana takes nothing returns nothing
            local real burnedManaMax
            local timer burnTimer = GetExpiredTimer()
            local Ghost_Data d = GetAttachedInteger(burnTimer, Ghost_SCOPE_ID)
            local unit dummyUnit = d.dummyUnit
            local Unit enumUnit
            local unit enumUnitSelf
            local real enumUnitMana
            local real enumUnitX
            local real enumUnitY
            local real enumUnitZ
            local real lostMana
            local group targetGroup = d.targetGroup
            local real x = d.x
            local real y = d.y
            local real z
            set TEMP_GROUP = targetGroup
            call GroupEnumUnitsInRangeWithCollision( Ghost_ENUM_GROUP, x, y, Ghost_AREA_RANGE, Ghost_TARGET_CONDITIONS )
            set enumUnitSelf = FirstOfGroup( Ghost_ENUM_GROUP )
            if ( enumUnitSelf != null ) then
                set z = GetUnitZ(dummyUnit, x, y) + Ghost_DUMMY_UNIT_OUTPACT_Z
                loop
                    set enumUnit = GetUnit(enumUnitSelf)
                    set enumUnitMana = GetUnitState( enumUnitSelf, UNIT_STATE_MANA )
                    set lostMana = Min(enumUnitMana, Ghost_BURNED_MANA)
                    set enumUnitX = GetUnitX( enumUnitSelf )
                    set enumUnitY = GetUnitY( enumUnitSelf )
                    set enumUnitZ = GetUnitZ(enumUnitSelf, enumUnitX, enumUnitY)
                    call GroupRemoveUnit( Ghost_ENUM_GROUP, enumUnitSelf )
                    call GroupAddUnit( targetGroup, enumUnitSelf )
                    call DestroyLightningTimedEx( EffectLightning_EffectLightning_Start( d, dummyUnit, x, y, z, enumUnit, enumUnitX, enumUnitY, enumUnitZ ), Ghost_EFFECT_LIGHTNING_DURATION )
                    call PlaySoundFromTypeOnUnit( SNOW_GHOST_MANA_DRAIN_SOUND_TYPE, enumUnitSelf )
                    call CreateRisingTextTag( I2S( R2I( lostMana ) ), 0.023, enumUnitX, enumUnitY, enumUnitZ + GetUnitOutpactZ(enumUnit), 40, 0, 0, 255, 255, 1, 4 )
                    call SetUnitState( enumUnitSelf, UNIT_STATE_MANA, enumUnitMana - lostMana )
                    set enumUnitSelf = FirstOfGroup( Ghost_ENUM_GROUP )
                    exitwhen ( enumUnitSelf == null )
                endloop
            endif
            set dummyUnit = null
        endfunction

        private function Ghost_Move takes nothing returns nothing
            local timer updateTimer = GetExpiredTimer()
            local Ghost_Data d = GetAttachedInteger( updateTimer, Ghost_SCOPE_ID )
            local unit dummyUnit = d.dummyUnit
            local real x = d.x + d.lengthX
            local real y = d.y + d.lengthY
            set updateTimer = null
            set d.x = x
            set d.y = y
            call SetUnitX( dummyUnit, x )
            call SetUnitY( dummyUnit, y )
            set dummyUnit = null
        endfunction

        public function Ghost_Start takes nothing returns nothing
            local real angle
            local timer burnTimer = CreateTimerWJ()
            local Ghost_Data d = Ghost_Data.create()
            local unit dummyUnit
            local timer durationTimer = CreateTimerWJ()
            local integer random = GetRandomIntWJ( 0, 1 )
            local timer updateTimer = CreateTimerWJ()
            local real sourceX
            local real sourceY
            local real targetX
            local real targetY
            if ( random == 0 ) then
                set random = GetRandomInt( 0, 1 )
                if ( random == 0 ) then
                    set sourceX = PLAY_RECT_MIN_X
                    set targetX = PLAY_RECT_MAX_X
                else
                    set sourceX = PLAY_RECT_MAX_X
                    set targetX = PLAY_RECT_MIN_X
                endif
                set sourceY = GetRandomReal( PLAY_RECT_MIN_Y, PLAY_RECT_MAX_Y )
                set targetY = GetRandomReal( PLAY_RECT_MIN_Y, PLAY_RECT_MAX_Y )
            else
                set random = GetRandomInt( 0, 1 )
                if ( random == 0 ) then
                    set sourceY = PLAY_RECT_MIN_Y
                    set targetY = PLAY_RECT_MAX_Y
                else
                    set sourceY = PLAY_RECT_MAX_Y
                    set targetY = PLAY_RECT_MIN_Y
                endif
                set sourceX = GetRandomReal( PLAY_RECT_MIN_X, PLAY_RECT_MAX_X )
                set targetX = GetRandomReal( PLAY_RECT_MIN_X, PLAY_RECT_MAX_X )
            endif
            set angle = Atan2( targetY - sourceY, targetX - sourceX )
            set dummyUnit = CreateUnitWJ( NEUTRAL_PASSIVE_PLAYER, Ghost_DUMMY_UNIT_ID, sourceX, sourceY, angle )
            set d.burnTimer = burnTimer
            set d.dummyUnit = dummyUnit
            set d.lengthX = Ghost_LENGTH * Cos(angle)
            set d.lengthY = Ghost_LENGTH * Sin(angle)
            set d.targetGroup = CreateGroupWJ()
            set d.updateTimer = updateTimer
            set d.x = sourceX
            set d.y = sourceY
            call AttachInteger(burnTimer, Ghost_SCOPE_ID, d)
            call AttachInteger(durationTimer, Ghost_SCOPE_ID, d)
            call AttachInteger(updateTimer, Ghost_SCOPE_ID, d)
            call SetUnitAnimationByIndex( dummyUnit, 5 )
            set dummyUnit = null
            call TimerStart( burnTimer, Ghost_BURN_INTERVAL, true, function Ghost_BurnMana )
            set burnTimer = null
            call TimerStart( updateTimer, Ghost_UPDATE_TIME, true, function Ghost_Move )
            set updateTimer = null
            call TimerStart( durationTimer, DistanceByCoordinates( sourceX, sourceY, targetX, targetY ) / Ghost_SPEED, false, function Ghost_Ending )
            set durationTimer = null
        endfunction

        public function Ghost_Init takes nothing returns nothing
            set Ghost_ENUM_GROUP = CreateGroupWJ()
            set Ghost_TARGET_CONDITIONS = ConditionWJ( function Ghost_TargetConditions )
            call InitUnitType(Ghost_DUMMY_UNIT_ID)
            call EffectLightning_EffectLightning_Init()
        endfunction
    //! runtextmacro Endscope()

    private function Interval takes nothing returns nothing
        call Ghost_Ghost_Start()
        call TimerStart( INTERVAL_TIMER, GetRandomReal( MIN_INTERVAL, MAX_INTERVAL ), false, function Interval )
    endfunction

    public function Start takes nothing returns nothing
        call DisplayTextTimedWJ( "Snow", 15, GetLocalPlayer() )
        call EnableWeatherEffectWJ( EFFECT_WEATHER_EFFECT, null, true )
        return
        call SetCineFilterTextureWJ( GetLocalPlayer(), "ReplaceableTextures\\CameraMasks\\DreamFilter_Mask.blp" )
        call SetCineFilterBlendModeWJ( GetLocalPlayer(), BLEND_MODE_BLEND )
        call SetCineFilterTexMapFlagsWJ( GetLocalPlayer(), TEXMAP_FLAG_NONE )
        call SetCineFilterUVWJ( GetLocalPlayer(), 0, 0, 1, 1 )
        call SetCineFilterColorWJ( GetLocalPlayer(), 160, 160, 160, 0 )
        call DisplayCineFilterWJ( GetLocalPlayer(), true )
        //call TimerStart( INTERVAL_TIMER, GetRandomReal( MIN_INTERVAL, MAX_INTERVAL ), false, function Interval )
    endfunction

    public function Init takes nothing returns nothing
        set INTERVAL_TIMER = CreateTimerWJ()
        set EFFECT_WEATHER_EFFECT = AddWeatherEffectWJ( PLAY_RECT, EFFECT_WEATHER_EFFECT_PATH )
        call Ghost_Ghost_Init()
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Weather\Snow.j

//file: D:\Warcraft III\Mapping\WFW\Data\Weather\StartWeather.j
//TESH.scrollpos=18
//TESH.alwaysfold=0
//! runtextmacro Scope("StartWeather")
    globals
        private constant real INTERVAL = 30.
        private timer INTERVAL_TIMER
        private integer LAST_WEATHER
    endglobals

    private function StartNew takes integer whichWeather returns nothing
        set LAST_WEATHER = whichWeather
        if ( whichWeather == 0 ) then
            call Sun_Start()
        elseif ( whichWeather == 1 ) then
            call Rain_Start()
        elseif ( whichWeather == 2 ) then
            call Snow_Start()
        elseif ( whichWeather == 3 ) then
            call Mist_Start()
        endif
    endfunction

    private function Interval takes nothing returns nothing
        local integer newWeather = ModulateInt( LAST_WEATHER + 1, 4 )
        if ( LAST_WEATHER == 0 ) then
            call Sun_Ending()
        elseif ( LAST_WEATHER == 1 ) then
            call Rain_Ending()
        elseif ( LAST_WEATHER == 2 ) then
            call Snow_Ending()
        elseif ( LAST_WEATHER == 3 ) then
            call Mist_Ending()
        endif
        call StartNew( newWeather )
    endfunction

    public function Start takes nothing returns nothing
        set INTERVAL_TIMER = CreateTimerWJ()
        call StartNew( 2 )
        call TimerStart( INTERVAL_TIMER, INTERVAL, true, function Interval )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Weather\StartWeather.j

//file: D:\Warcraft III\Mapping\WFW\Data\Weather\Sun.j
//TESH.scrollpos=0
//TESH.alwaysfold=0
//! runtextmacro Scope("Sun")
    globals
        private weathereffect EFFECT_WEATHER_EFFECT
        private constant real EFFECT_WEATHER_EFFECT_FADE_OUT = 3
        private constant integer EFFECT_WEATHER_EFFECT_PATH = 'LRaa'
    endglobals

    public function Ending takes nothing returns nothing
        call EnableWeatherEffectTimed( EFFECT_WEATHER_EFFECT, null, false, EFFECT_WEATHER_EFFECT_FADE_OUT )
    endfunction

    public function Start takes nothing returns nothing
        call DisplayTextTimedWJ( "Sun", 15, GetLocalPlayer() )
        call EnableWeatherEffectWJ( EFFECT_WEATHER_EFFECT, null, true )
    endfunction

    public function Init takes nothing returns nothing
        set EFFECT_WEATHER_EFFECT = AddWeatherEffectWJ( PLAY_RECT, EFFECT_WEATHER_EFFECT_PATH )
    endfunction
//! runtextmacro Endscope()

//end of file: D:\Warcraft III\Mapping\WFW\Data\Weather\Sun.j
